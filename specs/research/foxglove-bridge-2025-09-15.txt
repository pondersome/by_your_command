Directory structure:
└── foxglove-ros-foxglove-bridge/
    ├── README.md
    ├── CHANGELOG.rst
    ├── CMakeLists.txt
    ├── Dockerfile.ros1
    ├── Dockerfile.ros2
    ├── download_test_data.sh
    ├── LICENSE
    ├── Makefile
    ├── nodelets.xml
    ├── package.xml
    ├── .clang-format
    ├── foxglove_bridge_base/
    │   ├── include/
    │   │   └── foxglove_bridge/
    │   │       ├── base64.hpp
    │   │       ├── callback_queue.hpp
    │   │       ├── common.hpp
    │   │       ├── foxglove_bridge.hpp
    │   │       ├── message_definition_cache.hpp
    │   │       ├── parameter.hpp
    │   │       ├── regex_utils.hpp
    │   │       ├── serialization.hpp
    │   │       ├── server_factory.hpp
    │   │       ├── server_interface.hpp
    │   │       ├── websocket_client.hpp
    │   │       ├── websocket_logging.hpp
    │   │       ├── websocket_notls.hpp
    │   │       ├── websocket_tls.hpp
    │   │       └── test/
    │   │           └── test_client.hpp
    │   ├── src/
    │   │   ├── base64.cpp
    │   │   ├── foxglove_bridge.cpp
    │   │   ├── parameter.cpp
    │   │   ├── serialization.cpp
    │   │   ├── server_factory.cpp
    │   │   ├── version.cpp.in
    │   │   └── test/
    │   │       └── test_client.cpp
    │   └── tests/
    │       ├── base64_test.cpp
    │       ├── serialization_test.cpp
    │       └── version_test.cpp
    ├── ros1_foxglove_bridge/
    │   ├── include/
    │   │   └── foxglove_bridge/
    │   │       ├── generic_service.hpp
    │   │       ├── param_utils.hpp
    │   │       └── service_utils.hpp
    │   ├── launch/
    │   │   └── foxglove_bridge.launch
    │   ├── src/
    │   │   ├── param_utils.cpp
    │   │   ├── ros1_foxglove_bridge_node.cpp
    │   │   ├── ros1_foxglove_bridge_nodelet.cpp
    │   │   └── service_utils.cpp
    │   └── tests/
    │       ├── smoke.test
    │       └── smoke_test.cpp
    ├── ros2_foxglove_bridge/
    │   ├── include/
    │   │   └── foxglove_bridge/
    │   │       ├── generic_client.hpp
    │   │       ├── param_utils.hpp
    │   │       ├── parameter_interface.hpp
    │   │       ├── ros2_foxglove_bridge.hpp
    │   │       └── utils.hpp
    │   ├── launch/
    │   │   └── foxglove_bridge_launch.xml
    │   ├── src/
    │   │   ├── generic_client.cpp
    │   │   ├── message_definition_cache.cpp
    │   │   ├── param_utils.cpp
    │   │   ├── parameter_interface.cpp
    │   │   ├── ros2_foxglove_bridge.cpp
    │   │   └── ros2_foxglove_bridge_node.cpp
    │   └── tests/
    │       ├── smoke_test.cpp
    │       └── utils_test.cpp
    ├── ros2_foxglove_bridge_sdk/
    │   ├── include/
    │   │   └── foxglove_bridge/
    │   │       ├── common.hpp
    │   │       ├── generic_client.hpp
    │   │       ├── message_definition_cache.hpp
    │   │       ├── param_utils.hpp
    │   │       ├── parameter_interface.hpp
    │   │       ├── ros2_foxglove_bridge.hpp
    │   │       ├── utils.hpp
    │   │       ├── version.hpp.in
    │   │       └── test/
    │   │           ├── protocol_types.hpp
    │   │           └── test_client.hpp
    │   ├── launch/
    │   │   └── foxglove_bridge_launch.xml
    │   ├── src/
    │   │   ├── generic_client.cpp
    │   │   ├── message_definition_cache.cpp
    │   │   ├── param_utils.cpp
    │   │   ├── parameter_interface.cpp
    │   │   ├── ros2_foxglove_bridge.cpp
    │   │   └── ros2_foxglove_bridge_node.cpp
    │   └── tests/
    │       ├── smoke_test.cpp
    │       └── utils_test.cpp
    ├── scripts/
    │   └── format.py
    ├── .devcontainer/
    │   ├── colcon_defaults.yaml
    │   ├── devcontainer.json
    │   └── Dockerfile
    └── .github/
        └── workflows/
            └── ci.yml

================================================
FILE: README.md
================================================
foxglove_bridge
===============

[![ROS Melodic version](https://img.shields.io/ros/v/melodic/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#melodic)
[![ROS Noetic version](https://img.shields.io/ros/v/noetic/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#noetic)
[![ROS Humble version](https://img.shields.io/ros/v/humble/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#humble)
[![ROS Jazzy version](https://img.shields.io/ros/v/jazzy/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#jazzy)
[![ROS Kilted version](https://img.shields.io/ros/v/kilted/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#kilted)
[![ROS Rolling version](https://img.shields.io/ros/v/rolling/foxglove_bridge)](https://index.ros.org/p/foxglove_bridge/github-foxglove-ros-foxglove-bridge/#rolling)

High performance ROS 1 and ROS 2 WebSocket bridge using the Foxglove WebSocket protocol, written in C++.

## Motivation

Live debugging of ROS systems has traditionally relied on running ROS tooling such as rviz. This requires either a GUI and connected peripherals on the robot, or replicating the same ROS environment on a network-connected development machine including the same version of ROS, all custom message definitions, etc. To overcome this limitation and allow remote debugging from web tooling or non-ROS systems, rosbridge was developed. However, rosbridge suffers from performance problems with high frequency topics and/or large messages, and the protocol does not support full visibility into ROS systems such as interacting with parameters or seeing the full graph of publishers and subscribers.

The `foxglove_bridge` uses the [Foxglove WebSocket protocol](https://github.com/foxglove/ws-protocol), a similar protocol to rosbridge but with the ability to support additional schema formats such as ROS 2 `.msg` and ROS 2 `.idl`, parameters, graph introspection, and non-ROS systems. The bridge is written in C++ and designed for high performance with low overhead to minimize the impact to your robot stack.

## Installation

**Note**: This project is under active development and binary releases of `foxglove_bridge` might be quite outdated. For the latest features and bug fixes, consider [building foxglove_bridge from source](#building-from-source).

The `foxglove_bridge` package is available for ROS 1 Melodic and Noetic, and ROS 2 Humble and Rolling. Earlier releases of ROS will not be supported due to API design and/or performance limitations. The package can be installed with the following command:

```bash
sudo apt install ros-$ROS_DISTRO-foxglove-bridge
```

## Running the bridge

To run the bridge node, it is recommended to use the provided launch file:

**ROS 1**

```bash
roslaunch --screen foxglove_bridge foxglove_bridge.launch port:=8765
```

```xml
<launch>
  <!-- Including in another launch file -->
  <include file="$(find foxglove_bridge)/launch/foxglove_bridge.launch">
    <arg name="port" value="8765" />
    <!-- ... other arguments ... -->
  </include>
</launch>
```

**ROS 2**

```bash
ros2 launch foxglove_bridge foxglove_bridge_launch.xml port:=8765
```

```xml
<launch>
  <!-- Including in another launch file -->
  <include file="$(find-pkg-share foxglove_bridge)/launch/foxglove_bridge_launch.xml">
    <arg name="port" value="8765"/>
    <!-- ... other arguments ... -->
  </include>
</launch>
```

### Configuration

Parameters are provided to configure the behavior of the bridge. These parameters must be set at initialization through a launch file or the command line, they cannot be modified at runtime.

 * __port__: The TCP port to bind the WebSocket server to. Must be a valid TCP port number, or 0 to use a random port. Defaults to `8765`.
 * __address__: The host address to bind the WebSocket server to. Defaults to `0.0.0.0`, listening on all interfaces by default. Change this to `127.0.0.1` (or `::1` for IPv6) to only accept connections from the local machine.
 * __tls__: If `true`, use Transport Layer Security (TLS) for encrypted communication. Defaults to `false`.
 * __certfile__: Path to the certificate to use for TLS. Required when __tls__ is set to `true`. Defaults to `""`.
 * __keyfile__: Path to the private key to use for TLS. Required when __tls__ is set to `true`. Defaults to `""`.
 * __topic_whitelist__: List of regular expressions ([ECMAScript grammar](https://en.cppreference.com/w/cpp/regex/ecmascript)) of whitelisted topic names. Defaults to `[".*"]`.
 * __service_whitelist__: List of regular expressions ([ECMAScript grammar](https://en.cppreference.com/w/cpp/regex/ecmascript)) of whitelisted service names. Defaults to `[".*"]`.
 * __param_whitelist__: List of regular expressions ([ECMAScript grammar](https://en.cppreference.com/w/cpp/regex/ecmascript)) of whitelisted parameter names. Defaults to `[".*"]`.
  * __client_topic_whitelist__: List of regular expressions ([ECMAScript grammar](https://en.cppreference.com/w/cpp/regex/ecmascript)) of whitelisted client-published topic names. Defaults to `[".*"]`.
 * __send_buffer_limit__: Connection send buffer limit in bytes. Messages will be dropped when a connection's send buffer reaches this limit to avoid a queue of outdated messages building up. Defaults to `10000000` (10 MB).
 * __use_compression__: Use websocket compression (permessage-deflate). It is recommended to leave this turned off as it increases CPU usage and per-message compression often yields low compression ratios for robotics data. Defaults to `false`.
 * __capabilities__: List of supported [server capabilities](https://github.com/foxglove/ws-protocol/blob/main/docs/spec.md). Defaults to `[clientPublish,parameters,parametersSubscribe,services,connectionGraph,assets]`.
 * __asset_uri_allowlist__: List of regular expressions ([ECMAScript grammar](https://en.cppreference.com/w/cpp/regex/ecmascript)) of allowed asset URIs. Uses the [resource_retriever](https://index.ros.org/p/resource_retriever/github-ros-resource_retriever) to resolve `package://`, `file://` or `http(s)://` URIs. Note that this list should be carefully configured such that no confidential files are accidentally exposed over the websocket connection. As an extra security measure, URIs containing two consecutive dots (`..`) are disallowed as they could be used to construct URIs that would allow retrieval of confidential files if the allowlist is not configured strict enough (e.g. `package://<pkg_name>/../../../secret.txt`). Defaults to `["^package://(?:[-\w%]+/)*[-\w%]+\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$"]`.
 * (ROS 1) __max_update_ms__: The maximum number of milliseconds to wait in between polling `roscore` for new topics, services, or parameters. Defaults to `5000`.
 * (ROS 1) __service_type_retrieval_timeout_ms__: Max number of milliseconds for retrieving a services type information. Defaults to `250`.
 * (ROS 2) __num_threads__: The number of threads to use for the ROS node executor. This controls the number of subscriptions that can be processed in parallel. 0 means one thread per CPU core. Defaults to `0`.
 * (ROS 2) __min_qos_depth__: Minimum depth used for the QoS profile of subscriptions. Defaults to `1`. This is to set a lower limit for a subscriber's QoS depth which is computed by summing up depths of all publishers. See also [#208](https://github.com/foxglove/ros-foxglove-bridge/issues/208).
 * (ROS 2) __max_qos_depth__: Maximum depth used for the QoS profile of subscriptions. Defaults to `25`.
 * (ROS 2) __best_effort_qos_topic_whitelist__: List of regular expressions (ECMAScript) for topics that should be forced to use 'best_effort' QoS. Unmatched topics will use 'reliable' QoS if ALL publishers are 'reliable', 'best_effort' if any publishers are 'best_effort'. Defaults to `["(?!)"]` (match nothing).
 * (ROS 2) __include_hidden__: Include hidden topics and services. Defaults to `false`.
 * (ROS 2) __disable_load_message__: Do not publish as loaned message when publishing a client message. Defaults to `true`.
 * (ROS 2) __ignore_unresponsive_param_nodes__: Avoid requesting parameters from previously unresponsive nodes. Defaults to `true`.

## Building from source

### Fetch source and install dependencies

```bash
cd <path/to/your/ros_ws>
git clone https://github.com/foxglove/ros-foxglove-bridge.git src/ros-foxglove-bridge
rosdep update
rosdep install --ignore-src --default-yes --from-path src
```

### ROS 1
```
catkin_make
source install/local_setup.bash
roslaunch --screen foxglove_bridge foxglove_bridge.launch
```

### ROS 2
```
colcon build --event-handlers console_direct+ --symlink-install
source install/local_setup.bash
ros2 launch foxglove_bridge foxglove_bridge_launch.xml
```

## Clients

[Foxglove](https://foxglove.dev/) connects to foxglove_bridge for live robotics visualization.

## Development

A VSCode container is provided with a dual ROS 1 and ROS 2 installation and
enough tools to build and run the bridge. Some bash aliases are defined to simplify the common workflow. Here's an example of building and running the ROS 2 node:

```bash
source /opt/ros/humble/setup.bash
ros2_build_debug  # or ros2_build_release
ros2_foxglove_bridge
```

To test the bridge with example data, open another terminal and download the test `.mcap` files:

```bash
./download_test_data.sh
```

Then start playback:

```bash
source /opt/ros/humble/setup.bash
ros2 bag play -l --clock 100 -s mcap data/nuScenes-v1.0-mini-scene-0061-ros2.mcap
```

## License
`foxglove_bridge` is released with a MIT license. For full terms and conditions, see the [LICENSE](LICENSE) file.



================================================
FILE: CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package foxglove_bridge
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

0.8.5 (2025-05-15)
------------------
* fix rolling/kilted builds due to resource_retriever API changes (`#351 <https://github.com/foxglove/ros-foxglove-bridge/issues/351>`_)
* avoid requesting parameters from unresponsive nodes (`#345 <https://github.com/foxglove/ros-foxglove-bridge/issues/345>`_)
* Update default `asset_uri_allowlist` parameter to allow dashes (`#347 <https://github.com/foxglove/ros-foxglove-bridge/issues/347>`_)
* reorganize devcontainer dockerfile (`#350 <https://github.com/foxglove/ros-foxglove-bridge/issues/350>`_)
* Use RCLCPP_VERSION_GTE from rclcpp/version.h in generic_client.cpp (`#344 <https://github.com/foxglove/ros-foxglove-bridge/issues/344>`_)
* Fixed logging typo (`#343 <https://github.com/foxglove/ros-foxglove-bridge/issues/343>`_)
* Contributors: Hans-Joachim Krauch, Meet Gandhi, johannesschrimpf

0.8.4 (2025-02-21)
------------------
* also advertise channels for ROS1 topics without publishers (`#341 <https://github.com/foxglove/ros-foxglove-bridge/issues/341>`_)
* Contributors: Hans-Joachim Krauch

0.8.3 (2025-02-03)
------------------
* add best_effort_qos_topic_whitelist param (`#329 <https://github.com/foxglove/ros-foxglove-bridge/issues/329>`_)
* Add missing functional include in message_definition_cache.cpp (`#334 <https://github.com/foxglove/ros-foxglove-bridge/issues/334>`_)
* Contributors: David Revay, Silvio Traversaro

0.8.2 (2024-12-1)
------------------
* Fix "no matching function" error on yocto kirkstone (`#331 <https://github.com/foxglove/ros-foxglove-bridge/issues/331>`_)
* Contributors: Graham Harison

0.8.1 (2024-11-26)
------------------
* Improve Error Reporting and Reduce Log Redundancy (`#327 <https://github.com/foxglove/ros-foxglove-bridge/issues/327>`_)
* Contributors: Robin Dumas

0.8.0 (2024-07-31)
------------------
* Fix usage of deprecated AsyncParametersClient constructor (`#319 <https://github.com/foxglove/ros-foxglove-bridge/issues/319>`_)
* Add ROS2 JSON publishing support (`#307 <https://github.com/foxglove/ros-foxglove-bridge/issues/307>`_)
* Contributors: Davide Faconti, Hans-Joachim Krauch

0.7.10 (2024-07-12)
-------------------
* Make ROS1 service type retrieval more robust (`#316 <https://github.com/foxglove/ros-foxglove-bridge/issues/316>`_)
* Contributors: Hans-Joachim Krauch

0.7.9 (2024-07-05)
------------------
* Fix parsing of IDL message definitions (`#313 <https://github.com/foxglove/ros-foxglove-bridge/issues/313>`_)
* Support publishing client message as loaned message (`#314 <https://github.com/foxglove/ros-foxglove-bridge/issues/314>`_)
* fix: remove extra ";" in websocket_server.hpp (`#311 <https://github.com/foxglove/ros-foxglove-bridge/issues/311>`_)
* Fix rolling smoke tests crashing (`#309 <https://github.com/foxglove/ros-foxglove-bridge/issues/309>`_)
* Contributors: Andrey Milko, Hans-Joachim Krauch

0.7.8 (2024-06-11)
------------------
* Fix srv definition parsing failing due to carriage return (`#303 <https://github.com/foxglove/ros-foxglove-bridge/issues/303>`_)
* Contributors: Hans-Joachim Krauch

0.7.7 (2024-05-21)
------------------
* send service call failure operation (`#298 <https://github.com/foxglove/ros-foxglove-bridge/issues/298>`_)
* Fix service definition parsing on ROS rolling (`#293 <https://github.com/foxglove/ros-foxglove-bridge/issues/293>`_)
* Update docs to discourage users from using websocket compression (`#297 <https://github.com/foxglove/ros-foxglove-bridge/issues/297>`_)
* Update README.md to remove '$ ' so that you can copy and run command (`#294 <https://github.com/foxglove/ros-foxglove-bridge/issues/294>`_)
* Fix typo in ROS2 launch file example (`#296 <https://github.com/foxglove/ros-foxglove-bridge/issues/296>`_)
* Contributors: Felipe Galindo, Hans-Joachim Krauch, Jacob Bandes-Storch, Roman Shtylman

0.7.6 (2024-02-26)
------------------
* Fix rolling builds (`#289 <https://github.com/foxglove/ros-foxglove-bridge/issues/289>`_)
* Remove dual ROS 1+2 devcontainer, remove ROS Galactic from the support matrix (`#285 <https://github.com/foxglove/ros-foxglove-bridge/issues/285>`_)
* Contributors: Hans-Joachim Krauch, John Hurliman

0.7.5 (2023-12-29)
------------------
* Add ROS 2 dependency for ament_index_cpp (`#281 <https://github.com/foxglove/ros-foxglove-bridge/issues/281>`_)
* Contributors: Chris Lalancette

0.7.4 (2023-12-14)
------------------
* Solved bug with incompatible QoS policies
* added explicit call to ParameterValue() to avoid clang error (`#277 <https://github.com/foxglove/ros-foxglove-bridge/issues/277>`_)
* Add iron release badge to readme (`#271 <https://github.com/foxglove/ros-foxglove-bridge/issues/271>`_)
* Contributors: Hans-Joachim Krauch, Ted

0.7.3 (2023-10-25)
------------------
* Fix `asset_uri_whitelist` regex backtracking issue, add more extensions (`#270 <https://github.com/foxglove/ros-foxglove-bridge/issues/270>`_)
* [ROS1] Fix callback accessing invalid reference to promise (`#268 <https://github.com/foxglove/ros-foxglove-bridge/issues/268>`_)
* Contributors: Hans-Joachim Krauch

0.7.2 (2023-09-12)
------------------
* Fix invalid pointers not being caught (`#265 <https://github.com/foxglove/ros-foxglove-bridge/issues/265>`_)
* Make ROS1 service type retrieval more robust (`#263 <https://github.com/foxglove/ros-foxglove-bridge/issues/263>`_)
* Contributors: Hans-Joachim Krauch

0.7.1 (2023-08-21)
------------------
* Communicate double / double array parameters with type info, explicitly cast when set from integer (`#256 <https://github.com/foxglove/ros-foxglove-bridge/issues/256>`_)
* Make ROS 2 smoke tests less flaky (`#260 <https://github.com/foxglove/ros-foxglove-bridge/issues/260>`_)
* Add debug config for ros2 smoke test (`#257 <https://github.com/foxglove/ros-foxglove-bridge/issues/257>`_)
* Handle client disconnection in message handler thread (`#259 <https://github.com/foxglove/ros-foxglove-bridge/issues/259>`_)
* Reduce smoke test flakiness (`#258 <https://github.com/foxglove/ros-foxglove-bridge/issues/258>`_)
* Server code improvements (`#250 <https://github.com/foxglove/ros-foxglove-bridge/issues/250>`_)
* Contributors: Hans-Joachim Krauch

0.7.0 (2023-07-12)
------------------
* Fix ROS2 launch file install rule not installing launch subfolder (`#243 <https://github.com/foxglove/ros-foxglove-bridge/issues/243>`_)
* Support building with boost asio (`#247 <https://github.com/foxglove/ros-foxglove-bridge/issues/247>`_)
* Avoid usage of tmpnam() for creating random filename (`#246 <https://github.com/foxglove/ros-foxglove-bridge/issues/246>`_)
* Implement ws-protocol's `fetchAsset` specification (`#232 <https://github.com/foxglove/ros-foxglove-bridge/issues/232>`_)
* Use `--include-eol-distros` for `rosdep` to fix melodic builds (`#244 <https://github.com/foxglove/ros-foxglove-bridge/issues/244>`_)
* Reduce logging severity for parameter retrieval logs (`#240 <https://github.com/foxglove/ros-foxglove-bridge/issues/240>`_)
* Contributors: Hans-Joachim Krauch, Micah Guttman

0.6.4 (2023-07-05)
------------------
* Assume publisher qos depth of 1 if the middleware reports the qos history as unknown (`#239 <https://github.com/foxglove/ros-foxglove-bridge/issues/239>`_)
* devcontainer: Use `--include-eol-distros` for `rosdep update` (`#237 <https://github.com/foxglove/ros-foxglove-bridge/issues/237>`_)
* Contributors: Hans-Joachim Krauch

0.6.3 (2023-06-16)
------------------
* Add iron build to CI (`#234 <https://github.com/foxglove/ros-foxglove-bridge/issues/234>`_)
* Fix QoS history being unknown when copied from existing publisher (`#233 <https://github.com/foxglove/ros-foxglove-bridge/issues/233>`_)
* Extract ROS 2 bridge header (`#228 <https://github.com/foxglove/ros-foxglove-bridge/issues/228>`_)
* Contributors: Hans-Joachim Krauch, Milan Vukov

0.6.2 (2023-05-11)
------------------
* Fix connection graph updates to due incorrect use of std::set_difference (`#226 <https://github.com/foxglove/ros-foxglove-bridge/issues/226>`_)
* Contributors: Ivan Nenakhov

0.6.1 (2023-05-05)
------------------
* Fix warning messages not being logged (`#224 <https://github.com/foxglove/ros-foxglove-bridge/issues/224>`_)
* Contributors: Hans-Joachim Krauch

0.6.0 (2023-05-04)
------------------
* Add support for nested parameters (ROS1) (`#221 <https://github.com/foxglove/ros-foxglove-bridge/issues/221>`_)
* Catch exceptions thrown in handler functions, send status to client (`#210 <https://github.com/foxglove/ros-foxglove-bridge/issues/210>`_)
* Fix unhandled xmlrpc exception (`#218 <https://github.com/foxglove/ros-foxglove-bridge/issues/218>`_)
* Add support for action topic and services (ROS2) (`#214 <https://github.com/foxglove/ros-foxglove-bridge/issues/214>`_)
* Add parameter to include hidden topics and services (ROS 2) (`#216 <https://github.com/foxglove/ros-foxglove-bridge/issues/216>`_)
* Add workaround for publishers not being cleaned up after they got destroyed (`#215 <https://github.com/foxglove/ros-foxglove-bridge/issues/215>`_)
* Fix error when compiling with C++20 (`#212 <https://github.com/foxglove/ros-foxglove-bridge/issues/212>`_)
* Devcontainer improvements (`#213 <https://github.com/foxglove/ros-foxglove-bridge/issues/213>`_)
* Add parameter for minimum subscription QoS depth (`#211 <https://github.com/foxglove/ros-foxglove-bridge/issues/211>`_)
* Log version and commit hash when node is started (`#209 <https://github.com/foxglove/ros-foxglove-bridge/issues/209>`_)
* Contributors: Hans-Joachim Krauch

0.5.3 (2023-03-31)
------------------
* Fix publishers being created with invalid QoS profile (`#205 <https://github.com/foxglove/ros-foxglove-bridge/issues/205>`_)
* Contributors: Hans-Joachim Krauch

0.5.2 (2023-03-29)
------------------
* Notify client when Server's send buffer limit has been reached (`#201 <https://github.com/foxglove/ros-foxglove-bridge/issues/201>`_)
* Add support for byte array params (`#199 <https://github.com/foxglove/ros-foxglove-bridge/issues/199>`_)
* Do not allow connection output buffer to exceed configured limit (`#196 <https://github.com/foxglove/ros-foxglove-bridge/issues/196>`_)
* Fix exception parameter not being used (`#194 <https://github.com/foxglove/ros-foxglove-bridge/issues/194>`_)
* Contributors: Hans-Joachim Krauch

0.5.1 (2023-03-09)
------------------
* Add more exception handling (`#191 <https://github.com/foxglove/ros-foxglove-bridge/issues/191>`_)
* [ROS1] Fix exception not being caught when retrieving service type  (`#190 <https://github.com/foxglove/ros-foxglove-bridge/issues/190>`_)
* Devcontainer: Use catkin tools, add build commands for ros1 (`#188 <https://github.com/foxglove/ros-foxglove-bridge/issues/188>`_)
* Contributors: Hans-Joachim Krauch

0.5.0 (2023-03-08)
------------------
* Add support for `schemaEncoding` field (`#186 <https://github.com/foxglove/ros-foxglove-bridge/issues/186>`_)
* Use QoS profile of existing publishers (if available) when creating new publishers (`#184 <https://github.com/foxglove/ros-foxglove-bridge/issues/184>`_)
* Make server more independent of given server configurations (`#185 <https://github.com/foxglove/ros-foxglove-bridge/issues/185>`_)
* Add parameter `client_topic_whitelist` for whitelisting client-published topics (`#181 <https://github.com/foxglove/ros-foxglove-bridge/issues/181>`_)
* Make server capabilities configurable (`#182 <https://github.com/foxglove/ros-foxglove-bridge/issues/182>`_)
* Fix action topic log spam (`#179 <https://github.com/foxglove/ros-foxglove-bridge/issues/179>`_)
* Remove (clang specific) compiler flag -Wmost (`#177 <https://github.com/foxglove/ros-foxglove-bridge/issues/177>`_)
* Improve the way compiler flags are set, use clang as default compiler (`#175 <https://github.com/foxglove/ros-foxglove-bridge/issues/175>`_)
* Avoid re-advertising existing channels when advertising new channels (`#172 <https://github.com/foxglove/ros-foxglove-bridge/issues/172>`_)
* Allow subscribing to connection graph updates (`#167 <https://github.com/foxglove/ros-foxglove-bridge/issues/167>`_)
* Contributors: Hans-Joachim Krauch

0.4.1 (2023-02-17)
------------------
* Run client handler functions in separate thread (`#165 <https://github.com/foxglove/ros-foxglove-bridge/issues/165>`_)
* Fix compilation error due to mismatched new-delete (`#163 <https://github.com/foxglove/ros-foxglove-bridge/issues/163>`_)
* Decouple server implementation (`#156 <https://github.com/foxglove/ros-foxglove-bridge/issues/156>`_)
* ROS2 parameter fixes (`#169 <https://github.com/foxglove/ros-foxglove-bridge/issues/169>`_)
* Fix program crash due to unhandled exception when creating publisher with invalid topic name (`#168 <https://github.com/foxglove/ros-foxglove-bridge/issues/168>`_)
* Contributors: Hans-Joachim Krauch

0.4.0 (2023-02-15)
------------------
* Update README with suggestion to build from source, minor fixes
* Do not build docker images, remove corresponding documentation (`#159 <https://github.com/foxglove/ros-foxglove-bridge/issues/159>`_)
* Add option to use permessage-deflate compression (`#152 <https://github.com/foxglove/ros-foxglove-bridge/issues/152>`_)
* Improve launch file documentation, add missing launch file arguments (`#158 <https://github.com/foxglove/ros-foxglove-bridge/issues/158>`_)
* Allow unsetting (deleting) parameters (`#145 <https://github.com/foxglove/ros-foxglove-bridge/issues/145>`_)
* Improve mutex usage (`#154 <https://github.com/foxglove/ros-foxglove-bridge/issues/154>`_)
* Add sessionId to serverInfo (`#153 <https://github.com/foxglove/ros-foxglove-bridge/issues/153>`_)
* Performance improvements (`#151 <https://github.com/foxglove/ros-foxglove-bridge/issues/151>`_)
* Add ROS2 support for calling server-advertised services (`#142 <https://github.com/foxglove/ros-foxglove-bridge/issues/142>`_)
* Add ROS1 support for calling server-advertised services (`#136 <https://github.com/foxglove/ros-foxglove-bridge/issues/136>`_)
* ROS2 smoke test: Increase default timeout 8->10 seconds (`#143 <https://github.com/foxglove/ros-foxglove-bridge/issues/143>`_)
* Fix flaky parameter test (noetic) (`#141 <https://github.com/foxglove/ros-foxglove-bridge/issues/141>`_)
* Always --pull when building docker images in the makefile (`#140 <https://github.com/foxglove/ros-foxglove-bridge/issues/140>`_)
* Fix failed tests not causing CI to fail (`#138 <https://github.com/foxglove/ros-foxglove-bridge/issues/138>`_)
* Fix setting `int` / `int[]` parameters not working (ROS 1) (`#135 <https://github.com/foxglove/ros-foxglove-bridge/issues/135>`_)
* Send ROS_DISTRO to clients via metadata field (`#134 <https://github.com/foxglove/ros-foxglove-bridge/issues/134>`_)
* Communicate supported encodings for client-side publishing (`#131 <https://github.com/foxglove/ros-foxglove-bridge/issues/131>`_)
* Fix client advertised channels not being updated on unadvertise (`#132 <https://github.com/foxglove/ros-foxglove-bridge/issues/132>`_)
* Add support for optional request id for `setParameter` operation (`#133 <https://github.com/foxglove/ros-foxglove-bridge/issues/133>`_)
* Fix exception when setting parameter to empty array (`#130 <https://github.com/foxglove/ros-foxglove-bridge/issues/130>`_)
* Fix wrong parameter field names being used (`#129 <https://github.com/foxglove/ros-foxglove-bridge/issues/129>`_)
* Add parameter support (`#112 <https://github.com/foxglove/ros-foxglove-bridge/issues/112>`_)
* Add throttled logging when send buffer is full (`#128 <https://github.com/foxglove/ros-foxglove-bridge/issues/128>`_)
* Contributors: Hans-Joachim Krauch, John Hurliman

0.3.0 (2023-01-04)
------------------
* Add launch files, add install instructions to README (`#125 <https://github.com/foxglove/ros-foxglove-bridge/issues/125>`_)
* Drop messages when connection send buffer limit has been reached (`#126 <https://github.com/foxglove/ros-foxglove-bridge/issues/126>`_)
* Remove references to galactic support from README (`#117 <https://github.com/foxglove/ros-foxglove-bridge/issues/117>`_)
* Add missing build instructions (`#123 <https://github.com/foxglove/ros-foxglove-bridge/issues/123>`_)
* Use a single reentrant callback group for all subscriptions (`#122 <https://github.com/foxglove/ros-foxglove-bridge/issues/122>`_)
* Fix clang compilation errors (`#119 <https://github.com/foxglove/ros-foxglove-bridge/issues/119>`_)
* Publish binary time data when `use_sim_time` parameter is `true` (`#114 <https://github.com/foxglove/ros-foxglove-bridge/issues/114>`_)
* Optimize Dockerfiles (`#110 <https://github.com/foxglove/ros-foxglove-bridge/issues/110>`_)
* Contributors: Hans-Joachim Krauch, Ruffin

0.2.2 (2022-12-12)
------------------
* Fix messages not being received anymore after unadvertising a client publication (`#109 <https://github.com/foxglove/ros-foxglove-bridge/issues/109>`_)
* Allow to whitelist topics via a ROS paramater (`#108 <https://github.com/foxglove/ros-foxglove-bridge/issues/108>`_)
* Contributors: Hans-Joachim Krauch

0.2.1 (2022-12-05)
------------------
* Fix compilation on platforms where size_t is defined as `unsigned int`
* Contributors: Hans-Joachim Krauch

0.2.0 (2022-12-01)
------------------

* Add support for client channels (`#66 <https://github.com/foxglove/ros-foxglove-bridge/issues/66>`_)
* Add smoke tests (`#72 <https://github.com/foxglove/ros-foxglove-bridge/issues/72>`_)
* Update package maintainers (`#70 <https://github.com/foxglove/ros-foxglove-bridge/issues/70>`_)
* [ROS2]: Fix messages not being received anymore after unsubscribing a topic (`#92 <https://github.com/foxglove/ros-foxglove-bridge/issues/92>`_)
* [ROS2]: Refactor node as a component (`#63 <https://github.com/foxglove/ros-foxglove-bridge/issues/63>`_)
* [ROS2]: Fix message definition loading for `.msg` or `.idl` files not located in `msg/` (`#95 <https://github.com/foxglove/ros-foxglove-bridge/issues/95>`_)
* [ROS1]: Mirror ROS 2 node behavior when `/clock`` topic is present (`#99 <https://github.com/foxglove/ros-foxglove-bridge/issues/99>`_)
* [ROS1]: Fix topic discovery function not being called frequently at startup (`#68 <https://github.com/foxglove/ros-foxglove-bridge/issues/68>`_)
* Contributors: Hans-Joachim Krauch, Jacob Bandes-Storch, John Hurliman

0.1.0 (2022-11-21)
------------------
* Initial release, topic subscription only



================================================
FILE: CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.10.2)

if(POLICY CMP0048)
  cmake_policy(SET CMP0048 NEW)
  set(CMAKE_POLICY_DEFAULT_CMP0048 NEW)
endif()
if(POLICY CMP0024)
  cmake_policy(SET CMP0024 NEW)
  set(CMAKE_POLICY_DEFAULT_CMP0024 NEW)
endif()

project(foxglove_bridge LANGUAGES CXX VERSION 0.8.5)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

macro(enable_strict_compiler_warnings target)
  if (MSVC)
    target_compile_options(${target} PRIVATE /WX /W4)
  elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    target_compile_options(${target} PRIVATE -Wall -Wextra -Wpedantic -Werror -Wold-style-cast -Wfloat-equal -Wmost -Wunused-exception-parameter)
  else()
    target_compile_options(${target} PRIVATE -Wall -Wextra -Wpedantic -Werror -Wold-style-cast -Wfloat-equal)
  endif()
endmacro()

find_package(nlohmann_json QUIET)
find_package(OpenSSL REQUIRED)
find_package(Threads REQUIRED)
find_package(websocketpp REQUIRED)
find_package(ZLIB REQUIRED)

if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE RelWithDebInfo)
endif()

option(USE_FOXGLOVE_SDK "Build with Foxglove SDK" OFF)
add_definitions(-DUSE_FOXGLOVE_SDK=${USE_FOXGLOVE_SDK})

# Determine wheter to use standalone or boost asio
option(USE_ASIO_STANDALONE "Build with standalone ASIO" ON)
if(USE_ASIO_STANDALONE)
  message(STATUS "Using standalone ASIO")
  add_definitions(-DASIO_STANDALONE)
else()
  message(STATUS "Using Boost ASIO")
  find_package(Boost REQUIRED)
endif(USE_ASIO_STANDALONE)

# Detect big-endian architectures
include(TestBigEndian)
TEST_BIG_ENDIAN(ENDIAN)
if (ENDIAN)
  add_compile_definitions(ARCH_IS_BIG_ENDIAN=1)
endif()

if(USE_FOXGLOVE_SDK)
  if (CMAKE_SYSTEM_NAME STREQUAL "Linux" AND CMAKE_SYSTEM_PROCESSOR STREQUAL "aarch64")
    set(FOXGLOVE_SDK_RELEASES "https://github.com/foxglove/foxglove-sdk/releases/download/sdk%2Fv0.10.0/foxglove-v0.10.0-cpp-aarch64-unknown-linux-gnu.zip" "81e2379e3a08160c023779eab0fe5c5764ace3b30c8727b0030ac7dc8b415016")
  elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux" AND CMAKE_SYSTEM_PROCESSOR STREQUAL "x86_64")
    set(FOXGLOVE_SDK_RELEASES "https://github.com/foxglove/foxglove-sdk/releases/download/sdk%2Fv0.10.0/foxglove-v0.10.0-cpp-x86_64-unknown-linux-gnu.zip" "209d34a8703d44a129c559493e1a3fb215888b4d5973622750ac28b1c345946c")
  else()
    message(FATAL_ERROR "Unsupported platform: ${CMAKE_SYSTEM_PROCESSOR}-${CMAKE_SYSTEM_NAME}")
  endif()

  list(GET FOXGLOVE_SDK_RELEASES 0 url)
  list(GET FOXGLOVE_SDK_RELEASES 1 hash)

  # Download Foxglove SDK shared lib
  include(FetchContent)
  FetchContent_Declare(
    foxglove_sdk
    URL ${url}
    URL_HASH SHA256=${hash}
  )
  FetchContent_MakeAvailable(foxglove_sdk)

  add_library(foxglove_sdk STATIC)
  target_include_directories(foxglove_sdk SYSTEM
    PUBLIC
      $<BUILD_INTERFACE:${foxglove_sdk_SOURCE_DIR}/include>
      $<INSTALL_INTERFACE:include>
  )
  file(GLOB_RECURSE FOXGLOVE_SDK_SOURCES CONFIGURE_DEPENDS "${foxglove_sdk_SOURCE_DIR}/src/*.cpp")
  target_sources(foxglove_sdk PRIVATE ${FOXGLOVE_SDK_SOURCES})
  set_target_properties(foxglove_sdk PROPERTIES POSITION_INDEPENDENT_CODE ON)
  target_link_libraries(foxglove_sdk PRIVATE ${foxglove_sdk_SOURCE_DIR}/lib/libfoxglove.a)
endif()

# Get git commit hash and replace variables in version.cpp.in
find_program(GIT_SCM git DOC "Git version control")
if (GIT_SCM)
  execute_process(
    COMMAND ${GIT_SCM} describe --always --dirty --exclude="*"
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    OUTPUT_VARIABLE FOXGLOVE_BRIDGE_GIT_HASH
    OUTPUT_STRIP_TRAILING_WHITESPACE
  )
endif()
set(FOXGLOVE_BRIDGE_VERSION "${CMAKE_PROJECT_VERSION}")
configure_file(foxglove_bridge_base/src/version.cpp.in
               foxglove_bridge_base/src/version.cpp @ONLY)
# Build the foxglove_bridge_base library
add_library(foxglove_bridge_base SHARED
  foxglove_bridge_base/src/base64.cpp
  foxglove_bridge_base/src/foxglove_bridge.cpp
  foxglove_bridge_base/src/parameter.cpp
  foxglove_bridge_base/src/serialization.cpp
  foxglove_bridge_base/src/server_factory.cpp
  foxglove_bridge_base/src/test/test_client.cpp
  # Generated:
  ${CMAKE_CURRENT_BINARY_DIR}/foxglove_bridge_base/src/version.cpp
)
target_include_directories(foxglove_bridge_base
  PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/foxglove_bridge_base/include>
    $<INSTALL_INTERFACE:include>
)
target_link_libraries(foxglove_bridge_base
  OpenSSL::Crypto
  OpenSSL::SSL
  ZLIB::ZLIB
  ${CMAKE_THREAD_LIBS_INIT}
)

if(nlohmann_json_FOUND)
  target_link_libraries(foxglove_bridge_base nlohmann_json::nlohmann_json)
else()
  message(STATUS "nlohmann_json not found, will search at compile time")
endif()
enable_strict_compiler_warnings(foxglove_bridge_base)

message(STATUS "ROS_VERSION: " $ENV{ROS_VERSION})
message(STATUS "ROS_DISTRO: " $ENV{ROS_DISTRO})
message(STATUS "ROS_ROOT: " $ENV{ROS_ROOT})
if("$ENV{ROS_VERSION}" STREQUAL "1")
  # ROS 1
  if(CATKIN_DEVEL_PREFIX OR catkin_FOUND OR CATKIN_BUILD_BINARY_PACKAGE)
    message(STATUS "Building with catkin")
    set(ROS_BUILD_TYPE "catkin")

    find_package(catkin REQUIRED COMPONENTS nodelet resource_retriever ros_babel_fish rosgraph_msgs roslib roscpp)
    find_package(Boost REQUIRED)

    catkin_package(
      INCLUDE_DIRS foxglove_bridge_base/include
      LIBRARIES foxglove_bridge_base foxglove_bridge_nodelet
      CATKIN_DEPENDS nodelet resource_retriever ros_babel_fish rosgraph_msgs roslib roscpp
      DEPENDS Boost
    )

    add_library(foxglove_bridge_nodelet
      ros1_foxglove_bridge/src/ros1_foxglove_bridge_nodelet.cpp
      ros1_foxglove_bridge/src/param_utils.cpp
      ros1_foxglove_bridge/src/service_utils.cpp
    )
    target_include_directories(foxglove_bridge_nodelet
      SYSTEM PRIVATE
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/foxglove_bridge_base/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/ros1_foxglove_bridge/include>
        $<INSTALL_INTERFACE:include>
        ${catkin_INCLUDE_DIRS}
    )
    target_link_libraries(foxglove_bridge_nodelet foxglove_bridge_base ${catkin_LIBRARIES})
    enable_strict_compiler_warnings(foxglove_bridge_nodelet)

    add_executable(foxglove_bridge ros1_foxglove_bridge/src/ros1_foxglove_bridge_node.cpp)
    target_include_directories(foxglove_bridge SYSTEM PRIVATE ${catkin_INCLUDE_DIRS})
    target_link_libraries(foxglove_bridge ${catkin_LIBRARIES})
    enable_strict_compiler_warnings(foxglove_bridge)
  else()
    message(FATAL_ERROR "Could not find catkin")
  endif()
elseif("$ENV{ROS_VERSION}" STREQUAL "2")
  # ROS 2
  if(DEFINED ENV{AMENT_PREFIX_PATH})
    message(STATUS "Building with ament_cmake")
    set(ROS_BUILD_TYPE "ament_cmake")


    find_package(ament_cmake REQUIRED)
    find_package(rosgraph_msgs REQUIRED)
    find_package(rclcpp REQUIRED)
    find_package(rclcpp_components REQUIRED)
    find_package(resource_retriever REQUIRED)
    find_package(rosx_introspection REQUIRED)

    if(USE_FOXGLOVE_SDK)
      set(ros2_foxglove_bridge_src_dir ros2_foxglove_bridge_sdk)

      # Generate version.hpp
      configure_file(ros2_foxglove_bridge_sdk/include/foxglove_bridge/version.hpp.in
                    ros2_foxglove_bridge_sdk/include/foxglove_bridge/version.hpp @ONLY)

      add_library(foxglove_bridge_component SHARED
        ros2_foxglove_bridge_sdk/src/message_definition_cache.cpp
        ros2_foxglove_bridge_sdk/src/param_utils.cpp
        ros2_foxglove_bridge_sdk/src/ros2_foxglove_bridge.cpp
        ros2_foxglove_bridge_sdk/src/parameter_interface.cpp
        ros2_foxglove_bridge_sdk/src/generic_client.cpp
      )
      target_include_directories(foxglove_bridge_component
        PUBLIC
          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/ros2_foxglove_bridge_sdk/include>
          # For generated version.hpp
          $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/ros2_foxglove_bridge_sdk/include>
          $<INSTALL_INTERFACE:include>
      )

      target_link_libraries(foxglove_bridge_component
        foxglove_sdk
        OpenSSL::SSL
      )
      if (nlohmann_json_FOUND)
        target_link_libraries(foxglove_bridge_component nlohmann_json::nlohmann_json)
      endif()
    else()
      set(ros2_foxglove_bridge_src_dir ros2_foxglove_bridge)
      add_library(foxglove_bridge_component SHARED
        ros2_foxglove_bridge/src/message_definition_cache.cpp
        ros2_foxglove_bridge/src/param_utils.cpp
        ros2_foxglove_bridge/src/ros2_foxglove_bridge.cpp
        ros2_foxglove_bridge/src/parameter_interface.cpp
        ros2_foxglove_bridge/src/generic_client.cpp
      )
      target_include_directories(foxglove_bridge_component
        PUBLIC
          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/foxglove_bridge_base/include>
          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/ros2_foxglove_bridge/include>
          $<INSTALL_INTERFACE:include>
      )

      target_link_libraries(foxglove_bridge_component foxglove_bridge_base)
    endif()


    target_compile_definitions(foxglove_bridge_component
      PRIVATE
        RESOURCE_RETRIEVER_VERSION_MAJOR=${resource_retriever_VERSION_MAJOR}
        RESOURCE_RETRIEVER_VERSION_MINOR=${resource_retriever_VERSION_MINOR}
        RESOURCE_RETRIEVER_VERSION_PATCH=${resource_retriever_VERSION_PATCH}
    )

    target_link_libraries(foxglove_bridge_component
      ${rosgraph_msgs_TARGETS}
      ament_index_cpp::ament_index_cpp
      rclcpp::rclcpp
      rclcpp_components::component
      rclcpp_components::component_manager
      resource_retriever::resource_retriever
      rosx_introspection::rosx_introspection
    )

    rclcpp_components_register_nodes(foxglove_bridge_component "foxglove_bridge::FoxgloveBridge")
    enable_strict_compiler_warnings(foxglove_bridge_component)

    add_executable(foxglove_bridge
      ${ros2_foxglove_bridge_src_dir}/src/ros2_foxglove_bridge_node.cpp
    )
    target_include_directories(foxglove_bridge SYSTEM PRIVATE ${rclcpp_INCLUDE_DIRS})
    target_link_libraries(foxglove_bridge
      foxglove_bridge_component
      rclcpp::rclcpp
      rclcpp_components::component
      rclcpp_components::component_manager
    )
    enable_strict_compiler_warnings(foxglove_bridge)
  else()
    message(FATAL_ERROR "Could not find ament_cmake")
  endif()
else()
  message(FATAL_ERROR "ROS_VERSION environment variable must be 1 or 2")
endif()

#### TESTS #####################################################################

if(ROS_BUILD_TYPE STREQUAL "catkin")
  if (CATKIN_ENABLE_TESTING)
    message(STATUS "Building tests with catkin")

    find_package(catkin REQUIRED COMPONENTS roscpp std_msgs std_srvs)
    if(NOT "$ENV{ROS_DISTRO}" STREQUAL "melodic")
      find_package(GTest REQUIRED)
    endif()
    find_package(rostest REQUIRED)
    find_package(Boost REQUIRED COMPONENTS system)

    catkin_add_gtest(version_test foxglove_bridge_base/tests/version_test.cpp)
    target_link_libraries(version_test foxglove_bridge_base ${Boost_LIBRARIES})
    enable_strict_compiler_warnings(version_test)

    catkin_add_gtest(serialization_test foxglove_bridge_base/tests/serialization_test.cpp)
    target_link_libraries(serialization_test foxglove_bridge_base ${Boost_LIBRARIES})
    enable_strict_compiler_warnings(foxglove_bridge)

    catkin_add_gtest(base64_test foxglove_bridge_base/tests/base64_test.cpp)
    target_link_libraries(base64_test foxglove_bridge_base ${Boost_LIBRARIES})
    enable_strict_compiler_warnings(foxglove_bridge)

    add_rostest_gtest(smoke_test ros1_foxglove_bridge/tests/smoke.test ros1_foxglove_bridge/tests/smoke_test.cpp)
    target_include_directories(smoke_test SYSTEM PRIVATE
      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/foxglove_bridge_base/include>
      ${catkin_INCLUDE_DIRS}
      $<INSTALL_INTERFACE:include>
    )
    target_link_libraries(smoke_test foxglove_bridge_base ${catkin_LIBRARIES})
    enable_strict_compiler_warnings(smoke_test)
  endif()
elseif(ROS_BUILD_TYPE STREQUAL "ament_cmake")
  if(BUILD_TESTING)
    message(STATUS "Building tests with ament_cmake")

    find_package(ament_cmake_gtest REQUIRED)
    find_package(ament_lint_auto REQUIRED)
    ament_lint_auto_find_test_dependencies()

    ament_add_gtest(version_test foxglove_bridge_base/tests/version_test.cpp)
    target_link_libraries(version_test foxglove_bridge_base)
    enable_strict_compiler_warnings(version_test)

    ament_add_gtest(serialization_test foxglove_bridge_base/tests/serialization_test.cpp)
    target_link_libraries(serialization_test foxglove_bridge_base)
    enable_strict_compiler_warnings(serialization_test)

    ament_add_gtest(base64_test foxglove_bridge_base/tests/base64_test.cpp)
    target_link_libraries(base64_test foxglove_bridge_base)
    enable_strict_compiler_warnings(base64_test)

    # Repeat tests several times to catch nondeterministic issues
    ament_add_gtest(smoke_test ${ros2_foxglove_bridge_src_dir}/tests/smoke_test.cpp ENV GTEST_REPEAT=50 TIMEOUT 600)
    target_link_libraries(smoke_test
      foxglove_bridge_component
      ${std_msgs_TARGETS}
      ${std_srvs_TARGETS}
      rclcpp::rclcpp
      rclcpp_components::component
      rclcpp_components::component_manager
    )
    enable_strict_compiler_warnings(smoke_test)

    ament_add_gtest(utils_test ${ros2_foxglove_bridge_src_dir}/tests/utils_test.cpp)
    target_link_libraries(utils_test foxglove_bridge_component)
    enable_strict_compiler_warnings(utils_test)
  endif()
endif()

#### INSTALL ###################################################################

if(ROS_BUILD_TYPE STREQUAL "catkin")
    install(TARGETS foxglove_bridge
      RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
    )
    install(TARGETS foxglove_bridge_base foxglove_bridge_nodelet
      ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
      LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
      RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION}
    )
    install(FILES nodelets.xml
      DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
    )
    install(DIRECTORY ros1_foxglove_bridge/launch/
      DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}/launch
    )
elseif(ROS_BUILD_TYPE STREQUAL "ament_cmake")
    install(FILES ros2_foxglove_bridge/include/foxglove_bridge/ros2_foxglove_bridge.hpp
      DESTINATION include/${PROJECT_NAME}/
    )
    install(TARGETS foxglove_bridge
      DESTINATION lib/${PROJECT_NAME}
    )
    install(TARGETS foxglove_bridge_base foxglove_bridge_component
      ARCHIVE DESTINATION lib
      LIBRARY DESTINATION lib
      RUNTIME DESTINATION bin
    )
    install(DIRECTORY ros2_foxglove_bridge/launch
      DESTINATION share/${PROJECT_NAME}/
    )
    install(FILES ros2_foxglove_bridge/include/foxglove_bridge/utils.hpp
      DESTINATION include/${PROJECT_NAME}/
    )
    ament_export_libraries(foxglove_bridge_base foxglove_bridge_component)
    ament_package()
endif()



================================================
FILE: Dockerfile.ros1
================================================
ARG ROS_DISTRIBUTION=noetic
FROM ros:$ROS_DISTRIBUTION-ros-base

# Update apt keys for EOL distros. For current distros this is already in the base docker image.
# https://github.com/osrf/docker_images/commit/eb5634cf92ba079897e44fb7541d3b78aa6cf717
# https://discourse.ros.org/t/ros-signing-key-migration-guide/43937
ADD --checksum=sha256:c0cc26f70da91a4fa5a613278a53885184e91df45214ab34e1bae0f3a44f83ea https://github.com/ros-infrastructure/ros-apt-source/releases/download/1.1.0/ros-apt-source_1.1.0.focal_all.deb /tmp/ros-apt-source.deb
RUN rm -f /etc/apt/sources.list.d/ros1-latest.list \
  && apt-get install /tmp/ros-apt-source.deb \
  && rm -f /tmp/ros-apt-source.deb \
  && rm -rf /var/lib/apt/lists/*

  # Install clang and set as default compiler.
RUN apt-get update && apt-get install -y --no-install-recommends \
  clang \
  && rm -rf /var/lib/apt/lists/*

ENV CC=clang
ENV CXX=clang++

# Set environment and working directory
ENV ROS_WS /ros1_ws
WORKDIR $ROS_WS

# Add package.xml so we can install package dependencies.
COPY package.xml src/ros-foxglove-bridge/

# Install rosdep dependencies
RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
    apt-get update && rosdep update --include-eol-distros && rosdep install -y \
      --from-paths \
        src \
      --ignore-src \
    && rm -rf /var/lib/apt/lists/*

# Add common files and ROS 1 source code
COPY CMakeLists.txt src/ros-foxglove-bridge/CMakeLists.txt
COPY foxglove_bridge_base src/ros-foxglove-bridge/foxglove_bridge_base
COPY nodelets.xml src/ros-foxglove-bridge/nodelets.xml
COPY ros1_foxglove_bridge src/ros-foxglove-bridge/ros1_foxglove_bridge

ARG USE_ASIO_STANDALONE=ON

# Build the Catkin workspace
RUN . /opt/ros/$ROS_DISTRO/setup.sh \
  && catkin_make -DUSE_ASIO_STANDALONE=$USE_ASIO_STANDALONE

# source workspace from entrypoint
RUN sed --in-place \
      's|^source .*|source "$ROS_WS/devel/setup.bash"|' \
      /ros_entrypoint.sh

# Run foxglove_bridge
CMD ["rosrun", "foxglove_bridge", "foxglove_bridge"]



================================================
FILE: Dockerfile.ros2
================================================
ARG ROS_DISTRIBUTION=humble
FROM ros:$ROS_DISTRIBUTION-ros-base

# Update apt keys for EOL distros. For current distros this is already in the base docker image.
# https://github.com/osrf/docker_images/commit/eb5634cf92ba079897e44fb7541d3b78aa6cf717
# https://discourse.ros.org/t/ros-signing-key-migration-guide/43937
ADD --checksum=sha256:1600cb8cc28258a39bffc1736a75bcbf52d1f2db371a4d020c1b187d2a5a083b https://github.com/ros-infrastructure/ros-apt-source/releases/download/1.1.0/ros2-apt-source_1.1.0.jammy_all.deb /tmp/ros2-apt-source.deb
RUN (dpkg-query -s ros2-apt-source || apt-get install /tmp/ros2-apt-source.deb) \
  && rm -f /tmp/ros2-apt-source.deb \
  && rm -rf /var/lib/apt/lists/*

# Install clang and set as default compiler.
RUN apt-get update && apt-get install -y --no-install-recommends \
  clang \
  && rm -rf /var/lib/apt/lists/*

ENV CC=clang
ENV CXX=clang++

# Set environment and working directory
ENV ROS_WS /ros2_ws
WORKDIR $ROS_WS

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
  nlohmann-json3-dev \
  libasio-dev \
  libboost-all-dev \
  libssl-dev \
  libwebsocketpp-dev \
  && rm -rf /var/lib/apt/lists/*

# Add package.xml so we can install package dependencies.
COPY package.xml src/ros-foxglove-bridge/

# Install rosdep dependencies
RUN . /opt/ros/$ROS_DISTRO/setup.sh && \
    apt-get update && rosdep update --include-eol-distros && rosdep install -y \
      --from-paths \
        src \
      --ignore-src \
    && rm -rf /var/lib/apt/lists/*

# Add common files and ROS 2 source code
COPY CMakeLists.txt src/ros-foxglove-bridge/CMakeLists.txt
COPY foxglove_bridge_base src/ros-foxglove-bridge/foxglove_bridge_base
COPY ros2_foxglove_bridge src/ros-foxglove-bridge/ros2_foxglove_bridge
COPY ros2_foxglove_bridge_sdk src/ros-foxglove-bridge/ros2_foxglove_bridge_sdk

ARG USE_ASIO_STANDALONE=ON
ARG USE_FOXGLOVE_SDK=OFF

# Build the ROS 2 workspace
RUN . /opt/ros/$ROS_DISTRO/setup.sh \
  && colcon build --event-handlers console_direct+ --cmake-args -DUSE_ASIO_STANDALONE=$USE_ASIO_STANDALONE -DUSE_FOXGLOVE_SDK=$USE_FOXGLOVE_SDK

# source workspace from entrypoint
RUN sed --in-place \
      's|^source .*|source "$ROS_WS/install/setup.bash"|' \
      /ros_entrypoint.sh

# Run foxglove_bridge
CMD ["ros2", "run", "foxglove_bridge", "foxglove_bridge"]



================================================
FILE: download_test_data.sh
================================================
#!/usr/bin/env bash

mkdir -p data
cd data
git clone https://github.com/foxglove/ros-foxglove-bridge-benchmark-assets.git .



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2022 Foxglove

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: Makefile
================================================
ROS1_DISTRIBUTIONS := melodic noetic
ROS2_DISTRIBUTIONS := humble jazzy kilted rolling
USE_FOXGLOVE_SDK := OFF

define generate_ros1_targets
.PHONY: $(1)
$(1):
	docker build -t foxglove_bridge_$(1) --pull -f Dockerfile.ros1 --build-arg ROS_DISTRIBUTION=$(1) .

.PHONY: $(1)-test
$(1)-test: $(1)
	docker run -t --rm foxglove_bridge_$(1) bash -c "catkin_make run_tests && catkin_test_results"

.PHONY: $(1)-boost-asio
$(1)-boost-asio:
	docker build -t foxglove_bridge_$(1)_boost_asio --pull -f Dockerfile.ros1 --build-arg ROS_DISTRIBUTION=$(1) --build-arg USE_ASIO_STANDALONE=OFF .

.PHONY: $(1)-test-boost-asio
$(1)-test-boost-asio: $(1)-boost-asio
	docker run -t --rm foxglove_bridge_$(1)_boost_asio bash -c "catkin_make run_tests && catkin_test_results"
endef

define generate_ros2_targets
.PHONY: $(1)
$(1):
	docker build -t foxglove_bridge_$(1) --pull -f Dockerfile.ros2 --build-arg ROS_DISTRIBUTION=$(1) --build-arg USE_FOXGLOVE_SDK=$(USE_FOXGLOVE_SDK) .

.PHONY: $(1)-test
$(1)-test: $(1)
	docker run -t --rm foxglove_bridge_$(1) colcon test --event-handlers console_cohesion+ --return-code-on-test-failure

.PHONY: $(1)-boost-asio
$(1)-boost-asio:
	docker build -t foxglove_bridge_$(1)-boost-asio --pull -f Dockerfile.ros2 --build-arg ROS_DISTRIBUTION=$(1) --build-arg USE_ASIO_STANDALONE=OFF .

.PHONY: $(1)-test-boost-asio
$(1)-test-boost-asio: $(1)-boost-asio
	docker run -t --rm foxglove_bridge_$(1)-boost-asio colcon test --event-handlers console_cohesion+ --return-code-on-test-failure
endef

$(foreach distribution,$(ROS1_DISTRIBUTIONS),$(eval $(call generate_ros1_targets,$(strip $(distribution)))))
$(foreach distribution,$(ROS2_DISTRIBUTIONS),$(eval $(call generate_ros2_targets,$(strip $(distribution)))))


default: ros2

.PHONY: ros1
ros1:
	docker build -t foxglove_bridge_ros1 --pull -f Dockerfile.ros1 .

.PHONY: ros2
ros2:
	docker build -t foxglove_bridge_ros2 --pull -f Dockerfile.ros2 .

.PHONY: rosdev
rosdev:
	docker build -t foxglove_bridge_rosdev --pull -f .devcontainer/Dockerfile .

clean:
	docker rmi $(docker images --filter=reference="foxglove_bridge_*" -q)

.PHONY: lint
lint: rosdev
	docker run -t --rm -v $(CURDIR):/src foxglove_bridge_rosdev python3 /src/scripts/format.py /src



================================================
FILE: nodelets.xml
================================================
<library path="lib/libfoxglove_bridge_nodelet">
    <class name="foxglove_bridge/foxglove_bridge_nodelet"
           type="foxglove_bridge::FoxgloveBridge"
           base_class_type="nodelet::Nodelet">
        <description>
            Foxglove bridge nodelet.
        </description>
    </class>
</library>



================================================
FILE: package.xml
================================================
<?xml version="1.0"?>
<package format="3">
    <name>foxglove_bridge</name>
    <version>0.8.5</version>
    <description>ROS Foxglove Bridge</description>
    <license>MIT</license>
    <url type="website">https://github.com/foxglove/ros-foxglove-bridge</url>
    <author email="ros-tooling+foxglove_bridge@foxglove.dev">Foxglove</author>
    <maintainer email="ros-tooling+foxglove_bridge@foxglove.dev">Foxglove</maintainer>

    <buildtool_depend condition="$ROS_VERSION == 1">catkin</buildtool_depend>
    <buildtool_depend condition="$ROS_VERSION == 2">ament_cmake</buildtool_depend>

    <!-- ROS 1 runtime dependencies -->
    <depend condition="$ROS_VERSION == 1">nodelet</depend>
    <depend condition="$ROS_VERSION == 1">ros_babel_fish</depend>
    <depend condition="$ROS_VERSION == 1">roscpp</depend>
    <depend condition="$ROS_VERSION == 1">roslib</depend>

    <!-- ROS 2 runtime dependencies -->
    <depend condition="$ROS_VERSION == 2">ament_index_cpp</depend>
    <depend condition="$ROS_VERSION == 2">rclcpp</depend>
    <depend condition="$ROS_VERSION == 2">rclcpp_components</depend>

    <depend condition="$ROS_VERSION == 2">rosx_introspection</depend>


    <!-- Test dependencies -->
    <test_depend condition="$ROS_VERSION == 1">gtest</test_depend>
    <test_depend condition="$ROS_VERSION == 1">rostest</test_depend>
    <test_depend condition="$ROS_VERSION == 1">rosunit</test_depend>
    <test_depend condition="$ROS_VERSION == 2">ament_cmake_gtest</test_depend>
    <test_depend condition="$ROS_VERSION == 2">ament_lint_auto</test_depend>
    <test_depend>std_msgs</test_depend>
    <test_depend>std_srvs</test_depend>

    <!-- Common dependencies -->
    <build_depend>asio</build_depend>
    <build_depend>libssl-dev</build_depend>
    <build_depend>libwebsocketpp-dev</build_depend>
    <build_depend>nlohmann-json-dev</build_depend>
    <build_depend>ros_environment</build_depend>
    <build_depend>zlib</build_depend>

    <exec_depend>openssl</exec_depend>
    <exec_depend>zlib</exec_depend>

    <depend>resource_retriever</depend>
    <depend>rosgraph_msgs</depend>

    <!-- The export tag contains other, unspecified, tags -->
    <export>
        <build_type condition="$ROS_VERSION == 1">catkin</build_type>
        <build_type condition="$ROS_VERSION == 2">ament_cmake</build_type>
        <nodelet condition="$ROS_VERSION == 1" plugin="${prefix}/nodelets.xml" />
    </export>
</package>



================================================
FILE: .clang-format
================================================
---
Language: Cpp
Standard: c++17
BasedOnStyle: Google

AllowShortFunctionsOnASingleLine: Empty
AllowShortLambdasOnASingleLine: Empty
AccessModifierOffset: -2
TabWidth: 2
ContinuationIndentWidth: 2
UseTab: Never
BreakConstructorInitializers: BeforeComma
ColumnLimit: 100
ConstructorInitializerAllOnOneLineOrOnePerLine: false
DerivePointerAlignment: false
FixNamespaceComments: true
PointerAlignment: Left
ReflowComments: true
SortIncludes: true

IncludeCategories:
  - Regex: "^\".*"
    Priority: 4
    SortPriority: 0
  - Regex: "^<foxglove.*"
    Priority: 3
    SortPriority: 0
  - Regex: "^<.*/"
    Priority: 2
    SortPriority: 0
  - Regex: "^<.*"
    Priority: 1
    SortPriority: 0



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/base64.hpp
================================================
#pragma once

#include <cstdint>
#include <string>
#include <string_view>
#include <vector>

namespace foxglove_ws {

std::string base64Encode(const std::string_view& input);

std::vector<unsigned char> base64Decode(const std::string& input);

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/callback_queue.hpp
================================================
#pragma once

#include <atomic>
#include <condition_variable>
#include <deque>
#include <functional>
#include <mutex>
#include <thread>
#include <vector>

#include "websocket_logging.hpp"

namespace foxglove_ws {

class CallbackQueue {
public:
  CallbackQueue(LogCallback logCallback, size_t numThreads = 1)
      : _logCallback(logCallback)
      , _quit(false) {
    for (size_t i = 0; i < numThreads; ++i) {
      _workerThreads.push_back(std::thread(&CallbackQueue::doWork, this));
    }
  }

  ~CallbackQueue() {
    stop();
  }

  void stop() {
    _quit = true;
    _cv.notify_all();
    for (auto& thread : _workerThreads) {
      thread.join();
    }
  }

  void addCallback(std::function<void(void)> cb) {
    if (_quit) {
      return;
    }
    std::unique_lock<std::mutex> lock(_mutex);
    _callbackQueue.push_back(cb);
    _cv.notify_one();
  }

private:
  void doWork() {
    while (!_quit) {
      std::unique_lock<std::mutex> lock(_mutex);
      _cv.wait(lock, [this] {
        return (_quit || !_callbackQueue.empty());
      });
      if (_quit) {
        break;
      } else if (!_callbackQueue.empty()) {
        std::function<void(void)> cb = _callbackQueue.front();
        _callbackQueue.pop_front();
        lock.unlock();
        try {
          cb();
        } catch (const std::exception& ex) {
          // Should never get here if we catch all exceptions in the callbacks.
          const std::string msg =
            std::string("Caught unhandled exception in calback_queue") + ex.what();
          _logCallback(WebSocketLogLevel::Error, msg.c_str());
        } catch (...) {
          _logCallback(WebSocketLogLevel::Error, "Caught unhandled exception in calback_queue");
        }
      }
    }
  }

  LogCallback _logCallback;
  std::atomic<bool> _quit;
  std::mutex _mutex;
  std::condition_variable _cv;
  std::deque<std::function<void(void)>> _callbackQueue;
  std::vector<std::thread> _workerThreads;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/common.hpp
================================================
#pragma once

#include <array>
#include <cstring>
#include <optional>
#include <stdint.h>
#include <string>
#include <vector>

namespace foxglove_ws {

#ifdef USE_FOXGLOVE_SDK
constexpr char SUPPORTED_SUBPROTOCOL[] = "foxglove.sdk.v1";
#else
constexpr char SUPPORTED_SUBPROTOCOL[] = "foxglove.websocket.v1";
#endif

constexpr char CAPABILITY_CLIENT_PUBLISH[] = "clientPublish";
constexpr char CAPABILITY_TIME[] = "time";
constexpr char CAPABILITY_PARAMETERS[] = "parameters";
constexpr char CAPABILITY_PARAMETERS_SUBSCRIBE[] = "parametersSubscribe";
constexpr char CAPABILITY_SERVICES[] = "services";
constexpr char CAPABILITY_CONNECTION_GRAPH[] = "connectionGraph";
constexpr char CAPABILITY_ASSETS[] = "assets";

constexpr std::array<const char*, 6> DEFAULT_CAPABILITIES = {
  CAPABILITY_CLIENT_PUBLISH, CAPABILITY_CONNECTION_GRAPH, CAPABILITY_PARAMETERS_SUBSCRIBE,
  CAPABILITY_PARAMETERS,     CAPABILITY_SERVICES,         CAPABILITY_ASSETS,
};

using ChannelId = uint32_t;
using ClientChannelId = uint32_t;
using SubscriptionId = uint32_t;
using ServiceId = uint32_t;

enum class BinaryOpcode : uint8_t {
  MESSAGE_DATA = 1,
  TIME_DATA = 2,
  SERVICE_CALL_RESPONSE = 3,
  FETCH_ASSET_RESPONSE = 4,
};

enum class ClientBinaryOpcode : uint8_t {
  MESSAGE_DATA = 1,
  SERVICE_CALL_REQUEST = 2,
};

enum class WebSocketLogLevel {
  Debug,
  Info,
  Warn,
  Error,
  Critical,
};

struct ChannelWithoutId {
  std::string topic;
  std::string encoding;
  std::string schemaName;
  std::string schema;
  std::optional<std::string> schemaEncoding;

  bool operator==(const ChannelWithoutId& other) const {
    return topic == other.topic && encoding == other.encoding && schemaName == other.schemaName &&
           schema == other.schema && schemaEncoding == other.schemaEncoding;
  }
};

struct Channel : ChannelWithoutId {
  ChannelId id;

  Channel() = default;  // requirement for json conversions.
  Channel(ChannelId id, ChannelWithoutId ch)
      : ChannelWithoutId(std::move(ch))
      , id(id) {}

  bool operator==(const Channel& other) const {
    return id == other.id && ChannelWithoutId::operator==(other);
  }
};

struct ClientAdvertisement {
  ClientChannelId channelId;
  std::string topic;
  std::string encoding;
  std::string schemaName;
  std::vector<uint8_t> schema;
};

struct ClientMessage {
  uint64_t logTime;
  uint64_t publishTime;
  uint32_t sequence;
  ClientAdvertisement advertisement;
  size_t dataLength;
  std::vector<uint8_t> data;

  ClientMessage(uint64_t logTime, uint64_t publishTime, uint32_t sequence,
                const ClientAdvertisement& advertisement, size_t dataLength, const uint8_t* rawData)
      : logTime(logTime)
      , publishTime(publishTime)
      , sequence(sequence)
      , advertisement(advertisement)
      , dataLength(dataLength)
      , data(dataLength) {
    std::memcpy(data.data(), rawData, dataLength);
  }

  static const size_t MSG_PAYLOAD_OFFSET = 5;

  const uint8_t* getData() const {
    return data.data() + MSG_PAYLOAD_OFFSET;
  }
  std::size_t getLength() const {
    return data.size() - MSG_PAYLOAD_OFFSET;
  }
};

struct ServiceWithoutId {
  std::string name;
  std::string type;
  std::string requestSchema;
  std::string responseSchema;
};

struct Service : ServiceWithoutId {
  ServiceId id;

  Service() = default;
  Service(const ServiceWithoutId& s, const ServiceId& id)
      : ServiceWithoutId(s)
      , id(id) {}
};

struct ServiceResponse {
  ServiceId serviceId;
  uint32_t callId;
  std::string encoding;
  std::vector<uint8_t> data;

  size_t size() const {
    return 4 + 4 + 4 + encoding.size() + data.size();
  }
  void read(const uint8_t* data, size_t size);
  void write(uint8_t* data) const;

  bool operator==(const ServiceResponse& other) const {
    return serviceId == other.serviceId && callId == other.callId && encoding == other.encoding &&
           data == other.data;
  }
};

using ServiceRequest = ServiceResponse;

enum class FetchAssetStatus : uint8_t {
  Success = 0,
  Error = 1,
};

struct FetchAssetResponse {
  uint32_t requestId;
  FetchAssetStatus status;
  std::string errorMessage;
  std::vector<uint8_t> data;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/foxglove_bridge.hpp
================================================
#pragma once

namespace foxglove {

const char* WebSocketUserAgent();

extern const char FOXGLOVE_BRIDGE_VERSION[];

extern const char FOXGLOVE_BRIDGE_GIT_HASH[];

}  // namespace foxglove



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/message_definition_cache.hpp
================================================
#pragma once

#include <set>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

namespace foxglove {

// Taken from
// https://github.com/ros2/rosidl/blob/a57baea5/rosidl_parser/rosidl_parser/definition.py
constexpr char SERVICE_REQUEST_MESSAGE_SUFFIX[] = "_Request";
constexpr char SERVICE_RESPONSE_MESSAGE_SUFFIX[] = "_Response";
constexpr char ACTION_GOAL_SERVICE_SUFFIX[] = "_SendGoal";
constexpr char ACTION_RESULT_SERVICE_SUFFIX[] = "_GetResult";
constexpr char ACTION_FEEDBACK_MESSAGE_SUFFIX[] = "_FeedbackMessage";

enum struct MessageDefinitionFormat {
  IDL,
  MSG,
};

struct MessageSpec {
  MessageSpec(MessageDefinitionFormat format, std::string text, const std::string& package_context);
  const std::set<std::string> dependencies;
  const std::string text;
  MessageDefinitionFormat format;
};

struct DefinitionIdentifier {
  MessageDefinitionFormat format;
  std::string package_resource_name;

  bool operator==(const DefinitionIdentifier& di) const {
    return (format == di.format) && (package_resource_name == di.package_resource_name);
  }
};

class DefinitionNotFoundError : public std::exception {
private:
  std::string name_;

public:
  explicit DefinitionNotFoundError(std::string name)
      : name_(std::move(name)) {}

  const char* what() const noexcept override {
    return name_.c_str();
  }
};

class MessageDefinitionCache final {
public:
  /**
   * Concatenate the message definition with its dependencies into a self-contained schema.
   * The format is different for MSG and IDL definitions, and is described fully here:
   * [MSG](https://mcap.dev/specification/appendix.html#ros2msg-data-format)
   * [IDL](https://mcap.dev/specification/appendix.html#ros2idl-data-format)
   * Throws DefinitionNotFoundError if one or more definition files are missing for the given
   * package resource name.
   */
  std::pair<MessageDefinitionFormat, const std::string&> get_full_text(
    const std::string& package_resource_name);

private:
  struct DefinitionIdentifierHash {
    std::size_t operator()(const DefinitionIdentifier& di) const {
      std::size_t h1 = std::hash<MessageDefinitionFormat>()(di.format);
      std::size_t h2 = std::hash<std::string>()(di.package_resource_name);
      return h1 ^ h2;
    }
  };
  /**
   * Load and parse the message file referenced by the given datatype, or return it from
   * msg_specs_by_datatype
   */
  const MessageSpec& load_message_spec(const DefinitionIdentifier& definition_identifier);

  std::unordered_map<DefinitionIdentifier, MessageSpec, DefinitionIdentifierHash>
    msg_specs_by_definition_identifier_;
  std::unordered_map<std::string, std::string> full_text_cache_;
};

std::set<std::string> parse_dependencies(MessageDefinitionFormat format, const std::string& text,
                                         const std::string& package_context);

}  // namespace foxglove



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/parameter.hpp
================================================
#pragma once

#include <any>
#include <stdint.h>
#include <string>
#include <unordered_map>
#include <vector>

namespace foxglove_ws {

enum class ParameterSubscriptionOperation {
  SUBSCRIBE,
  UNSUBSCRIBE,
};

enum class ParameterType {
  PARAMETER_NOT_SET,
  PARAMETER_BOOL,
  PARAMETER_INTEGER,
  PARAMETER_DOUBLE,
  PARAMETER_STRING,
  PARAMETER_ARRAY,
  PARAMETER_STRUCT,      // ROS 1 only
  PARAMETER_BYTE_ARRAY,  // ROS 2 only
};

class ParameterValue {
public:
  ParameterValue();
  ParameterValue(bool value);
  ParameterValue(int value);
  ParameterValue(int64_t value);
  ParameterValue(double value);
  ParameterValue(const std::string& value);
  ParameterValue(const char* value);
  ParameterValue(const std::vector<unsigned char>& value);
  ParameterValue(const std::vector<ParameterValue>& value);
  ParameterValue(const std::unordered_map<std::string, ParameterValue>& value);

  inline ParameterType getType() const {
    return _type;
  }

  template <typename T>
  inline const T& getValue() const {
    return std::any_cast<const T&>(_value);
  }

private:
  ParameterType _type;
  std::any _value;
};

class Parameter {
public:
  Parameter();
  Parameter(const std::string& name);
  Parameter(const std::string& name, const ParameterValue& value);

  inline const std::string& getName() const {
    return _name;
  }

  inline ParameterType getType() const {
    return _value.getType();
  }

  inline const ParameterValue& getValue() const {
    return _value;
  }

private:
  std::string _name;
  ParameterValue _value;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/regex_utils.hpp
================================================
#pragma once

#include <algorithm>
#include <regex>
#include <string>
#include <vector>

namespace foxglove_ws {

inline bool isWhitelisted(const std::string& name, const std::vector<std::regex>& regexPatterns) {
  return std::find_if(regexPatterns.begin(), regexPatterns.end(), [name](const auto& regex) {
           return std::regex_match(name, regex);
         }) != regexPatterns.end();
}

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/serialization.hpp
================================================
#pragma once

#include <stdint.h>

#include <nlohmann/json.hpp>

#include "common.hpp"
#include "parameter.hpp"

namespace foxglove_ws {

inline void WriteUint64LE(uint8_t* buf, uint64_t val) {
#ifdef ARCH_IS_BIG_ENDIAN
  buf[0] = val & 0xff;
  buf[1] = (val >> 8) & 0xff;
  buf[2] = (val >> 16) & 0xff;
  buf[3] = (val >> 24) & 0xff;
  buf[4] = (val >> 32) & 0xff;
  buf[5] = (val >> 40) & 0xff;
  buf[6] = (val >> 48) & 0xff;
  buf[7] = (val >> 56) & 0xff;
#else
  reinterpret_cast<uint64_t*>(buf)[0] = val;
#endif
}

inline void WriteUint32LE(uint8_t* buf, uint32_t val) {
#ifdef ARCH_IS_BIG_ENDIAN
  buf[0] = val & 0xff;
  buf[1] = (val >> 8) & 0xff;
  buf[2] = (val >> 16) & 0xff;
  buf[3] = (val >> 24) & 0xff;
#else
  reinterpret_cast<uint32_t*>(buf)[0] = val;
#endif
}

inline uint32_t ReadUint32LE(const uint8_t* buf) {
#ifdef ARCH_IS_BIG_ENDIAN
  uint32_t val = (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
  return val;
#else
  return reinterpret_cast<const uint32_t*>(buf)[0];
#endif
}

void to_json(nlohmann::json& j, const Channel& c);
void from_json(const nlohmann::json& j, Channel& c);
void to_json(nlohmann::json& j, const ParameterValue& p);
void from_json(const nlohmann::json& j, ParameterValue& p);
void to_json(nlohmann::json& j, const Parameter& p);
void from_json(const nlohmann::json& j, Parameter& p);
void to_json(nlohmann::json& j, const Service& p);
void from_json(const nlohmann::json& j, Service& p);

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/server_factory.hpp
================================================
#pragma once

#include <memory>
#include <string>

#include <websocketpp/common/connection_hdl.hpp>

#include "common.hpp"
#include "server_interface.hpp"

namespace foxglove_ws {

class ServerFactory {
public:
  template <typename ConnectionHandle>
  static std::unique_ptr<ServerInterface<ConnectionHandle>> createServer(
    const std::string& name, const std::function<void(WebSocketLogLevel, char const*)>& logHandler,
    const ServerOptions& options);
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/server_interface.hpp
================================================
#pragma once

#include <functional>
#include <optional>
#include <regex>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "common.hpp"
#include "parameter.hpp"

namespace foxglove_ws {

constexpr size_t DEFAULT_SEND_BUFFER_LIMIT_BYTES = 10000000UL;  // 10 MB

using MapOfSets = std::unordered_map<std::string, std::unordered_set<std::string>>;

template <typename IdType>
class ExeptionWithId : public std::runtime_error {
public:
  explicit ExeptionWithId(IdType id, const std::string& what_arg)
      : std::runtime_error(what_arg)
      , _id(id) {}

  IdType id() const {
    return _id;
  }

private:
  IdType _id;
};

class ChannelError : public ExeptionWithId<ChannelId> {
  using ExeptionWithId::ExeptionWithId;
};
class ClientChannelError : public ExeptionWithId<ClientChannelId> {
  using ExeptionWithId::ExeptionWithId;
};
class ServiceError : public ExeptionWithId<ServiceId> {
  using ExeptionWithId::ExeptionWithId;
};

struct ServerOptions {
  std::vector<std::string> capabilities;
  std::vector<std::string> supportedEncodings;
  std::unordered_map<std::string, std::string> metadata;
  size_t sendBufferLimitBytes = DEFAULT_SEND_BUFFER_LIMIT_BYTES;
  bool useTls = false;
  std::string certfile = "";
  std::string keyfile = "";
  std::string sessionId;
  bool useCompression = false;
  std::vector<std::regex> clientTopicWhitelistPatterns;
};

template <typename ConnectionHandle>
struct ServerHandlers {
  std::function<void(ChannelId, ConnectionHandle)> subscribeHandler;
  std::function<void(ChannelId, ConnectionHandle)> unsubscribeHandler;
  std::function<void(const ClientAdvertisement&, ConnectionHandle)> clientAdvertiseHandler;
  std::function<void(ClientChannelId, ConnectionHandle)> clientUnadvertiseHandler;
  std::function<void(const ClientMessage&, ConnectionHandle)> clientMessageHandler;
  std::function<void(const std::vector<std::string>&, const std::optional<std::string>&,
                     ConnectionHandle)>
    parameterRequestHandler;
  std::function<void(const std::vector<Parameter>&, const std::optional<std::string>&,
                     ConnectionHandle)>
    parameterChangeHandler;
  std::function<void(const std::vector<std::string>&, ParameterSubscriptionOperation,
                     ConnectionHandle)>
    parameterSubscriptionHandler;
  std::function<void(const ServiceRequest&, ConnectionHandle)> serviceRequestHandler;
  std::function<void(bool)> subscribeConnectionGraphHandler;
  std::function<void(const std::string&, uint32_t, ConnectionHandle)> fetchAssetHandler;
};

template <typename ConnectionHandle>
class ServerInterface {
public:
  virtual ~ServerInterface() {}
  virtual void start(const std::string& host, uint16_t port) = 0;
  virtual void stop() = 0;

  virtual std::vector<ChannelId> addChannels(const std::vector<ChannelWithoutId>& channels) = 0;
  virtual void removeChannels(const std::vector<ChannelId>& channelIds) = 0;
  virtual void publishParameterValues(ConnectionHandle clientHandle,
                                      const std::vector<Parameter>& parameters,
                                      const std::optional<std::string>& requestId) = 0;
  virtual void updateParameterValues(const std::vector<Parameter>& parameters) = 0;
  virtual std::vector<ServiceId> addServices(const std::vector<ServiceWithoutId>& services) = 0;
  virtual void removeServices(const std::vector<ServiceId>& serviceIds) = 0;

  virtual void setHandlers(ServerHandlers<ConnectionHandle>&& handlers) = 0;

  virtual void sendMessage(ConnectionHandle clientHandle, ChannelId chanId, uint64_t timestamp,
                           const uint8_t* payload, size_t payloadSize) = 0;
  virtual void broadcastTime(uint64_t timestamp) = 0;
  virtual void sendServiceResponse(ConnectionHandle clientHandle,
                                   const ServiceResponse& response) = 0;
  virtual void sendServiceFailure(ConnectionHandle clientHandle, ServiceId serviceId,
                                  uint32_t callId, const std::string& message) = 0;
  virtual void updateConnectionGraph(const MapOfSets& publishedTopics,
                                     const MapOfSets& subscribedTopics,
                                     const MapOfSets& advertisedServices) = 0;
  virtual void sendFetchAssetResponse(ConnectionHandle clientHandle,
                                      const FetchAssetResponse& response) = 0;

  virtual uint16_t getPort() = 0;
  virtual std::string remoteEndpointString(ConnectionHandle clientHandle) = 0;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/websocket_client.hpp
================================================
#pragma once

#include <functional>
#include <future>
#include <optional>
#include <shared_mutex>
#include <utility>
#include <vector>

#include <nlohmann/json.hpp>
#include <websocketpp/client.hpp>
#include <websocketpp/common/memory.hpp>
#include <websocketpp/common/thread.hpp>

#include "common.hpp"
#include "parameter.hpp"
#include "serialization.hpp"

namespace foxglove_ws {

inline void to_json(nlohmann::json& j, const ClientAdvertisement& p) {
  j = nlohmann::json{{"id", p.channelId},
                     {"topic", p.topic},
                     {"encoding", p.encoding},
                     {"schemaName", p.schemaName}};
}

using TextMessageHandler = std::function<void(const std::string&)>;
using BinaryMessageHandler = std::function<void(const uint8_t*, size_t)>;
using OpCode = websocketpp::frame::opcode::value;

class ClientInterface {
public:
  virtual void connect(
    const std::string& uri, std::function<void(websocketpp::connection_hdl)> onOpenHandler,
    std::function<void(websocketpp::connection_hdl)> onCloseHandler = nullptr) = 0;
  virtual std::future<void> connect(const std::string& uri) = 0;
  virtual void close() = 0;

  virtual void subscribe(
    const std::vector<std::pair<SubscriptionId, ChannelId>>& subscriptions) = 0;
  virtual void unsubscribe(const std::vector<SubscriptionId>& subscriptionIds) = 0;
  virtual void advertise(const std::vector<ClientAdvertisement>& channels) = 0;
  virtual void unadvertise(const std::vector<ClientChannelId>& channelIds) = 0;
  virtual void publish(ClientChannelId channelId, const uint8_t* buffer, size_t size) = 0;
  virtual void sendServiceRequest(const ServiceRequest& request) = 0;
  virtual void getParameters(const std::vector<std::string>& parameterNames,
                             const std::optional<std::string>& requestId) = 0;
  virtual void setParameters(const std::vector<Parameter>& parameters,
                             const std::optional<std::string>& requestId) = 0;
  virtual void subscribeParameterUpdates(const std::vector<std::string>& parameterNames) = 0;
  virtual void unsubscribeParameterUpdates(const std::vector<std::string>& parameterNames) = 0;
  virtual void fetchAsset(const std::string& name, uint32_t requestId) = 0;

  virtual void setTextMessageHandler(TextMessageHandler handler) = 0;
  virtual void setBinaryMessageHandler(BinaryMessageHandler handler) = 0;
};

template <typename ClientConfiguration>
class Client : public ClientInterface {
public:
  using ClientType = websocketpp::client<ClientConfiguration>;
  using MessagePtr = typename ClientType::message_ptr;
  using ConnectionPtr = typename ClientType::connection_ptr;

  Client() {
    _endpoint.clear_access_channels(websocketpp::log::alevel::all);
    _endpoint.clear_error_channels(websocketpp::log::elevel::all);

    _endpoint.init_asio();
    _endpoint.start_perpetual();

    _endpoint.set_message_handler(
      bind(&Client::messageHandler, this, std::placeholders::_1, std::placeholders::_2));

    _thread.reset(new websocketpp::lib::thread(&ClientType::run, &_endpoint));
  }

  virtual ~Client() {
    close();
    _endpoint.stop_perpetual();
    _thread->join();
  }

  void connect(const std::string& uri,
               std::function<void(websocketpp::connection_hdl)> onOpenHandler,
               std::function<void(websocketpp::connection_hdl)> onCloseHandler = nullptr) override {
    std::unique_lock<std::shared_mutex> lock(_mutex);

    websocketpp::lib::error_code ec;
    _con = _endpoint.get_connection(uri, ec);

    if (ec) {
      throw std::runtime_error("Failed to get connection from URI " + uri);
    }

    if (onOpenHandler) {
      _con->set_open_handler(onOpenHandler);
    }
    if (onCloseHandler) {
      _con->set_close_handler(onCloseHandler);
    }

    _con->add_subprotocol(SUPPORTED_SUBPROTOCOL);
    _endpoint.connect(_con);
  }

  std::future<void> connect(const std::string& uri) override {
    auto promise = std::make_shared<std::promise<void>>();
    auto future = promise->get_future();

    connect(uri, [p = std::move(promise)](websocketpp::connection_hdl) mutable {
      p->set_value();
    });

    return future;
  }

  void close() override {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    if (!_con) {
      return;  // Already disconnected
    }

    _endpoint.close(_con, websocketpp::close::status::going_away, "");
    _con.reset();
  }

  void messageHandler(websocketpp::connection_hdl hdl, MessagePtr msg) {
    (void)hdl;
    const OpCode op = msg->get_opcode();

    switch (op) {
      case OpCode::TEXT: {
        std::shared_lock<std::shared_mutex> lock(_mutex);
        if (_textMessageHandler) {
          _textMessageHandler(msg->get_payload());
        }
      } break;
      case OpCode::BINARY: {
        std::shared_lock<std::shared_mutex> lock(_mutex);
        const auto& payload = msg->get_payload();
        if (_binaryMessageHandler) {
          _binaryMessageHandler(reinterpret_cast<const uint8_t*>(payload.data()), payload.size());
        }
      } break;
      default:
        break;
    }
  }

  void subscribe(const std::vector<std::pair<SubscriptionId, ChannelId>>& subscriptions) override {
    nlohmann::json subscriptionsJson;
    for (const auto& [subId, channelId] : subscriptions) {
      subscriptionsJson.push_back({{"id", subId}, {"channelId", channelId}});
    }

    const std::string payload =
      nlohmann::json{{"op", "subscribe"}, {"subscriptions", std::move(subscriptionsJson)}}.dump();
    sendText(payload);
  }

  void unsubscribe(const std::vector<SubscriptionId>& subscriptionIds) override {
    const std::string payload =
      nlohmann::json{{"op", "unsubscribe"}, {"subscriptionIds", subscriptionIds}}.dump();
    sendText(payload);
  }

  void advertise(const std::vector<ClientAdvertisement>& channels) override {
    const std::string payload = nlohmann::json{{"op", "advertise"}, {"channels", channels}}.dump();
    sendText(payload);
  }

  void unadvertise(const std::vector<ClientChannelId>& channelIds) override {
    const std::string payload =
      nlohmann::json{{"op", "unadvertise"}, {"channelIds", channelIds}}.dump();
    sendText(payload);
  }

  void publish(ClientChannelId channelId, const uint8_t* buffer, size_t size) override {
    std::vector<uint8_t> payload(1 + 4 + size);
    payload[0] = uint8_t(ClientBinaryOpcode::MESSAGE_DATA);
    foxglove_ws::WriteUint32LE(payload.data() + 1, channelId);
    std::memcpy(payload.data() + 1 + 4, buffer, size);
    sendBinary(payload.data(), payload.size());
  }

  void sendServiceRequest(const ServiceRequest& request) override {
    std::vector<uint8_t> payload(1 + request.size());
    payload[0] = uint8_t(ClientBinaryOpcode::SERVICE_CALL_REQUEST);
    request.write(payload.data() + 1);
    sendBinary(payload.data(), payload.size());
  }

  void getParameters(const std::vector<std::string>& parameterNames,
                     const std::optional<std::string>& requestId = std::nullopt) override {
    nlohmann::json jsonPayload{{"op", "getParameters"}, {"parameterNames", parameterNames}};
    if (requestId) {
      jsonPayload["id"] = requestId.value();
    }
    sendText(jsonPayload.dump());
  }

  void setParameters(const std::vector<Parameter>& parameters,
                     const std::optional<std::string>& requestId = std::nullopt) override {
    nlohmann::json jsonPayload{{"op", "setParameters"}, {"parameters", parameters}};
    if (requestId) {
      jsonPayload["id"] = requestId.value();
    }
    sendText(jsonPayload.dump());
  }

  void subscribeParameterUpdates(const std::vector<std::string>& parameterNames) override {
    nlohmann::json jsonPayload{{"op", "subscribeParameterUpdates"},
                               {"parameterNames", parameterNames}};
    sendText(jsonPayload.dump());
  }

  void unsubscribeParameterUpdates(const std::vector<std::string>& parameterNames) override {
    nlohmann::json jsonPayload{{"op", "unsubscribeParameterUpdates"},
                               {"parameterNames", parameterNames}};
    sendText(jsonPayload.dump());
  }

  void fetchAsset(const std::string& uri, uint32_t requestId) override {
    nlohmann::json jsonPayload{{"op", "fetchAsset"}, {"uri", uri}, {"requestId", requestId}};
    sendText(jsonPayload.dump());
  }

  void setTextMessageHandler(TextMessageHandler handler) override {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    _textMessageHandler = std::move(handler);
  }

  void setBinaryMessageHandler(BinaryMessageHandler handler) override {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    _binaryMessageHandler = std::move(handler);
  }

  void sendText(const std::string& payload) {
    std::shared_lock<std::shared_mutex> lock(_mutex);
    _endpoint.send(_con, payload, OpCode::TEXT);
  }

  void sendBinary(const uint8_t* data, size_t dataLength) {
    std::shared_lock<std::shared_mutex> lock(_mutex);
    _endpoint.send(_con, data, dataLength, OpCode::BINARY);
  }

protected:
  ClientType _endpoint;
  websocketpp::lib::shared_ptr<websocketpp::lib::thread> _thread;
  ConnectionPtr _con;
  std::shared_mutex _mutex;
  TextMessageHandler _textMessageHandler;
  BinaryMessageHandler _binaryMessageHandler;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/websocket_logging.hpp
================================================
#pragma once

#include <functional>

#include <websocketpp/common/asio.hpp>
#include <websocketpp/logger/levels.hpp>

#include "common.hpp"

namespace foxglove_ws {

using LogCallback = std::function<void(WebSocketLogLevel, char const*)>;

inline std::string IPAddressToString(const websocketpp::lib::asio::ip::address& addr) {
  if (addr.is_v6()) {
    return "[" + addr.to_string() + "]";
  }
  return addr.to_string();
}

inline void NoOpLogCallback(WebSocketLogLevel, char const*) {}

class CallbackLogger {
public:
  using channel_type_hint = websocketpp::log::channel_type_hint;

  CallbackLogger(channel_type_hint::value hint = channel_type_hint::access)
      : _staticChannels(0xffffffff)
      , _dynamicChannels(0)
      , _channelTypeHint(hint)
      , _callback(NoOpLogCallback) {}

  CallbackLogger(websocketpp::log::level channels,
                 channel_type_hint::value hint = channel_type_hint::access)
      : _staticChannels(channels)
      , _dynamicChannels(0)
      , _channelTypeHint(hint)
      , _callback(NoOpLogCallback) {}

  void set_callback(LogCallback callback) {
    _callback = callback;
  }

  void set_channels(websocketpp::log::level channels) {
    if (channels == 0) {
      clear_channels(0xffffffff);
      return;
    }

    _dynamicChannels |= (channels & _staticChannels);
  }

  void clear_channels(websocketpp::log::level channels) {
    _dynamicChannels &= ~channels;
  }

  void write(websocketpp::log::level channel, std::string const& msg) {
    write(channel, msg.c_str());
  }

  void write(websocketpp::log::level channel, char const* msg) {
    if (!this->dynamic_test(channel)) {
      return;
    }

    if (_channelTypeHint == channel_type_hint::access) {
      _callback(WebSocketLogLevel::Info, msg);
    } else {
      if (channel == websocketpp::log::elevel::devel) {
        _callback(WebSocketLogLevel::Debug, msg);
      } else if (channel == websocketpp::log::elevel::library) {
        _callback(WebSocketLogLevel::Debug, msg);
      } else if (channel == websocketpp::log::elevel::info) {
        _callback(WebSocketLogLevel::Info, msg);
      } else if (channel == websocketpp::log::elevel::warn) {
        _callback(WebSocketLogLevel::Warn, msg);
      } else if (channel == websocketpp::log::elevel::rerror) {
        _callback(WebSocketLogLevel::Error, msg);
      } else if (channel == websocketpp::log::elevel::fatal) {
        _callback(WebSocketLogLevel::Critical, msg);
      }
    }
  }

  constexpr bool static_test(websocketpp::log::level channel) const {
    return ((channel & _staticChannels) != 0);
  }

  bool dynamic_test(websocketpp::log::level channel) {
    return ((channel & _dynamicChannels) != 0);
  }

private:
  websocketpp::log::level const _staticChannels;
  websocketpp::log::level _dynamicChannels;
  channel_type_hint::value _channelTypeHint;
  LogCallback _callback;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/websocket_notls.hpp
================================================
#pragma once

#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/extensions/permessage_deflate/enabled.hpp>
#include <websocketpp/server.hpp>

#include "./websocket_logging.hpp"

namespace foxglove_ws {

struct WebSocketNoTls : public websocketpp::config::core {
  typedef WebSocketNoTls type;
  typedef core base;

  typedef base::concurrency_type concurrency_type;

  typedef base::request_type request_type;
  typedef base::response_type response_type;

  typedef base::message_type message_type;
  typedef base::con_msg_manager_type con_msg_manager_type;
  typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;

  typedef CallbackLogger alog_type;
  typedef CallbackLogger elog_type;

  typedef base::rng_type rng_type;

  struct transport_config : public base::transport_config {
    typedef type::concurrency_type concurrency_type;
    typedef CallbackLogger alog_type;
    typedef CallbackLogger elog_type;
    typedef type::request_type request_type;
    typedef type::response_type response_type;
    typedef websocketpp::transport::asio::basic_socket::endpoint socket_type;
  };

  typedef websocketpp::transport::asio::endpoint<transport_config> transport_type;

  struct permessage_deflate_config {};

  typedef websocketpp::extensions::permessage_deflate::enabled<permessage_deflate_config>
    permessage_deflate_type;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/websocket_tls.hpp
================================================
#pragma once

#include <websocketpp/config/asio.hpp>
#include <websocketpp/extensions/permessage_deflate/enabled.hpp>

#include "./websocket_logging.hpp"

namespace foxglove_ws {

struct WebSocketTls : public websocketpp::config::core {
  typedef WebSocketTls type;
  typedef core base;

  typedef base::concurrency_type concurrency_type;

  typedef base::request_type request_type;
  typedef base::response_type response_type;

  typedef base::message_type message_type;
  typedef base::con_msg_manager_type con_msg_manager_type;
  typedef base::endpoint_msg_manager_type endpoint_msg_manager_type;

  typedef CallbackLogger alog_type;
  typedef CallbackLogger elog_type;

  typedef base::rng_type rng_type;

  struct transport_config : public base::transport_config {
    typedef type::concurrency_type concurrency_type;
    typedef CallbackLogger alog_type;
    typedef CallbackLogger elog_type;
    typedef type::request_type request_type;
    typedef type::response_type response_type;
    typedef websocketpp::transport::asio::tls_socket::endpoint socket_type;
  };

  typedef websocketpp::transport::asio::endpoint<transport_config> transport_type;

  struct permessage_deflate_config {};

  typedef websocketpp::extensions::permessage_deflate::enabled<permessage_deflate_config>
    permessage_deflate_type;
};

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/include/foxglove_bridge/test/test_client.hpp
================================================
#pragma once

#include <future>
#include <string>
#include <vector>

#include <websocketpp/config/asio_client.hpp>

#include "../parameter.hpp"
#include "../websocket_client.hpp"

namespace foxglove_ws {

std::future<std::vector<uint8_t>> waitForChannelMsg(ClientInterface* client,
                                                    SubscriptionId subscriptionId);

std::future<std::vector<Parameter>> waitForParameters(std::shared_ptr<ClientInterface> client,
                                                      const std::string& requestId = std::string());

std::future<ServiceResponse> waitForServiceResponse(std::shared_ptr<ClientInterface> client);

std::future<Service> waitForService(std::shared_ptr<ClientInterface> client,
                                    const std::string& serviceName);

std::future<Channel> waitForChannel(std::shared_ptr<ClientInterface> client,
                                    const std::string& topicName);

std::future<FetchAssetResponse> waitForFetchAssetResponse(std::shared_ptr<ClientInterface> client);

extern template class Client<websocketpp::config::asio_client>;

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/src/base64.cpp
================================================
#include <stdexcept>

#include <foxglove_bridge/base64.hpp>

namespace foxglove_ws {

// Adapted from:
// https://gist.github.com/tomykaira/f0fd86b6c73063283afe550bc5d77594
// https://github.com/protocolbuffers/protobuf/blob/01fe22219a0/src/google/protobuf/compiler/csharp/csharp_helpers.cc#L346
std::string base64Encode(const std::string_view& input) {
  constexpr const char ALPHABET[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  std::string result;
  // Every 3 bytes of data yields 4 bytes of output
  result.reserve((input.size() + (3 - 1 /* round up */)) / 3 * 4);

  // Unsigned values are required for bit-shifts below to work properly
  const unsigned char* data = reinterpret_cast<const unsigned char*>(input.data());

  size_t i = 0;
  for (; i + 2 < input.size(); i += 3) {
    result.push_back(ALPHABET[data[i] >> 2]);
    result.push_back(ALPHABET[((data[i] & 0b11) << 4) | (data[i + 1] >> 4)]);
    result.push_back(ALPHABET[((data[i + 1] & 0b1111) << 2) | (data[i + 2] >> 6)]);
    result.push_back(ALPHABET[data[i + 2] & 0b111111]);
  }
  switch (input.size() - i) {
    case 2:
      result.push_back(ALPHABET[data[i] >> 2]);
      result.push_back(ALPHABET[((data[i] & 0b11) << 4) | (data[i + 1] >> 4)]);
      result.push_back(ALPHABET[(data[i + 1] & 0b1111) << 2]);
      result.push_back('=');
      break;
    case 1:
      result.push_back(ALPHABET[data[i] >> 2]);
      result.push_back(ALPHABET[(data[i] & 0b11) << 4]);
      result.push_back('=');
      result.push_back('=');
      break;
  }

  return result;
}

// Adapted from:
// https://github.com/mvorbrodt/blog/blob/cd46051e180/src/base64.hpp#L55-L110
std::vector<unsigned char> base64Decode(const std::string& input) {
  if (input.length() % 4) {
    throw std::runtime_error("Invalid base64 length!");
  }

  constexpr char kPadCharacter = '=';

  std::size_t padding{};

  if (input.length()) {
    if (input[input.length() - 1] == kPadCharacter) padding++;
    if (input[input.length() - 2] == kPadCharacter) padding++;
  }

  std::vector<unsigned char> decoded;
  decoded.reserve(((input.length() / 4) * 3) - padding);

  std::uint32_t temp{};
  auto it = input.begin();

  while (it < input.end()) {
    for (std::size_t i = 0; i < 4; ++i) {
      temp <<= 6;
      if (*it >= 0x41 && *it <= 0x5A)
        temp |= *it - 0x41;
      else if (*it >= 0x61 && *it <= 0x7A)
        temp |= *it - 0x47;
      else if (*it >= 0x30 && *it <= 0x39)
        temp |= *it + 0x04;
      else if (*it == 0x2B)
        temp |= 0x3E;
      else if (*it == 0x2F)
        temp |= 0x3F;
      else if (*it == kPadCharacter) {
        switch (input.end() - it) {
          case 1:
            decoded.push_back((temp >> 16) & 0x000000FF);
            decoded.push_back((temp >> 8) & 0x000000FF);
            return decoded;
          case 2:
            decoded.push_back((temp >> 10) & 0x000000FF);
            return decoded;
          default:
            throw std::runtime_error("Invalid padding in base64!");
        }
      } else
        throw std::runtime_error("Invalid character in base64!");

      ++it;
    }

    decoded.push_back((temp >> 16) & 0x000000FF);
    decoded.push_back((temp >> 8) & 0x000000FF);
    decoded.push_back((temp)&0x000000FF);
  }

  return decoded;
}

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/src/foxglove_bridge.cpp
================================================
#include "foxglove_bridge/foxglove_bridge.hpp"

#include "websocketpp/version.hpp"

namespace foxglove {

const char* WebSocketUserAgent() {
  return websocketpp::user_agent;
}

}  // namespace foxglove



================================================
FILE: foxglove_bridge_base/src/parameter.cpp
================================================
#include <foxglove_bridge/parameter.hpp>

namespace foxglove_ws {

ParameterValue::ParameterValue()
    : _type(ParameterType::PARAMETER_NOT_SET) {}
ParameterValue::ParameterValue(bool value)
    : _type(ParameterType::PARAMETER_BOOL)
    , _value(value) {}
ParameterValue::ParameterValue(int value)
    : _type(ParameterType::PARAMETER_INTEGER)
    , _value(static_cast<int64_t>(value)) {}
ParameterValue::ParameterValue(int64_t value)
    : _type(ParameterType::PARAMETER_INTEGER)
    , _value(value) {}
ParameterValue::ParameterValue(double value)
    : _type(ParameterType::PARAMETER_DOUBLE)
    , _value(value) {}
ParameterValue::ParameterValue(const std::string& value)
    : _type(ParameterType::PARAMETER_STRING)
    , _value(value) {}
ParameterValue::ParameterValue(const char* value)
    : _type(ParameterType::PARAMETER_STRING)
    , _value(std::string(value)) {}
ParameterValue::ParameterValue(const std::vector<unsigned char>& value)
    : _type(ParameterType::PARAMETER_BYTE_ARRAY)
    , _value(value) {}
ParameterValue::ParameterValue(const std::vector<ParameterValue>& value)
    : _type(ParameterType::PARAMETER_ARRAY)
    , _value(value) {}
ParameterValue::ParameterValue(const std::unordered_map<std::string, ParameterValue>& value)
    : _type(ParameterType::PARAMETER_STRUCT)
    , _value(value) {}

Parameter::Parameter() {}
Parameter::Parameter(const std::string& name)
    : _name(name)
    , _value(ParameterValue()) {}
Parameter::Parameter(const std::string& name, const ParameterValue& value)
    : _name(name)
    , _value(value) {}

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/src/serialization.cpp
================================================
#include <foxglove_bridge/base64.hpp>
#include <foxglove_bridge/serialization.hpp>

namespace foxglove_ws {

void to_json(nlohmann::json& j, const Channel& c) {
  j = {
    {"id", c.id},
    {"topic", c.topic},
    {"encoding", c.encoding},
    {"schemaName", c.schemaName},
    {"schema", c.schema},
  };

  if (c.schemaEncoding.has_value()) {
    j["schemaEncoding"] = c.schemaEncoding.value();
  }
}
void from_json(const nlohmann::json& j, Channel& c) {
  const auto schemaEncoding =
    j.find("schemaEncoding") == j.end()
      ? std::optional<std::string>(std::nullopt)
      : std::optional<std::string>(j["schemaEncoding"].get<std::string>());

  ChannelWithoutId channelWithoutId{j["topic"].get<std::string>(), j["encoding"].get<std::string>(),
                                    j["schemaName"].get<std::string>(),
                                    j["schema"].get<std::string>(), schemaEncoding};
  c = Channel(j["id"].get<ChannelId>(), channelWithoutId);
}

void to_json(nlohmann::json& j, const ParameterValue& p) {
  const auto paramType = p.getType();
  if (paramType == ParameterType::PARAMETER_BOOL) {
    j = p.getValue<bool>();
  } else if (paramType == ParameterType::PARAMETER_INTEGER) {
    j = p.getValue<int64_t>();
  } else if (paramType == ParameterType::PARAMETER_DOUBLE) {
    j = p.getValue<double>();
  } else if (paramType == ParameterType::PARAMETER_STRING) {
    j = p.getValue<std::string>();
  } else if (paramType == ParameterType::PARAMETER_BYTE_ARRAY) {
    const auto& paramValue = p.getValue<std::vector<unsigned char>>();
    const std::string_view strValue(reinterpret_cast<const char*>(paramValue.data()),
                                    paramValue.size());
    j = base64Encode(strValue);
  } else if (paramType == ParameterType::PARAMETER_STRUCT) {
    j = p.getValue<std::unordered_map<std::string, ParameterValue>>();
  } else if (paramType == ParameterType::PARAMETER_ARRAY) {
    j = p.getValue<std::vector<ParameterValue>>();
  } else if (paramType == ParameterType::PARAMETER_NOT_SET) {
    // empty value.
  }
}

void from_json(const nlohmann::json& j, ParameterValue& p) {
  const auto jsonType = j.type();

  if (jsonType == nlohmann::detail::value_t::string) {
    p = ParameterValue(j.get<std::string>());
  } else if (jsonType == nlohmann::detail::value_t::boolean) {
    p = ParameterValue(j.get<bool>());
  } else if (jsonType == nlohmann::detail::value_t::number_integer) {
    p = ParameterValue(j.get<int64_t>());
  } else if (jsonType == nlohmann::detail::value_t::number_unsigned) {
    p = ParameterValue(j.get<int64_t>());
  } else if (jsonType == nlohmann::detail::value_t::number_float) {
    p = ParameterValue(j.get<double>());
  } else if (jsonType == nlohmann::detail::value_t::object) {
    p = ParameterValue(j.get<std::unordered_map<std::string, ParameterValue>>());
  } else if (jsonType == nlohmann::detail::value_t::array) {
    p = ParameterValue(j.get<std::vector<ParameterValue>>());
  }
}

void to_json(nlohmann::json& j, const Parameter& p) {
  j["name"] = p.getName();
  if (p.getType() == ParameterType::PARAMETER_NOT_SET) {
    return;
  }
  to_json(j["value"], p.getValue());
  if (p.getType() == ParameterType::PARAMETER_BYTE_ARRAY) {
    j["type"] = "byte_array";
  } else if (p.getType() == ParameterType::PARAMETER_DOUBLE) {
    j["type"] = "float64";
  } else if (p.getType() == ParameterType::PARAMETER_ARRAY) {
    const auto& vec = p.getValue().getValue<std::vector<ParameterValue>>();
    if (!vec.empty() && vec.front().getType() == ParameterType::PARAMETER_DOUBLE) {
      j["type"] = "float64_array";
    }
  }
}

void from_json(const nlohmann::json& j, Parameter& p) {
  const auto name = j["name"].get<std::string>();

  if (j.find("value") == j.end()) {
    p = Parameter(name);  // Value is not set (undefined).
    return;
  }

  ParameterValue pValue;
  from_json(j["value"], pValue);
  const auto typeIt = j.find("type");
  const std::string type = typeIt != j.end() ? typeIt->get<std::string>() : "";

  if (pValue.getType() == ParameterType::PARAMETER_STRING && type == "byte_array") {
    p = Parameter(name, base64Decode(pValue.getValue<std::string>()));
  } else if (pValue.getType() == ParameterType::PARAMETER_INTEGER && type == "float64") {
    // Explicitly cast integer value to double.
    p = Parameter(name, static_cast<double>(pValue.getValue<int64_t>()));
  } else if (pValue.getType() == ParameterType::PARAMETER_ARRAY && type == "float64_array") {
    // Explicitly cast elements to double, if possible.
    auto values = pValue.getValue<std::vector<ParameterValue>>();
    for (ParameterValue& value : values) {
      if (value.getType() == ParameterType::PARAMETER_INTEGER) {
        value = ParameterValue(static_cast<double>(value.getValue<int64_t>()));
      } else if (value.getType() != ParameterType::PARAMETER_DOUBLE) {
        throw std::runtime_error("Parameter '" + name +
                                 "' (float64_array) contains non-numeric elements.");
      }
    }
    p = Parameter(name, values);
  } else {
    p = Parameter(name, pValue);
  }
}

void to_json(nlohmann::json& j, const Service& service) {
  j = {
    {"id", service.id},
    {"name", service.name},
    {"type", service.type},
    {"request", {{"schema", service.requestSchema}}},
    {"response", {{"schema", service.responseSchema}}},
  };
}

void from_json(const nlohmann::json& j, Service& p) {
  p.id = j["id"].get<ServiceId>();
  p.name = j["name"].get<std::string>();
  p.type = j["type"].get<std::string>();

  if (j.find("request") != j.end() && j["request"].find("schema") != j["request"].end()) {
    p.requestSchema = j["request"]["schema"].get<std::string>();
  } else if (j.find("requestSchema") != j.end()) {
    throw std::runtime_error("Field 'requestSchema' (found in service " + p.name +
                             ") is deprecated. Use 'request' instead.");
  } else {
    throw std::runtime_error("Service '" + p.name + "' has no request schema");
  }

  if (j.find("response") != j.end() && j["response"].find("schema") != j["response"].end()) {
    p.responseSchema = j["response"]["schema"].get<std::string>();
  } else if (j.find("responseSchema") != j.end()) {
    throw std::runtime_error("Field 'responseSchema' (found in service " + p.name +
                             ") is deprecated. Use 'response' instead.");
  } else {
    throw std::runtime_error("Service '" + p.name + "' has no response schema");
  }
}

void ServiceResponse::read(const uint8_t* data, size_t dataLength) {
  size_t offset = 0;
  this->serviceId = ReadUint32LE(data + offset);
  offset += 4;
  this->callId = ReadUint32LE(data + offset);
  offset += 4;
  const size_t encondingLength = static_cast<size_t>(ReadUint32LE(data + offset));
  offset += 4;
  this->encoding = std::string(reinterpret_cast<const char*>(data + offset), encondingLength);
  offset += encondingLength;
  const auto payloadLength = dataLength - offset;
  this->data.resize(payloadLength);
  std::memcpy(this->data.data(), data + offset, payloadLength);
}

void ServiceResponse::write(uint8_t* data) const {
  size_t offset = 0;
  foxglove_ws::WriteUint32LE(data + offset, this->serviceId);
  offset += 4;
  foxglove_ws::WriteUint32LE(data + offset, this->callId);
  offset += 4;
  foxglove_ws::WriteUint32LE(data + offset, static_cast<uint32_t>(this->encoding.size()));
  offset += 4;
  std::memcpy(data + offset, this->encoding.data(), this->encoding.size());
  offset += this->encoding.size();
  std::memcpy(data + offset, this->data.data(), this->data.size());
}

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/src/server_factory.cpp
================================================
#include <websocketpp/common/connection_hdl.hpp>

#include <foxglove_bridge/server_factory.hpp>
#include <foxglove_bridge/websocket_notls.hpp>
#include <foxglove_bridge/websocket_server.hpp>
#include <foxglove_bridge/websocket_tls.hpp>

namespace foxglove_ws {

template <>
std::unique_ptr<ServerInterface<websocketpp::connection_hdl>> ServerFactory::createServer(
  const std::string& name, const std::function<void(WebSocketLogLevel, char const*)>& logHandler,
  const ServerOptions& options) {
  if (options.useTls) {
    return std::make_unique<foxglove_ws::Server<foxglove_ws::WebSocketTls>>(name, logHandler,
                                                                            options);
  } else {
    return std::make_unique<foxglove_ws::Server<foxglove_ws::WebSocketNoTls>>(name, logHandler,
                                                                              options);
  }
}

template <>
inline void Server<WebSocketNoTls>::setupTlsHandler() {
  _server.get_alog().write(APP, "Server running without TLS");
}

template <>
inline void Server<WebSocketTls>::setupTlsHandler() {
  _server.set_tls_init_handler([this](ConnHandle hdl) {
    (void)hdl;

    namespace asio = websocketpp::lib::asio;
    auto ctx = websocketpp::lib::make_shared<asio::ssl::context>(asio::ssl::context::sslv23);

    try {
      ctx->set_options(asio::ssl::context::default_workarounds | asio::ssl::context::no_tlsv1 |
                       asio::ssl::context::no_sslv2 | asio::ssl::context::no_sslv3);
      ctx->use_certificate_chain_file(_options.certfile);
      ctx->use_private_key_file(_options.keyfile, asio::ssl::context::pem);

      // Ciphers are taken from the websocketpp example echo tls server:
      // https://github.com/zaphoyd/websocketpp/blob/1b11fd301/examples/echo_server_tls/echo_server_tls.cpp#L119
      constexpr char ciphers[] =
        "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:"
        "ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+"
        "AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-"
        "AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-"
        "ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-"
        "AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:"
        "!MD5:!PSK";

      if (SSL_CTX_set_cipher_list(ctx->native_handle(), ciphers) != 1) {
        _server.get_elog().write(RECOVERABLE, "Error setting cipher list");
      }
    } catch (const std::exception& ex) {
      _server.get_elog().write(RECOVERABLE,
                               std::string("Exception in TLS handshake: ") + ex.what());
    }
    return ctx;
  });
}

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/src/version.cpp.in
================================================
#include <foxglove_bridge/foxglove_bridge.hpp>

namespace foxglove {

const char FOXGLOVE_BRIDGE_VERSION[] = "@FOXGLOVE_BRIDGE_VERSION@";

const char FOXGLOVE_BRIDGE_GIT_HASH[] = "@FOXGLOVE_BRIDGE_GIT_HASH@";

}  // namespace foxglove



================================================
FILE: foxglove_bridge_base/src/test/test_client.cpp
================================================
#include <chrono>

#include <websocketpp/config/asio_client.hpp>

#include <foxglove_bridge/serialization.hpp>
#include <foxglove_bridge/test/test_client.hpp>
#include <foxglove_bridge/websocket_client.hpp>

namespace foxglove_ws {

std::future<std::vector<uint8_t>> waitForChannelMsg(ClientInterface* client,
                                                    SubscriptionId subscriptionId) {
  // Set up binary message handler to resolve when a binary message has been received
  auto promise = std::make_shared<std::promise<std::vector<uint8_t>>>();
  auto future = promise->get_future();

  client->setBinaryMessageHandler(
    [promise = std::move(promise), subscriptionId](const uint8_t* data, size_t dataLength) {
      if (ReadUint32LE(data + 1) != subscriptionId) {
        return;
      }
      const size_t offset = 1 + 4 + 8;
      std::vector<uint8_t> dataCopy(dataLength - offset);
      std::memcpy(dataCopy.data(), data + offset, dataLength - offset);
      promise->set_value(std::move(dataCopy));
    });

  return future;
}

std::future<std::vector<Parameter>> waitForParameters(std::shared_ptr<ClientInterface> client,
                                                      const std::string& requestId) {
  auto promise = std::make_shared<std::promise<std::vector<Parameter>>>();
  auto future = promise->get_future();

  client->setTextMessageHandler(
    [promise = std::move(promise), requestId](const std::string& payload) {
      const auto msg = nlohmann::json::parse(payload);
      const auto& op = msg["op"].get<std::string>();
      const auto id = msg.value("id", "");

      if (op == "parameterValues" && (requestId.empty() || requestId == id)) {
        const auto parameters = msg["parameters"].get<std::vector<Parameter>>();
        promise->set_value(std::move(parameters));
      }
    });

  return future;
}

std::future<ServiceResponse> waitForServiceResponse(std::shared_ptr<ClientInterface> client) {
  auto promise = std::make_shared<std::promise<ServiceResponse>>();
  auto future = promise->get_future();

  client->setBinaryMessageHandler(
    [promise = std::move(promise)](const uint8_t* data, size_t dataLength) mutable {
      if (static_cast<BinaryOpcode>(data[0]) != BinaryOpcode::SERVICE_CALL_RESPONSE) {
        return;
      }

      foxglove_ws::ServiceResponse response;
      response.read(data + 1, dataLength - 1);
      promise->set_value(response);
    });
  return future;
}

std::future<Service> waitForService(std::shared_ptr<ClientInterface> client,
                                    const std::string& serviceName) {
  auto promise = std::make_shared<std::promise<Service>>();
  auto future = promise->get_future();

  client->setTextMessageHandler(
    [promise = std::move(promise), serviceName](const std::string& payload) mutable {
      const auto msg = nlohmann::json::parse(payload);
      const auto& op = msg["op"].get<std::string>();

      if (op == "advertiseServices") {
        const auto services = msg["services"].get<std::vector<Service>>();
        for (const auto& service : services) {
          if (service.name == serviceName) {
            promise->set_value(service);
            break;
          }
        }
      }
    });

  return future;
}

std::future<Channel> waitForChannel(std::shared_ptr<ClientInterface> client,
                                    const std::string& topicName) {
  auto promise = std::make_shared<std::promise<Channel>>();
  auto future = promise->get_future();

  client->setTextMessageHandler(
    [promise = std::move(promise), topicName](const std::string& payload) mutable {
      const auto msg = nlohmann::json::parse(payload);
      const auto& op = msg["op"].get<std::string>();

      if (op == "advertise") {
        const auto channels = msg["channels"].get<std::vector<Channel>>();
        for (const auto& channel : channels) {
          if (channel.topic == topicName) {
            promise->set_value(channel);
            break;
          }
        }
      }
    });
  return future;
}

std::future<FetchAssetResponse> waitForFetchAssetResponse(std::shared_ptr<ClientInterface> client) {
  auto promise = std::make_shared<std::promise<FetchAssetResponse>>();
  auto future = promise->get_future();

  client->setBinaryMessageHandler(
    [promise = std::move(promise)](const uint8_t* data, size_t dataLength) mutable {
      if (static_cast<BinaryOpcode>(data[0]) != BinaryOpcode::FETCH_ASSET_RESPONSE) {
        return;
      }

      foxglove_ws::FetchAssetResponse response;
      size_t offset = 1;
      response.requestId = ReadUint32LE(data + offset);
      offset += 4;
      response.status = static_cast<foxglove_ws::FetchAssetStatus>(data[offset]);
      offset += 1;
      const size_t errorMsgLength = static_cast<size_t>(ReadUint32LE(data + offset));
      offset += 4;
      response.errorMessage =
        std::string(reinterpret_cast<const char*>(data + offset), errorMsgLength);
      offset += errorMsgLength;
      const auto payloadLength = dataLength - offset;
      response.data.resize(payloadLength);
      std::memcpy(response.data.data(), data + offset, payloadLength);
      promise->set_value(response);
    });
  return future;
}

// Explicit template instantiation
template class Client<websocketpp::config::asio_client>;

}  // namespace foxglove_ws



================================================
FILE: foxglove_bridge_base/tests/base64_test.cpp
================================================
#include <gtest/gtest.h>

#include <foxglove_bridge/base64.hpp>

TEST(Base64Test, EncodingTest) {
  constexpr char arr[] = {'A', 'B', 'C', 'D'};
  const std::string_view sv(arr, sizeof(arr));
  const std::string b64encoded = foxglove_ws::base64Encode(sv);
  EXPECT_EQ(b64encoded, "QUJDRA==");
}

TEST(Base64Test, DecodeTest) {
  const std::vector<unsigned char> expectedVal = {0x00, 0xFF, 0x01, 0xFE};
  EXPECT_EQ(foxglove_ws::base64Decode("AP8B/g=="), expectedVal);
}

TEST(Base64Test, DecodeInvalidStringTest) {
  // String length not multiple of 4
  EXPECT_THROW(foxglove_ws::base64Decode("faefa"), std::runtime_error);
  // Invalid characters
  EXPECT_THROW(foxglove_ws::base64Decode("fa^ef a"), std::runtime_error);
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}



================================================
FILE: foxglove_bridge_base/tests/serialization_test.cpp
================================================
#include <gtest/gtest.h>

#include <foxglove_bridge/serialization.hpp>

TEST(SerializationTest, ServiceRequestSerialization) {
  foxglove_ws::ServiceRequest req;
  req.serviceId = 2;
  req.callId = 1;
  req.encoding = "json";
  req.data = {1, 2, 3};

  std::vector<uint8_t> data(req.size());
  req.write(data.data());

  foxglove_ws::ServiceRequest req2;
  req2.read(data.data(), data.size());
  EXPECT_EQ(req.serviceId, req2.serviceId);
  EXPECT_EQ(req.callId, req2.callId);
  EXPECT_EQ(req.encoding, req2.encoding);
  EXPECT_EQ(req.data.size(), req2.data.size());
  EXPECT_EQ(req.data, req2.data);
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}



================================================
FILE: foxglove_bridge_base/tests/version_test.cpp
================================================
#include <string>

#include <gtest/gtest.h>

#include <foxglove_bridge/foxglove_bridge.hpp>

TEST(VersionTest, TestWebSocketVersion) {
  // ex: "WebSocket++/0.8.1"
  const std::string version = foxglove::WebSocketUserAgent();
  EXPECT_EQ(version.substr(0, 14), "WebSocket++/0.");
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}



================================================
FILE: ros1_foxglove_bridge/include/foxglove_bridge/generic_service.hpp
================================================
#pragma once

#include <string>
#include <vector>

#include <ros/serialization.h>
#include <ros/service_traits.h>

namespace foxglove_bridge {

struct GenericService {
  std::string type;
  std::string md5sum;
  std::vector<uint8_t> data;

  template <typename Stream>
  inline void write(Stream& stream) const {
    std::memcpy(stream.getData(), data.data(), data.size());
  }

  template <typename Stream>
  inline void read(Stream& stream) {
    data.resize(stream.getLength());
    std::memcpy(data.data(), stream.getData(), stream.getLength());
  }
};

}  // namespace foxglove_bridge

namespace ros::service_traits {
template <>
struct MD5Sum<foxglove_bridge::GenericService> {
  static const char* value(const foxglove_bridge::GenericService& m) {
    return m.md5sum.c_str();
  }

  static const char* value() {
    return "*";
  }
};

template <>
struct DataType<foxglove_bridge::GenericService> {
  static const char* value(const foxglove_bridge::GenericService& m) {
    return m.type.c_str();
  }

  static const char* value() {
    return "*";
  }
};
}  // namespace ros::service_traits

namespace ros::serialization {

template <>
struct Serializer<foxglove_bridge::GenericService> {
  template <typename Stream>
  inline static void write(Stream& stream, const foxglove_bridge::GenericService& m) {
    m.write(stream);
  }

  template <typename Stream>
  inline static void read(Stream& stream, foxglove_bridge::GenericService& m) {
    m.read(stream);
  }

  inline static uint32_t serializedLength(const foxglove_bridge::GenericService& m) {
    return m.data.size();
  }
};
}  // namespace ros::serialization



================================================
FILE: ros1_foxglove_bridge/include/foxglove_bridge/param_utils.hpp
================================================
#pragma once

#include <regex>
#include <string>
#include <vector>

#include <xmlrpcpp/XmlRpc.h>

#include <foxglove_bridge/parameter.hpp>

namespace foxglove_bridge {

foxglove_ws::Parameter fromRosParam(const std::string& name, const XmlRpc::XmlRpcValue& value);
XmlRpc::XmlRpcValue toRosParam(const foxglove_ws::ParameterValue& param);

std::vector<std::regex> parseRegexPatterns(const std::vector<std::string>& strings);

}  // namespace foxglove_bridge



================================================
FILE: ros1_foxglove_bridge/include/foxglove_bridge/service_utils.hpp
================================================
#pragma once

#include <chrono>
#include <string>

namespace foxglove_bridge {

/**
 * Opens a socket to the service server and retrieves the service type from the connection header.
 * This is necessary as the service type is not stored on the ROS master.
 */
std::string retrieveServiceType(const std::string& serviceName,
                                std::chrono::milliseconds timeout_ms);

}  // namespace foxglove_bridge



================================================
FILE: ros1_foxglove_bridge/launch/foxglove_bridge.launch
================================================
<launch>
  <arg name="port"                              default="8765" />
  <arg name="address"                           default="0.0.0.0" />
  <arg name="tls"                               default="false" />
  <arg name="certfile"                          default="" />
  <arg name="keyfile"                           default="" />
  <arg name="topic_whitelist"                   default="['.*']" />
  <arg name="param_whitelist"                   default="['.*']" />
  <arg name="service_whitelist"                 default="['.*']" />
  <arg name="client_topic_whitelist"            default="['.*']" />
  <arg name="max_update_ms"                     default="5000" />
  <arg name="send_buffer_limit"                 default="10000000" />
  <arg name="nodelet_manager"                   default="foxglove_nodelet_manager" />
  <arg name="num_threads"                       default="0" />
  <arg name="capabilities"                      default="[clientPublish,parameters,parametersSubscribe,services,connectionGraph,assets]" />
  <arg name="asset_uri_allowlist"               default="['^package://(?:[-\w%]+/)*[-\w%.]+\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$']" />
  <arg name="service_type_retrieval_timeout_ms" default="250" />

  <node pkg="nodelet" type="nodelet" name="foxglove_nodelet_manager" args="manager"
        if="$(eval nodelet_manager == 'foxglove_nodelet_manager')">
    <param name="num_worker_threads"  type="int"        value="$(arg num_threads)" />
  </node>

  <node pkg="nodelet" type="nodelet" name="foxglove_bridge"
        args="load foxglove_bridge/foxglove_bridge_nodelet $(arg nodelet_manager)">
    <param name="port"                              type="int"        value="$(arg port)" />
    <param name="address"                           type="string"     value="$(arg address)" />
    <param name="tls"                               type="bool"       value="$(arg tls)" />
    <param name="certfile"                          type="string"     value="$(arg certfile)" />
    <param name="keyfile"                           type="string"     value="$(arg keyfile)" />
    <param name="max_update_ms"                     type="int"        value="$(arg max_update_ms)" />
    <param name="send_buffer_limit"                 type="int"        value="$(arg send_buffer_limit)" />
    <param name="service_type_retrieval_timeout_ms" type="int"        value="$(arg service_type_retrieval_timeout_ms)" />

    <rosparam param="topic_whitelist"         subst_value="True">$(arg topic_whitelist)</rosparam>
    <rosparam param="param_whitelist"         subst_value="True">$(arg param_whitelist)</rosparam>
    <rosparam param="service_whitelist"       subst_value="True">$(arg service_whitelist)</rosparam>
    <rosparam param="client_topic_whitelist"  subst_value="True">$(arg client_topic_whitelist)</rosparam>
    <rosparam param="capabilities"            subst_value="True">$(arg capabilities)</rosparam>
    <rosparam param="asset_uri_allowlist"     subst_value="True">$(arg asset_uri_allowlist)</rosparam>
  </node>
</launch>



================================================
FILE: ros1_foxglove_bridge/src/param_utils.cpp
================================================

#include <iostream>
#include <stdexcept>

#include <foxglove_bridge/param_utils.hpp>

namespace foxglove_bridge {

foxglove_ws::ParameterValue fromRosParam(const XmlRpc::XmlRpcValue& value) {
  const auto type = value.getType();

  if (type == XmlRpc::XmlRpcValue::Type::TypeBoolean) {
    return foxglove_ws::ParameterValue(static_cast<bool>(value));
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeInt) {
    return foxglove_ws::ParameterValue(static_cast<int64_t>(static_cast<int>(value)));
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeDouble) {
    return foxglove_ws::ParameterValue(static_cast<double>(value));
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeString) {
    return foxglove_ws::ParameterValue(static_cast<std::string>(value));
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeStruct) {
    std::unordered_map<std::string, foxglove_ws::ParameterValue> paramMap;
    for (const auto& [elementName, elementVal] : value) {
      paramMap.insert({elementName, fromRosParam(elementVal)});
    }
    return foxglove_ws::ParameterValue(paramMap);
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeArray) {
    std::vector<foxglove_ws::ParameterValue> paramVec;
    for (int i = 0; i < value.size(); ++i) {
      paramVec.push_back(fromRosParam(value[i]));
    }
    return foxglove_ws::ParameterValue(paramVec);
  } else if (type == XmlRpc::XmlRpcValue::Type::TypeInvalid) {
    throw std::runtime_error("Parameter not set");
  } else {
    throw std::runtime_error("Unsupported parameter type: " + std::to_string(type));
  }
}

foxglove_ws::Parameter fromRosParam(const std::string& name, const XmlRpc::XmlRpcValue& value) {
  return foxglove_ws::Parameter(name, fromRosParam(value));
}

XmlRpc::XmlRpcValue toRosParam(const foxglove_ws::ParameterValue& param) {
  const auto paramType = param.getType();
  if (paramType == foxglove_ws::ParameterType::PARAMETER_BOOL) {
    return param.getValue<bool>();
  } else if (paramType == foxglove_ws::ParameterType::PARAMETER_INTEGER) {
    return static_cast<int>(param.getValue<int64_t>());
  } else if (paramType == foxglove_ws::ParameterType::PARAMETER_DOUBLE) {
    return param.getValue<double>();
  } else if (paramType == foxglove_ws::ParameterType::PARAMETER_STRING) {
    return param.getValue<std::string>();
  } else if (paramType == foxglove_ws::ParameterType::PARAMETER_STRUCT) {
    XmlRpc::XmlRpcValue valueStruct;
    const auto& paramMap =
      param.getValue<std::unordered_map<std::string, foxglove_ws::ParameterValue>>();
    for (const auto& [paramName, paramElement] : paramMap) {
      valueStruct[paramName] = toRosParam(paramElement);
    }
    return valueStruct;
  } else if (paramType == foxglove_ws::ParameterType::PARAMETER_ARRAY) {
    XmlRpc::XmlRpcValue arr;
    const auto vec = param.getValue<std::vector<foxglove_ws::ParameterValue>>();
    for (int i = 0; i < static_cast<int>(vec.size()); ++i) {
      arr[i] = toRosParam(vec[i]);
    }
    return arr;
  } else {
    throw std::runtime_error("Unsupported parameter type");
  }

  return XmlRpc::XmlRpcValue();
}

std::vector<std::regex> parseRegexPatterns(const std::vector<std::string>& patterns) {
  std::vector<std::regex> result;
  for (const auto& pattern : patterns) {
    try {
      result.push_back(
        std::regex(pattern, std::regex_constants::ECMAScript | std::regex_constants::icase));
    } catch (...) {
      continue;
    }
  }
  return result;
}

}  // namespace foxglove_bridge



================================================
FILE: ros1_foxglove_bridge/src/ros1_foxglove_bridge_node.cpp
================================================
#include <nodelet/loader.h>
#include <ros/ros.h>

int main(int argc, char** argv) {
  ros::init(argc, argv, "foxglove_bridge");
  nodelet::Loader nodelet;
  nodelet::M_string remap(ros::names::getRemappings());
  nodelet::V_string nargv;
  std::string nodelet_name = ros::this_node::getName();
  if (nodelet.load(nodelet_name, "foxglove_bridge/foxglove_bridge_nodelet", remap, nargv)) {
    ros::spin();
    return EXIT_SUCCESS;
  } else {
    return EXIT_FAILURE;
  }
}



================================================
FILE: ros1_foxglove_bridge/src/ros1_foxglove_bridge_nodelet.cpp
================================================
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>
#include <regex>
#include <shared_mutex>
#include <string>
#include <unordered_set>

#include <nodelet/nodelet.h>
#include <pluginlib/class_list_macros.h>
#include <resource_retriever/retriever.h>
#include <ros/message_event.h>
#include <ros/ros.h>
#include <ros/xmlrpc_manager.h>
#include <ros_babel_fish/babel_fish_message.h>
#include <ros_babel_fish/generation/providers/integrated_description_provider.h>
#include <rosgraph_msgs/Clock.h>
#include <websocketpp/common/connection_hdl.hpp>

#include <foxglove_bridge/foxglove_bridge.hpp>
#include <foxglove_bridge/generic_service.hpp>
#include <foxglove_bridge/param_utils.hpp>
#include <foxglove_bridge/regex_utils.hpp>
#include <foxglove_bridge/server_factory.hpp>
#include <foxglove_bridge/service_utils.hpp>
#include <foxglove_bridge/websocket_server.hpp>

namespace {

inline std::unordered_set<std::string> rpcValueToStringSet(const XmlRpc::XmlRpcValue& v) {
  std::unordered_set<std::string> set;
  for (int i = 0; i < v.size(); ++i) {
    set.insert(v[i]);
  }
  return set;
}

}  // namespace

namespace foxglove_bridge {

constexpr int DEFAULT_PORT = 8765;
constexpr char DEFAULT_ADDRESS[] = "0.0.0.0";
constexpr int DEFAULT_MAX_UPDATE_MS = 5000;
constexpr char ROS1_CHANNEL_ENCODING[] = "ros1";
constexpr uint32_t SUBSCRIPTION_QUEUE_LENGTH = 10;
constexpr double MIN_UPDATE_PERIOD_MS = 100.0;
constexpr uint32_t PUBLICATION_QUEUE_LENGTH = 10;
constexpr int DEFAULT_SERVICE_TYPE_RETRIEVAL_TIMEOUT_MS = 250;
constexpr int MAX_INVALID_PARAMS_TRACKED = 1000;

using ConnectionHandle = websocketpp::connection_hdl;
using TopicAndDatatype = std::pair<std::string, std::string>;
using SubscriptionsByClient = std::map<ConnectionHandle, ros::Subscriber, std::owner_less<>>;
using ClientPublications = std::unordered_map<foxglove_ws::ClientChannelId, ros::Publisher>;
using PublicationsByClient = std::map<ConnectionHandle, ClientPublications, std::owner_less<>>;
using foxglove_ws::isWhitelisted;

class FoxgloveBridge : public nodelet::Nodelet {
public:
  FoxgloveBridge() = default;
  virtual void onInit() {
    auto& nhp = getPrivateNodeHandle();
    const auto address = nhp.param<std::string>("address", DEFAULT_ADDRESS);
    const int port = nhp.param<int>("port", DEFAULT_PORT);
    const auto send_buffer_limit = static_cast<size_t>(
      nhp.param<int>("send_buffer_limit", foxglove_ws::DEFAULT_SEND_BUFFER_LIMIT_BYTES));
    const auto useTLS = nhp.param<bool>("tls", false);
    const auto certfile = nhp.param<std::string>("certfile", "");
    const auto keyfile = nhp.param<std::string>("keyfile", "");
    _maxUpdateMs = static_cast<size_t>(nhp.param<int>("max_update_ms", DEFAULT_MAX_UPDATE_MS));
    const auto useCompression = nhp.param<bool>("use_compression", false);
    _useSimTime = nhp.param<bool>("/use_sim_time", false);
    const auto sessionId = nhp.param<std::string>("/run_id", std::to_string(std::time(nullptr)));
    _capabilities = nhp.param<std::vector<std::string>>(
      "capabilities", std::vector<std::string>(foxglove_ws::DEFAULT_CAPABILITIES.begin(),
                                               foxglove_ws::DEFAULT_CAPABILITIES.end()));
    _serviceRetrievalTimeoutMs = nhp.param<int>("service_type_retrieval_timeout_ms",
                                                DEFAULT_SERVICE_TYPE_RETRIEVAL_TIMEOUT_MS);

    const auto topicWhitelistPatterns =
      nhp.param<std::vector<std::string>>("topic_whitelist", {".*"});
    _topicWhitelistPatterns = parseRegexPatterns(topicWhitelistPatterns);
    if (topicWhitelistPatterns.size() != _topicWhitelistPatterns.size()) {
      ROS_ERROR("Failed to parse one or more topic whitelist patterns");
    }
    const auto paramWhitelist = nhp.param<std::vector<std::string>>("param_whitelist", {".*"});
    _paramWhitelistPatterns = parseRegexPatterns(paramWhitelist);
    if (paramWhitelist.size() != _paramWhitelistPatterns.size()) {
      ROS_ERROR("Failed to parse one or more param whitelist patterns");
    }

    const auto serviceWhitelist = nhp.param<std::vector<std::string>>("service_whitelist", {".*"});
    _serviceWhitelistPatterns = parseRegexPatterns(serviceWhitelist);
    if (serviceWhitelist.size() != _serviceWhitelistPatterns.size()) {
      ROS_ERROR("Failed to parse one or more service whitelist patterns");
    }

    const auto clientTopicWhitelist =
      nhp.param<std::vector<std::string>>("client_topic_whitelist", {".*"});
    const auto clientTopicWhitelistPatterns = parseRegexPatterns(clientTopicWhitelist);
    if (clientTopicWhitelist.size() != clientTopicWhitelistPatterns.size()) {
      ROS_ERROR("Failed to parse one or more service whitelist patterns");
    }

    const auto assetUriAllowlist = nhp.param<std::vector<std::string>>(
      "asset_uri_allowlist",
      {"^package://(?:[-\\w%]+/"
       ")*[-\\w%.]+\\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$"});
    _assetUriAllowlistPatterns = parseRegexPatterns(assetUriAllowlist);
    if (assetUriAllowlist.size() != _assetUriAllowlistPatterns.size()) {
      ROS_ERROR("Failed to parse one or more asset URI whitelist patterns");
    }

    const char* rosDistro = std::getenv("ROS_DISTRO");
    ROS_INFO("Starting foxglove_bridge (%s, %s@%s) with %s", rosDistro,
             foxglove::FOXGLOVE_BRIDGE_VERSION, foxglove::FOXGLOVE_BRIDGE_GIT_HASH,
             foxglove::WebSocketUserAgent());

    try {
      foxglove_ws::ServerOptions serverOptions;
      serverOptions.capabilities = _capabilities;
      if (_useSimTime) {
        serverOptions.capabilities.push_back(foxglove_ws::CAPABILITY_TIME);
      }
      serverOptions.supportedEncodings = {ROS1_CHANNEL_ENCODING};
      serverOptions.metadata = {{"ROS_DISTRO", rosDistro}};
      serverOptions.sendBufferLimitBytes = send_buffer_limit;
      serverOptions.sessionId = sessionId;
      serverOptions.useTls = useTLS;
      serverOptions.certfile = certfile;
      serverOptions.keyfile = keyfile;
      serverOptions.useCompression = useCompression;
      serverOptions.clientTopicWhitelistPatterns = clientTopicWhitelistPatterns;

      const auto logHandler =
        std::bind(&FoxgloveBridge::logHandler, this, std::placeholders::_1, std::placeholders::_2);

      // Fetching of assets may be blocking, hence we fetch them in a separate thread.
      _fetchAssetQueue =
        std::make_unique<foxglove_ws::CallbackQueue>(logHandler, 1 /* num_threads */);

      _server = foxglove_ws::ServerFactory::createServer<ConnectionHandle>(
        "foxglove_bridge", logHandler, serverOptions);
      foxglove_ws::ServerHandlers<ConnectionHandle> hdlrs;
      hdlrs.subscribeHandler =
        std::bind(&FoxgloveBridge::subscribe, this, std::placeholders::_1, std::placeholders::_2);
      hdlrs.unsubscribeHandler =
        std::bind(&FoxgloveBridge::unsubscribe, this, std::placeholders::_1, std::placeholders::_2);
      hdlrs.clientAdvertiseHandler = std::bind(&FoxgloveBridge::clientAdvertise, this,
                                               std::placeholders::_1, std::placeholders::_2);
      hdlrs.clientUnadvertiseHandler = std::bind(&FoxgloveBridge::clientUnadvertise, this,
                                                 std::placeholders::_1, std::placeholders::_2);
      hdlrs.clientMessageHandler = std::bind(&FoxgloveBridge::clientMessage, this,
                                             std::placeholders::_1, std::placeholders::_2);
      hdlrs.parameterRequestHandler =
        std::bind(&FoxgloveBridge::getParameters, this, std::placeholders::_1,
                  std::placeholders::_2, std::placeholders::_3);
      hdlrs.parameterChangeHandler =
        std::bind(&FoxgloveBridge::setParameters, this, std::placeholders::_1,
                  std::placeholders::_2, std::placeholders::_3);
      hdlrs.parameterSubscriptionHandler =
        std::bind(&FoxgloveBridge::subscribeParameters, this, std::placeholders::_1,
                  std::placeholders::_2, std::placeholders::_3);
      hdlrs.serviceRequestHandler = std::bind(&FoxgloveBridge::serviceRequest, this,
                                              std::placeholders::_1, std::placeholders::_2);
      hdlrs.subscribeConnectionGraphHandler = [this](bool subscribe) {
        _subscribeGraphUpdates = subscribe;
      };

      if (hasCapability(foxglove_ws::CAPABILITY_ASSETS)) {
        hdlrs.fetchAssetHandler = [this](const std::string& uri, uint32_t requestId,
                                         foxglove_ws::ConnHandle hdl) {
          _fetchAssetQueue->addCallback(
            std::bind(&FoxgloveBridge::fetchAsset, this, uri, requestId, hdl));
        };
      }

      _server->setHandlers(std::move(hdlrs));

      _server->start(address, static_cast<uint16_t>(port));

      xmlrpcServer.bind("paramUpdate", std::bind(&FoxgloveBridge::parameterUpdates, this,
                                                 std::placeholders::_1, std::placeholders::_2));
      xmlrpcServer.start();

      updateAdvertisedTopicsAndServices(ros::TimerEvent());

      if (_useSimTime) {
        _clockSubscription = getMTNodeHandle().subscribe<rosgraph_msgs::Clock>(
          "/clock", 10, [&](const rosgraph_msgs::Clock::ConstPtr msg) {
            _server->broadcastTime(msg->clock.toNSec());
          });
      }
    } catch (const std::exception& err) {
      ROS_ERROR("Failed to start websocket server: %s", err.what());
      // Rethrow exception such that the nodelet is unloaded.
      throw err;
    }
  };
  virtual ~FoxgloveBridge() {
    xmlrpcServer.shutdown();
    if (_server) {
      _server->stop();
    }
  }

private:
  struct PairHash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2>& pair) const {
      return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
    }
  };

  void subscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle) {
    std::lock_guard<std::mutex> lock(_subscriptionsMutex);

    auto it = _advertisedTopics.find(channelId);
    if (it == _advertisedTopics.end()) {
      const std::string errMsg =
        "Received subscribe request for unknown channel " + std::to_string(channelId);
      ROS_WARN_STREAM(errMsg);
      throw foxglove_ws::ChannelError(channelId, errMsg);
    }

    const auto& channel = it->second;
    const auto& topic = channel.topic;
    const auto& datatype = channel.schemaName;

    // Get client subscriptions for this channel or insert an empty map.
    auto [subscriptionsIt, firstSubscription] =
      _subscriptions.emplace(channelId, SubscriptionsByClient());
    auto& subscriptionsByClient = subscriptionsIt->second;

    if (!firstSubscription &&
        subscriptionsByClient.find(clientHandle) != subscriptionsByClient.end()) {
      const std::string errMsg =
        "Client is already subscribed to channel " + std::to_string(channelId);
      ROS_WARN_STREAM(errMsg);
      throw foxglove_ws::ChannelError(channelId, errMsg);
    }

    try {
      subscriptionsByClient.emplace(
        clientHandle, getMTNodeHandle().subscribe<ros_babel_fish::BabelFishMessage>(
                        topic, SUBSCRIPTION_QUEUE_LENGTH,
                        std::bind(&FoxgloveBridge::rosMessageHandler, this, channelId, clientHandle,
                                  std::placeholders::_1)));
      if (firstSubscription) {
        ROS_INFO("Subscribed to topic \"%s\" (%s) on channel %d", topic.c_str(), datatype.c_str(),
                 channelId);

      } else {
        ROS_INFO("Added subscriber #%zu to topic \"%s\" (%s) on channel %d",
                 subscriptionsByClient.size(), topic.c_str(), datatype.c_str(), channelId);
      }
    } catch (const std::exception& ex) {
      const std::string errMsg =
        "Failed to subscribe to topic '" + topic + "' (" + datatype + "): " + ex.what();
      ROS_ERROR_STREAM(errMsg);
      throw foxglove_ws::ChannelError(channelId, errMsg);
    }
  }

  void unsubscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle) {
    std::lock_guard<std::mutex> lock(_subscriptionsMutex);

    const auto channelIt = _advertisedTopics.find(channelId);
    if (channelIt == _advertisedTopics.end()) {
      const std::string errMsg =
        "Received unsubscribe request for unknown channel " + std::to_string(channelId);
      ROS_WARN_STREAM(errMsg);
      throw foxglove_ws::ChannelError(channelId, errMsg);
    }
    const auto& channel = channelIt->second;

    auto subscriptionsIt = _subscriptions.find(channelId);
    if (subscriptionsIt == _subscriptions.end()) {
      throw foxglove_ws::ChannelError(channelId, "Received unsubscribe request for channel " +
                                                   std::to_string(channelId) +
                                                   " that was not subscribed to ");
    }

    auto& subscriptionsByClient = subscriptionsIt->second;
    const auto clientSubscription = subscriptionsByClient.find(clientHandle);
    if (clientSubscription == subscriptionsByClient.end()) {
      throw foxglove_ws::ChannelError(
        channelId, "Received unsubscribe request for channel " + std::to_string(channelId) +
                     "from a client that was not subscribed to this channel");
    }

    subscriptionsByClient.erase(clientSubscription);
    if (subscriptionsByClient.empty()) {
      ROS_INFO("Unsubscribing from topic \"%s\" (%s) on channel %d", channel.topic.c_str(),
               channel.schemaName.c_str(), channelId);
      _subscriptions.erase(subscriptionsIt);
    } else {
      ROS_INFO("Removed one subscription from channel %d (%zu subscription(s) left)", channelId,
               subscriptionsByClient.size());
    }
  }

  void clientAdvertise(const foxglove_ws::ClientAdvertisement& channel,
                       ConnectionHandle clientHandle) {
    if (channel.encoding != ROS1_CHANNEL_ENCODING) {
      throw foxglove_ws::ClientChannelError(
        channel.channelId, "Unsupported encoding. Only '" + std::string(ROS1_CHANNEL_ENCODING) +
                             "' encoding is supported at the moment.");
    }

    std::unique_lock<std::shared_mutex> lock(_publicationsMutex);

    // Get client publications or insert an empty map.
    auto [clientPublicationsIt, isFirstPublication] =
      _clientAdvertisedTopics.emplace(clientHandle, ClientPublications());

    auto& clientPublications = clientPublicationsIt->second;
    if (!isFirstPublication &&
        clientPublications.find(channel.channelId) != clientPublications.end()) {
      throw foxglove_ws::ClientChannelError(
        channel.channelId, "Received client advertisement from " +
                             _server->remoteEndpointString(clientHandle) + " for channel " +
                             std::to_string(channel.channelId) + " it had already advertised");
    }

    const auto msgDescription = _rosTypeInfoProvider.getMessageDescription(channel.schemaName);
    if (!msgDescription) {
      throw foxglove_ws::ClientChannelError(
        channel.channelId, "Failed to retrieve type information of data type '" +
                             channel.schemaName + "'. Unable to advertise topic " + channel.topic);
    }

    ros::AdvertiseOptions advertiseOptions;
    advertiseOptions.datatype = channel.schemaName;
    advertiseOptions.has_header = false;  // TODO
    advertiseOptions.latch = false;
    advertiseOptions.md5sum = msgDescription->md5;
    advertiseOptions.message_definition = msgDescription->message_definition;
    advertiseOptions.queue_size = PUBLICATION_QUEUE_LENGTH;
    advertiseOptions.topic = channel.topic;
    auto publisher = getMTNodeHandle().advertise(advertiseOptions);

    if (publisher) {
      clientPublications.insert({channel.channelId, std::move(publisher)});
      ROS_INFO("Client %s is advertising \"%s\" (%s) on channel %d",
               _server->remoteEndpointString(clientHandle).c_str(), channel.topic.c_str(),
               channel.schemaName.c_str(), channel.channelId);
      // Trigger topic discovery so other clients are immediately informed about this new topic.
      updateAdvertisedTopics();
    } else {
      const auto errMsg =
        "Failed to create publisher for topic " + channel.topic + "(" + channel.schemaName + ")";
      ROS_ERROR_STREAM(errMsg);
      throw foxglove_ws::ClientChannelError(channel.channelId, errMsg);
    }
  }

  void clientUnadvertise(foxglove_ws::ClientChannelId channelId, ConnectionHandle clientHandle) {
    std::unique_lock<std::shared_mutex> lock(_publicationsMutex);

    auto clientPublicationsIt = _clientAdvertisedTopics.find(clientHandle);
    if (clientPublicationsIt == _clientAdvertisedTopics.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Ignoring client unadvertisement from " +
                     _server->remoteEndpointString(clientHandle) + " for unknown channel " +
                     std::to_string(channelId) + ", client has no advertised topics");
    }

    auto& clientPublications = clientPublicationsIt->second;

    auto channelPublicationIt = clientPublications.find(channelId);
    if (channelPublicationIt == clientPublications.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Ignoring client unadvertisement from " +
                     _server->remoteEndpointString(clientHandle) + " for unknown channel " +
                     std::to_string(channelId) + ", client has " +
                     std::to_string(clientPublications.size()) + " advertised topic(s)");
    }

    const auto& publisher = channelPublicationIt->second;
    ROS_INFO("Client %s is no longer advertising %s (%d subscribers) on channel %d",
             _server->remoteEndpointString(clientHandle).c_str(), publisher.getTopic().c_str(),
             publisher.getNumSubscribers(), channelId);
    clientPublications.erase(channelPublicationIt);

    if (clientPublications.empty()) {
      _clientAdvertisedTopics.erase(clientPublicationsIt);
    }
  }

  void clientMessage(const foxglove_ws::ClientMessage& clientMsg, ConnectionHandle clientHandle) {
    ros_babel_fish::BabelFishMessage::Ptr msg(new ros_babel_fish::BabelFishMessage);
    msg->read(clientMsg);

    const auto channelId = clientMsg.advertisement.channelId;
    std::shared_lock<std::shared_mutex> lock(_publicationsMutex);

    auto clientPublicationsIt = _clientAdvertisedTopics.find(clientHandle);
    if (clientPublicationsIt == _clientAdvertisedTopics.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Dropping client message from " + _server->remoteEndpointString(clientHandle) +
                     " for unknown channel " + std::to_string(channelId) +
                     ", client has no advertised topics");
    }

    auto& clientPublications = clientPublicationsIt->second;

    auto channelPublicationIt = clientPublications.find(clientMsg.advertisement.channelId);
    if (channelPublicationIt == clientPublications.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Dropping client message from " + _server->remoteEndpointString(clientHandle) +
                     " for unknown channel " + std::to_string(channelId) + ", client has " +
                     std::to_string(clientPublications.size()) + " advertised topic(s)");
    }

    try {
      channelPublicationIt->second.publish(msg);
    } catch (const std::exception& ex) {
      throw foxglove_ws::ClientChannelError(channelId, "Failed to publish message on topic '" +
                                                         channelPublicationIt->second.getTopic() +
                                                         "': " + ex.what());
    }
  }

  void updateAdvertisedTopicsAndServices(const ros::TimerEvent&) {
    _updateTimer.stop();
    if (!ros::ok()) {
      return;
    }

    const bool servicesEnabled = hasCapability(foxglove_ws::CAPABILITY_SERVICES);
    const bool querySystemState = servicesEnabled || _subscribeGraphUpdates;

    std::vector<std::string> serviceNames;
    foxglove_ws::MapOfSets publishers, subscribers, services;

    // Retrieve system state from ROS master.
    if (querySystemState) {
      XmlRpc::XmlRpcValue params, result, payload;
      params[0] = this->getName();
      if (ros::master::execute("getSystemState", params, result, payload, false) &&
          static_cast<int>(result[0]) == 1) {
        const auto& systemState = result[2];
        const auto& publishersXmlRpc = systemState[0];
        const auto& subscribersXmlRpc = systemState[1];
        const auto& servicesXmlRpc = systemState[2];

        for (int i = 0; i < servicesXmlRpc.size(); ++i) {
          const std::string& name = servicesXmlRpc[i][0];
          if (isWhitelisted(name, _serviceWhitelistPatterns)) {
            serviceNames.push_back(name);
            services.emplace(name, rpcValueToStringSet(servicesXmlRpc[i][1]));
          }
        }
        for (int i = 0; i < publishersXmlRpc.size(); ++i) {
          const std::string& name = publishersXmlRpc[i][0];
          if (isWhitelisted(name, _topicWhitelistPatterns)) {
            publishers.emplace(name, rpcValueToStringSet(publishersXmlRpc[i][1]));
          }
        }
        for (int i = 0; i < subscribersXmlRpc.size(); ++i) {
          const std::string& name = subscribersXmlRpc[i][0];
          if (isWhitelisted(name, _topicWhitelistPatterns)) {
            subscribers.emplace(name, rpcValueToStringSet(subscribersXmlRpc[i][1]));
          }
        }
      } else {
        ROS_WARN("Failed to call getSystemState: %s", result.toXml().c_str());
      }
    }

    updateAdvertisedTopics();
    if (servicesEnabled) {
      updateAdvertisedServices(serviceNames);
    }
    if (_subscribeGraphUpdates) {
      _server->updateConnectionGraph(publishers, subscribers, services);
    }

    // Schedule the next update using truncated exponential backoff, between `MIN_UPDATE_PERIOD_MS`
    // and `_maxUpdateMs`
    _updateCount++;
    const auto nextUpdateMs = std::max(
      MIN_UPDATE_PERIOD_MS, static_cast<double>(std::min(size_t(1) << _updateCount, _maxUpdateMs)));
    _updateTimer = getMTNodeHandle().createTimer(
      ros::Duration(nextUpdateMs / 1e3), &FoxgloveBridge::updateAdvertisedTopicsAndServices, this);
  }

  void updateAdvertisedTopics() {
    // Get the current list of visible topics and datatypes from the ROS graph
    // For this, we call the ros master's `getTopicTypes` method (See
    // https://wiki.ros.org/ROS/Master_API) which also includes topics without publisher(s) and only
    // subscriber(s).
    XmlRpc::XmlRpcValue request, response, topicNamesAndTypes;
    request[0] = ros::this_node::getName();

    if (!ros::master::execute("getTopicTypes", request, response, topicNamesAndTypes, false)) {
      ROS_WARN("Failed to retrieve topics from ROS master.");
      return;
    }

    std::unordered_set<TopicAndDatatype, PairHash> latestTopics;
    latestTopics.reserve(topicNamesAndTypes.size());
    for (int i = 0; i < topicNamesAndTypes.size(); ++i) {
      const std::string topicName = topicNamesAndTypes[i][0];
      const std::string datatype = topicNamesAndTypes[i][1];

      // Ignore the topic if it is not on the topic whitelist
      if (isWhitelisted(topicName, _topicWhitelistPatterns)) {
        latestTopics.emplace(topicName, datatype);
      }
    }

    if (const auto numIgnoredTopics = topicNamesAndTypes.size() - latestTopics.size()) {
      ROS_DEBUG(
        "%zu topics have been ignored as they do not match any pattern on the topic whitelist",
        numIgnoredTopics);
    }

    std::lock_guard<std::mutex> lock(_subscriptionsMutex);

    // Remove channels for which the topic does not exist anymore
    std::vector<foxglove_ws::ChannelId> channelIdsToRemove;
    for (auto channelIt = _advertisedTopics.begin(); channelIt != _advertisedTopics.end();) {
      const TopicAndDatatype topicAndDatatype = {channelIt->second.topic,
                                                 channelIt->second.schemaName};
      if (latestTopics.find(topicAndDatatype) == latestTopics.end()) {
        const auto channelId = channelIt->first;
        channelIdsToRemove.push_back(channelId);
        _subscriptions.erase(channelId);
        ROS_DEBUG("Removed channel %d for topic \"%s\" (%s)", channelId,
                  topicAndDatatype.first.c_str(), topicAndDatatype.second.c_str());
        channelIt = _advertisedTopics.erase(channelIt);
      } else {
        channelIt++;
      }
    }
    _server->removeChannels(channelIdsToRemove);

    // Add new channels for new topics
    std::vector<foxglove_ws::ChannelWithoutId> channelsToAdd;
    for (const auto& topicAndDatatype : latestTopics) {
      if (std::find_if(_advertisedTopics.begin(), _advertisedTopics.end(),
                       [topicAndDatatype](const auto& channelIdAndChannel) {
                         const auto& channel = channelIdAndChannel.second;
                         return channel.topic == topicAndDatatype.first &&
                                channel.schemaName == topicAndDatatype.second;
                       }) != _advertisedTopics.end()) {
        continue;  // Topic already advertised
      }

      foxglove_ws::ChannelWithoutId newChannel{};
      newChannel.topic = topicAndDatatype.first;
      newChannel.schemaName = topicAndDatatype.second;
      newChannel.encoding = ROS1_CHANNEL_ENCODING;

      try {
        const auto msgDescription =
          _rosTypeInfoProvider.getMessageDescription(topicAndDatatype.second);
        if (msgDescription) {
          newChannel.schema = msgDescription->message_definition;
        } else {
          ROS_WARN("Could not find definition for type %s", topicAndDatatype.second.c_str());

          // We still advertise the channel, but with an emtpy schema
          newChannel.schema = "";
        }
      } catch (const std::exception& err) {
        ROS_WARN("Failed to add channel for topic \"%s\" (%s): %s", topicAndDatatype.first.c_str(),
                 topicAndDatatype.second.c_str(), err.what());
        continue;
      }

      channelsToAdd.push_back(newChannel);
    }

    const auto channelIds = _server->addChannels(channelsToAdd);
    for (size_t i = 0; i < channelsToAdd.size(); ++i) {
      const auto channelId = channelIds[i];
      const auto& channel = channelsToAdd[i];
      _advertisedTopics.emplace(channelId, channel);
      ROS_DEBUG("Advertising channel %d for topic \"%s\" (%s)", channelId, channel.topic.c_str(),
                channel.schemaName.c_str());
    }
  }

  void updateAdvertisedServices(const std::vector<std::string>& serviceNames) {
    std::unique_lock<std::shared_mutex> lock(_servicesMutex);

    // Remove advertisements for services that have been removed
    std::vector<foxglove_ws::ServiceId> servicesToRemove;
    for (const auto& service : _advertisedServices) {
      const auto it =
        std::find_if(serviceNames.begin(), serviceNames.end(), [service](const auto& serviceName) {
          return serviceName == service.second.name;
        });
      if (it == serviceNames.end()) {
        servicesToRemove.push_back(service.first);
      }
    }
    for (auto serviceId : servicesToRemove) {
      _advertisedServices.erase(serviceId);
    }
    _server->removeServices(servicesToRemove);

    // Advertise new services
    std::vector<foxglove_ws::ServiceWithoutId> newServices;
    for (const auto& serviceName : serviceNames) {
      if (std::find_if(_advertisedServices.begin(), _advertisedServices.end(),
                       [&serviceName](const auto& idWithService) {
                         return idWithService.second.name == serviceName;
                       }) != _advertisedServices.end()) {
        continue;  // Already advertised
      }

      try {
        const auto serviceType =
          retrieveServiceType(serviceName, std::chrono::milliseconds(_serviceRetrievalTimeoutMs));
        const auto srvDescription = _rosTypeInfoProvider.getServiceDescription(serviceType);

        foxglove_ws::ServiceWithoutId service;
        service.name = serviceName;
        service.type = serviceType;

        if (srvDescription) {
          service.requestSchema = srvDescription->request->message_definition;
          service.responseSchema = srvDescription->response->message_definition;
        } else {
          ROS_ERROR("Failed to retrieve type information for service '%s' of type '%s'",
                    serviceName.c_str(), serviceType.c_str());

          // We still advertise the channel, but with empty schema.
          service.requestSchema = "";
          service.responseSchema = "";
        }
        newServices.push_back(service);
      } catch (const std::exception& e) {
        ROS_ERROR("Failed to retrieve service type or service description of service %s: %s",
                  serviceName.c_str(), e.what());
        continue;
      }
    }

    const auto serviceIds = _server->addServices(newServices);
    for (size_t i = 0; i < serviceIds.size(); ++i) {
      _advertisedServices.emplace(serviceIds[i], newServices[i]);
    }
  }

  void getParameters(const std::vector<std::string>& parameters,
                     const std::optional<std::string>& requestId, ConnectionHandle hdl) {
    const bool allParametersRequested = parameters.empty();
    std::vector<std::string> parameterNames = parameters;
    if (allParametersRequested) {
      if (!getMTNodeHandle().getParamNames(parameterNames)) {
        const auto errMsg = "Failed to retrieve parameter names";
        ROS_ERROR_STREAM(errMsg);
        throw std::runtime_error(errMsg);
      }
    }

    bool success = true;
    std::vector<foxglove_ws::Parameter> params;
    std::vector<std::string> invalidParams;
    for (const auto& paramName : parameterNames) {
      if (!isWhitelisted(paramName, _paramWhitelistPatterns)) {
        if (allParametersRequested) {
          continue;
        } else {
          ROS_ERROR("Parameter '%s' is not on the allowlist", paramName.c_str());
          success = false;
        }
      }
      if (_invalidParams.find(paramName) != _invalidParams.end()) {
        continue;
      }

      try {
        XmlRpc::XmlRpcValue value;
        getMTNodeHandle().getParam(paramName, value);
        params.push_back(fromRosParam(paramName, value));
      } catch (const std::exception& ex) {
        ROS_ERROR("Invalid parameter '%s': %s", paramName.c_str(), ex.what());
        invalidParams.push_back(paramName);
        success = false;
      } catch (const XmlRpc::XmlRpcException& ex) {
        ROS_ERROR("Invalid parameter '%s': %s", paramName.c_str(), ex.getMessage().c_str());
        invalidParams.push_back(paramName);
        success = false;
      } catch (...) {
        ROS_ERROR("Invalid parameter '%s'", paramName.c_str());
        invalidParams.push_back(paramName);
        success = false;
      }
    }

    _server->publishParameterValues(hdl, params, requestId);

    if (!success) {
      for (std::string& param : invalidParams) {
        if (_invalidParams.size() < MAX_INVALID_PARAMS_TRACKED) {
          _invalidParams.insert(param);
        }
      }

      if (!invalidParams.empty()) {
        std::string errorMsg = "Failed to retrieve the following parameters: ";
        for (size_t i = 0; i < invalidParams.size(); i++) {
          errorMsg += invalidParams[i];
          if (i < invalidParams.size() - 1) {
            errorMsg += ", ";
          }
        }
        throw std::runtime_error(errorMsg);
      } else {
        throw std::runtime_error("Failed to retrieve one or multiple parameters");
      }
    }
  }

  void setParameters(const std::vector<foxglove_ws::Parameter>& parameters,
                     const std::optional<std::string>& requestId, ConnectionHandle hdl) {
    using foxglove_ws::ParameterType;
    auto nh = this->getMTNodeHandle();

    bool success = true;
    for (const auto& param : parameters) {
      const auto paramName = param.getName();
      if (!isWhitelisted(paramName, _paramWhitelistPatterns)) {
        ROS_ERROR("Parameter '%s' is not on the allowlist", paramName.c_str());
        success = false;
        continue;
      }

      try {
        const auto paramType = param.getType();
        const auto paramValue = param.getValue();
        if (paramType == ParameterType::PARAMETER_NOT_SET) {
          nh.deleteParam(paramName);
        } else {
          nh.setParam(paramName, toRosParam(paramValue));
        }
      } catch (const std::exception& ex) {
        ROS_ERROR("Failed to set parameter '%s': %s", paramName.c_str(), ex.what());
        success = false;
      } catch (const XmlRpc::XmlRpcException& ex) {
        ROS_ERROR("Failed to set parameter '%s': %s", paramName.c_str(), ex.getMessage().c_str());
        success = false;
      } catch (...) {
        ROS_ERROR("Failed to set parameter '%s'", paramName.c_str());
        success = false;
      }
    }

    // If a request Id was given, send potentially updated parameters back to client
    if (requestId) {
      std::vector<std::string> parameterNames(parameters.size());
      for (size_t i = 0; i < parameters.size(); ++i) {
        parameterNames[i] = parameters[i].getName();
      }
      getParameters(parameterNames, requestId, hdl);
    }

    if (!success) {
      throw std::runtime_error("Failed to set one or multiple parameters");
    }
  }

  void subscribeParameters(const std::vector<std::string>& parameters,
                           foxglove_ws::ParameterSubscriptionOperation op, ConnectionHandle) {
    const auto opVerb =
      (op == foxglove_ws::ParameterSubscriptionOperation::SUBSCRIBE) ? "subscribe" : "unsubscribe";
    bool success = true;
    for (const auto& paramName : parameters) {
      if (!isWhitelisted(paramName, _paramWhitelistPatterns)) {
        ROS_ERROR("Parameter '%s' is not allowlist", paramName.c_str());
        continue;
      }

      XmlRpc::XmlRpcValue params, result, payload;
      params[0] = getName() + "2";
      params[1] = xmlrpcServer.getServerURI();
      params[2] = ros::names::resolve(paramName);

      const std::string opName = std::string(opVerb) + "Param";
      if (ros::master::execute(opName, params, result, payload, false)) {
        ROS_DEBUG("%s '%s'", opName.c_str(), paramName.c_str());
      } else {
        ROS_WARN("Failed to %s '%s': %s", opVerb, paramName.c_str(), result.toXml().c_str());
        success = false;
      }
    }

    if (!success) {
      throw std::runtime_error("Failed to " + std::string(opVerb) + " one or multiple parameters.");
    }
  }

  void parameterUpdates(XmlRpc::XmlRpcValue& params, XmlRpc::XmlRpcValue& result) {
    result[0] = 1;
    result[1] = std::string("");
    result[2] = 0;

    if (params.size() != 3) {
      ROS_ERROR("Parameter update called with invalid parameter size: %d", params.size());
      return;
    }

    try {
      const std::string paramName = ros::names::clean(params[1]);
      const XmlRpc::XmlRpcValue paramValue = params[2];
      const auto param = fromRosParam(paramName, paramValue);
      _server->updateParameterValues({param});
    } catch (const std::exception& ex) {
      ROS_ERROR("Failed to update parameter: %s", ex.what());
    } catch (const XmlRpc::XmlRpcException& ex) {
      ROS_ERROR("Failed to update parameter: %s", ex.getMessage().c_str());
    } catch (...) {
      ROS_ERROR("Failed to update parameter");
    }
  }

  void logHandler(foxglove_ws::WebSocketLogLevel level, char const* msg) {
    switch (level) {
      case foxglove_ws::WebSocketLogLevel::Debug:
        ROS_DEBUG("[WS] %s", msg);
        break;
      case foxglove_ws::WebSocketLogLevel::Info:
        ROS_INFO("[WS] %s", msg);
        break;
      case foxglove_ws::WebSocketLogLevel::Warn:
        ROS_WARN("[WS] %s", msg);
        break;
      case foxglove_ws::WebSocketLogLevel::Error:
        ROS_ERROR("[WS] %s", msg);
        break;
      case foxglove_ws::WebSocketLogLevel::Critical:
        ROS_FATAL("[WS] %s", msg);
        break;
    }
  }

  void rosMessageHandler(
    const foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle,
    const ros::MessageEvent<ros_babel_fish::BabelFishMessage const>& msgEvent) {
    const auto& msg = msgEvent.getConstMessage();
    const auto receiptTimeNs = msgEvent.getReceiptTime().toNSec();
    _server->sendMessage(clientHandle, channelId, receiptTimeNs, msg->buffer(), msg->size());
  }

  void serviceRequest(const foxglove_ws::ServiceRequest& request, ConnectionHandle clientHandle) {
    std::shared_lock<std::shared_mutex> lock(_servicesMutex);
    const auto serviceIt = _advertisedServices.find(request.serviceId);
    if (serviceIt == _advertisedServices.end()) {
      const auto errMsg =
        "Service with id " + std::to_string(request.serviceId) + " does not exist";
      ROS_ERROR_STREAM(errMsg);
      throw foxglove_ws::ServiceError(request.serviceId, errMsg);
    }
    const auto& serviceName = serviceIt->second.name;
    const auto& serviceType = serviceIt->second.type;
    ROS_DEBUG("Received a service request for service %s (%s)", serviceName.c_str(),
              serviceType.c_str());

    if (!ros::service::exists(serviceName, false)) {
      throw foxglove_ws::ServiceError(request.serviceId,
                                      "Service '" + serviceName + "' does not exist");
    }

    const auto srvDescription = _rosTypeInfoProvider.getServiceDescription(serviceType);
    if (!srvDescription) {
      const auto errMsg =
        "Failed to retrieve type information for service " + serviceName + "(" + serviceType + ")";
      ROS_ERROR_STREAM(errMsg);
      throw foxglove_ws::ServiceError(request.serviceId, errMsg);
    }

    GenericService genReq, genRes;
    genReq.type = genRes.type = serviceType;
    genReq.md5sum = genRes.md5sum = srvDescription->md5;
    genReq.data = request.data;

    if (ros::service::call(serviceName, genReq, genRes)) {
      foxglove_ws::ServiceResponse res;
      res.serviceId = request.serviceId;
      res.callId = request.callId;
      res.encoding = request.encoding;
      res.data = genRes.data;
      _server->sendServiceResponse(clientHandle, res);
    } else {
      throw foxglove_ws::ServiceError(
        request.serviceId, "Failed to call service " + serviceName + "(" + serviceType + ")");
    }
  }

  void fetchAsset(const std::string& uri, uint32_t requestId, ConnectionHandle clientHandle) {
    foxglove_ws::FetchAssetResponse response;
    response.requestId = requestId;

    try {
      // We reject URIs that are not on the allowlist or that contain two consecutive dots. The
      // latter can be utilized to construct URIs for retrieving confidential files that should not
      // be accessible over the WebSocket connection. Example:
      // `package://<pkg_name>/../../../secret.txt`. This is an extra security measure and should
      // not be necessary if the allowlist is strict enough.
      if (uri.find("..") != std::string::npos || !isWhitelisted(uri, _assetUriAllowlistPatterns)) {
        throw std::runtime_error("Asset URI not allowed: " + uri);
      }

      resource_retriever::Retriever resource_retriever;
      const resource_retriever::MemoryResource memoryResource = resource_retriever.get(uri);
      response.status = foxglove_ws::FetchAssetStatus::Success;
      response.errorMessage = "";
      response.data.resize(memoryResource.size);
      std::memcpy(response.data.data(), memoryResource.data.get(), memoryResource.size);
    } catch (const std::exception& ex) {
      ROS_WARN("Failed to retrieve asset '%s': %s", uri.c_str(), ex.what());
      response.status = foxglove_ws::FetchAssetStatus::Error;
      response.errorMessage = "Failed to retrieve asset " + uri;
    }

    if (_server) {
      _server->sendFetchAssetResponse(clientHandle, response);
    }
  }

  bool hasCapability(const std::string& capability) {
    return std::find(_capabilities.begin(), _capabilities.end(), capability) != _capabilities.end();
  }

  std::unique_ptr<foxglove_ws::ServerInterface<ConnectionHandle>> _server;
  ros_babel_fish::IntegratedDescriptionProvider _rosTypeInfoProvider;
  std::vector<std::regex> _topicWhitelistPatterns;
  std::vector<std::regex> _paramWhitelistPatterns;
  std::vector<std::regex> _serviceWhitelistPatterns;
  std::vector<std::regex> _assetUriAllowlistPatterns;
  ros::XMLRPCManager xmlrpcServer;
  std::unordered_map<foxglove_ws::ChannelId, foxglove_ws::ChannelWithoutId> _advertisedTopics;
  std::unordered_map<foxglove_ws::ChannelId, SubscriptionsByClient> _subscriptions;
  std::unordered_map<foxglove_ws::ServiceId, foxglove_ws::ServiceWithoutId> _advertisedServices;
  PublicationsByClient _clientAdvertisedTopics;
  std::mutex _subscriptionsMutex;
  std::shared_mutex _publicationsMutex;
  std::shared_mutex _servicesMutex;
  ros::Timer _updateTimer;
  size_t _maxUpdateMs = size_t(DEFAULT_MAX_UPDATE_MS);
  size_t _updateCount = 0;
  ros::Subscriber _clockSubscription;
  bool _useSimTime = false;
  std::vector<std::string> _capabilities;
  int _serviceRetrievalTimeoutMs = DEFAULT_SERVICE_TYPE_RETRIEVAL_TIMEOUT_MS;
  std::atomic<bool> _subscribeGraphUpdates = false;
  std::unique_ptr<foxglove_ws::CallbackQueue> _fetchAssetQueue;
  std::unordered_set<std::string> _invalidParams;
};

}  // namespace foxglove_bridge

PLUGINLIB_EXPORT_CLASS(foxglove_bridge::FoxgloveBridge, nodelet::Nodelet)



================================================
FILE: ros1_foxglove_bridge/src/service_utils.cpp
================================================
#include <chrono>
#include <future>

#include <ros/connection.h>
#include <ros/connection_manager.h>
#include <ros/poll_manager.h>
#include <ros/service_manager.h>
#include <ros/this_node.h>
#include <ros/transport/transport_tcp.h>

#include <foxglove_bridge/service_utils.hpp>

namespace foxglove_bridge {

/**
 * Looks up the service server host & port and opens a TCP connection to it to retrieve the header
 * which contains the service type.
 *
 * The implementation is similar to how ROS does it under the hood when creating a service server
 * link:
 * https://github.com/ros/ros_comm/blob/845f74602c7464e08ef5ac6fd9e26c97d0fe42c9/clients/roscpp/src/libros/service_manager.cpp#L246-L261
 * https://github.com/ros/ros_comm/blob/845f74602c7464e08ef5ac6fd9e26c97d0fe42c9/clients/roscpp/src/libros/service_server_link.cpp#L114-L130
 */
std::string retrieveServiceType(const std::string& serviceName, std::chrono::milliseconds timeout) {
  std::string srvHost;
  uint32_t srvPort;
  if (!ros::ServiceManager::instance()->lookupService(serviceName, srvHost, srvPort)) {
    throw std::runtime_error("Failed to lookup service " + serviceName);
  }

  auto transport =
    boost::make_shared<ros::TransportTCP>(&ros::PollManager::instance()->getPollSet());
  auto connection = boost::make_shared<ros::Connection>();
  ros::ConnectionManager::instance()->addConnection(connection);
  connection->initialize(transport, false, ros::HeaderReceivedFunc());

  if (!transport->connect(srvHost, srvPort)) {
    throw std::runtime_error("Failed to connect to service server of service " + serviceName);
  }

  std::promise<std::string> promise;
  auto future = promise.get_future();

  connection->setHeaderReceivedCallback(
    [&promise](const ros::ConnectionPtr& conn, const ros::Header& header) {
      std::string serviceType;
      if (header.getValue("type", serviceType)) {
        promise.set_value(serviceType);
      } else {
        promise.set_exception(std::make_exception_ptr(
          std::runtime_error("Key 'type' not found in service connection header")));
      }
      // Close connection since we don't need it any more.
      conn->drop(ros::Connection::DropReason::Destructing);
      return true;
    });

  ros::M_string header;
  header["service"] = serviceName;
  header["md5sum"] = "*";
  header["callerid"] = ros::this_node::getName();
  header["persistent"] = "0";
  header["probe"] = "1";
  connection->writeHeader(header, [](const ros::ConnectionPtr&) {});

  if (future.wait_for(timeout) != std::future_status::ready) {
    // Drop the connection here to prevent that the header-received callback is called after the
    // promise has already been destroyed.
    connection->drop(ros::Connection::DropReason::Destructing);
    throw std::runtime_error("Timed out when retrieving service type");
  }

  return future.get();
}

}  // namespace foxglove_bridge



================================================
FILE: ros1_foxglove_bridge/tests/smoke.test
================================================
<launch>
  <node name="foxglove_bridge" pkg="foxglove_bridge" type="foxglove_bridge" output="screen">
    <param name="port" value="9876" />
    <rosparam param="asset_uri_allowlist" subst_value="True">['file://.*']</rosparam>
  </node>

  <test test-name="smoke_test" pkg="foxglove_bridge" type="smoke_test" />
</launch>



================================================
FILE: ros1_foxglove_bridge/tests/smoke_test.cpp
================================================
#include <chrono>
#include <future>
#include <thread>

#include <boost/filesystem.hpp>
#include <gtest/gtest.h>
#include <ros/ros.h>
#include <std_msgs/builtin_string.h>
#include <std_srvs/SetBool.h>
#include <websocketpp/config/asio_client.hpp>

#include <foxglove_bridge/test/test_client.hpp>
constexpr char URI[] = "ws://localhost:9876";

// Binary representation of std_msgs/String for "hello world"
constexpr uint8_t HELLO_WORLD_BINARY[] = {11,  0,  0,   0,   104, 101, 108, 108,
                                          111, 32, 119, 111, 114, 108, 100};

constexpr auto ONE_SECOND = std::chrono::seconds(1);
constexpr auto DEFAULT_TIMEOUT = std::chrono::seconds(8);

class ParameterTest : public ::testing::Test {
public:
  using PARAM_1_TYPE = std::string;
  inline static const std::string PARAM_1_NAME = "/node_1/string_param";
  inline static const PARAM_1_TYPE PARAM_1_DEFAULT_VALUE = "hello";

  using PARAM_2_TYPE = std::vector<double>;
  inline static const std::string PARAM_2_NAME = "/node_2/int_array_param";
  inline static const PARAM_2_TYPE PARAM_2_DEFAULT_VALUE = {1.2, 2.1, 3.3};

protected:
  void SetUp() override {
    _nh = ros::NodeHandle();
    _nh.setParam(PARAM_1_NAME, PARAM_1_DEFAULT_VALUE);
    _nh.setParam(PARAM_2_NAME, PARAM_2_DEFAULT_VALUE);

    _wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
    ASSERT_EQ(std::future_status::ready, _wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));
  }

  ros::NodeHandle _nh;
  std::shared_ptr<foxglove_ws::Client<websocketpp::config::asio_client>> _wsClient;
};

class ServiceTest : public ::testing::Test {
public:
  inline static const std::string SERVICE_NAME = "/foo_service";

protected:
  void SetUp() override {
    _nh = ros::NodeHandle();
    _service = _nh.advertiseService<std_srvs::SetBool::Request, std_srvs::SetBool::Response>(
      SERVICE_NAME, [&](auto& req, auto& res) {
        res.message = "hello";
        res.success = req.data;
        return true;
      });
  }

private:
  ros::NodeHandle _nh;
  ros::ServiceServer _service;
};

TEST(SmokeTest, testConnection) {
  foxglove_ws::Client<websocketpp::config::asio_client> wsClient;
  EXPECT_EQ(std::future_status::ready, wsClient.connect(URI).wait_for(DEFAULT_TIMEOUT));
}

TEST(SmokeTest, testSubscription) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  ros::NodeHandle nh;
  auto pub = nh.advertise<std_msgs::String>(topic_name, 10, true);
  pub.publish(std::string("hello world"));

  // Connect a few clients and make sure that they receive the correct message
  const auto clientCount = 3;
  for (auto i = 0; i < clientCount; ++i) {
    // Set up a client and subscribe to the channel.
    auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
    auto channelFuture = foxglove_ws::waitForChannel(client, topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(DEFAULT_TIMEOUT));
    const foxglove_ws::Channel channel = channelFuture.get();
    const foxglove_ws::SubscriptionId subscriptionId = 1;

    // Subscribe to the channel and confirm that the promise resolves
    auto msgFuture = waitForChannelMsg(client.get(), subscriptionId);
    client->subscribe({{subscriptionId, channel.id}});
    ASSERT_EQ(std::future_status::ready, msgFuture.wait_for(ONE_SECOND));
    const auto msgData = msgFuture.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_BINARY), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_BINARY, msgData.data(), msgData.size()));

    // Unsubscribe from the channel again.
    client->unsubscribe({subscriptionId});
  }
}

TEST(SmokeTest, testSubscriptionParallel) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  ros::NodeHandle nh;
  auto pub = nh.advertise<std_msgs::String>(topic_name, 10, true);
  pub.publish(std::string("hello world"));

  // Connect a few clients (in parallel) and make sure that they receive the correct message
  const foxglove_ws::SubscriptionId subscriptionId = 1;
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<uint8_t>>> futures;
  for (auto client : clients) {
    futures.push_back(waitForChannelMsg(client.get(), subscriptionId));
  }

  for (auto client : clients) {
    auto channelFuture = foxglove_ws::waitForChannel(client, topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(DEFAULT_TIMEOUT));
    const foxglove_ws::Channel channel = channelFuture.get();
    client->subscribe({{subscriptionId, channel.id}});
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    auto msgData = future.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_BINARY), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_BINARY, msgData.data(), msgData.size()));
  }

  for (auto client : clients) {
    client->unsubscribe({subscriptionId});
  }
}

TEST(SmokeTest, testPublishing) {
  foxglove_ws::Client<websocketpp::config::asio_client> wsClient;

  foxglove_ws::ClientAdvertisement advertisement;
  advertisement.channelId = 1;
  advertisement.topic = "/foo";
  advertisement.encoding = "ros1";
  advertisement.schemaName = "std_msgs/String";

  // Set up a ROS node with a subscriber
  ros::NodeHandle nh;
  std::promise<std::string> msgPromise;
  auto msgFuture = msgPromise.get_future();
  auto subscriber = nh.subscribe<std_msgs::String>(
    advertisement.topic, 10, [&msgPromise](const std_msgs::String::ConstPtr& msg) {
      msgPromise.set_value(msg->data);
    });

  // Set up the client, advertise and publish the binary message
  ASSERT_EQ(std::future_status::ready, wsClient.connect(URI).wait_for(DEFAULT_TIMEOUT));
  wsClient.advertise({advertisement});
  std::this_thread::sleep_for(ONE_SECOND);
  wsClient.publish(advertisement.channelId, HELLO_WORLD_BINARY, sizeof(HELLO_WORLD_BINARY));
  wsClient.unadvertise({advertisement.channelId});

  // Ensure that we have received the correct message via our ROS subscriber
  const auto msgResult = msgFuture.wait_for(ONE_SECOND);
  ASSERT_EQ(std::future_status::ready, msgResult);
  EXPECT_EQ("hello world", msgFuture.get());
}

TEST_F(ParameterTest, testGetAllParams) {
  const std::string requestId = "req-testGetAllParams";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_GE(params.size(), 2UL);
}

TEST_F(ParameterTest, testGetNonExistingParameters) {
  const std::string requestId = "req-testGetNonExistingParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters(
    {"/foo_1/non_existing_parameter", "/foo_2/non_existing/nested_parameter"}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_TRUE(params.empty());
}

TEST_F(ParameterTest, testGetParameters) {
  const std::string requestId = "req-testGetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({PARAM_1_NAME, PARAM_2_NAME}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [](const auto& param) {
    return param.getName() == PARAM_1_NAME;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [](const auto& param) {
    return param.getName() == PARAM_2_NAME;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(PARAM_1_DEFAULT_VALUE, p1Iter->getValue().getValue<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<double> double_array_val;
  const auto array_params = p2Iter->getValue().getValue<std::vector<foxglove_ws::ParameterValue>>();
  for (const auto& paramValue : array_params) {
    double_array_val.push_back(paramValue.getValue<double>());
  }
  EXPECT_EQ(double_array_val, PARAM_2_DEFAULT_VALUE);
}

TEST_F(ParameterTest, testSetParameters) {
  const PARAM_1_TYPE newP1value = "world";
  const std::vector<foxglove_ws::ParameterValue> newP2value = {4.1, 5.5, 6.6};

  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(PARAM_1_NAME, newP1value),
    foxglove_ws::Parameter(PARAM_2_NAME, newP2value),
  };

  _wsClient->setParameters(parameters);
  const std::string requestId = "req-testSetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({PARAM_1_NAME, PARAM_2_NAME}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [](const auto& param) {
    return param.getName() == PARAM_1_NAME;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [](const auto& param) {
    return param.getName() == PARAM_2_NAME;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(newP1value, p1Iter->getValue().getValue<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<double> double_array_val;
  const auto array_params = p2Iter->getValue().getValue<std::vector<foxglove_ws::ParameterValue>>();
  for (const auto& paramValue : array_params) {
    double_array_val.push_back(paramValue.getValue<double>());
  }
  const std::vector<double> expected_value = {4.1, 5.5, 6.6};
  EXPECT_EQ(double_array_val, expected_value);
}

TEST_F(ParameterTest, testSetParametersWithReqId) {
  const PARAM_1_TYPE newP1value = "world";
  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(PARAM_1_NAME, newP1value),
  };

  const std::string requestId = "req-testSetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(1UL, params.size());
}

TEST_F(ParameterTest, testUnsetParameter) {
  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(PARAM_1_NAME),
  };

  const std::string requestId = "req-testUnsetParameter";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(0UL, params.size());
}

TEST_F(ParameterTest, testParameterSubscription) {
  auto future = foxglove_ws::waitForParameters(_wsClient);

  _wsClient->subscribeParameterUpdates({PARAM_1_NAME});
  _wsClient->setParameters({foxglove_ws::Parameter(PARAM_1_NAME, "foo")});
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  ASSERT_EQ(1UL, params.size());
  EXPECT_EQ(params.front().getName(), PARAM_1_NAME);

  _wsClient->unsubscribeParameterUpdates({PARAM_1_NAME});
  _wsClient->setParameters({foxglove_ws::Parameter(PARAM_1_NAME, "bar")});

  future = foxglove_ws::waitForParameters(_wsClient);
  ASSERT_EQ(std::future_status::timeout, future.wait_for(ONE_SECOND));
}

TEST_F(ParameterTest, testGetParametersParallel) {
  // Connect a few clients (in parallel) and make sure that they all receive parameters
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<foxglove_ws::Parameter>>> futures;
  for (auto client : clients) {
    futures.push_back(
      std::async(std::launch::async, [client]() -> std::vector<foxglove_ws::Parameter> {
        if (std::future_status::ready == client->connect(URI).wait_for(DEFAULT_TIMEOUT)) {
          const std::string requestId = "req-123";
          auto future = foxglove_ws::waitForParameters(client, requestId);
          client->getParameters({}, requestId);
          future.wait_for(DEFAULT_TIMEOUT);
          if (future.valid()) {
            return future.get();
          }
        }
        return {};
      }));
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    std::vector<foxglove_ws::Parameter> parameters;
    EXPECT_NO_THROW(parameters = future.get());
    EXPECT_GE(parameters.size(), 2UL);
  }
}

TEST_F(ServiceTest, testCallServiceParallel) {
  // Connect a few clients (in parallel) and make sure that they can all call the service
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  auto serviceFuture = foxglove_ws::waitForService(*clients.begin(), SERVICE_NAME);
  for (auto client : clients) {
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(std::chrono::seconds(5)));
  }
  ASSERT_EQ(std::future_status::ready, serviceFuture.wait_for(std::chrono::seconds(5)));
  const foxglove_ws::Service service = serviceFuture.get();

  foxglove_ws::ServiceRequest request;
  request.serviceId = service.id;
  request.callId = 123lu;
  request.encoding = "ros1";
  request.data = {1};  // Serialized boolean "True"

  const std::vector<uint8_t> expectedSerializedResponse = {1, 5, 0, 0, 0, 104, 101, 108, 108, 111};

  std::vector<std::future<foxglove_ws::ServiceResponse>> futures;
  for (auto client : clients) {
    futures.push_back(foxglove_ws::waitForServiceResponse(client));
    client->sendServiceRequest(request);
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(std::chrono::seconds(5)));
    foxglove_ws::ServiceResponse response;
    EXPECT_NO_THROW(response = future.get());
    EXPECT_EQ(response.serviceId, request.serviceId);
    EXPECT_EQ(response.callId, request.callId);
    EXPECT_EQ(response.encoding, request.encoding);
    EXPECT_EQ(response.data, expectedSerializedResponse);
  }
}

TEST(FetchAssetTest, fetchExistingAsset) {
  auto wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const auto millisSinceEpoch = std::chrono::duration_cast<std::chrono::milliseconds>(
    std::chrono::system_clock::now().time_since_epoch());
  const auto tmpFilePath =
    boost::filesystem::temp_directory_path() / std::to_string(millisSinceEpoch.count());
  constexpr char content[] = "Hello, world";
  FILE* tmpAssetFile = std::fopen(tmpFilePath.c_str(), "w");
  std::fputs(content, tmpAssetFile);
  std::fclose(tmpAssetFile);

  const std::string uri = std::string("file://") + tmpFilePath.string();
  const uint32_t requestId = 123;

  auto future = foxglove_ws::waitForFetchAssetResponse(wsClient);
  wsClient->fetchAsset(uri, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove_ws::FetchAssetStatus::Success);
  // +1 since NULL terminator is not written to file.
  ASSERT_EQ(response.data.size() + 1ul, sizeof(content));
  EXPECT_EQ(0, std::memcmp(content, response.data.data(), response.data.size()));
  std::remove(tmpFilePath.c_str());
}

TEST(FetchAssetTest, fetchNonExistingAsset) {
  auto wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const std::string assetId = "file:///foo/bar";
  const uint32_t requestId = 456;

  auto future = foxglove_ws::waitForFetchAssetResponse(wsClient);
  wsClient->fetchAsset(assetId, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove_ws::FetchAssetStatus::Error);
  EXPECT_FALSE(response.errorMessage.empty());
}

// Run all the tests that were declared with TEST()
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  ros::init(argc, argv, "tester");
  ros::NodeHandle nh;

  // Give the server some time to start
  std::this_thread::sleep_for(std::chrono::seconds(2));

  ros::AsyncSpinner spinner(1);
  spinner.start();
  const auto testResult = RUN_ALL_TESTS();
  spinner.stop();

  return testResult;
}



================================================
FILE: ros2_foxglove_bridge/include/foxglove_bridge/generic_client.hpp
================================================
#pragma once

#include <future>

#include <rclcpp/client.hpp>
#include <rclcpp/serialized_message.hpp>
#include <rcpputils/shared_library.hpp>

namespace foxglove_bridge {

class GenericClient : public rclcpp::ClientBase {
public:
  using SharedRequest = std::shared_ptr<rclcpp::SerializedMessage>;
  using SharedResponse = std::shared_ptr<rclcpp::SerializedMessage>;
  using Promise = std::promise<SharedResponse>;
  using PromiseWithRequest = std::promise<std::pair<SharedRequest, SharedResponse>>;
  using SharedPromise = std::shared_ptr<Promise>;
  using SharedPromiseWithRequest = std::shared_ptr<PromiseWithRequest>;
  using SharedFuture = std::shared_future<SharedResponse>;
  using SharedFutureWithRequest = std::shared_future<std::pair<SharedRequest, SharedResponse>>;
  using CallbackType = std::function<void(SharedFuture)>;
  using CallbackWithRequestType = std::function<void(SharedFutureWithRequest)>;

  RCLCPP_SMART_PTR_DEFINITIONS(GenericClient)

  GenericClient(rclcpp::node_interfaces::NodeBaseInterface* node_base,
                rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,
                std::string service_name, std::string service_type,
                rcl_client_options_t& client_options);
  virtual ~GenericClient() {}

  std::shared_ptr<void> create_response() override;
  std::shared_ptr<rmw_request_id_t> create_request_header() override;
  void handle_response(std::shared_ptr<rmw_request_id_t> request_header,
                       std::shared_ptr<void> response) override;
  SharedFuture async_send_request(SharedRequest request);
  SharedFuture async_send_request(SharedRequest request, CallbackType&& cb);

private:
  RCLCPP_DISABLE_COPY(GenericClient)

  std::map<int64_t, std::tuple<SharedPromise, CallbackType, SharedFuture>> pending_requests_;
  std::mutex pending_requests_mutex_;
  std::shared_ptr<rcpputils::SharedLibrary> _typeSupportLib;
  std::shared_ptr<rcpputils::SharedLibrary> _typeIntrospectionLib;
  const rosidl_service_type_support_t* _serviceTypeSupportHdl;
  const rosidl_message_type_support_t* _requestTypeSupportHdl;
  const rosidl_message_type_support_t* _responseTypeSupportHdl;
  const rosidl_service_type_support_t* _typeIntrospectionHdl;
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/include/foxglove_bridge/param_utils.hpp
================================================
#pragma once

#include <regex>
#include <string>
#include <vector>

#include <rclcpp/node.hpp>

namespace foxglove_bridge {

constexpr char PARAM_PORT[] = "port";
constexpr char PARAM_ADDRESS[] = "address";
constexpr char PARAM_SEND_BUFFER_LIMIT[] = "send_buffer_limit";
constexpr char PARAM_USETLS[] = "tls";
constexpr char PARAM_CERTFILE[] = "certfile";
constexpr char PARAM_KEYFILE[] = "keyfile";
constexpr char PARAM_MIN_QOS_DEPTH[] = "min_qos_depth";
constexpr char PARAM_MAX_QOS_DEPTH[] = "max_qos_depth";
constexpr char PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST[] = "best_effort_qos_topic_whitelist";
constexpr char PARAM_TOPIC_WHITELIST[] = "topic_whitelist";
constexpr char PARAM_SERVICE_WHITELIST[] = "service_whitelist";
constexpr char PARAM_PARAMETER_WHITELIST[] = "param_whitelist";
constexpr char PARAM_USE_COMPRESSION[] = "use_compression";
constexpr char PARAM_CAPABILITIES[] = "capabilities";
constexpr char PARAM_CLIENT_TOPIC_WHITELIST[] = "client_topic_whitelist";
constexpr char PARAM_INCLUDE_HIDDEN[] = "include_hidden";
constexpr char PARAM_DISABLE_LOAN_MESSAGE[] = "disable_load_message";
constexpr char PARAM_ASSET_URI_ALLOWLIST[] = "asset_uri_allowlist";
constexpr char PARAM_IGN_UNRESPONSIVE_PARAM_NODES[] = "ignore_unresponsive_param_nodes";

constexpr int64_t DEFAULT_PORT = 8765;
constexpr char DEFAULT_ADDRESS[] = "0.0.0.0";
constexpr int64_t DEFAULT_SEND_BUFFER_LIMIT = 10000000;
constexpr int64_t DEFAULT_MIN_QOS_DEPTH = 1;
constexpr int64_t DEFAULT_MAX_QOS_DEPTH = 25;

void declareParameters(rclcpp::Node* node);

std::vector<std::regex> parseRegexStrings(rclcpp::Node* node,
                                          const std::vector<std::string>& strings);

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/include/foxglove_bridge/parameter_interface.hpp
================================================
#pragma once

#include <chrono>
#include <functional>
#include <mutex>
#include <regex>
#include <string>
#include <unordered_set>
#include <vector>

#include <rclcpp/rclcpp.hpp>

#include <foxglove_bridge/parameter.hpp>

namespace foxglove_bridge {

using ParameterList = std::vector<foxglove_ws::Parameter>;
using ParamUpdateFunc = std::function<void(const ParameterList&)>;

enum class UnresponsiveNodePolicy {
  Ignore,
  Retry,
};

class ParameterInterface {
public:
  ParameterInterface(rclcpp::Node* node, std::vector<std::regex> paramWhitelistPatterns,
                     UnresponsiveNodePolicy unresponsiveNodePolicy);

  ParameterList getParams(const std::vector<std::string>& paramNames,
                          const std::chrono::duration<double>& timeout);
  void setParams(const ParameterList& params, const std::chrono::duration<double>& timeout);
  void subscribeParams(const std::vector<std::string>& paramNames);
  void unsubscribeParams(const std::vector<std::string>& paramNames);
  void setParamUpdateCallback(ParamUpdateFunc paramUpdateFunc);

private:
  rclcpp::Node* _node;
  std::vector<std::regex> _paramWhitelistPatterns;
  rclcpp::CallbackGroup::SharedPtr _callbackGroup;
  std::mutex _mutex;
  std::unordered_map<std::string, rclcpp::AsyncParametersClient::SharedPtr> _paramClientsByNode;
  std::unordered_map<std::string, std::unordered_set<std::string>> _subscribedParamsByNode;
  std::unordered_map<std::string, rclcpp::SubscriptionBase::SharedPtr> _paramSubscriptionsByNode;
  std::unordered_set<std::string> _ignoredNodeNames;
  UnresponsiveNodePolicy _unresponsiveNodePolicy;
  ParamUpdateFunc _paramUpdateFunc;

  ParameterList getNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                                  const std::string& nodeName,
                                  const std::vector<std::string>& paramNames,
                                  const std::chrono::duration<double>& timeout);
  void setNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                         const std::string& nodeName, const std::vector<rclcpp::Parameter>& params,
                         const std::chrono::duration<double>& timeout);
  bool isWhitelistedParam(const std::string& paramName);
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/include/foxglove_bridge/ros2_foxglove_bridge.hpp
================================================
#pragma once

#include <atomic>
#include <chrono>
#include <memory>
#include <regex>
#include <thread>

#include <rclcpp/rclcpp.hpp>
#include <rosgraph_msgs/msg/clock.hpp>
#include <rosx_introspection/ros_parser.hpp>
#include <websocketpp/common/connection_hdl.hpp>

#include <foxglove_bridge/callback_queue.hpp>
#include <foxglove_bridge/foxglove_bridge.hpp>
#include <foxglove_bridge/generic_client.hpp>
#include <foxglove_bridge/message_definition_cache.hpp>
#include <foxglove_bridge/param_utils.hpp>
#include <foxglove_bridge/parameter_interface.hpp>
#include <foxglove_bridge/regex_utils.hpp>
#include <foxglove_bridge/server_factory.hpp>
#include <foxglove_bridge/utils.hpp>

namespace foxglove_bridge {

using ConnectionHandle = websocketpp::connection_hdl;
using LogLevel = foxglove_ws::WebSocketLogLevel;
using Subscription = rclcpp::GenericSubscription::SharedPtr;
using SubscriptionsByClient = std::map<ConnectionHandle, Subscription, std::owner_less<>>;
using Publication = rclcpp::GenericPublisher::SharedPtr;
using ClientPublications = std::unordered_map<foxglove_ws::ClientChannelId, Publication>;
using PublicationsByClient = std::map<ConnectionHandle, ClientPublications, std::owner_less<>>;

class FoxgloveBridge : public rclcpp::Node {
public:
  using TopicAndDatatype = std::pair<std::string, std::string>;

  FoxgloveBridge(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());

  ~FoxgloveBridge();

  void rosgraphPollThread();

  void updateAdvertisedTopics(
    const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes);

  void updateAdvertisedServices();

  void updateConnectionGraph(
    const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes);

private:
  struct PairHash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2>& pair) const {
      return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
    }
  };

  std::unique_ptr<foxglove_ws::ServerInterface<ConnectionHandle>> _server;
  foxglove::MessageDefinitionCache _messageDefinitionCache;
  std::vector<std::regex> _topicWhitelistPatterns;
  std::vector<std::regex> _serviceWhitelistPatterns;
  std::vector<std::regex> _assetUriAllowlistPatterns;
  std::vector<std::regex> _bestEffortQosTopicWhiteListPatterns;
  std::shared_ptr<ParameterInterface> _paramInterface;
  std::unordered_map<foxglove_ws::ChannelId, foxglove_ws::ChannelWithoutId> _advertisedTopics;
  std::unordered_map<foxglove_ws::ServiceId, foxglove_ws::ServiceWithoutId> _advertisedServices;
  std::unordered_map<foxglove_ws::ChannelId, SubscriptionsByClient> _subscriptions;
  PublicationsByClient _clientAdvertisedTopics;
  std::unordered_map<foxglove_ws::ServiceId, GenericClient::SharedPtr> _serviceClients;
  rclcpp::CallbackGroup::SharedPtr _subscriptionCallbackGroup;
  rclcpp::CallbackGroup::SharedPtr _clientPublishCallbackGroup;
  rclcpp::CallbackGroup::SharedPtr _servicesCallbackGroup;
  std::mutex _subscriptionsMutex;
  std::mutex _clientAdvertisementsMutex;
  std::mutex _servicesMutex;
  std::unique_ptr<std::thread> _rosgraphPollThread;
  size_t _minQosDepth = DEFAULT_MIN_QOS_DEPTH;
  size_t _maxQosDepth = DEFAULT_MAX_QOS_DEPTH;
  std::shared_ptr<rclcpp::Subscription<rosgraph_msgs::msg::Clock>> _clockSubscription;
  bool _useSimTime = false;
  std::vector<std::string> _capabilities;
  std::atomic<bool> _subscribeGraphUpdates = false;
  bool _includeHidden = false;
  bool _disableLoanMessage = true;
  std::unique_ptr<foxglove_ws::CallbackQueue> _fetchAssetQueue;
  std::unordered_map<std::string, std::shared_ptr<RosMsgParser::Parser>> _jsonParsers;
  std::atomic<bool> _shuttingDown = false;

  void subscribeConnectionGraph(bool subscribe);

  void subscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle);

  void unsubscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle);

  void clientAdvertise(const foxglove_ws::ClientAdvertisement& advertisement, ConnectionHandle hdl);

  void clientUnadvertise(foxglove_ws::ChannelId channelId, ConnectionHandle hdl);

  void clientMessage(const foxglove_ws::ClientMessage& message, ConnectionHandle hdl);

  void setParameters(const std::vector<foxglove_ws::Parameter>& parameters,
                     const std::optional<std::string>& requestId, ConnectionHandle hdl);

  void getParameters(const std::vector<std::string>& parameters,
                     const std::optional<std::string>& requestId, ConnectionHandle hdl);

  void subscribeParameters(const std::vector<std::string>& parameters,
                           foxglove_ws::ParameterSubscriptionOperation op, ConnectionHandle);

  void parameterUpdates(const std::vector<foxglove_ws::Parameter>& parameters);

  void logHandler(LogLevel level, char const* msg);

  void rosMessageHandler(const foxglove_ws::ChannelId& channelId, ConnectionHandle clientHandle,
                         std::shared_ptr<const rclcpp::SerializedMessage> msg);

  void serviceRequest(const foxglove_ws::ServiceRequest& request, ConnectionHandle clientHandle);

  void fetchAsset(const std::string& assetId, uint32_t requestId, ConnectionHandle clientHandle);

  bool hasCapability(const std::string& capability);
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/include/foxglove_bridge/utils.hpp
================================================
#pragma once

#include <algorithm>
#include <regex>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

namespace foxglove_bridge {

inline std::pair<std::string, std::string> getNodeAndNodeNamespace(const std::string& fqnNodeName) {
  const std::size_t found = fqnNodeName.find_last_of("/");
  if (found == std::string::npos) {
    throw std::runtime_error("Invalid fully qualified node name: " + fqnNodeName);
  }
  return std::make_pair(fqnNodeName.substr(0, found), fqnNodeName.substr(found + 1));
}

inline std::string trimString(std::string& str) {
  constexpr char whitespaces[] = "\t\n\r ";
  str.erase(0, str.find_first_not_of(whitespaces));  // trim left
  str.erase(str.find_last_not_of(whitespaces) + 1);  // trim right
  return str;
}

inline std::vector<std::string> splitMessageDefinitions(std::istream& stream) {
  std::vector<std::string> definitions;

  std::string line = "";
  std::string definition = "";

  while (std::getline(stream, line)) {
    line = trimString(line);
    if (line == "---") {
      definitions.push_back(trimString(definition));
      definition = "";
    } else {
      definition += line + "\n";
    }
  }

  definitions.push_back(trimString(definition));
  return definitions;
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/launch/foxglove_bridge_launch.xml
================================================
<launch>
  <arg name="port"                            default="8765" />
  <arg name="address"                         default="0.0.0.0" />
  <arg name="tls"                             default="false" />
  <arg name="certfile"                        default="" />
  <arg name="keyfile"                         default="" />
  <arg name="topic_whitelist"                 default="['.*']" />
  <arg name="param_whitelist"                 default="['.*']" />
  <arg name="service_whitelist"               default="['.*']" />
  <arg name="client_topic_whitelist"          default="['.*']" />
  <arg name="min_qos_depth"                   default="1" />
  <arg name="max_qos_depth"                   default="10" />
  <arg name="num_threads"                     default="0" />
  <arg name="send_buffer_limit"               default="10000000" />
  <arg name="use_sim_time"                    default="false" />
  <arg name="capabilities"                    default="[clientPublish,parameters,parametersSubscribe,services,connectionGraph,assets]" />
  <arg name="include_hidden"                  default="false" />
  <arg name="asset_uri_allowlist"             default="['^package://(?:[-\\w%]+/)*[-\\w%.]+\\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$']" />  <!-- Needs double-escape -->
  <arg name="ignore_unresponsive_param_nodes" default="true" />

  <node pkg="foxglove_bridge" exec="foxglove_bridge">
    <param name="port"                            value="$(var port)" />
    <param name="address"                         value="$(var address)" />
    <param name="tls"                             value="$(var tls)" />
    <param name="certfile"                        value="$(var certfile)" />
    <param name="keyfile"                         value="$(var keyfile)" />
    <param name="topic_whitelist"                 value="$(var topic_whitelist)" />
    <param name="service_whitelist"               value="$(var service_whitelist)" />
    <param name="param_whitelist"                 value="$(var param_whitelist)" />
    <param name="client_topic_whitelist"          value="$(var client_topic_whitelist)" />
    <param name="min_qos_depth"                   value="$(var min_qos_depth)" />
    <param name="max_qos_depth"                   value="$(var max_qos_depth)" />
    <param name="num_threads"                     value="$(var num_threads)" />
    <param name="send_buffer_limit"               value="$(var send_buffer_limit)" />
    <param name="use_sim_time"                    value="$(var use_sim_time)" />
    <param name="capabilities"                    value="$(var capabilities)" />
    <param name="include_hidden"                  value="$(var include_hidden)" />
    <param name="asset_uri_allowlist"             value="$(var asset_uri_allowlist)" />
    <param name="ignore_unresponsive_param_nodes" value="$(var ignore_unresponsive_param_nodes)" />
  </node>
</launch>



================================================
FILE: ros2_foxglove_bridge/src/generic_client.cpp
================================================
#include <future>
#include <iostream>

#include <rclcpp/client.hpp>
#include <rclcpp/serialized_message.hpp>
#include <rclcpp/typesupport_helpers.hpp>
#include <rclcpp/version.h>
#include <rosidl_typesupport_introspection_cpp/field_types.hpp>
#include <rosidl_typesupport_introspection_cpp/service_introspection.hpp>

#include <foxglove_bridge/generic_client.hpp>

namespace {

// Copy of github.com/ros2/rclcpp/blob/33dae5d67/rclcpp/src/rclcpp/typesupport_helpers.cpp#L69-L92
static std::tuple<std::string, std::string, std::string> extract_type_identifier(
  const std::string& full_type) {
  char type_separator = '/';
  auto sep_position_back = full_type.find_last_of(type_separator);
  auto sep_position_front = full_type.find_first_of(type_separator);
  if (sep_position_back == std::string::npos || sep_position_back == 0 ||
      sep_position_back == full_type.length() - 1) {
    throw std::runtime_error(
      "Message type is not of the form package/type and cannot be processed");
  }

  std::string package_name = full_type.substr(0, sep_position_front);
  std::string middle_module = "";
  if (sep_position_back - sep_position_front > 0) {
    middle_module =
      full_type.substr(sep_position_front + 1, sep_position_back - sep_position_front - 1);
  }
  std::string type_name = full_type.substr(sep_position_back + 1);

  return std::make_tuple(package_name, middle_module, type_name);
}
}  // namespace

namespace foxglove_bridge {

constexpr char TYPESUPPORT_INTROSPECTION_LIB_NAME[] = "rosidl_typesupport_introspection_cpp";
constexpr char TYPESUPPORT_LIB_NAME[] = "rosidl_typesupport_cpp";
using rosidl_typesupport_introspection_cpp::MessageMembers;
using rosidl_typesupport_introspection_cpp::ServiceMembers;

std::shared_ptr<void> allocate_message(const MessageMembers* members) {
  void* buffer = malloc(members->size_of_);
  if (buffer == nullptr) {
    throw std::runtime_error("Failed to allocate memory");
  }
  memset(buffer, 0, members->size_of_);
  members->init_function(buffer, rosidl_runtime_cpp::MessageInitialization::ALL);
  return std::shared_ptr<void>(buffer, free);
}

std::string getTypeIntrospectionSymbolName(const std::string& serviceType) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);

  return std::string(TYPESUPPORT_INTROSPECTION_LIB_NAME) + "__get_service_type_support_handle__" +
         pkgName + "__" + (middleModule.empty() ? "srv" : middleModule) + "__" + typeName;
}

/**
 * The default symbol names for getting type support handles for services are missing from the
 * rosidl_typesupport_cpp shared libraries, see
 * https://github.com/ros2/rosidl_typesupport/issues/122
 *
 * We can however, as a (hacky) workaround, use other symbols defined in the shared library.
 * With `nm -C -D /opt/ros/humble/lib/libtest_msgs__rosidl_typesupport_cpp.so` we see that there is
 * `rosidl_service_type_support_t const*
 * rosidl_typesupport_cpp::get_service_type_support_handle<test_msgs::srv::BasicTypes>()` which
 * mangled becomes
 * `_ZN22rosidl_typesupport_cpp31get_service_type_support_handleIN9test_msgs3srv10BasicTypesEEEPK29rosidl_service_type_support_tv`
 * This is the same for galactic, humble and rolling (tested with gcc / clang)
 *
 * This function produces the mangled symbol name for a given service type.
 *
 * \param[in] serviceType The service type, e.g. "test_msgs/srv/BasicTypes"
 * \return Symbol name for getting the service type support handle
 */
std::string getServiceTypeSupportHandleSymbolName(const std::string& serviceType) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);
  const auto lengthPrefixedString = [](const std::string& s) {
    return std::to_string(s.size()) + s;
  };

  return "_ZN" + lengthPrefixedString(TYPESUPPORT_LIB_NAME) +
         lengthPrefixedString("get_service_type_support_handle") + "IN" +
         lengthPrefixedString(pkgName) +
         lengthPrefixedString(middleModule.empty() ? "srv" : middleModule) +
         lengthPrefixedString(typeName) + "EEEPK" +
         lengthPrefixedString("rosidl_service_type_support_t") + "v";
}

GenericClient::GenericClient(rclcpp::node_interfaces::NodeBaseInterface* nodeBase,
                             rclcpp::node_interfaces::NodeGraphInterface::SharedPtr nodeGraph,
                             std::string serviceName, std::string serviceType,
                             rcl_client_options_t& client_options)
    : rclcpp::ClientBase(nodeBase, nodeGraph) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);
  const auto requestTypeName = serviceType + "_Request";
  const auto responseTypeName = serviceType + "_Response";

  _typeSupportLib = rclcpp::get_typesupport_library(serviceType, TYPESUPPORT_LIB_NAME);
  _typeIntrospectionLib =
    rclcpp::get_typesupport_library(serviceType, TYPESUPPORT_INTROSPECTION_LIB_NAME);
  if (!_typeSupportLib || !_typeIntrospectionLib) {
    throw std::runtime_error("Failed to load shared library for service type " + serviceType);
  }

  const auto typesupportSymbolName = getServiceTypeSupportHandleSymbolName(serviceType);
  if (!_typeSupportLib->has_symbol(typesupportSymbolName)) {
    throw std::runtime_error("Failed to find symbol '" + typesupportSymbolName + "' in " +
                             _typeSupportLib->get_library_path());
  }

  const rosidl_service_type_support_t* (*get_ts)() = nullptr;
  _serviceTypeSupportHdl =
    (reinterpret_cast<decltype(get_ts)>(_typeSupportLib->get_symbol(typesupportSymbolName)))();

  const auto typeinstrospection_symbol_name = getTypeIntrospectionSymbolName(serviceType);

  // This will throw runtime_error if the symbol was not found.
  _typeIntrospectionHdl = (reinterpret_cast<decltype(get_ts)>(
    _typeIntrospectionLib->get_symbol(typeinstrospection_symbol_name)))();

  // get_typesupport_handle is deprecated since rclcpp 25.0.0
  // (https://github.com/ros2/rclcpp/pull/2209)
#if RCLCPP_VERSION_GTE(25, 0, 0)
  _requestTypeSupportHdl =
    rclcpp::get_message_typesupport_handle(requestTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
  _responseTypeSupportHdl = rclcpp::get_message_typesupport_handle(
    responseTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
#else
  _requestTypeSupportHdl =
    rclcpp::get_typesupport_handle(requestTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
  _responseTypeSupportHdl =
    rclcpp::get_typesupport_handle(responseTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
#endif

  rcl_ret_t ret = rcl_client_init(this->get_client_handle().get(), this->get_rcl_node_handle(),
                                  _serviceTypeSupportHdl, serviceName.c_str(), &client_options);
  if (ret != RCL_RET_OK) {
    if (ret == RCL_RET_SERVICE_NAME_INVALID) {
      auto rcl_node_handle = this->get_rcl_node_handle();
      // this will throw on any validation problem
      rcl_reset_error();
      rclcpp::expand_topic_or_service_name(serviceName, rcl_node_get_name(rcl_node_handle),
                                           rcl_node_get_namespace(rcl_node_handle), true);
    }
    rclcpp::exceptions::throw_from_rcl_error(ret, "could not create client");
  }
}

std::shared_ptr<void> GenericClient::create_response() {
  auto srv_members = static_cast<const ServiceMembers*>(_typeIntrospectionHdl->data);
  return allocate_message(srv_members->response_members_);
}

std::shared_ptr<rmw_request_id_t> GenericClient::create_request_header() {
  return std::shared_ptr<rmw_request_id_t>(new rmw_request_id_t);
}

void GenericClient::handle_response(std::shared_ptr<rmw_request_id_t> request_header,
                                    std::shared_ptr<void> response) {
  std::unique_lock<std::mutex> lock(pending_requests_mutex_);
  int64_t sequence_number = request_header->sequence_number;

  auto ser_response = std::make_shared<rclcpp::SerializedMessage>();
  rmw_ret_t r = rmw_serialize(response.get(), _responseTypeSupportHdl,
                              &ser_response->get_rcl_serialized_message());
  if (r != RMW_RET_OK) {
    RCUTILS_LOG_ERROR_NAMED("foxglove_bridge", "Failed to serialize service response. Ignoring...");
    return;
  }

  // TODO(esteve) this should throw instead since it is not expected to happen in the first place
  if (this->pending_requests_.count(sequence_number) == 0) {
    RCUTILS_LOG_ERROR_NAMED("foxglove_bridge", "Received invalid sequence number. Ignoring...");
    return;
  }
  auto tuple = this->pending_requests_[sequence_number];
  auto call_promise = std::get<0>(tuple);
  auto callback = std::get<1>(tuple);
  auto future = std::get<2>(tuple);
  this->pending_requests_.erase(sequence_number);
  // Unlock here to allow the service to be called recursively from one of its callbacks.
  lock.unlock();

  call_promise->set_value(ser_response);
  callback(future);
}

GenericClient::SharedFuture GenericClient::async_send_request(SharedRequest request) {
  return async_send_request(request, [](SharedFuture) {});
}

GenericClient::SharedFuture GenericClient::async_send_request(SharedRequest request,
                                                              CallbackType&& cb) {
  std::lock_guard<std::mutex> lock(pending_requests_mutex_);
  int64_t sequence_number;

  auto srv_members = static_cast<const ServiceMembers*>(_typeIntrospectionHdl->data);
  auto buf = allocate_message(srv_members->request_members_);

  const rmw_serialized_message_t* sm = &request->get_rcl_serialized_message();
  if (const auto ret = rmw_deserialize(sm, _requestTypeSupportHdl, buf.get()) != RCL_RET_OK) {
    rclcpp::exceptions::throw_from_rcl_error(ret, "failed to desirialize request");
  }
  rcl_ret_t ret = rcl_send_request(get_client_handle().get(), buf.get(), &sequence_number);
  if (RCL_RET_OK != ret) {
    rclcpp::exceptions::throw_from_rcl_error(ret, "failed to send request");
  }

  SharedPromise call_promise = std::make_shared<Promise>();
  SharedFuture f(call_promise->get_future());
  pending_requests_[sequence_number] =
    std::make_tuple(call_promise, std::forward<CallbackType>(cb), f);
  return f;
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/src/message_definition_cache.cpp
================================================
#include "foxglove_bridge/message_definition_cache.hpp"

#include <filesystem>
#include <fstream>
#include <functional>
#include <optional>
#include <regex>
#include <set>
#include <string>
#include <unordered_set>
#include <utility>

#include <ament_index_cpp/get_package_share_directory.hpp>
#include <ament_index_cpp/get_resource.hpp>
#include <ament_index_cpp/get_resources.hpp>
#include <rcutils/logging_macros.h>

#include "foxglove_bridge/utils.hpp"

namespace foxglove {

// Match datatype names (foo_msgs/Bar or foo_msgs/msg/Bar or foo_msgs/srv/Bar)
static const std::regex PACKAGE_TYPENAME_REGEX{
  R"(^([a-zA-Z0-9_]+)/(?:(msg|srv|action)/)?([a-zA-Z0-9_]+)$)"};

// Match field types from .msg definitions ("foo_msgs/Bar" in "foo_msgs/Bar[] bar")
static const std::regex MSG_FIELD_TYPE_REGEX{R"((?:^|\n)\s*([a-zA-Z0-9_/]+)(?:\[[^\]]*\])?\s+)"};

// match field types from `.idl` definitions ("foo_msgs/msg/bar" in #include <foo_msgs/msg/Bar.idl>)
static const std::regex IDL_FIELD_TYPE_REGEX{
  R"((?:^|\n)#include\s+(?:"|<)([a-zA-Z0-9_/]+)\.idl(?:"|>))"};

static const std::unordered_set<std::string> PRIMITIVE_TYPES{
  "bool",  "byte",   "char",  "float32", "float64", "int8",   "uint8",
  "int16", "uint16", "int32", "uint32",  "int64",   "uint64", "string"};

enum class DefinitionType {
  Message,
  Service,
  Action,
};

static std::set<std::string> parse_msg_dependencies(const std::string& text,
                                                    const std::string& package_context) {
  std::set<std::string> dependencies;

  for (std::sregex_iterator iter(text.begin(), text.end(), MSG_FIELD_TYPE_REGEX);
       iter != std::sregex_iterator(); ++iter) {
    std::string type = (*iter)[1];
    if (PRIMITIVE_TYPES.find(type) != PRIMITIVE_TYPES.end()) {
      continue;
    }
    if (type.find('/') == std::string::npos) {
      dependencies.insert(package_context + '/' + std::move(type));
    } else {
      dependencies.insert(std::move(type));
    }
  }
  return dependencies;
}

static std::set<std::string> parse_idl_dependencies(const std::string& text) {
  std::set<std::string> dependencies;

  for (std::sregex_iterator iter(text.begin(), text.end(), IDL_FIELD_TYPE_REGEX);
       iter != std::sregex_iterator(); ++iter) {
    dependencies.insert((*iter)[1]);
  }
  return dependencies;
}

std::set<std::string> parse_dependencies(MessageDefinitionFormat format, const std::string& text,
                                         const std::string& package_context) {
  switch (format) {
    case MessageDefinitionFormat::MSG:
      return parse_msg_dependencies(text, package_context);
    case MessageDefinitionFormat::IDL:
      return parse_idl_dependencies(text);
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
}

static const char* extension_for_format(MessageDefinitionFormat format,
                                        DefinitionType definitionType) {
  switch (format) {
    case MessageDefinitionFormat::MSG:
      switch (definitionType) {
        case DefinitionType::Message:
          return ".msg";
        case DefinitionType::Service:
          return ".srv";
        case DefinitionType::Action:
          return ".action";
        default:
          throw std::runtime_error("unknown definition type");
      }
    case MessageDefinitionFormat::IDL:
      return ".idl";
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
}

static std::string delimiter(const DefinitionIdentifier& definition_identifier) {
  std::string result =
    "================================================================================\n";
  switch (definition_identifier.format) {
    case MessageDefinitionFormat::MSG:
      result += "MSG: ";
      break;
    case MessageDefinitionFormat::IDL:
      result += "IDL: ";
      break;
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
  result += definition_identifier.package_resource_name;
  result += "\n";
  return result;
}

static std::vector<std::string> split_string(const std::string& str,
                                             const std::string& delimiter = "\n") {
  std::vector<std::string> strings;
  std::string::size_type pos = 0;
  std::string::size_type prev = 0;

  while ((pos = str.find(delimiter, prev)) != std::string::npos) {
    strings.push_back(str.substr(prev, pos - prev));
    prev = pos + delimiter.size();
  }

  // Get the last substring (or only, if delimiter is not found)
  strings.push_back(str.substr(prev));

  return strings;
}

inline bool ends_with(const std::string& str, const std::string& suffix) {
  return str.size() >= suffix.size() &&
         0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
}

std::string remove_action_subtype(const std::string action_type) {
  const auto action_subtype_suffixes = {
    std::string(ACTION_FEEDBACK_MESSAGE_SUFFIX),
    std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
    std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
    std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
    std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
  };

  for (const auto& suffix : action_subtype_suffixes) {
    if (ends_with(action_type, suffix)) {
      return action_type.substr(0, action_type.length() - suffix.length());
    }
  }

  return action_type;
}

std::string remove_service_subtype(const std::string service_type) {
  const std::vector<std::string> service_subtype_suffixes = {
    SERVICE_REQUEST_MESSAGE_SUFFIX,
    SERVICE_RESPONSE_MESSAGE_SUFFIX,
  };

  for (const auto& suffix : service_subtype_suffixes) {
    if (ends_with(service_type, suffix)) {
      return service_type.substr(0, service_type.length() - suffix.length());
    }
  }

  return service_type;
}

MessageSpec::MessageSpec(MessageDefinitionFormat format, std::string text,
                         const std::string& package_context)
    : dependencies(parse_dependencies(format, text, package_context))
    , text(std::move(text))
    , format(format) {}

const MessageSpec& MessageDefinitionCache::load_message_spec(
  const DefinitionIdentifier& definition_identifier) {
  if (auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
      it != msg_specs_by_definition_identifier_.end()) {
    return it->second;
  }

  std::smatch match;
  if (!std::regex_match(definition_identifier.package_resource_name, match,
                        PACKAGE_TYPENAME_REGEX)) {
    throw std::invalid_argument("Invalid package resource name: " +
                                definition_identifier.package_resource_name);
  }
  const std::string package = match[1].str();
  const std::string subfolder = match[2].str();
  const std::string type_name = match[3].str();

  const auto& format = definition_identifier.format;
  std::string filename = "";
  if (subfolder == "action") {
    // The action type name includes the subtype which we have to remove to get the action name.
    // Type name: Fibonacci_FeedbackMessage -> Action name: Fibonacci
    filename =
      remove_action_subtype(type_name) + extension_for_format(format, DefinitionType::Action);
  } else if (subfolder == "srv") {
    // The service type name includes the subtype which we have to remove to get the service name.
    // Type name: SetBool_Request -> Service name: SetBool
    filename =
      remove_service_subtype(type_name) + extension_for_format(format, DefinitionType::Service);
  } else {
    filename = type_name + extension_for_format(format, DefinitionType::Message);
  }

  // Get the package share directory, or throw a PackageNotFoundError
  const std::string share_dir = ament_index_cpp::get_package_share_directory(package);

  // Get the rosidl_interfaces index contents for this package
  std::string index_contents;
  if (!ament_index_cpp::get_resource("rosidl_interfaces", package, index_contents)) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  // Find the first line that ends with the filename we're looking for
  const auto lines = split_string(index_contents);
  const auto it = std::find_if(lines.begin(), lines.end(), [&filename](const std::string& line) {
    std::filesystem::path filePath(line);
    return filePath.filename() == filename;
  });
  if (it == lines.end()) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  // Read the file
  const std::string full_path = (std::filesystem::path(share_dir) / *it).string();
  std::ifstream file{full_path};
  if (!file.good()) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  if (subfolder == "action") {
    if (definition_identifier.format == MessageDefinitionFormat::IDL) {
      RCUTILS_LOG_ERROR_NAMED("foxglove_bridge",
                              "Action IDL definitions are currently not supported");
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }

    const auto split_definitions = foxglove_bridge::splitMessageDefinitions(file);
    if (split_definitions.size() != 3) {
      throw std::invalid_argument("Invalid action definition in " + filename +
                                  ": Expected 3 definitions, got " +
                                  std::to_string(split_definitions.size()));
    }

    const auto& goalDef = split_definitions[0];
    const auto& resultDef = split_definitions[1];
    const auto& feedbackDef = split_definitions[2];

    // Define type definitions for each action subtype.
    // These type definitions may include additional fields such as the goal_id.
    // See also https://design.ros2.org/articles/actions.html
    const std::map<std::string, std::string> action_type_definitions = {
      {ACTION_FEEDBACK_MESSAGE_SUFFIX, "unique_identifier_msgs/UUID goal_id\n" + feedbackDef},
      {std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
       "unique_identifier_msgs/UUID goal_id\n"},
      {std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
       "int8 status\n" + resultDef},
      {std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
       "unique_identifier_msgs/UUID goal_id\n" + goalDef},
      {std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
       "bool accepted\nbuiltin_interfaces/msg/Time stamp"}};

    // Create a MessageSpec instance for every action subtype and add it to the cache.
    const std::string action_name = remove_action_subtype(type_name);
    for (const auto& [action_suffix, definition] : action_type_definitions) {
      DefinitionIdentifier definition_id;
      definition_id.format = definition_identifier.format;
      definition_id.package_resource_name = package + "/action/" + action_name + action_suffix;
      msg_specs_by_definition_identifier_.emplace(
        definition_id, MessageSpec(definition_id.format, definition, package));
    }

    // Find the the subtype that was originally requested and return it.
    const auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
    if (it == msg_specs_by_definition_identifier_.end()) {
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }
    return it->second;
  } else if (subfolder == "srv") {
    if (definition_identifier.format == MessageDefinitionFormat::IDL) {
      RCUTILS_LOG_ERROR_NAMED("foxglove_bridge",
                              "Service IDL definitions are currently not supported");
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }

    const auto split_definitions = foxglove_bridge::splitMessageDefinitions(file);
    if (split_definitions.size() != 2) {
      throw std::invalid_argument("Invalid service definition in " + filename +
                                  ": Expected 2 definitions, got " +
                                  std::to_string(split_definitions.size()));
    }

    const auto& requestDef = split_definitions[0];
    const auto& responseDef = split_definitions[1];
    const std::map<std::string, std::string> service_type_definitions = {
      {SERVICE_REQUEST_MESSAGE_SUFFIX, requestDef}, {SERVICE_RESPONSE_MESSAGE_SUFFIX, responseDef}};

    // Create a MessageSpec instance for both the request and response subtypes and add it to the
    // cache.
    const std::string service_name = remove_service_subtype(type_name);
    for (const auto& [subType, definition] : service_type_definitions) {
      DefinitionIdentifier definition_id;
      definition_id.format = definition_identifier.format;
      definition_id.package_resource_name = package + "/srv/" + service_name + subType;
      msg_specs_by_definition_identifier_.emplace(
        definition_id, MessageSpec(definition_id.format, definition, package));
    }

    // Find the the subtype that was originally requested and return it.
    const auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
    if (it == msg_specs_by_definition_identifier_.end()) {
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }
    return it->second;
  } else {
    // Normal message type.
    const MessageSpec& spec =
      msg_specs_by_definition_identifier_
        .emplace(definition_identifier,
                 MessageSpec(definition_identifier.format,
                             std::string{std::istreambuf_iterator(file), {}}, package))
        .first->second;

    // "References and pointers to data stored in the container are only invalidated by erasing that
    // element, even when the corresponding iterator is invalidated."
    return spec;
  }
}  // namespace foxglove

std::pair<MessageDefinitionFormat, const std::string&> MessageDefinitionCache::get_full_text(
  const std::string& root_package_resource_name) {
  if (full_text_cache_.find(root_package_resource_name) != full_text_cache_.end()) {
    return {MessageDefinitionFormat::MSG, full_text_cache_[root_package_resource_name]};
  }
  std::unordered_set<DefinitionIdentifier, DefinitionIdentifierHash> seen_deps;

  std::function<std::string(const DefinitionIdentifier&)> append_recursive =
    [&](const DefinitionIdentifier& definition_identifier) {
      const MessageSpec& spec = load_message_spec(definition_identifier);
      std::string result = spec.text;
      for (const auto& dep_name : spec.dependencies) {
        DefinitionIdentifier dep{definition_identifier.format, dep_name};
        bool inserted = seen_deps.insert(dep).second;
        if (inserted) {
          result += "\n";
          result += delimiter(dep);
          result += append_recursive(dep);
        }
      }
      return result;
    };

  std::string result;
  auto format = MessageDefinitionFormat::MSG;
  try {
    result = append_recursive(DefinitionIdentifier{format, root_package_resource_name});
  } catch (const DefinitionNotFoundError& err) {
    // log that we've fallen back
    RCUTILS_LOG_WARN_NAMED("foxglove_bridge", "no .msg definition for %s, falling back to IDL",
                           err.what());
    format = MessageDefinitionFormat::IDL;
    DefinitionIdentifier root_definition_identifier{format, root_package_resource_name};
    result = delimiter(root_definition_identifier) + append_recursive(root_definition_identifier);
  }
  auto [it, _] = full_text_cache_.emplace(root_package_resource_name, result);
  return {format, it->second};
}

}  // namespace foxglove



================================================
FILE: ros2_foxglove_bridge/src/param_utils.cpp
================================================


#include <foxglove_bridge/common.hpp>
#include <foxglove_bridge/param_utils.hpp>

namespace foxglove_bridge {

void declareParameters(rclcpp::Node* node) {
  auto portDescription = rcl_interfaces::msg::ParameterDescriptor{};
  portDescription.name = PARAM_PORT;
  portDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  portDescription.description = "The TCP port to bind the WebSocket server to";
  portDescription.read_only = true;
  portDescription.additional_constraints =
    "Must be a valid TCP port number, or 0 to use a random port";
  portDescription.integer_range.resize(1);
  portDescription.integer_range[0].from_value = 0;
  portDescription.integer_range[0].to_value = 65535;
  portDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_PORT, DEFAULT_PORT, portDescription);

  auto addressDescription = rcl_interfaces::msg::ParameterDescriptor{};
  addressDescription.name = PARAM_ADDRESS;
  addressDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  addressDescription.description = "The host address to bind the WebSocket server to";
  addressDescription.read_only = true;
  node->declare_parameter(PARAM_ADDRESS, DEFAULT_ADDRESS, addressDescription);

  auto sendBufferLimitDescription = rcl_interfaces::msg::ParameterDescriptor{};
  sendBufferLimitDescription.name = PARAM_SEND_BUFFER_LIMIT;
  sendBufferLimitDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  sendBufferLimitDescription.description =
    "Connection send buffer limit in bytes. Messages will be dropped when a connection's send "
    "buffer reaches this limit to avoid a queue of outdated messages building up.";
  sendBufferLimitDescription.integer_range.resize(1);
  sendBufferLimitDescription.integer_range[0].from_value = 0;
  sendBufferLimitDescription.integer_range[0].to_value = std::numeric_limits<int64_t>::max();
  sendBufferLimitDescription.read_only = true;
  node->declare_parameter(PARAM_SEND_BUFFER_LIMIT, DEFAULT_SEND_BUFFER_LIMIT,
                          sendBufferLimitDescription);

  auto useTlsDescription = rcl_interfaces::msg::ParameterDescriptor{};
  useTlsDescription.name = PARAM_USETLS;
  useTlsDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  useTlsDescription.description = "Use Transport Layer Security for encrypted communication";
  useTlsDescription.read_only = true;
  node->declare_parameter(PARAM_USETLS, false, useTlsDescription);

  auto certfileDescription = rcl_interfaces::msg::ParameterDescriptor{};
  certfileDescription.name = PARAM_CERTFILE;
  certfileDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  certfileDescription.description = "Path to the certificate to use for TLS";
  certfileDescription.read_only = true;
  node->declare_parameter(PARAM_CERTFILE, "", certfileDescription);

  auto keyfileDescription = rcl_interfaces::msg::ParameterDescriptor{};
  keyfileDescription.name = PARAM_KEYFILE;
  keyfileDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  keyfileDescription.description = "Path to the private key to use for TLS";
  keyfileDescription.read_only = true;
  node->declare_parameter(PARAM_KEYFILE, "", keyfileDescription);

  auto minQosDepthDescription = rcl_interfaces::msg::ParameterDescriptor{};
  minQosDepthDescription.name = PARAM_MIN_QOS_DEPTH;
  minQosDepthDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  minQosDepthDescription.description = "Minimum depth used for the QoS profile of subscriptions.";
  minQosDepthDescription.read_only = true;
  minQosDepthDescription.additional_constraints = "Must be a non-negative integer";
  minQosDepthDescription.integer_range.resize(1);
  minQosDepthDescription.integer_range[0].from_value = 0;
  minQosDepthDescription.integer_range[0].to_value = INT32_MAX;
  minQosDepthDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_MIN_QOS_DEPTH, DEFAULT_MIN_QOS_DEPTH, minQosDepthDescription);

  auto maxQosDepthDescription = rcl_interfaces::msg::ParameterDescriptor{};
  maxQosDepthDescription.name = PARAM_MAX_QOS_DEPTH;
  maxQosDepthDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  maxQosDepthDescription.description = "Maximum depth used for the QoS profile of subscriptions.";
  maxQosDepthDescription.read_only = true;
  maxQosDepthDescription.additional_constraints = "Must be a non-negative integer";
  maxQosDepthDescription.integer_range.resize(1);
  maxQosDepthDescription.integer_range[0].from_value = 0;
  maxQosDepthDescription.integer_range[0].to_value = INT32_MAX;
  maxQosDepthDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_MAX_QOS_DEPTH, DEFAULT_MAX_QOS_DEPTH, maxQosDepthDescription);

  auto bestEffortQosTopicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  bestEffortQosTopicWhiteListDescription.name = PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST;
  bestEffortQosTopicWhiteListDescription.type =
    rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  bestEffortQosTopicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) for topics that should be forced to use "
    "'best_effort' QoS. Unmatched topics will use 'reliable' QoS if ALL publishers are 'reliable', "
    "'best_effort' if any publishers are 'best_effort'.";
  bestEffortQosTopicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST, std::vector<std::string>({"(?!)"}),
                          bestEffortQosTopicWhiteListDescription);

  auto topicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  topicWhiteListDescription.name = PARAM_TOPIC_WHITELIST;
  topicWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  topicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted topic names.";
  topicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_TOPIC_WHITELIST, std::vector<std::string>({".*"}),
                          topicWhiteListDescription);

  auto serviceWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  serviceWhiteListDescription.name = PARAM_SERVICE_WHITELIST;
  serviceWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  serviceWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted service names.";
  serviceWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_SERVICE_WHITELIST, std::vector<std::string>({".*"}),
                          serviceWhiteListDescription);

  auto paramWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  paramWhiteListDescription.name = PARAM_PARAMETER_WHITELIST;
  paramWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  paramWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted parameter names.";
  paramWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_PARAMETER_WHITELIST, std::vector<std::string>({".*"}),
                          paramWhiteListDescription);

  auto useCompressionDescription = rcl_interfaces::msg::ParameterDescriptor{};
  useCompressionDescription.name = PARAM_USE_COMPRESSION;
  useCompressionDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  useCompressionDescription.description =
    "Use websocket compression (permessage-deflate). Suited for connections with smaller bandwith, "
    "at the cost of additional CPU load.";
  useCompressionDescription.read_only = true;
  node->declare_parameter(PARAM_USE_COMPRESSION, false, useCompressionDescription);

  auto paramCapabilities = rcl_interfaces::msg::ParameterDescriptor{};
  paramCapabilities.name = PARAM_CAPABILITIES;
  paramCapabilities.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  paramCapabilities.description = "Server capabilities";
  paramCapabilities.read_only = true;
  node->declare_parameter(
    PARAM_CAPABILITIES,
    std::vector<std::string>(std::vector<std::string>(foxglove_ws::DEFAULT_CAPABILITIES.begin(),
                                                      foxglove_ws::DEFAULT_CAPABILITIES.end())),
    paramCapabilities);

  auto clientTopicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  clientTopicWhiteListDescription.name = PARAM_CLIENT_TOPIC_WHITELIST;
  clientTopicWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  clientTopicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted client-published topic names.";
  clientTopicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_CLIENT_TOPIC_WHITELIST, std::vector<std::string>({".*"}),
                          paramWhiteListDescription);

  auto includeHiddenDescription = rcl_interfaces::msg::ParameterDescriptor{};
  includeHiddenDescription.name = PARAM_INCLUDE_HIDDEN;
  includeHiddenDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  includeHiddenDescription.description = "Include hidden topics and services";
  includeHiddenDescription.read_only = true;
  node->declare_parameter(PARAM_INCLUDE_HIDDEN, false, includeHiddenDescription);

  auto disableLoanMessageDescription = rcl_interfaces::msg::ParameterDescriptor{};
  disableLoanMessageDescription.name = PARAM_DISABLE_LOAN_MESSAGE;
  disableLoanMessageDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  disableLoanMessageDescription.description =
    "Do not publish as loaned message when publishing a client message";
  disableLoanMessageDescription.read_only = true;
  node->declare_parameter(PARAM_DISABLE_LOAN_MESSAGE, true, disableLoanMessageDescription);

  auto assetUriAllowlistDescription = rcl_interfaces::msg::ParameterDescriptor{};
  assetUriAllowlistDescription.name = PARAM_ASSET_URI_ALLOWLIST;
  assetUriAllowlistDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  assetUriAllowlistDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted asset URIs.";
  assetUriAllowlistDescription.read_only = true;
  node->declare_parameter(
    PARAM_ASSET_URI_ALLOWLIST,
    std::vector<std::string>(
      {"^package://(?:[-\\w%]+/"
       ")*[-\\w%.]+\\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$"}),
    paramWhiteListDescription);

  auto ignUnresponsiveParamNodes = rcl_interfaces::msg::ParameterDescriptor{};
  ignUnresponsiveParamNodes.name = PARAM_IGN_UNRESPONSIVE_PARAM_NODES;
  ignUnresponsiveParamNodes.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  ignUnresponsiveParamNodes.description =
    "Avoid requesting parameters from previously unresponsive nodes";
  ignUnresponsiveParamNodes.read_only = true;
  node->declare_parameter(PARAM_IGN_UNRESPONSIVE_PARAM_NODES, true, ignUnresponsiveParamNodes);
}

std::vector<std::regex> parseRegexStrings(rclcpp::Node* node,
                                          const std::vector<std::string>& strings) {
  std::vector<std::regex> regexVector;
  regexVector.reserve(strings.size());

  for (const auto& pattern : strings) {
    try {
      regexVector.push_back(
        std::regex(pattern, std::regex_constants::ECMAScript | std::regex_constants::icase));
    } catch (const std::exception& ex) {
      RCLCPP_ERROR(node->get_logger(), "Ignoring invalid regular expression '%s': %s",
                   pattern.c_str(), ex.what());
    }
  }

  return regexVector;
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/src/parameter_interface.cpp
================================================
#include "foxglove_bridge/parameter_interface.hpp"

#include <nlohmann/json.hpp>
#include <rclcpp/qos.hpp>
#include <rclcpp/version.h>

#include <foxglove_bridge/regex_utils.hpp>
#include <foxglove_bridge/utils.hpp>

namespace {

constexpr char PARAM_SEP = '.';

#if RCLCPP_VERSION_MAJOR > 16
const rclcpp::ParametersQoS parameterQoS;
#else
const rmw_qos_profile_t& parameterQoS = rmw_qos_profile_parameters;
#endif

static std::pair<std::string, std::string> getNodeAndParamName(
  const std::string& nodeNameAndParamName) {
  return {nodeNameAndParamName.substr(0UL, nodeNameAndParamName.find(PARAM_SEP)),
          nodeNameAndParamName.substr(nodeNameAndParamName.find(PARAM_SEP) + 1UL)};
}

static std::string prependNodeNameToParamName(const std::string& paramName,
                                              const std::string& nodeName) {
  return nodeName + PARAM_SEP + paramName;
}

static rclcpp::Parameter toRosParam(const foxglove_ws::Parameter& p) {
  using foxglove_ws::Parameter;
  using foxglove_ws::ParameterType;

  const auto paramType = p.getType();
  const auto value = p.getValue();

  if (paramType == ParameterType::PARAMETER_BOOL) {
    return rclcpp::Parameter(p.getName(), value.getValue<bool>());
  } else if (paramType == ParameterType::PARAMETER_INTEGER) {
    return rclcpp::Parameter(p.getName(), value.getValue<int64_t>());
  } else if (paramType == ParameterType::PARAMETER_DOUBLE) {
    return rclcpp::Parameter(p.getName(), value.getValue<double>());
  } else if (paramType == ParameterType::PARAMETER_STRING) {
    return rclcpp::Parameter(p.getName(), value.getValue<std::string>());
  } else if (paramType == ParameterType::PARAMETER_BYTE_ARRAY) {
    return rclcpp::Parameter(p.getName(), value.getValue<std::vector<unsigned char>>());
  } else if (paramType == ParameterType::PARAMETER_ARRAY) {
    const auto paramVec = value.getValue<std::vector<foxglove_ws::ParameterValue>>();

    const auto elementType = paramVec.front().getType();
    if (elementType == ParameterType::PARAMETER_BOOL) {
      std::vector<bool> vec;
      for (const auto& paramValue : paramVec) {
        vec.push_back(paramValue.getValue<bool>());
      }
      return rclcpp::Parameter(p.getName(), vec);
    } else if (elementType == ParameterType::PARAMETER_INTEGER) {
      std::vector<int64_t> vec;
      for (const auto& paramValue : paramVec) {
        vec.push_back(paramValue.getValue<int64_t>());
      }
      return rclcpp::Parameter(p.getName(), vec);
    } else if (elementType == ParameterType::PARAMETER_DOUBLE) {
      std::vector<double> vec;
      for (const auto& paramValue : paramVec) {
        vec.push_back(paramValue.getValue<double>());
      }
      return rclcpp::Parameter(p.getName(), vec);
    } else if (elementType == ParameterType::PARAMETER_STRING) {
      std::vector<std::string> vec;
      for (const auto& paramValue : paramVec) {
        vec.push_back(paramValue.getValue<std::string>());
      }
      return rclcpp::Parameter(p.getName(), vec);
    }
    throw std::runtime_error("Unsupported parameter type");
  } else if (paramType == ParameterType::PARAMETER_NOT_SET) {
    return rclcpp::Parameter(p.getName());
  } else {
    throw std::runtime_error("Unsupported parameter type");
  }

  return rclcpp::Parameter();
}

static foxglove_ws::Parameter fromRosParam(const rclcpp::Parameter& p) {
  const auto type = p.get_type();

  if (type == rclcpp::ParameterType::PARAMETER_NOT_SET) {
    return foxglove_ws::Parameter(p.get_name(), foxglove_ws::ParameterValue());
  } else if (type == rclcpp::ParameterType::PARAMETER_BOOL) {
    return foxglove_ws::Parameter(p.get_name(), p.as_bool());
  } else if (type == rclcpp::ParameterType::PARAMETER_INTEGER) {
    return foxglove_ws::Parameter(p.get_name(), p.as_int());
  } else if (type == rclcpp::ParameterType::PARAMETER_DOUBLE) {
    return foxglove_ws::Parameter(p.get_name(), p.as_double());
  } else if (type == rclcpp::ParameterType::PARAMETER_STRING) {
    return foxglove_ws::Parameter(p.get_name(), p.as_string());
  } else if (type == rclcpp::ParameterType::PARAMETER_BYTE_ARRAY) {
    return foxglove_ws::Parameter(p.get_name(), p.as_byte_array());
  } else if (type == rclcpp::ParameterType::PARAMETER_BOOL_ARRAY) {
    std::vector<foxglove_ws::ParameterValue> paramVec;
    for (const auto value : p.as_bool_array()) {
      paramVec.push_back(foxglove_ws::ParameterValue(value));
    }
    return foxglove_ws::Parameter(p.get_name(), paramVec);
  } else if (type == rclcpp::ParameterType::PARAMETER_INTEGER_ARRAY) {
    std::vector<foxglove_ws::ParameterValue> paramVec;
    for (const auto value : p.as_integer_array()) {
      paramVec.push_back(value);
    }
    return foxglove_ws::Parameter(p.get_name(), paramVec);
  } else if (type == rclcpp::ParameterType::PARAMETER_DOUBLE_ARRAY) {
    std::vector<foxglove_ws::ParameterValue> paramVec;
    for (const auto value : p.as_double_array()) {
      paramVec.push_back(value);
    }
    return foxglove_ws::Parameter(p.get_name(), paramVec);
  } else if (type == rclcpp::ParameterType::PARAMETER_STRING_ARRAY) {
    std::vector<foxglove_ws::ParameterValue> paramVec;
    for (const auto& value : p.as_string_array()) {
      paramVec.push_back(value);
    }
    return foxglove_ws::Parameter(p.get_name(), paramVec);
  } else {
    throw std::runtime_error("Unsupported parameter type");
  }
}

}  // namespace

namespace foxglove_bridge {

using foxglove_ws::isWhitelisted;

ParameterInterface::ParameterInterface(rclcpp::Node* node,
                                       std::vector<std::regex> paramWhitelistPatterns,
                                       UnresponsiveNodePolicy unresponsiveNodePolicy)
    : _node(node)
    , _paramWhitelistPatterns(paramWhitelistPatterns)
    , _callbackGroup(node->create_callback_group(rclcpp::CallbackGroupType::Reentrant))
    , _ignoredNodeNames({node->get_fully_qualified_name()})
    , _unresponsiveNodePolicy(unresponsiveNodePolicy) {}

ParameterList ParameterInterface::getParams(const std::vector<std::string>& paramNames,
                                            const std::chrono::duration<double>& timeout) {
  std::lock_guard<std::mutex> lock(_mutex);

  std::unordered_map<std::string, std::vector<std::string>> paramNamesByNodeName;
  const auto thisNode = _node->get_fully_qualified_name();

  if (!paramNames.empty()) {
    // Break apart fully qualified {node_name}.{param_name} strings and build a
    // mape of node names to the list of parameters for each node
    for (const auto& fullParamName : paramNames) {
      const auto& [nodeName, paramName] = getNodeAndParamName(fullParamName);
      paramNamesByNodeName[nodeName].push_back(paramName);
    }

    RCLCPP_DEBUG(_node->get_logger(), "Getting %zu parameters from %zu nodes...", paramNames.size(),
                 paramNamesByNodeName.size());
  } else {
    // Make a map of node names to empty parameter lists
    // Only consider nodes that offer services to list & get parameters.
    for (const auto& fqnNodeName : _node->get_node_names()) {
      if (_ignoredNodeNames.find(fqnNodeName) != _ignoredNodeNames.end()) {
        continue;
      }
      const auto [nodeNs, nodeName] = getNodeAndNodeNamespace(fqnNodeName);
      const auto serviceNamesAndTypes =
        _node->get_service_names_and_types_by_node(nodeName, nodeNs);

      bool listParamsSrvFound = false, getParamsSrvFound = false;
      for (const auto& [serviceName, serviceTypes] : serviceNamesAndTypes) {
        constexpr char GET_PARAMS_SERVICE_TYPE[] = "rcl_interfaces/srv/GetParameters";
        constexpr char LIST_PARAMS_SERVICE_TYPE[] = "rcl_interfaces/srv/ListParameters";

        if (!getParamsSrvFound) {
          getParamsSrvFound = std::find(serviceTypes.begin(), serviceTypes.end(),
                                        GET_PARAMS_SERVICE_TYPE) != serviceTypes.end();
        }
        if (!listParamsSrvFound) {
          listParamsSrvFound = std::find(serviceTypes.begin(), serviceTypes.end(),
                                         LIST_PARAMS_SERVICE_TYPE) != serviceTypes.end();
        }
      }

      if (listParamsSrvFound && getParamsSrvFound) {
        paramNamesByNodeName.insert({fqnNodeName, {}});
      }
    }

    if (!paramNamesByNodeName.empty()) {
      RCLCPP_DEBUG(_node->get_logger(), "Getting all parameters from %zu nodes...",
                   paramNamesByNodeName.size());
    }
  }

  std::unordered_map<std::string, std::future<ParameterList>> getParametersFuture;
  for (const auto& [nodeName, nodeParamNames] : paramNamesByNodeName) {
    if (nodeName == thisNode) {
      continue;
    }

    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    getParametersFuture.emplace(
      nodeName, std::async(std::launch::async, &ParameterInterface::getNodeParameters, this,
                           paramClientIt->second, nodeName, nodeParamNames, timeout));
  }

  ParameterList result;
  for (auto& [nodeName, future] : getParametersFuture) {
    try {
      const auto params = future.get();
      result.insert(result.begin(), params.begin(), params.end());
    } catch (const std::exception& e) {
      RCLCPP_ERROR(_node->get_logger(), "Failed to retrieve parameters from node '%s': %s",
                   nodeName.c_str(), e.what());

      if (_unresponsiveNodePolicy == UnresponsiveNodePolicy::Ignore) {
        // Certain nodes may fail to handle incoming service requests — for example, if they're
        // stuck in a busy loop or otherwise unresponsive. In such cases, attempting to retrieve
        // parameter names or values can result in timeouts. To avoid repeated failures, these nodes
        // are added to an ignore list, and future parameter-related service calls to them will be
        // skipped.
        _ignoredNodeNames.insert(nodeName);
        RCLCPP_WARN(_node->get_logger(),
                    "Adding node %s to the ignore list to prevent repeated timeouts or failures in "
                    "future parameter requests.",
                    nodeName.c_str());
      }
    }
  }

  return result;
}

void ParameterInterface::setParams(const ParameterList& parameters,
                                   const std::chrono::duration<double>& timeout) {
  std::lock_guard<std::mutex> lock(_mutex);

  rclcpp::ParameterMap paramsByNode;
  for (const auto& param : parameters) {
    if (!isWhitelisted(param.getName(), _paramWhitelistPatterns)) {
      return;
    }

    const auto rosParam = toRosParam(param);
    const auto& [nodeName, paramName] = getNodeAndParamName(rosParam.get_name());
    paramsByNode[nodeName].emplace_back(paramName, rosParam.get_parameter_value());
  }

  std::vector<std::future<void>> setParametersFuture;
  for (const auto& [nodeName, params] : paramsByNode) {
    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    setParametersFuture.emplace_back(std::async(std::launch::async,
                                                &ParameterInterface::setNodeParameters, this,
                                                paramClientIt->second, nodeName, params, timeout));
  }

  for (auto& future : setParametersFuture) {
    try {
      future.get();
    } catch (const std::exception& e) {
      RCLCPP_ERROR(_node->get_logger(), "Exception when setting parameters: %s", e.what());
    }
  }
}

void ParameterInterface::subscribeParams(const std::vector<std::string>& paramNames) {
  std::lock_guard<std::mutex> lock(_mutex);

  std::unordered_set<std::string> nodesToSubscribe;
  for (const auto& paramName : paramNames) {
    if (!isWhitelisted(paramName, _paramWhitelistPatterns)) {
      return;
    }

    const auto& [nodeName, paramN] = getNodeAndParamName(paramName);
    auto [subscribedParamsit, wasNewlyCreated] = _subscribedParamsByNode.try_emplace(nodeName);

    auto& subscribedNodeParams = subscribedParamsit->second;
    subscribedNodeParams.insert(paramN);

    if (wasNewlyCreated) {
      nodesToSubscribe.insert(nodeName);
    }
  }

  for (const auto& nodeName : nodesToSubscribe) {
    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    auto& paramClient = paramClientIt->second;

    _paramSubscriptionsByNode[nodeName] = paramClient->on_parameter_event(
      [this, nodeName](rcl_interfaces::msg::ParameterEvent::ConstSharedPtr msg) {
        RCLCPP_DEBUG(_node->get_logger(), "Retrieved param update for node %s: %zu params changed",
                     nodeName.c_str(), msg->changed_parameters.size());

        ParameterList result;
        const auto& subscribedNodeParams = _subscribedParamsByNode[nodeName];
        for (const auto& param : msg->changed_parameters) {
          if (subscribedNodeParams.find(param.name) != subscribedNodeParams.end()) {
            result.push_back(fromRosParam(
              rclcpp::Parameter(prependNodeNameToParamName(param.name, nodeName), param.value)));
          }
        }

        if (!result.empty() && _paramUpdateFunc) {
          _paramUpdateFunc(result);
        }
      });
  }
}

void ParameterInterface::unsubscribeParams(const std::vector<std::string>& paramNames) {
  std::lock_guard<std::mutex> lock(_mutex);

  for (const auto& paramName : paramNames) {
    const auto& [nodeName, paramN] = getNodeAndParamName(paramName);

    const auto subscribedNodeParamsIt = _subscribedParamsByNode.find(nodeName);
    if (subscribedNodeParamsIt != _subscribedParamsByNode.end()) {
      subscribedNodeParamsIt->second.erase(subscribedNodeParamsIt->second.find(paramN));

      if (subscribedNodeParamsIt->second.empty()) {
        _subscribedParamsByNode.erase(subscribedNodeParamsIt);
        _paramSubscriptionsByNode.erase(_paramSubscriptionsByNode.find(nodeName));
      }
    }
  }
}

void ParameterInterface::setParamUpdateCallback(ParamUpdateFunc paramUpdateFunc) {
  std::lock_guard<std::mutex> lock(_mutex);
  _paramUpdateFunc = paramUpdateFunc;
}

ParameterList ParameterInterface::getNodeParameters(
  const rclcpp::AsyncParametersClient::SharedPtr paramClient, const std::string& nodeName,
  const std::vector<std::string>& paramNames, const std::chrono::duration<double>& timeout) {
  if (!paramClient->service_is_ready()) {
    throw std::runtime_error("Parameter service for node '" + nodeName + "' is not ready");
  }

  auto paramsToRequest = paramNames;
  if (paramsToRequest.empty()) {
    // `paramNames` is empty, list all parameter names for this node
    auto future = paramClient->list_parameters({}, 0UL);
    if (std::future_status::ready != future.wait_for(timeout)) {
      throw std::runtime_error("Failed to retrieve parameter names for node '" + nodeName + "'");
    }
    paramsToRequest = future.get().names;
  }

  // Start parameter fetches and wait for them to complete
  auto getParamsFuture = paramClient->get_parameters(paramsToRequest);
  if (std::future_status::ready != getParamsFuture.wait_for(timeout)) {
    throw std::runtime_error("Timed out waiting for " + std::to_string(paramsToRequest.size()) +
                             " parameter(s) from node '" + nodeName + "'");
  }
  const auto params = getParamsFuture.get();

  ParameterList result;
  for (const auto& param : params) {
    const auto fullParamName = prependNodeNameToParamName(param.get_name(), nodeName);
    if (isWhitelisted(fullParamName, _paramWhitelistPatterns)) {
      result.push_back(fromRosParam(rclcpp::Parameter(fullParamName, param.get_parameter_value())));
    }
  }
  return result;
}

void ParameterInterface::setNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                                           const std::string& nodeName,
                                           const std::vector<rclcpp::Parameter>& params,
                                           const std::chrono::duration<double>& timeout) {
  if (!paramClient->service_is_ready()) {
    throw std::runtime_error("Parameter service for node '" + nodeName + "' is not ready");
  }

  auto future = paramClient->set_parameters(params);

  std::vector<std::string> paramsToDelete;
  for (const auto& p : params) {
    if (p.get_type() == rclcpp::ParameterType::PARAMETER_NOT_SET) {
      paramsToDelete.push_back(p.get_name());
    }
  }

  if (!paramsToDelete.empty()) {
    auto deleteFuture = paramClient->delete_parameters(paramsToDelete);
    if (std::future_status::ready != deleteFuture.wait_for(timeout)) {
      RCLCPP_WARN(
        _node->get_logger(),
        "Param client failed to delete %zu parameter(s) for node '%s' within the given timeout",
        paramsToDelete.size(), nodeName.c_str());
    }
  }

  if (std::future_status::ready != future.wait_for(timeout)) {
    throw std::runtime_error("Param client failed to set " + std::to_string(params.size()) +
                             " parameter(s) for node '" + nodeName + "' within the given timeout");
  }

  const auto setParamResults = future.get();
  for (auto& result : setParamResults) {
    if (!result.successful) {
      RCLCPP_WARN(_node->get_logger(), "Failed to set one or more parameters for node '%s': %s",
                  nodeName.c_str(), result.reason.c_str());
    }
  }
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge/src/ros2_foxglove_bridge.cpp
================================================
#include <unordered_set>

#include <resource_retriever/retriever.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>

namespace foxglove_bridge {
namespace {
inline bool isHiddenTopicOrService(const std::string& name) {
  if (name.empty()) {
    throw std::invalid_argument("Topic or service name can't be empty");
  }
  return name.front() == '_' || name.find("/_") != std::string::npos;
}
}  // namespace

using namespace std::chrono_literals;
using namespace std::placeholders;
using foxglove_ws::isWhitelisted;

FoxgloveBridge::FoxgloveBridge(const rclcpp::NodeOptions& options)
    : Node("foxglove_bridge", options) {
  const char* rosDistro = std::getenv("ROS_DISTRO");
  RCLCPP_INFO(this->get_logger(), "Starting foxglove_bridge (%s, %s@%s) with %s", rosDistro,
              foxglove::FOXGLOVE_BRIDGE_VERSION, foxglove::FOXGLOVE_BRIDGE_GIT_HASH,
              foxglove::WebSocketUserAgent());

  declareParameters(this);

  const auto port = static_cast<uint16_t>(this->get_parameter(PARAM_PORT).as_int());
  const auto address = this->get_parameter(PARAM_ADDRESS).as_string();
  const auto send_buffer_limit =
    static_cast<size_t>(this->get_parameter(PARAM_SEND_BUFFER_LIMIT).as_int());
  const auto useTLS = this->get_parameter(PARAM_USETLS).as_bool();
  const auto certfile = this->get_parameter(PARAM_CERTFILE).as_string();
  const auto keyfile = this->get_parameter(PARAM_KEYFILE).as_string();
  _minQosDepth = static_cast<size_t>(this->get_parameter(PARAM_MIN_QOS_DEPTH).as_int());
  _maxQosDepth = static_cast<size_t>(this->get_parameter(PARAM_MAX_QOS_DEPTH).as_int());
  const auto bestEffortQosTopicWhiteList =
    this->get_parameter(PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST).as_string_array();
  _bestEffortQosTopicWhiteListPatterns = parseRegexStrings(this, bestEffortQosTopicWhiteList);
  const auto topicWhiteList = this->get_parameter(PARAM_TOPIC_WHITELIST).as_string_array();
  _topicWhitelistPatterns = parseRegexStrings(this, topicWhiteList);
  const auto serviceWhiteList = this->get_parameter(PARAM_SERVICE_WHITELIST).as_string_array();
  _serviceWhitelistPatterns = parseRegexStrings(this, serviceWhiteList);
  const auto paramWhiteList = this->get_parameter(PARAM_PARAMETER_WHITELIST).as_string_array();
  const auto paramWhitelistPatterns = parseRegexStrings(this, paramWhiteList);
  const auto useCompression = this->get_parameter(PARAM_USE_COMPRESSION).as_bool();
  _useSimTime = this->get_parameter("use_sim_time").as_bool();
  _capabilities = this->get_parameter(PARAM_CAPABILITIES).as_string_array();
  const auto clientTopicWhiteList =
    this->get_parameter(PARAM_CLIENT_TOPIC_WHITELIST).as_string_array();
  const auto clientTopicWhiteListPatterns = parseRegexStrings(this, clientTopicWhiteList);
  _includeHidden = this->get_parameter(PARAM_INCLUDE_HIDDEN).as_bool();
  const auto assetUriAllowlist = this->get_parameter(PARAM_ASSET_URI_ALLOWLIST).as_string_array();
  _assetUriAllowlistPatterns = parseRegexStrings(this, assetUriAllowlist);
  _disableLoanMessage = this->get_parameter(PARAM_DISABLE_LOAN_MESSAGE).as_bool();
  const auto ignoreUnresponsiveParamNodes =
    this->get_parameter(PARAM_IGN_UNRESPONSIVE_PARAM_NODES).as_bool();

  const auto logHandler = std::bind(&FoxgloveBridge::logHandler, this, _1, _2);
  // Fetching of assets may be blocking, hence we fetch them in a separate thread.
  _fetchAssetQueue = std::make_unique<foxglove_ws::CallbackQueue>(logHandler, 1 /* num_threads */);

  foxglove_ws::ServerOptions serverOptions;
  serverOptions.capabilities = _capabilities;
  if (_useSimTime) {
    serverOptions.capabilities.push_back(foxglove_ws::CAPABILITY_TIME);
  }
  serverOptions.supportedEncodings = {"cdr", "json"};
  serverOptions.metadata = {{"ROS_DISTRO", rosDistro}};
  serverOptions.sendBufferLimitBytes = send_buffer_limit;
  serverOptions.sessionId = std::to_string(std::time(nullptr));
  serverOptions.useCompression = useCompression;
  serverOptions.useTls = useTLS;
  serverOptions.certfile = certfile;
  serverOptions.keyfile = keyfile;
  serverOptions.clientTopicWhitelistPatterns = clientTopicWhiteListPatterns;

  _server = foxglove_ws::ServerFactory::createServer<ConnectionHandle>("foxglove_bridge",
                                                                       logHandler, serverOptions);

  foxglove_ws::ServerHandlers<ConnectionHandle> hdlrs;
  hdlrs.subscribeHandler = std::bind(&FoxgloveBridge::subscribe, this, _1, _2);
  hdlrs.unsubscribeHandler = std::bind(&FoxgloveBridge::unsubscribe, this, _1, _2);
  hdlrs.clientAdvertiseHandler = std::bind(&FoxgloveBridge::clientAdvertise, this, _1, _2);
  hdlrs.clientUnadvertiseHandler = std::bind(&FoxgloveBridge::clientUnadvertise, this, _1, _2);
  hdlrs.clientMessageHandler = std::bind(&FoxgloveBridge::clientMessage, this, _1, _2);
  hdlrs.serviceRequestHandler = std::bind(&FoxgloveBridge::serviceRequest, this, _1, _2);
  hdlrs.subscribeConnectionGraphHandler =
    std::bind(&FoxgloveBridge::subscribeConnectionGraph, this, _1);

  if (hasCapability(foxglove_ws::CAPABILITY_PARAMETERS) ||
      hasCapability(foxglove_ws::CAPABILITY_PARAMETERS_SUBSCRIBE)) {
    hdlrs.parameterRequestHandler = std::bind(&FoxgloveBridge::getParameters, this, _1, _2, _3);
    hdlrs.parameterChangeHandler = std::bind(&FoxgloveBridge::setParameters, this, _1, _2, _3);
    hdlrs.parameterSubscriptionHandler =
      std::bind(&FoxgloveBridge::subscribeParameters, this, _1, _2, _3);

    _paramInterface = std::make_shared<ParameterInterface>(this, paramWhitelistPatterns,
                                                           ignoreUnresponsiveParamNodes
                                                             ? UnresponsiveNodePolicy::Ignore
                                                             : UnresponsiveNodePolicy::Retry);
    _paramInterface->setParamUpdateCallback(std::bind(&FoxgloveBridge::parameterUpdates, this, _1));
  }

  if (hasCapability(foxglove_ws::CAPABILITY_ASSETS)) {
    hdlrs.fetchAssetHandler = [this](const std::string& uri, uint32_t requestId,
                                     ConnectionHandle hdl) {
      _fetchAssetQueue->addCallback(
        std::bind(&FoxgloveBridge::fetchAsset, this, uri, requestId, hdl));
    };
  }

  _server->setHandlers(std::move(hdlrs));
  _server->start(address, port);

  // Get the actual port we bound to
  uint16_t listeningPort = _server->getPort();
  if (port != listeningPort) {
    RCLCPP_DEBUG(this->get_logger(), "Reassigning \"port\" parameter from %d to %d", port,
                 listeningPort);
    this->set_parameter(rclcpp::Parameter{PARAM_PORT, listeningPort});
  }

  // Start the thread polling for rosgraph changes
  _rosgraphPollThread =
    std::make_unique<std::thread>(std::bind(&FoxgloveBridge::rosgraphPollThread, this));

  _subscriptionCallbackGroup = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);
  _clientPublishCallbackGroup =
    this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
  _servicesCallbackGroup = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);

  if (_useSimTime) {
    _clockSubscription = this->create_subscription<rosgraph_msgs::msg::Clock>(
      "/clock", rclcpp::QoS{rclcpp::KeepLast(1)}.best_effort(),
      [&](std::shared_ptr<const rosgraph_msgs::msg::Clock> msg) {
        const auto timestamp = rclcpp::Time{msg->clock}.nanoseconds();
        assert(timestamp >= 0 && "Timestamp is negative");
        _server->broadcastTime(static_cast<uint64_t>(timestamp));
      });
  }
}

FoxgloveBridge::~FoxgloveBridge() {
  _shuttingDown = true;
  RCLCPP_INFO(this->get_logger(), "Shutting down %s", this->get_name());
  if (_rosgraphPollThread) {
    _rosgraphPollThread->join();
  }
  _server->stop();
  RCLCPP_INFO(this->get_logger(), "Shutdown complete");
}

void FoxgloveBridge::rosgraphPollThread() {
  updateAdvertisedTopics(get_topic_names_and_types());
  updateAdvertisedServices();

  auto graphEvent = this->get_graph_event();
  while (!_shuttingDown && rclcpp::ok()) {
    try {
      this->wait_for_graph_change(graphEvent, 200ms);
      bool triggered = graphEvent->check_and_clear();
      if (triggered) {
        RCLCPP_DEBUG(this->get_logger(), "rosgraph change detected");
        const auto topicNamesAndTypes = get_topic_names_and_types();
        updateAdvertisedTopics(topicNamesAndTypes);
        updateAdvertisedServices();
        if (_subscribeGraphUpdates) {
          updateConnectionGraph(topicNamesAndTypes);
        }
        // Graph changes tend to come in batches, so wait a bit before checking again
        std::this_thread::sleep_for(500ms);
      }
    } catch (const std::exception& ex) {
      RCLCPP_ERROR(this->get_logger(), "Exception thrown in rosgraphPollThread: %s", ex.what());
    }
  }

  RCLCPP_DEBUG(this->get_logger(), "rosgraph polling thread exiting");
}

void FoxgloveBridge::updateAdvertisedTopics(
  const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes) {
  if (!rclcpp::ok()) {
    return;
  }

  std::unordered_set<TopicAndDatatype, PairHash> latestTopics;
  latestTopics.reserve(topicNamesAndTypes.size());
  for (const auto& topicNamesAndType : topicNamesAndTypes) {
    const auto& topicName = topicNamesAndType.first;
    const auto& datatypes = topicNamesAndType.second;

    // Ignore hidden topics if not explicitly included
    if (!_includeHidden && isHiddenTopicOrService(topicName)) {
      continue;
    }

    // Ignore the topic if it is not on the topic whitelist
    if (isWhitelisted(topicName, _topicWhitelistPatterns)) {
      for (const auto& datatype : datatypes) {
        latestTopics.emplace(topicName, datatype);
      }
    }
  }

  if (const auto numIgnoredTopics = topicNamesAndTypes.size() - latestTopics.size()) {
    RCLCPP_DEBUG(
      this->get_logger(),
      "%zu topics have been ignored as they do not match any pattern on the topic whitelist",
      numIgnoredTopics);
  }

  std::lock_guard<std::mutex> lock(_subscriptionsMutex);

  // Remove channels for which the topic does not exist anymore
  std::vector<foxglove_ws::ChannelId> channelIdsToRemove;
  for (auto channelIt = _advertisedTopics.begin(); channelIt != _advertisedTopics.end();) {
    const TopicAndDatatype topicAndDatatype = {channelIt->second.topic,
                                               channelIt->second.schemaName};
    if (latestTopics.find(topicAndDatatype) == latestTopics.end()) {
      const auto channelId = channelIt->first;
      channelIdsToRemove.push_back(channelId);
      _subscriptions.erase(channelId);
      RCLCPP_INFO(this->get_logger(), "Removed channel %d for topic \"%s\" (%s)", channelId,
                  topicAndDatatype.first.c_str(), topicAndDatatype.second.c_str());
      channelIt = _advertisedTopics.erase(channelIt);
    } else {
      channelIt++;
    }
  }
  _server->removeChannels(channelIdsToRemove);

  // Add new channels for new topics
  std::vector<foxglove_ws::ChannelWithoutId> channelsToAdd;
  for (const auto& topicAndDatatype : latestTopics) {
    if (std::find_if(_advertisedTopics.begin(), _advertisedTopics.end(),
                     [topicAndDatatype](const auto& channelIdAndChannel) {
                       const auto& channel = channelIdAndChannel.second;
                       return channel.topic == topicAndDatatype.first &&
                              channel.schemaName == topicAndDatatype.second;
                     }) != _advertisedTopics.end()) {
      continue;  // Topic already advertised
    }

    foxglove_ws::ChannelWithoutId newChannel{};
    newChannel.topic = topicAndDatatype.first;
    newChannel.schemaName = topicAndDatatype.second;

    try {
      auto [format, schema] = _messageDefinitionCache.get_full_text(topicAndDatatype.second);
      switch (format) {
        case foxglove::MessageDefinitionFormat::MSG:
          newChannel.encoding = "cdr";
          newChannel.schema = schema;
          newChannel.schemaEncoding = "ros2msg";
          break;
        case foxglove::MessageDefinitionFormat::IDL:
          newChannel.encoding = "cdr";
          newChannel.schema = schema;
          newChannel.schemaEncoding = "ros2idl";
          break;
      }

    } catch (const foxglove::DefinitionNotFoundError& err) {
      RCLCPP_WARN(this->get_logger(), "Could not find definition for type %s: %s",
                  topicAndDatatype.second.c_str(), err.what());
      // We still advertise the channel, but with an emtpy schema
      newChannel.schema = "";
    } catch (const std::exception& err) {
      RCLCPP_WARN(this->get_logger(), "Failed to add channel for topic \"%s\" (%s): %s",
                  topicAndDatatype.first.c_str(), topicAndDatatype.second.c_str(), err.what());
      continue;
    }
    channelsToAdd.push_back(newChannel);
  }

  const auto channelIds = _server->addChannels(channelsToAdd);
  for (size_t i = 0; i < channelsToAdd.size(); ++i) {
    const auto channelId = channelIds[i];
    const auto& channel = channelsToAdd[i];
    _advertisedTopics.emplace(channelId, channel);
    RCLCPP_DEBUG(this->get_logger(), "Advertising channel %d for topic \"%s\" (%s)", channelId,
                 channel.topic.c_str(), channel.schemaName.c_str());
  }
}

void FoxgloveBridge::updateAdvertisedServices() {
  if (!rclcpp::ok()) {
    return;
  } else if (!hasCapability(foxglove_ws::CAPABILITY_SERVICES)) {
    return;
  }

  // Get the current list of visible services and datatypes from the ROS graph
  const auto serviceNamesAndTypes = this->get_node_graph_interface()->get_service_names_and_types();

  std::lock_guard<std::mutex> lock(_servicesMutex);

  // Remove advertisements for services that have been removed
  std::vector<foxglove_ws::ServiceId> servicesToRemove;
  for (const auto& service : _advertisedServices) {
    const auto it = std::find_if(serviceNamesAndTypes.begin(), serviceNamesAndTypes.end(),
                                 [service](const auto& serviceNameAndTypes) {
                                   return serviceNameAndTypes.first == service.second.name;
                                 });
    if (it == serviceNamesAndTypes.end()) {
      servicesToRemove.push_back(service.first);
    }
  }
  for (auto serviceId : servicesToRemove) {
    _advertisedServices.erase(serviceId);
  }
  _server->removeServices(servicesToRemove);

  // Advertise new services
  std::vector<foxglove_ws::ServiceWithoutId> newServices;
  for (const auto& serviceNamesAndType : serviceNamesAndTypes) {
    const auto& serviceName = serviceNamesAndType.first;
    const auto& datatypes = serviceNamesAndType.second;

    // Ignore the service if it's already advertised
    if (std::find_if(_advertisedServices.begin(), _advertisedServices.end(),
                     [serviceName](const auto& idWithService) {
                       return idWithService.second.name == serviceName;
                     }) != _advertisedServices.end()) {
      continue;
    }

    // Ignore hidden services if not explicitly included
    if (!_includeHidden && isHiddenTopicOrService(serviceName)) {
      continue;
    }

    // Ignore the service if it is not on the service whitelist
    if (!isWhitelisted(serviceName, _serviceWhitelistPatterns)) {
      continue;
    }

    foxglove_ws::ServiceWithoutId service;
    service.name = serviceName;
    service.type = datatypes.front();

    try {
      const auto requestTypeName = service.type + foxglove::SERVICE_REQUEST_MESSAGE_SUFFIX;
      const auto responseTypeName = service.type + foxglove::SERVICE_RESPONSE_MESSAGE_SUFFIX;
      const auto [format, reqSchema] = _messageDefinitionCache.get_full_text(requestTypeName);
      const auto resSchema = _messageDefinitionCache.get_full_text(responseTypeName).second;
      switch (format) {
        case foxglove::MessageDefinitionFormat::MSG:
          service.requestSchema = reqSchema;
          service.responseSchema = resSchema;
          break;
        case foxglove::MessageDefinitionFormat::IDL:
          RCLCPP_WARN(this->get_logger(),
                      "IDL message definition format cannot be communicated over ws-protocol. "
                      "Service \"%s\" (%s) may not decode correctly in clients",
                      service.name.c_str(), service.type.c_str());
          service.requestSchema = reqSchema;
          service.responseSchema = resSchema;
          break;
      }
    } catch (const foxglove::DefinitionNotFoundError& err) {
      RCLCPP_WARN(this->get_logger(), "Could not find definition for type %s: %s",
                  service.type.c_str(), err.what());
      // We still advertise the service, but with an emtpy schema
      service.requestSchema = "";
      service.responseSchema = "";
    } catch (const std::exception& err) {
      RCLCPP_WARN(this->get_logger(), "Failed to add service \"%s\" (%s): %s", service.name.c_str(),
                  service.type.c_str(), err.what());
      continue;
    }

    newServices.push_back(service);
  }

  const auto serviceIds = _server->addServices(newServices);
  for (size_t i = 0; i < serviceIds.size(); ++i) {
    _advertisedServices.emplace(serviceIds[i], newServices[i]);
  }
}

void FoxgloveBridge::updateConnectionGraph(
  const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes) {
  foxglove_ws::MapOfSets publishers, subscribers;

  for (const auto& topicNameAndType : topicNamesAndTypes) {
    const auto& topicName = topicNameAndType.first;
    if (!isWhitelisted(topicName, _topicWhitelistPatterns)) {
      continue;
    }

    const auto publishersInfo = get_publishers_info_by_topic(topicName);
    const auto subscribersInfo = get_subscriptions_info_by_topic(topicName);
    std::unordered_set<std::string> publisherIds, subscriberIds;
    for (const auto& publisher : publishersInfo) {
      const auto& ns = publisher.node_namespace();
      const auto sep = (!ns.empty() && ns.back() == '/') ? "" : "/";
      publisherIds.insert(ns + sep + publisher.node_name());
    }
    for (const auto& subscriber : subscribersInfo) {
      const auto& ns = subscriber.node_namespace();
      const auto sep = (!ns.empty() && ns.back() == '/') ? "" : "/";
      subscriberIds.insert(ns + sep + subscriber.node_name());
    }
    publishers.emplace(topicName, publisherIds);
    subscribers.emplace(topicName, subscriberIds);
  }

  foxglove_ws::MapOfSets services;
  for (const auto& fqnNodeName : get_node_names()) {
    const auto [nodeNs, nodeName] = getNodeAndNodeNamespace(fqnNodeName);
    const auto serviceNamesAndTypes = get_service_names_and_types_by_node(nodeName, nodeNs);

    for (const auto& [serviceName, serviceTypes] : serviceNamesAndTypes) {
      (void)serviceTypes;
      if (isWhitelisted(serviceName, _serviceWhitelistPatterns)) {
        services[serviceName].insert(fqnNodeName);
      }
    }
  }

  _server->updateConnectionGraph(publishers, subscribers, services);
}

void FoxgloveBridge::subscribeConnectionGraph(bool subscribe) {
  if ((_subscribeGraphUpdates = subscribe)) {
    updateConnectionGraph(get_topic_names_and_types());
  };
}

void FoxgloveBridge::subscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle) {
  std::lock_guard<std::mutex> lock(_subscriptionsMutex);
  auto it = _advertisedTopics.find(channelId);
  if (it == _advertisedTopics.end()) {
    throw foxglove_ws::ChannelError(
      channelId, "Received subscribe request for unknown channel " + std::to_string(channelId));
  }

  const auto& channel = it->second;
  const auto& topic = channel.topic;
  const auto& datatype = channel.schemaName;

  // Get client subscriptions for this channel or insert an empty map.
  auto [subscriptionsIt, firstSubscription] =
    _subscriptions.emplace(channelId, SubscriptionsByClient());
  auto& subscriptionsByClient = subscriptionsIt->second;

  if (!firstSubscription &&
      subscriptionsByClient.find(clientHandle) != subscriptionsByClient.end()) {
    throw foxglove_ws::ChannelError(
      channelId, "Client is already subscribed to channel " + std::to_string(channelId));
  }

  rclcpp::SubscriptionEventCallbacks eventCallbacks;
  eventCallbacks.incompatible_qos_callback = [&](const rclcpp::QOSRequestedIncompatibleQoSInfo&) {
    RCLCPP_ERROR(this->get_logger(), "Incompatible subscriber QoS settings for topic \"%s\" (%s)",
                 topic.c_str(), datatype.c_str());
  };

  rclcpp::SubscriptionOptions subscriptionOptions;
  subscriptionOptions.event_callbacks = eventCallbacks;
  subscriptionOptions.callback_group = _subscriptionCallbackGroup;

  // Select an appropriate subscription QOS profile. This is similar to how ros2 topic echo
  // does it:
  // https://github.com/ros2/ros2cli/blob/619b3d1c9/ros2topic/ros2topic/verb/echo.py#L137-L194
  size_t depth = 0;
  size_t reliabilityReliableEndpointsCount = 0;
  size_t durabilityTransientLocalEndpointsCount = 0;

  const auto publisherInfo = this->get_publishers_info_by_topic(topic);
  for (const auto& publisher : publisherInfo) {
    const auto& qos = publisher.qos_profile();
    if (qos.reliability() == rclcpp::ReliabilityPolicy::Reliable) {
      ++reliabilityReliableEndpointsCount;
    }
    if (qos.durability() == rclcpp::DurabilityPolicy::TransientLocal) {
      ++durabilityTransientLocalEndpointsCount;
    }
    // Some RMWs do not retrieve history information of the publisher endpoint in which case the
    // history depth is 0. We use a lower limit of 1 here, so that the history depth is at least
    // equal to the number of publishers. This covers the case where there are multiple
    // transient_local publishers with a depth of 1 (e.g. multiple tf_static transform
    // broadcasters). See also
    // https://github.com/foxglove/ros-foxglove-bridge/issues/238 and
    // https://github.com/foxglove/ros-foxglove-bridge/issues/208
    const size_t publisherHistoryDepth = std::max(static_cast<size_t>(1), qos.depth());
    depth = depth + publisherHistoryDepth;
  }

  depth = std::max(depth, _minQosDepth);
  if (depth > _maxQosDepth) {
    RCLCPP_WARN(this->get_logger(),
                "Limiting history depth for topic '%s' to %zu (was %zu). You may want to increase "
                "the max_qos_depth parameter value.",
                topic.c_str(), _maxQosDepth, depth);
    depth = _maxQosDepth;
  }

  rclcpp::QoS qos{rclcpp::KeepLast(depth)};

  // Force the QoS to be "best_effort" if in the whitelist
  if (isWhitelisted(topic, _bestEffortQosTopicWhiteListPatterns)) {
    qos.best_effort();
  } else if (!publisherInfo.empty() && reliabilityReliableEndpointsCount == publisherInfo.size()) {
    // If all endpoints are reliable, ask for reliable
    qos.reliable();
  } else {
    if (reliabilityReliableEndpointsCount > 0) {
      RCLCPP_WARN(
        this->get_logger(),
        "Some, but not all, publishers on topic '%s' are offering QoSReliabilityPolicy.RELIABLE. "
        "Falling back to QoSReliabilityPolicy.BEST_EFFORT as it will connect to all publishers",
        topic.c_str());
    }
    qos.best_effort();
  }

  // If all endpoints are transient_local, ask for transient_local
  if (!publisherInfo.empty() && durabilityTransientLocalEndpointsCount == publisherInfo.size()) {
    qos.transient_local();
  } else {
    if (durabilityTransientLocalEndpointsCount > 0) {
      RCLCPP_WARN(this->get_logger(),
                  "Some, but not all, publishers on topic '%s' are offering "
                  "QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to "
                  "QoSDurabilityPolicy.VOLATILE as it will connect to all publishers",
                  topic.c_str());
    }
    qos.durability_volatile();
  }

  if (firstSubscription) {
    RCLCPP_INFO(
      this->get_logger(), "Subscribing to topic \"%s\" (%s) on channel %d with reliablity \"%s\"",
      topic.c_str(), datatype.c_str(), channelId,
      qos.reliability() == rclcpp::ReliabilityPolicy::Reliable ? "reliable" : "best_effort");

  } else {
    RCLCPP_INFO(this->get_logger(), "Adding subscriber #%zu to topic \"%s\" (%s) on channel %d",
                subscriptionsByClient.size(), topic.c_str(), datatype.c_str(), channelId);
  }

  try {
    auto subscriber = this->create_generic_subscription(
      topic, datatype, qos,
      [this, channelId, clientHandle](std::shared_ptr<const rclcpp::SerializedMessage> msg) {
        this->rosMessageHandler(channelId, clientHandle, msg);
      },
      subscriptionOptions);
    subscriptionsByClient.emplace(clientHandle, std::move(subscriber));
  } catch (const std::exception& ex) {
    throw foxglove_ws::ChannelError(
      channelId, "Failed to subscribe to topic " + topic + " (" + datatype + "): " + ex.what());
  }
}

void FoxgloveBridge::unsubscribe(foxglove_ws::ChannelId channelId, ConnectionHandle clientHandle) {
  std::lock_guard<std::mutex> lock(_subscriptionsMutex);

  const auto channelIt = _advertisedTopics.find(channelId);
  if (channelIt == _advertisedTopics.end()) {
    throw foxglove_ws::ChannelError(
      channelId, "Received unsubscribe request for unknown channel " + std::to_string(channelId));
  }
  const auto& channel = channelIt->second;

  auto subscriptionsIt = _subscriptions.find(channelId);
  if (subscriptionsIt == _subscriptions.end()) {
    throw foxglove_ws::ChannelError(channelId, "Received unsubscribe request for channel " +
                                                 std::to_string(channelId) +
                                                 " that was not subscribed to");
  }

  auto& subscriptionsByClient = subscriptionsIt->second;
  const auto clientSubscription = subscriptionsByClient.find(clientHandle);
  if (clientSubscription == subscriptionsByClient.end()) {
    throw foxglove_ws::ChannelError(
      channelId, "Received unsubscribe request for channel " + std::to_string(channelId) +
                   "from a client that was not subscribed to this channel");
  }

  subscriptionsByClient.erase(clientSubscription);
  if (subscriptionsByClient.empty()) {
    RCLCPP_INFO(this->get_logger(), "Unsubscribing from topic \"%s\" (%s) on channel %d",
                channel.topic.c_str(), channel.schemaName.c_str(), channelId);
    _subscriptions.erase(subscriptionsIt);
  } else {
    RCLCPP_INFO(this->get_logger(),
                "Removed one subscription from channel %d (%zu subscription(s) left)", channelId,
                subscriptionsByClient.size());
  }
}

void FoxgloveBridge::clientAdvertise(const foxglove_ws::ClientAdvertisement& advertisement,
                                     ConnectionHandle hdl) {
  std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

  // Get client publications or insert an empty map.
  auto [clientPublicationsIt, isFirstPublication] =
    _clientAdvertisedTopics.emplace(hdl, ClientPublications());

  auto& clientPublications = clientPublicationsIt->second;

  if (!isFirstPublication &&
      clientPublications.find(advertisement.channelId) != clientPublications.end()) {
    throw foxglove_ws::ClientChannelError(
      advertisement.channelId,
      "Received client advertisement from " + _server->remoteEndpointString(hdl) + " for channel " +
        std::to_string(advertisement.channelId) + " it had already advertised");
  }

  if (advertisement.schemaName.empty()) {
    throw foxglove_ws::ClientChannelError(
      advertisement.channelId,
      "Received client advertisement from " + _server->remoteEndpointString(hdl) + " for channel " +
        std::to_string(advertisement.channelId) + " with empty schema name");
  }

  if (advertisement.encoding == "json") {
    // register the JSON parser for this schemaName
    auto parserIt = _jsonParsers.find(advertisement.schemaName);
    if (parserIt == _jsonParsers.end()) {
      const auto& schemaName = advertisement.schemaName;
      std::string schema = "";

      if (!advertisement.schema.empty()) {
        // Schema is given by the advertisement
        schema = std::string(reinterpret_cast<const char*>(advertisement.schema.data()),
                             advertisement.schema.size());
      } else {
        // Schema not given, look it up.
        auto [format, msgDefinition] = _messageDefinitionCache.get_full_text(schemaName);
        if (format != foxglove::MessageDefinitionFormat::MSG) {
          throw foxglove_ws::ClientChannelError(
            advertisement.channelId,
            "Message definition (.msg) for schema " + schemaName + " not found.");
        }

        schema = msgDefinition;
      }

      auto parser = std::make_shared<RosMsgParser::Parser>(
        advertisement.topic, RosMsgParser::ROSType(schemaName), schema);
      _jsonParsers.insert({schemaName, parser});
    }
  }

  try {
    // Create a new topic advertisement
    const auto& topicName = advertisement.topic;
    const auto& topicType = advertisement.schemaName;

    // Lookup if there are publishers from other nodes for that topic. If that's the case, we use
    // a matching QoS profile.
    const auto otherPublishers = get_publishers_info_by_topic(topicName);
    const auto otherPublisherIt =
      std::find_if(otherPublishers.begin(), otherPublishers.end(),
                   [this](const rclcpp::TopicEndpointInfo& endpoint) {
                     return endpoint.node_name() != this->get_name() ||
                            endpoint.node_namespace() != this->get_namespace();
                   });
    rclcpp::QoS qos = otherPublisherIt == otherPublishers.end() ? rclcpp::SystemDefaultsQoS()
                                                                : otherPublisherIt->qos_profile();

    // When the QoS profile is copied from another existing publisher, it can happen that the
    // history policy is Unknown, leading to an error when subsequently trying to create a publisher
    // with that QoS profile. As a fix, we explicitly set the history policy to the system default.
    if (qos.history() == rclcpp::HistoryPolicy::Unknown) {
      qos.history(rclcpp::HistoryPolicy::SystemDefault);
    }
    rclcpp::PublisherOptions publisherOptions{};
    publisherOptions.callback_group = _clientPublishCallbackGroup;
    auto publisher = this->create_generic_publisher(topicName, topicType, qos, publisherOptions);

    RCLCPP_INFO(this->get_logger(),
                "Client %s is advertising \"%s\" (%s) on channel %d with encoding \"%s\"",
                _server->remoteEndpointString(hdl).c_str(), topicName.c_str(), topicType.c_str(),
                advertisement.channelId, advertisement.encoding.c_str());

    // Store the new topic advertisement
    clientPublications.emplace(advertisement.channelId, std::move(publisher));
  } catch (const std::exception& ex) {
    throw foxglove_ws::ClientChannelError(advertisement.channelId,
                                          std::string("Failed to create publisher: ") + ex.what());
  }
}

void FoxgloveBridge::clientUnadvertise(foxglove_ws::ChannelId channelId, ConnectionHandle hdl) {
  std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

  auto it = _clientAdvertisedTopics.find(hdl);
  if (it == _clientAdvertisedTopics.end()) {
    throw foxglove_ws::ClientChannelError(
      channelId, "Ignoring client unadvertisement from " + _server->remoteEndpointString(hdl) +
                   " for unknown channel " + std::to_string(channelId) +
                   ", client has no advertised topics");
  }

  auto& clientPublications = it->second;
  auto it2 = clientPublications.find(channelId);
  if (it2 == clientPublications.end()) {
    throw foxglove_ws::ClientChannelError(
      channelId, "Ignoring client unadvertisement from " + _server->remoteEndpointString(hdl) +
                   " for unknown channel " + std::to_string(channelId) + ", client has " +
                   std::to_string(clientPublications.size()) + " advertised topic(s)");
  }

  const auto& publisher = it2->second;
  RCLCPP_INFO(this->get_logger(),
              "Client %s is no longer advertising %s (%zu subscribers) on channel %d",
              _server->remoteEndpointString(hdl).c_str(), publisher->get_topic_name(),
              publisher->get_subscription_count(), channelId);

  clientPublications.erase(it2);
  if (clientPublications.empty()) {
    _clientAdvertisedTopics.erase(it);
  }

  // Create a timer that immedeately goes out of scope (so it never fires) which will trigger
  // the previously destroyed publisher to be cleaned up. This is a workaround for
  // https://github.com/ros2/rclcpp/issues/2146
  this->create_wall_timer(1s, []() {});
}

void FoxgloveBridge::clientMessage(const foxglove_ws::ClientMessage& message,
                                   ConnectionHandle hdl) {
  // Get the publisher
  rclcpp::GenericPublisher::SharedPtr publisher;
  {
    const auto channelId = message.advertisement.channelId;
    std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

    auto it = _clientAdvertisedTopics.find(hdl);
    if (it == _clientAdvertisedTopics.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Dropping client message from " + _server->remoteEndpointString(hdl) +
                     " for unknown channel " + std::to_string(channelId) +
                     ", client has no advertised topics");
    }

    auto& clientPublications = it->second;
    auto it2 = clientPublications.find(channelId);
    if (it2 == clientPublications.end()) {
      throw foxglove_ws::ClientChannelError(
        channelId, "Dropping client message from " + _server->remoteEndpointString(hdl) +
                     " for unknown channel " + std::to_string(channelId) + ", client has " +
                     std::to_string(clientPublications.size()) + " advertised topic(s)");
    }
    publisher = it2->second;
  }

  auto publishMessage = [publisher, this](const void* data, size_t size) {
    // Copy the message payload into a SerializedMessage object
    rclcpp::SerializedMessage serializedMessage{size};
    auto& rclSerializedMsg = serializedMessage.get_rcl_serialized_message();
    std::memcpy(rclSerializedMsg.buffer, data, size);
    rclSerializedMsg.buffer_length = size;
    // Publish the message
    if (_disableLoanMessage || !publisher->can_loan_messages()) {
      publisher->publish(serializedMessage);
    } else {
      publisher->publish_as_loaned_msg(serializedMessage);
    }
  };

  if (message.advertisement.encoding == "cdr") {
    publishMessage(message.getData(), message.getLength());
  } else if (message.advertisement.encoding == "json") {
    // get the specific parser for this schemaName
    std::shared_ptr<RosMsgParser::Parser> parser;
    {
      std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);
      auto parserIt = _jsonParsers.find(message.advertisement.schemaName);
      if (parserIt != _jsonParsers.end()) {
        parser = parserIt->second;
      }
    }
    if (!parser) {
      throw foxglove_ws::ClientChannelError(message.advertisement.channelId,
                                            "Dropping client message from " +
                                              _server->remoteEndpointString(hdl) +
                                              " with encoding \"json\": no parser found");
    } else {
      thread_local RosMsgParser::ROS2_Serializer serializer;
      serializer.reset();
      const std::string jsonMessage(reinterpret_cast<const char*>(message.getData()),
                                    message.getLength());
      try {
        parser->serializeFromJson(jsonMessage, &serializer);
        publishMessage(serializer.getBufferData(), serializer.getBufferSize());
      } catch (const std::exception& ex) {
        throw foxglove_ws::ClientChannelError(message.advertisement.channelId,
                                              "Dropping client message from " +
                                                _server->remoteEndpointString(hdl) +
                                                " with encoding \"json\": " + ex.what());
      }
    }
  } else {
    throw foxglove_ws::ClientChannelError(
      message.advertisement.channelId,
      "Dropping client message from " + _server->remoteEndpointString(hdl) +
        " with unknown encoding \"" + message.advertisement.encoding + "\"");
  }
}

void FoxgloveBridge::setParameters(const std::vector<foxglove_ws::Parameter>& parameters,
                                   const std::optional<std::string>& requestId,
                                   ConnectionHandle hdl) {
  _paramInterface->setParams(parameters, std::chrono::seconds(5));

  // If a request Id was given, send potentially updated parameters back to client
  if (requestId) {
    std::vector<std::string> parameterNames(parameters.size());
    for (size_t i = 0; i < parameters.size(); ++i) {
      parameterNames[i] = parameters[i].getName();
    }
    getParameters(parameterNames, requestId, hdl);
  }
}

void FoxgloveBridge::getParameters(const std::vector<std::string>& parameters,
                                   const std::optional<std::string>& requestId,
                                   ConnectionHandle hdl) {
  const auto params = _paramInterface->getParams(parameters, std::chrono::seconds(5));
  _server->publishParameterValues(hdl, params, requestId);
}

void FoxgloveBridge::subscribeParameters(const std::vector<std::string>& parameters,
                                         foxglove_ws::ParameterSubscriptionOperation op,
                                         ConnectionHandle) {
  if (op == foxglove_ws::ParameterSubscriptionOperation::SUBSCRIBE) {
    _paramInterface->subscribeParams(parameters);
  } else {
    _paramInterface->unsubscribeParams(parameters);
  }
}

void FoxgloveBridge::parameterUpdates(const std::vector<foxglove_ws::Parameter>& parameters) {
  _server->updateParameterValues(parameters);
}

void FoxgloveBridge::logHandler(LogLevel level, char const* msg) {
  switch (level) {
    case LogLevel::Debug:
      RCLCPP_DEBUG(this->get_logger(), "[WS] %s", msg);
      break;
    case LogLevel::Info:
      RCLCPP_INFO(this->get_logger(), "[WS] %s", msg);
      break;
    case LogLevel::Warn:
      RCLCPP_WARN(this->get_logger(), "[WS] %s", msg);
      break;
    case LogLevel::Error:
      RCLCPP_ERROR(this->get_logger(), "[WS] %s", msg);
      break;
    case LogLevel::Critical:
      RCLCPP_FATAL(this->get_logger(), "[WS] %s", msg);
      break;
  }
}

void FoxgloveBridge::rosMessageHandler(const foxglove_ws::ChannelId& channelId,
                                       ConnectionHandle clientHandle,
                                       std::shared_ptr<const rclcpp::SerializedMessage> msg) {
  // NOTE: Do not call any RCLCPP_* logging functions from this function. Otherwise, subscribing
  // to `/rosout` will cause a feedback loop
  const auto timestamp = this->now().nanoseconds();
  assert(timestamp >= 0 && "Timestamp is negative");
  const auto rclSerializedMsg = msg->get_rcl_serialized_message();
  _server->sendMessage(clientHandle, channelId, static_cast<uint64_t>(timestamp),
                       rclSerializedMsg.buffer, rclSerializedMsg.buffer_length);
}

void FoxgloveBridge::serviceRequest(const foxglove_ws::ServiceRequest& request,
                                    ConnectionHandle clientHandle) {
  RCLCPP_DEBUG(this->get_logger(), "Received a request for service %d", request.serviceId);

  std::lock_guard<std::mutex> lock(_servicesMutex);
  const auto serviceIt = _advertisedServices.find(request.serviceId);
  if (serviceIt == _advertisedServices.end()) {
    throw foxglove_ws::ServiceError(
      request.serviceId,
      "Service with id " + std::to_string(request.serviceId) + " does not exist");
  }

  auto clientIt = _serviceClients.find(request.serviceId);
  if (clientIt == _serviceClients.end()) {
    try {
      auto clientOptions = rcl_client_get_default_options();
      auto genClient = GenericClient::make_shared(
        this->get_node_base_interface().get(), this->get_node_graph_interface(),
        serviceIt->second.name, serviceIt->second.type, clientOptions);
      clientIt = _serviceClients.emplace(request.serviceId, std::move(genClient)).first;
      this->get_node_services_interface()->add_client(clientIt->second, _servicesCallbackGroup);
    } catch (const std::exception& ex) {
      throw foxglove_ws::ServiceError(
        request.serviceId,
        "Failed to create service client for service " + serviceIt->second.name + ": " + ex.what());
    }
  }

  auto client = clientIt->second;
  if (!client->wait_for_service(1s)) {
    throw foxglove_ws::ServiceError(request.serviceId,
                                    "Service " + serviceIt->second.name + " is not available");
  }

  auto reqMessage = std::make_shared<rclcpp::SerializedMessage>(request.data.size());
  auto& rclSerializedMsg = reqMessage->get_rcl_serialized_message();
  std::memcpy(rclSerializedMsg.buffer, request.data.data(), request.data.size());
  rclSerializedMsg.buffer_length = request.data.size();

  auto responseReceivedCallback = [this, request,
                                   clientHandle](GenericClient::SharedFuture future) {
    const auto serializedResponseMsg = future.get()->get_rcl_serialized_message();
    foxglove_ws::ServiceRequest response{request.serviceId, request.callId, request.encoding,
                                         std::vector<uint8_t>(serializedResponseMsg.buffer_length)};
    std::memcpy(response.data.data(), serializedResponseMsg.buffer,
                serializedResponseMsg.buffer_length);
    _server->sendServiceResponse(clientHandle, response);
  };
  client->async_send_request(reqMessage, responseReceivedCallback);
}

void FoxgloveBridge::fetchAsset(const std::string& uri, uint32_t requestId,
                                ConnectionHandle clientHandle) {
  foxglove_ws::FetchAssetResponse response;
  response.requestId = requestId;

  try {
    // We reject URIs that are not on the allowlist or that contain two consecutive dots. The latter
    // can be utilized to construct URIs for retrieving confidential files that should not be
    // accessible over the WebSocket connection. Example:
    // `package://<pkg_name>/../../../secret.txt`. This is an extra security measure and should not
    // be necessary if the allowlist is strict enough.
    if (uri.find("..") != std::string::npos || !isWhitelisted(uri, _assetUriAllowlistPatterns)) {
      throw std::runtime_error("Asset URI not allowed: " + uri);
    }

    resource_retriever::Retriever resource_retriever;

    // The resource_retriever API has changed from 3.7 onwards.
#if RESOURCE_RETRIEVER_VERSION_MAJOR > 3 || \
  (RESOURCE_RETRIEVER_VERSION_MAJOR == 3 && RESOURCE_RETRIEVER_VERSION_MINOR > 6)
    const auto memoryResource = resource_retriever.get_shared(uri);
    response.status = foxglove_ws::FetchAssetStatus::Success;
    response.errorMessage = "";
    response.data.resize(memoryResource->data.size());
    std::memcpy(response.data.data(), memoryResource->data.data(), memoryResource->data.size());
#else
    const resource_retriever::MemoryResource memoryResource = resource_retriever.get(uri);
    response.status = foxglove_ws::FetchAssetStatus::Success;
    response.errorMessage = "";
    response.data.resize(memoryResource.size);
    std::memcpy(response.data.data(), memoryResource.data.get(), memoryResource.size);
#endif
  } catch (const std::exception& ex) {
    RCLCPP_WARN(this->get_logger(), "Failed to retrieve asset '%s': %s", uri.c_str(), ex.what());
    response.status = foxglove_ws::FetchAssetStatus::Error;
    response.errorMessage = "Failed to retrieve asset " + uri;
  }

  if (_server) {
    _server->sendFetchAssetResponse(clientHandle, response);
  }
}

bool FoxgloveBridge::hasCapability(const std::string& capability) {
  return std::find(_capabilities.begin(), _capabilities.end(), capability) != _capabilities.end();
}

}  // namespace foxglove_bridge

#include <rclcpp_components/register_node_macro.hpp>

// Register the component with class_loader.
// This acts as a sort of entry point, allowing the component to be discoverable when its library
// is being loaded into a running process.
RCLCPP_COMPONENTS_REGISTER_NODE(foxglove_bridge::FoxgloveBridge)



================================================
FILE: ros2_foxglove_bridge/src/ros2_foxglove_bridge_node.cpp
================================================
#include <rclcpp_components/component_manager.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>

int main(int argc, char* argv[]) {
  rclcpp::init(argc, argv);

  size_t numThreads = 0;
  {
    // Temporary dummy node to get num_threads param.
    auto dummyNode = std::make_shared<rclcpp::Node>("dummy");
    auto numThreadsDescription = rcl_interfaces::msg::ParameterDescriptor{};
    numThreadsDescription.name = "num_threads";
    numThreadsDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
    numThreadsDescription.description =
      "The number of threads to use for the ROS node executor. 0 means one thread per CPU core.";
    numThreadsDescription.read_only = true;
    numThreadsDescription.additional_constraints = "Must be a non-negative integer";
    numThreadsDescription.integer_range.resize(1);
    numThreadsDescription.integer_range[0].from_value = 0;
    numThreadsDescription.integer_range[0].to_value = INT32_MAX;
    numThreadsDescription.integer_range[0].step = 1;
    constexpr int DEFAULT_NUM_THREADS = 0;
    dummyNode->declare_parameter(numThreadsDescription.name, DEFAULT_NUM_THREADS,
                                 numThreadsDescription);
    numThreads = static_cast<size_t>(dummyNode->get_parameter(numThreadsDescription.name).as_int());
  }

  auto executor =
    rclcpp::executors::MultiThreadedExecutor::make_shared(rclcpp::ExecutorOptions{}, numThreads);

  foxglove_bridge::FoxgloveBridge node;
  executor->add_node(node.get_node_base_interface());
  executor->spin();
  rclcpp::shutdown();

  return EXIT_SUCCESS;
}



================================================
FILE: ros2_foxglove_bridge/tests/smoke_test.cpp
================================================
#include <chrono>
#include <filesystem>
#include <future>
#include <thread>

#include <gtest/gtest.h>
#include <std_msgs/msg/string.hpp>
#include <std_srvs/srv/set_bool.hpp>
#include <websocketpp/config/asio_client.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>
#include <foxglove_bridge/test/test_client.hpp>

constexpr char URI[] = "ws://localhost:8765";

// Binary representation of std_msgs/msg/String for "hello world"
constexpr uint8_t HELLO_WORLD_CDR[] = {0,   1,   0,   0,  12,  0,   0,   0,   104, 101,
                                       108, 108, 111, 32, 119, 111, 114, 108, 100, 0};
constexpr char HELLO_WORLD_JSON[] = "{\"data\": \"hello world\"}";
constexpr char STD_MSGS_STRING_SCHEMA[] = "data string";

constexpr auto ONE_SECOND = std::chrono::seconds(1);
constexpr auto DEFAULT_TIMEOUT = std::chrono::seconds(10);

class TestWithExecutor : public testing::Test {
protected:
  TestWithExecutor() {
    this->_executorThread = std::thread([this]() {
      this->executor.spin();
    });
  }

  ~TestWithExecutor() override {
    this->executor.cancel();
    this->_executorThread.join();
  }

  rclcpp::executors::SingleThreadedExecutor executor;

private:
  std::thread _executorThread;
};

class ParameterTest : public TestWithExecutor {
public:
  using PARAM_1_TYPE = std::string;
  inline static const std::string NODE_1_NAME = "node_1";
  inline static const std::string PARAM_1_NAME = "string_param";
  inline static const PARAM_1_TYPE PARAM_1_DEFAULT_VALUE = "hello";
  inline static const std::string DELETABLE_PARAM_NAME = "deletable_param";

  using PARAM_2_TYPE = std::vector<int64_t>;
  inline static const std::string NODE_2_NAME = "node_2";
  inline static const std::string PARAM_2_NAME = "int_array_param";
  inline static const PARAM_2_TYPE PARAM_2_DEFAULT_VALUE = {1, 2, 3};

  using PARAM_3_TYPE = double;
  inline static const std::string PARAM_3_NAME = "float_param";
  inline static const PARAM_3_TYPE PARAM_3_DEFAULT_VALUE = 1.123;

  using PARAM_4_TYPE = std::vector<double>;
  inline static const std::string PARAM_4_NAME = "float_array_param";
  inline static const PARAM_4_TYPE PARAM_4_DEFAULT_VALUE = {1.1, 2.2, 3.3};

protected:
  void SetUp() override {
    auto nodeOptions = rclcpp::NodeOptions();
    nodeOptions.allow_undeclared_parameters(true);
    _paramNode1 = rclcpp::Node::make_shared(NODE_1_NAME, nodeOptions);
    auto p1Param = rcl_interfaces::msg::ParameterDescriptor{};
    p1Param.name = PARAM_1_NAME;
    p1Param.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
    p1Param.read_only = false;
    _paramNode1->declare_parameter(p1Param.name, PARAM_1_DEFAULT_VALUE, p1Param);
    _paramNode1->set_parameter(rclcpp::Parameter(DELETABLE_PARAM_NAME, true));

    _paramNode2 = rclcpp::Node::make_shared(NODE_2_NAME);
    auto p2Param = rcl_interfaces::msg::ParameterDescriptor{};
    p2Param.name = PARAM_2_NAME;
    p2Param.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY;
    p2Param.read_only = false;
    _paramNode2->declare_parameter(p2Param.name, PARAM_2_DEFAULT_VALUE, p2Param);
    _paramNode2->declare_parameter(PARAM_3_NAME, PARAM_3_DEFAULT_VALUE);
    _paramNode2->declare_parameter(PARAM_4_NAME, PARAM_4_DEFAULT_VALUE);

    executor.add_node(_paramNode1);
    executor.add_node(_paramNode2);

    _wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
    ASSERT_EQ(std::future_status::ready, _wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));
  }

  void TearDown() override {
    executor.remove_node(_paramNode1);
    executor.remove_node(_paramNode2);
  }

  rclcpp::Node::SharedPtr _paramNode1;
  rclcpp::Node::SharedPtr _paramNode2;
  std::shared_ptr<foxglove_ws::Client<websocketpp::config::asio_client>> _wsClient;
};

class ServiceTest : public TestWithExecutor {
public:
  inline static const std::string SERVICE_NAME = "/foo_service";

protected:
  void SetUp() override {
    _node = rclcpp::Node::make_shared("node");
    _service = _node->create_service<std_srvs::srv::SetBool>(
      SERVICE_NAME, [&](std::shared_ptr<std_srvs::srv::SetBool::Request> req,
                        std::shared_ptr<std_srvs::srv::SetBool::Response> res) {
        res->message = "hello";
        res->success = req->data;
      });
    executor.add_node(_node);
  }

  void TearDown() override {
    executor.remove_node(_node);
  }

  rclcpp::Node::SharedPtr _node;
  rclcpp::ServiceBase::SharedPtr _service;
  std::shared_ptr<foxglove_ws::Client<websocketpp::config::asio_client>> _wsClient;
};

class PublisherTest
    : public TestWithExecutor,
      public testing::WithParamInterface<std::pair<std::string, std::vector<uint8_t>>> {};

class ExistingPublisherTest : public PublisherTest {
public:
  inline static const std::string TOPIC_NAME = "/some_topic";

protected:
  void SetUp() override {
    _node = rclcpp::Node::make_shared("node");
    _publisher =
      _node->create_publisher<std_msgs::msg::String>(TOPIC_NAME, rclcpp::SystemDefaultsQoS());
    executor.add_node(_node);
  }

  void TearDown() override {
    executor.remove_node(_node);
  }

  rclcpp::Node::SharedPtr _node;
  rclcpp::PublisherBase::SharedPtr _publisher;
};

template <class T>
std::shared_ptr<rclcpp::SerializedMessage> serializeMsg(const T* msg) {
  using rosidl_typesupport_cpp::get_message_type_support_handle;
  auto typeSupportHdl = get_message_type_support_handle<T>();
  auto result = std::make_shared<rclcpp::SerializedMessage>();
  rmw_ret_t ret = rmw_serialize(msg, typeSupportHdl, &result->get_rcl_serialized_message());
  EXPECT_EQ(ret, RMW_RET_OK);
  return result;
}

template <class T>
std::shared_ptr<T> deserializeMsg(const rcl_serialized_message_t* msg) {
  using rosidl_typesupport_cpp::get_message_type_support_handle;
  auto typeSupportHdl = get_message_type_support_handle<T>();
  auto result = std::make_shared<T>();
  rmw_ret_t ret = rmw_deserialize(msg, typeSupportHdl, result.get());
  EXPECT_EQ(ret, RMW_RET_OK);
  return result;
}

TEST(SmokeTest, testConnection) {
  foxglove_ws::Client<websocketpp::config::asio_client> wsClient;
  EXPECT_EQ(std::future_status::ready, wsClient.connect(URI).wait_for(DEFAULT_TIMEOUT));
}

TEST(SmokeTest, testSubscription) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  std_msgs::msg::String rosMsg;
  rosMsg.data = "hello world";

  auto node = rclcpp::Node::make_shared("tester");
  rclcpp::QoS qos = rclcpp::QoS{rclcpp::KeepLast(1lu)};
  qos.reliable();
  qos.transient_local();
  auto pub = node->create_publisher<std_msgs::msg::String>(topic_name, qos);
  pub->publish(rosMsg);

  // Connect a few clients and make sure that they receive the correct message
  const auto clientCount = 3;
  for (auto i = 0; i < clientCount; ++i) {
    // Set up a client and subscribe to the channel.
    auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
    auto channelFuture = foxglove_ws::waitForChannel(client, topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
    const foxglove_ws::Channel channel = channelFuture.get();
    const foxglove_ws::SubscriptionId subscriptionId = 1;

    // Subscribe to the channel and confirm that the promise resolves
    auto msgFuture = waitForChannelMsg(client.get(), subscriptionId);
    client->subscribe({{subscriptionId, channel.id}});
    ASSERT_EQ(std::future_status::ready, msgFuture.wait_for(ONE_SECOND));
    const auto msgData = msgFuture.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_CDR), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_CDR, msgData.data(), msgData.size()));

    // Unsubscribe from the channel again.
    client->unsubscribe({subscriptionId});
  }
}

TEST(SmokeTest, testSubscriptionParallel) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  std_msgs::msg::String rosMsg;
  rosMsg.data = "hello world";

  auto node = rclcpp::Node::make_shared("tester");
  rclcpp::QoS qos = rclcpp::QoS{rclcpp::KeepLast(1lu)};
  qos.reliable();
  qos.transient_local();
  auto pub = node->create_publisher<std_msgs::msg::String>(topic_name, qos);
  pub->publish(rosMsg);

  // Connect a few clients (in parallel) and make sure that they receive the correct message
  const foxglove_ws::SubscriptionId subscriptionId = 1;
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<uint8_t>>> futures;
  for (auto client : clients) {
    futures.push_back(waitForChannelMsg(client.get(), subscriptionId));
  }

  for (auto client : clients) {
    auto channelFuture = foxglove_ws::waitForChannel(client, topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
    const foxglove_ws::Channel channel = channelFuture.get();
    client->subscribe({{subscriptionId, channel.id}});
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    auto msgData = future.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_CDR), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_CDR, msgData.data(), msgData.size()));
  }

  for (auto client : clients) {
    client->unsubscribe({subscriptionId});
  }
}

TEST_P(PublisherTest, testPublishing) {
  const auto& [encoding, message] = GetParam();
  // use a unique topic for each test to prevent tests from interfering with each other
  static size_t testPublishingCount = 0;
  ++testPublishingCount;

  foxglove_ws::ClientAdvertisement advertisement;
  advertisement.channelId = 1;
  advertisement.topic = "/testPublishing_" + std::to_string(testPublishingCount);
  advertisement.encoding = encoding;
  advertisement.schemaName = "std_msgs/msg/String";
  advertisement.schema =
    std::vector<uint8_t>(STD_MSGS_STRING_SCHEMA, std::end(STD_MSGS_STRING_SCHEMA));

  // Set up a ROS node with a subscriber
  std::promise<std::string> msgPromise;
  auto msgFuture = msgPromise.get_future();
  auto node = rclcpp::Node::make_shared("tester");
  auto sub = node->create_subscription<std_msgs::msg::String>(
    advertisement.topic, 10, [&msgPromise](std::shared_ptr<const std_msgs::msg::String> msg) {
      msgPromise.set_value(msg->data);
    });
  this->executor.add_node(node);

  // Set up the client, advertise and publish the binary message
  auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  auto channelFuture = foxglove_ws::waitForChannel(client, advertisement.topic);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  client->advertise({advertisement});

  // Wait until the advertisement got advertised as channel by the server
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));

  // Publish the message and unadvertise again
  client->publish(advertisement.channelId, message.data(), message.size());
  client->unadvertise({advertisement.channelId});

  // Ensure that we have received the correct message via our ROS subscriber
  ASSERT_EQ(std::future_status::ready, msgFuture.wait_for(DEFAULT_TIMEOUT));
  this->executor.remove_node(node);
  EXPECT_EQ("hello world", msgFuture.get());
}

INSTANTIATE_TEST_SUITE_P(
  TestPublishingCDR, PublisherTest,
  testing::Values(std::make_pair("cdr", std::vector<uint8_t>(HELLO_WORLD_CDR,
                                                             std::end(HELLO_WORLD_CDR)))));

INSTANTIATE_TEST_SUITE_P(
  TestPublishingJSON, PublisherTest,
  testing::Values(std::make_pair("json", std::vector<uint8_t>(HELLO_WORLD_JSON,
                                                              std::end(HELLO_WORLD_JSON)))));

TEST_P(ExistingPublisherTest, testPublishingWithExistingPublisher) {
  const auto& [encoding, message] = GetParam();

  foxglove_ws::ClientAdvertisement advertisement;
  advertisement.channelId = 1;
  advertisement.topic = TOPIC_NAME;
  advertisement.encoding = encoding;
  advertisement.schemaName = "std_msgs/msg/String";
  advertisement.schema = {};  // Schema intentionally left empty.

  // Set up a ROS node with a subscriber
  std::promise<std::string> msgPromise;
  auto msgFuture = msgPromise.get_future();
  auto node = rclcpp::Node::make_shared("tester");
  auto sub = node->create_subscription<std_msgs::msg::String>(
    advertisement.topic, 10, [&msgPromise](std::shared_ptr<const std_msgs::msg::String> msg) {
      msgPromise.set_value(msg->data);
    });
  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);

  // Set up the client, advertise and publish the binary message
  auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  auto channelFuture = foxglove_ws::waitForChannel(client, advertisement.topic);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  client->advertise({advertisement});

  // Wait until the advertisement got advertised as channel by the server
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));

  // Publish the message and unadvertise again
  client->publish(advertisement.channelId, message.data(), message.size());
  client->unadvertise({advertisement.channelId});

  // Ensure that we have received the correct message via our ROS subscriber
  const auto ret = executor.spin_until_future_complete(msgFuture, ONE_SECOND);
  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);
  EXPECT_EQ("hello world", msgFuture.get());
}

INSTANTIATE_TEST_SUITE_P(
  ExistingPublisherTestCDR, ExistingPublisherTest,
  testing::Values(std::make_pair("cdr", std::vector<uint8_t>(HELLO_WORLD_CDR,
                                                             std::end(HELLO_WORLD_CDR)))));

INSTANTIATE_TEST_SUITE_P(
  ExistingPublisherTestJSON, ExistingPublisherTest,
  testing::Values(std::make_pair("json", std::vector<uint8_t>(HELLO_WORLD_JSON,
                                                              std::end(HELLO_WORLD_JSON)))));

TEST_F(ParameterTest, testGetAllParams) {
  const std::string requestId = "req-testGetAllParams";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_GE(params.size(), 2UL);
}

TEST_F(ParameterTest, testGetNonExistingParameters) {
  const std::string requestId = "req-testGetNonExistingParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters(
    {"/foo_1.non_existing_parameter", "/foo_2.non_existing.nested_parameter"}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_TRUE(params.empty());
}

TEST_F(ParameterTest, testGetParameters) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const auto p2 = NODE_2_NAME + "." + PARAM_2_NAME;

  const std::string requestId = "req-testGetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({p1, p2}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [&p1](const auto& param) {
    return param.getName() == p1;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [&p2](const auto& param) {
    return param.getName() == p2;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(PARAM_1_DEFAULT_VALUE, p1Iter->getValue().getValue<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<int64_t> int_array_val;
  const auto array_params = p2Iter->getValue().getValue<std::vector<foxglove_ws::ParameterValue>>();
  for (const auto& paramValue : array_params) {
    int_array_val.push_back(paramValue.getValue<int64_t>());
  }
  EXPECT_EQ(int_array_val, PARAM_2_DEFAULT_VALUE);
}

TEST_F(ParameterTest, testSetParameters) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const auto p2 = NODE_2_NAME + "." + PARAM_2_NAME;
  const PARAM_1_TYPE newP1value = "world";
  const std::vector<foxglove_ws::ParameterValue> newP2value = {4, 5, 6};

  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(p1, newP1value),
    foxglove_ws::Parameter(p2, newP2value),
  };

  _wsClient->setParameters(parameters);
  const std::string requestId = "req-testSetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->getParameters({p1, p2}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [&p1](const auto& param) {
    return param.getName() == p1;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [&p2](const auto& param) {
    return param.getName() == p2;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(newP1value, p1Iter->getValue().getValue<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<int64_t> int_array_val;
  const auto array_params = p2Iter->getValue().getValue<std::vector<foxglove_ws::ParameterValue>>();
  for (const auto& paramValue : array_params) {
    int_array_val.push_back(paramValue.getValue<int64_t>());
  }
  const std::vector<int64_t> expected_value = {4, 5, 6};
  EXPECT_EQ(int_array_val, expected_value);
}

TEST_F(ParameterTest, testSetParametersWithReqId) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const PARAM_1_TYPE newP1value = "world";
  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(p1, newP1value),
  };

  const std::string requestId = "req-testSetParameters";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(1UL, params.size());
}

TEST_F(ParameterTest, testSetFloatParametersWithIntegers) {
  const auto floatParamName = NODE_2_NAME + "." + PARAM_3_NAME;
  const auto floatArrayParamName = NODE_2_NAME + "." + PARAM_4_NAME;
  const int64_t floatParamVal = 10;
  const std::vector<int64_t> floatArrayParamVal = {3, 2, 1};
  const std::string requestId = "req-testSetFloatParametersWithIntegers";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  const nlohmann::json::array_t parameters = {
    {{"name", floatParamName}, {"value", floatParamVal}, {"type", "float64"}},
    {{"name", floatArrayParamName}, {"value", floatArrayParamVal}, {"type", "float64_array"}},
  };
  _wsClient->sendText(
    nlohmann::json{{"op", "setParameters"}, {"id", requestId}, {"parameters", parameters}}.dump());
  ASSERT_EQ(std::future_status::ready, future.wait_for(ONE_SECOND));
  std::vector<foxglove_ws::Parameter> params = future.get();

  {
    const auto param =
      std::find_if(params.begin(), params.end(), [floatParamName](const foxglove_ws::Parameter& p) {
        return p.getName() == floatParamName;
      });
    ASSERT_NE(param, params.end());
    EXPECT_EQ(param->getType(), foxglove_ws::ParameterType::PARAMETER_DOUBLE);
    EXPECT_NEAR(param->getValue().getValue<double>(), static_cast<double>(floatParamVal), 1e-9);
  }
  {
    const auto param = std::find_if(params.begin(), params.end(),
                                    [floatArrayParamName](const foxglove_ws::Parameter& p) {
                                      return p.getName() == floatArrayParamName;
                                    });
    ASSERT_NE(param, params.end());
    EXPECT_EQ(param->getType(), foxglove_ws::ParameterType::PARAMETER_ARRAY);
    const auto paramValue = param->getValue().getValue<std::vector<foxglove_ws::ParameterValue>>();
    ASSERT_EQ(paramValue.size(), floatArrayParamVal.size());
    for (size_t i = 0; i < paramValue.size(); ++i) {
      EXPECT_NEAR(paramValue[i].getValue<double>(), static_cast<double>(floatArrayParamVal[i]),
                  1e-9);
    }
  }
}

TEST_F(ParameterTest, testUnsetParameter) {
  const auto p1 = NODE_1_NAME + "." + DELETABLE_PARAM_NAME;
  const std::vector<foxglove_ws::Parameter> parameters = {
    foxglove_ws::Parameter(p1),
  };

  const std::string requestId = "req-testUnsetParameter";
  auto future = foxglove_ws::waitForParameters(_wsClient, requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  EXPECT_EQ(0UL, params.size());
}

TEST_F(ParameterTest, testParameterSubscription) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;

  _wsClient->subscribeParameterUpdates({p1});
  auto future = foxglove_ws::waitForParameters(_wsClient);
  _wsClient->setParameters({foxglove_ws::Parameter(p1, "foo")});
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove_ws::Parameter> params = future.get();

  ASSERT_EQ(1UL, params.size());
  EXPECT_EQ(params.front().getName(), p1);

  _wsClient->unsubscribeParameterUpdates({p1});
  _wsClient->setParameters({foxglove_ws::Parameter(p1, "bar")});

  future = foxglove_ws::waitForParameters(_wsClient);
  ASSERT_EQ(std::future_status::timeout, future.wait_for(ONE_SECOND));
}

TEST_F(ParameterTest, testGetParametersParallel) {
  // Connect a few clients (in parallel) and make sure that they all receive parameters
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<foxglove_ws::Parameter>>> futures;
  for (auto client : clients) {
    futures.push_back(
      std::async(std::launch::async, [client]() -> std::vector<foxglove_ws::Parameter> {
        if (std::future_status::ready == client->connect(URI).wait_for(DEFAULT_TIMEOUT)) {
          const std::string requestId = "req-123";
          auto future = foxglove_ws::waitForParameters(client, requestId);
          client->getParameters({}, requestId);
          future.wait_for(DEFAULT_TIMEOUT);
          if (future.valid()) {
            return future.get();
          }
        }
        return {};
      }));
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    std::vector<foxglove_ws::Parameter> parameters;
    EXPECT_NO_THROW(parameters = future.get());
    EXPECT_GE(parameters.size(), 2UL);
  }
}

TEST_F(ServiceTest, testAdvertiseService) {
  auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  auto serviceFuture = foxglove_ws::waitForService(client, SERVICE_NAME);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  ASSERT_EQ(std::future_status::ready, serviceFuture.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::Service service = serviceFuture.get();

  EXPECT_EQ(service.name, SERVICE_NAME);
  EXPECT_EQ(service.type, "std_srvs/srv/SetBool");
  EXPECT_EQ(service.requestSchema, "bool data # e.g. for hardware enabling / disabling");
  EXPECT_EQ(service.responseSchema,
            "bool success   # indicate successful run of triggered service\nstring message # "
            "informational, e.g. for error messages");
}

TEST_F(ServiceTest, testCallServiceParallel) {
  // Connect a few clients (in parallel) and make sure that they can all call the service
  auto clients = {
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>(),
  };

  auto serviceFuture = foxglove_ws::waitForService(*clients.begin(), SERVICE_NAME);
  for (auto client : clients) {
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  }
  ASSERT_EQ(std::future_status::ready, serviceFuture.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::Service service = serviceFuture.get();

  std_srvs::srv::SetBool::Request requestMsg;
  requestMsg.data = true;
  const auto serializedRequest = serializeMsg(&requestMsg);
  const auto& serRequestMsg = serializedRequest->get_rcl_serialized_message();

  foxglove_ws::ServiceRequest request;
  request.serviceId = service.id;
  request.callId = 123lu;
  request.encoding = "cdr";
  request.data.resize(serRequestMsg.buffer_length);
  std::memcpy(request.data.data(), serRequestMsg.buffer, serRequestMsg.buffer_length);

  std::vector<std::future<foxglove_ws::ServiceResponse>> futures;
  for (auto client : clients) {
    futures.push_back(foxglove_ws::waitForServiceResponse(client));
    client->sendServiceRequest(request);
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    foxglove_ws::ServiceResponse response;
    EXPECT_NO_THROW(response = future.get());
    EXPECT_EQ(response.serviceId, request.serviceId);
    EXPECT_EQ(response.callId, request.callId);
    EXPECT_EQ(response.encoding, request.encoding);

    rclcpp::SerializedMessage serializedResponseMsg(response.data.size());
    auto& serMsg = serializedResponseMsg.get_rcl_serialized_message();
    std::memcpy(serMsg.buffer, response.data.data(), response.data.size());
    serMsg.buffer_length = response.data.size();
    const auto resMsg = deserializeMsg<std_srvs::srv::SetBool::Response>(&serMsg);

    EXPECT_EQ(resMsg->message, "hello");
    EXPECT_EQ(resMsg->success, requestMsg.data);
  }
}

TEST_F(ServiceTest, testCallNonexistentService) {
  auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(std::chrono::seconds(5)));

  std::promise<nlohmann::json> promise;
  auto serviceFailureFuture = promise.get_future();
  client->setTextMessageHandler([&promise](const std::string& payload) mutable {
    const auto msg = nlohmann::json::parse(payload);
    if (msg["op"].get<std::string>() == "serviceCallFailure") {
      promise.set_value(msg);
    }
  });

  foxglove_ws::ServiceRequest request;
  request.serviceId = 99u;
  request.callId = 123u;
  request.encoding = "";
  request.data = {};
  client->sendServiceRequest(request);

  ASSERT_EQ(std::future_status::ready, serviceFailureFuture.wait_for(std::chrono::seconds(5)));
  const auto failureMsg = serviceFailureFuture.get();
  EXPECT_EQ(failureMsg["serviceId"].get<foxglove_ws::ServiceId>(), request.serviceId);
  EXPECT_EQ(failureMsg["callId"].get<uint32_t>(), request.callId);
}

TEST(SmokeTest, receiveMessagesOfMultipleTransientLocalPublishers) {
  const std::string topicName = "/latched";
  auto node = rclcpp::Node::make_shared("node");
  rclcpp::QoS qos = rclcpp::QoS(rclcpp::KeepLast(1));
  qos.transient_local();
  qos.reliable();

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);
  auto spinnerThread = std::thread([&executor]() {
    executor.spin();
  });

  constexpr size_t nPubs = 15;
  std::vector<rclcpp::Publisher<std_msgs::msg::String>::SharedPtr> pubs;
  for (size_t i = 0; i < nPubs; ++i) {
    auto pub = pubs.emplace_back(node->create_publisher<std_msgs::msg::String>(topicName, qos));
    std_msgs::msg::String msg;
    msg.data = "Hello";
    pub->publish(msg);
  }

  // Set up a client and subscribe to the channel.
  auto client = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  auto channelFuture = foxglove_ws::waitForChannel(client, topicName);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
  const foxglove_ws::Channel channel = channelFuture.get();
  const foxglove_ws::SubscriptionId subscriptionId = 1;

  // Set up binary message handler to resolve the promise when all nPub message have been received
  std::promise<void> promise;
  std::atomic<size_t> nReceivedMessages = 0;
  client->setBinaryMessageHandler([&promise, &nReceivedMessages](const uint8_t*, size_t) {
    if (++nReceivedMessages == nPubs) {
      promise.set_value();
    }
  });

  // Subscribe to the channel and confirm that the promise resolves
  client->subscribe({{subscriptionId, channel.id}});
  EXPECT_EQ(std::future_status::ready, promise.get_future().wait_for(DEFAULT_TIMEOUT));
  EXPECT_EQ(nReceivedMessages, nPubs);
  client->unsubscribe({subscriptionId});

  pubs.clear();
  executor.remove_node(node);
  executor.cancel();
  spinnerThread.join();
}

TEST(FetchAssetTest, fetchExistingAsset) {
  auto wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const auto millisSinceEpoch = std::chrono::duration_cast<std::chrono::milliseconds>(
    std::chrono::system_clock::now().time_since_epoch());
  const auto tmpFilePath =
    std::filesystem::temp_directory_path() / std::to_string(millisSinceEpoch.count());
  constexpr char content[] = "Hello, world";
  FILE* tmpAssetFile = std::fopen(tmpFilePath.c_str(), "w");
  std::fputs(content, tmpAssetFile);
  std::fclose(tmpAssetFile);

  const std::string uri = std::string("file://") + tmpFilePath.string();
  const uint32_t requestId = 123;

  auto future = foxglove_ws::waitForFetchAssetResponse(wsClient);
  wsClient->fetchAsset(uri, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove_ws::FetchAssetStatus::Success);
  // +1 since NULL terminator is not written to file.
  ASSERT_EQ(response.data.size() + 1ul, sizeof(content));
  EXPECT_EQ(0, std::memcmp(content, response.data.data(), response.data.size()));
  std::remove(tmpFilePath.c_str());
}

TEST(FetchAssetTest, fetchNonExistingAsset) {
  auto wsClient = std::make_shared<foxglove_ws::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const std::string assetId = "file:///foo/bar";
  const uint32_t requestId = 456;

  auto future = foxglove_ws::waitForFetchAssetResponse(wsClient);
  wsClient->fetchAsset(assetId, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove_ws::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove_ws::FetchAssetStatus::Error);
  EXPECT_FALSE(response.errorMessage.empty());
}

// Run all the tests that were declared with TEST()
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  rclcpp::init(argc, argv);

  rclcpp::executors::SingleThreadedExecutor executor;
  rclcpp::NodeOptions nodeOptions;
  // Explicitly allow file:// asset URIs for testing purposes.
  nodeOptions.append_parameter_override("asset_uri_allowlist",
                                        std::vector<std::string>({"file://.*"}));
  foxglove_bridge::FoxgloveBridge node(nodeOptions);
  executor.add_node(node.get_node_base_interface());

  std::thread spinnerThread([&executor]() {
    executor.spin();
  });

  const auto testResult = RUN_ALL_TESTS();

  executor.cancel();
  spinnerThread.join();
  executor.remove_node(node.get_node_base_interface());

  return testResult;
}



================================================
FILE: ros2_foxglove_bridge/tests/utils_test.cpp
================================================
#include <gtest/gtest.h>

#include <foxglove_bridge/utils.hpp>

TEST(SplitDefinitionsTest, EmptyMessageDefinition) {
  const std::string messageDef = "";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 1u);
  EXPECT_EQ(definitions[0], "");
}

TEST(SplitDefinitionsTest, ServiceDefinition) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "bool success ";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "bool success");
}

TEST(SplitDefinitionsTest, ServiceDefinitionEmptyRequest) {
  const std::string messageDef =
    "---\n"
    "bool success ";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "");
  EXPECT_EQ(definitions[1], "bool success");
}

TEST(SplitDefinitionsTest, ServiceDefinitionEmptyResponse) {
  const std::string messageDef =
    "bool data\n"
    "---";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "");
}

TEST(SplitDefinitionsTest, ActionDefinition) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "bool success\n"
    "---\n"
    "bool feedback";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 3u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "bool success");
  EXPECT_EQ(definitions[2], "bool feedback");
}

TEST(SplitDefinitionsTest, ActionDefinitionNoGoal) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "---\n"
    "bool feedback";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 3u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "");
  EXPECT_EQ(definitions[2], "bool feedback");
}

TEST(SplitDefinitionsTest, HandleCarriageReturn) {
  const std::string messageDef =
    "---\r\n"
    "string device_name\n";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "");
  EXPECT_EQ(definitions[1], "string device_name");
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/common.hpp
================================================
#pragma once

#include <array>
#include <cstring>
#include <optional>
#include <regex>
#include <stdint.h>
#include <string>
#include <vector>

namespace foxglove_bridge {
constexpr char SUPPORTED_SUBPROTOCOL[] = "foxglove.sdk.v1";

constexpr char CAPABILITY_CLIENT_PUBLISH[] = "clientPublish";
constexpr char CAPABILITY_TIME[] = "time";
constexpr char CAPABILITY_PARAMETERS[] = "parameters";
constexpr char CAPABILITY_PARAMETERS_SUBSCRIBE[] = "parametersSubscribe";
constexpr char CAPABILITY_SERVICES[] = "services";
constexpr char CAPABILITY_CONNECTION_GRAPH[] = "connectionGraph";
constexpr char CAPABILITY_ASSETS[] = "assets";
constexpr std::array<const char*, 6> DEFAULT_CAPABILITIES = {
  CAPABILITY_CLIENT_PUBLISH, CAPABILITY_CONNECTION_GRAPH, CAPABILITY_PARAMETERS_SUBSCRIBE,
  CAPABILITY_PARAMETERS,     CAPABILITY_SERVICES,         CAPABILITY_ASSETS,
};
}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/generic_client.hpp
================================================
#pragma once

#include <rclcpp/client.hpp>
#include <rclcpp/serialized_message.hpp>
#include <rcpputils/shared_library.hpp>

#include <foxglove/server/service.hpp>

namespace foxglove_bridge {

class GenericClient : public rclcpp::ClientBase {
public:
  using SharedRequest = std::shared_ptr<rclcpp::SerializedMessage>;

  RCLCPP_SMART_PTR_DEFINITIONS(GenericClient)

  GenericClient(rclcpp::node_interfaces::NodeBaseInterface* node_base,
                rclcpp::node_interfaces::NodeGraphInterface::SharedPtr node_graph,
                std::string service_name, std::string service_type,
                rcl_client_options_t& client_options);
  virtual ~GenericClient() {}

  std::shared_ptr<void> create_response() override;
  std::shared_ptr<rmw_request_id_t> create_request_header() override;
  void handle_response(std::shared_ptr<rmw_request_id_t> request_header,
                       std::shared_ptr<void> response) override;
  void async_send_request(SharedRequest request, foxglove::ServiceResponder&& cb);

private:
  RCLCPP_DISABLE_COPY(GenericClient)

  std::map<int64_t, foxglove::ServiceResponder> pending_requests_;
  std::mutex pending_requests_mutex_;
  std::shared_ptr<rcpputils::SharedLibrary> _typeSupportLib;
  std::shared_ptr<rcpputils::SharedLibrary> _typeIntrospectionLib;
  const rosidl_service_type_support_t* _serviceTypeSupportHdl;
  const rosidl_message_type_support_t* _requestTypeSupportHdl;
  const rosidl_message_type_support_t* _responseTypeSupportHdl;
  const rosidl_service_type_support_t* _typeIntrospectionHdl;
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/message_definition_cache.hpp
================================================
#pragma once

#include <set>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>

namespace foxglove_bridge {

// Taken from
// https://github.com/ros2/rosidl/blob/a57baea5/rosidl_parser/rosidl_parser/definition.py
constexpr char SERVICE_REQUEST_MESSAGE_SUFFIX[] = "_Request";
constexpr char SERVICE_RESPONSE_MESSAGE_SUFFIX[] = "_Response";
constexpr char ACTION_GOAL_SERVICE_SUFFIX[] = "_SendGoal";
constexpr char ACTION_RESULT_SERVICE_SUFFIX[] = "_GetResult";
constexpr char ACTION_FEEDBACK_MESSAGE_SUFFIX[] = "_FeedbackMessage";

enum struct MessageDefinitionFormat {
  IDL,
  MSG,
};

struct MessageSpec {
  MessageSpec(MessageDefinitionFormat format, std::string text, const std::string& package_context);
  const std::set<std::string> dependencies;
  const std::string text;
  MessageDefinitionFormat format;
};

struct DefinitionIdentifier {
  MessageDefinitionFormat format;
  std::string package_resource_name;

  bool operator==(const DefinitionIdentifier& di) const {
    return (format == di.format) && (package_resource_name == di.package_resource_name);
  }
};

class DefinitionNotFoundError : public std::exception {
private:
  std::string name_;

public:
  explicit DefinitionNotFoundError(std::string name)
      : name_(std::move(name)) {}

  const char* what() const noexcept override {
    return name_.c_str();
  }
};

class MessageDefinitionCache final {
public:
  /**
   * Concatenate the message definition with its dependencies into a self-contained schema.
   * The format is different for MSG and IDL definitions, and is described fully here:
   * [MSG](https://mcap.dev/specification/appendix.html#ros2msg-data-format)
   * [IDL](https://mcap.dev/specification/appendix.html#ros2idl-data-format)
   * Throws DefinitionNotFoundError if one or more definition files are missing for the given
   * package resource name.
   */
  std::pair<MessageDefinitionFormat, const std::string&> get_full_text(
    const std::string& package_resource_name);

private:
  struct DefinitionIdentifierHash {
    std::size_t operator()(const DefinitionIdentifier& di) const {
      std::size_t h1 = std::hash<MessageDefinitionFormat>()(di.format);
      std::size_t h2 = std::hash<std::string>()(di.package_resource_name);
      return h1 ^ h2;
    }
  };
  /**
   * Load and parse the message file referenced by the given datatype, or return it from
   * msg_specs_by_datatype
   */
  const MessageSpec& load_message_spec(const DefinitionIdentifier& definition_identifier);

  std::unordered_map<DefinitionIdentifier, MessageSpec, DefinitionIdentifierHash>
    msg_specs_by_definition_identifier_;
  std::unordered_map<std::string, std::string> full_text_cache_;
};

std::set<std::string> parse_dependencies(MessageDefinitionFormat format, const std::string& text,
                                         const std::string& package_context);

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/param_utils.hpp
================================================
#pragma once

#include <regex>
#include <string>
#include <vector>

#include <rclcpp/node.hpp>

namespace foxglove_bridge {

constexpr char PARAM_PORT[] = "port";
constexpr char PARAM_ADDRESS[] = "address";
constexpr char PARAM_SEND_BUFFER_LIMIT[] = "send_buffer_limit";
constexpr char PARAM_USETLS[] = "tls";
constexpr char PARAM_CERTFILE[] = "certfile";
constexpr char PARAM_KEYFILE[] = "keyfile";
constexpr char PARAM_MIN_QOS_DEPTH[] = "min_qos_depth";
constexpr char PARAM_MAX_QOS_DEPTH[] = "max_qos_depth";
constexpr char PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST[] = "best_effort_qos_topic_whitelist";
constexpr char PARAM_TOPIC_WHITELIST[] = "topic_whitelist";
constexpr char PARAM_SERVICE_WHITELIST[] = "service_whitelist";
constexpr char PARAM_PARAMETER_WHITELIST[] = "param_whitelist";
constexpr char PARAM_USE_COMPRESSION[] = "use_compression";
constexpr char PARAM_CAPABILITIES[] = "capabilities";
constexpr char PARAM_CLIENT_TOPIC_WHITELIST[] = "client_topic_whitelist";
constexpr char PARAM_INCLUDE_HIDDEN[] = "include_hidden";
constexpr char PARAM_DISABLE_LOAN_MESSAGE[] = "disable_load_message";
constexpr char PARAM_ASSET_URI_ALLOWLIST[] = "asset_uri_allowlist";
constexpr char PARAM_IGN_UNRESPONSIVE_PARAM_NODES[] = "ignore_unresponsive_param_nodes";

constexpr int64_t DEFAULT_PORT = 8765;
constexpr char DEFAULT_ADDRESS[] = "0.0.0.0";
constexpr int64_t DEFAULT_SEND_BUFFER_LIMIT = 10000000;
constexpr int64_t DEFAULT_MIN_QOS_DEPTH = 1;
constexpr int64_t DEFAULT_MAX_QOS_DEPTH = 25;

void declareParameters(rclcpp::Node* node);

std::vector<std::regex> parseRegexStrings(rclcpp::Node* node,
                                          const std::vector<std::string>& strings);

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/parameter_interface.hpp
================================================
#pragma once

#include <chrono>
#include <functional>
#include <mutex>
#include <regex>
#include <string>
#include <unordered_set>
#include <vector>

#include <rclcpp/rclcpp.hpp>

#include <foxglove/server/parameter.hpp>

namespace foxglove_bridge {

using ParameterList = std::vector<foxglove::Parameter>;
using ParamUpdateFunc = std::function<void(const ParameterList&)>;

enum class UnresponsiveNodePolicy {
  Ignore,
  Retry,
};

class ParameterInterface {
public:
  ParameterInterface(rclcpp::Node* node, std::vector<std::regex> paramWhitelistPatterns,
                     UnresponsiveNodePolicy unresponsiveNodePolicy);

  ParameterList getParams(const std::vector<std::string_view>& paramNames,
                          const std::chrono::duration<double>& timeout);
  void setParams(const ParameterList& params, const std::chrono::duration<double>& timeout);
  void subscribeParams(const std::vector<std::string_view>& paramNames);
  void unsubscribeParams(const std::vector<std::string_view>& paramNames);
  void setParamUpdateCallback(ParamUpdateFunc paramUpdateFunc);

  static ParameterList cloneParameterList(const ParameterList& other);

private:
  rclcpp::Node* _node;
  std::vector<std::regex> _paramWhitelistPatterns;
  rclcpp::CallbackGroup::SharedPtr _callbackGroup;
  std::mutex _mutex;
  std::unordered_map<std::string, rclcpp::AsyncParametersClient::SharedPtr> _paramClientsByNode;
  std::unordered_map<std::string, std::unordered_set<std::string>> _subscribedParamsByNode;
  std::unordered_map<std::string, rclcpp::SubscriptionBase::SharedPtr> _paramSubscriptionsByNode;
  std::unordered_set<std::string> _ignoredNodeNames;
  UnresponsiveNodePolicy _unresponsiveNodePolicy;
  ParamUpdateFunc _paramUpdateFunc;

  ParameterList getNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                                  const std::string& nodeName,
                                  const std::vector<std::string>& paramNames,
                                  const std::chrono::duration<double>& timeout);
  void setNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                         const std::string& nodeName, const std::vector<rclcpp::Parameter>& params,
                         const std::chrono::duration<double>& timeout);
  bool isWhitelistedParam(const std::string& paramName);
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/ros2_foxglove_bridge.hpp
================================================
#pragma once

#include <atomic>
#include <chrono>
#include <memory>
#include <regex>
#include <thread>

#include <rclcpp/rclcpp.hpp>
#include <rosgraph_msgs/msg/clock.hpp>
#include <rosx_introspection/ros_parser.hpp>
#include <websocketpp/common/connection_hdl.hpp>

#include <foxglove/foxglove.hpp>
#include <foxglove/server.hpp>
#include <foxglove/server/fetch_asset.hpp>
#include <foxglove_bridge/generic_client.hpp>
#include <foxglove_bridge/message_definition_cache.hpp>
#include <foxglove_bridge/param_utils.hpp>
#include <foxglove_bridge/parameter_interface.hpp>
#include <foxglove_bridge/utils.hpp>

namespace foxglove_bridge {

extern const char FOXGLOVE_BRIDGE_VERSION[];
extern const char FOXGLOVE_BRIDGE_GIT_HASH[];

using Subscription = rclcpp::GenericSubscription::SharedPtr;
using Publication = rclcpp::GenericPublisher::SharedPtr;

using MapOfSets = std::unordered_map<std::string, std::unordered_set<std::string>>;
using ServicesByType = std::unordered_map<std::string, std::string>;

using ClientId = uint32_t;
using SinkId = uint64_t;
using ChannelId = uint64_t;
using ChannelAndClientId = std::pair<ChannelId, ClientId>;
struct ClientAdvertisement {
  Publication publisher;
  std::string topicName;
  std::string topicType;
  std::string encoding;
};

class ClientChannelError : public std::runtime_error {
public:
  ClientChannelError(const std::string& msg)
      : std::runtime_error(msg){};
};

class FoxgloveBridge : public rclcpp::Node {
public:
  using TopicAndDatatype = std::pair<std::string, std::string>;

  FoxgloveBridge(const rclcpp::NodeOptions& options = rclcpp::NodeOptions());

  ~FoxgloveBridge();

  void rosgraphPollThread();

  void updateAdvertisedTopics(
    const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes);

  void updateAdvertisedServices();

  void updateConnectionGraph(
    const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes);

private:
  struct PairHash {
    template <class T1, class T2>
    std::size_t operator()(const std::pair<T1, T2>& pair) const {
      return std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);
    }
  };

  std::unique_ptr<foxglove::WebSocketServer> _server;
  std::unordered_map<ChannelId, foxglove::RawChannel> _channels;
  std::unordered_map<ChannelAndClientId, Subscription, PairHash> _subscriptions;
  std::unordered_map<ChannelAndClientId, ClientAdvertisement, PairHash> _clientAdvertisedTopics;
  foxglove::WebSocketServerCapabilities _capabilities;
  ServicesByType _advertisedServices;
  std::unordered_map<std::string, GenericClient::SharedPtr> _serviceClients;
  std::unordered_map<std::string, std::unique_ptr<foxglove::ServiceHandler>> _serviceHandlers;

  foxglove_bridge::MessageDefinitionCache _messageDefinitionCache;
  std::vector<std::regex> _topicWhitelistPatterns;
  std::vector<std::regex> _serviceWhitelistPatterns;
  std::vector<std::regex> _assetUriAllowlistPatterns;
  std::vector<std::regex> _bestEffortQosTopicWhiteListPatterns;
  std::shared_ptr<ParameterInterface> _paramInterface;
  rclcpp::CallbackGroup::SharedPtr _subscriptionCallbackGroup;
  rclcpp::CallbackGroup::SharedPtr _clientPublishCallbackGroup;
  rclcpp::CallbackGroup::SharedPtr _servicesCallbackGroup;
  std::mutex _subscriptionsMutex;
  std::mutex _clientAdvertisementsMutex;
  std::mutex _servicesMutex;
  std::unique_ptr<std::thread> _rosgraphPollThread;
  size_t _minQosDepth = DEFAULT_MIN_QOS_DEPTH;
  size_t _maxQosDepth = DEFAULT_MAX_QOS_DEPTH;
  std::shared_ptr<rclcpp::Subscription<rosgraph_msgs::msg::Clock>> _clockSubscription;
  bool _useSimTime = false;
  std::atomic<bool> _subscribeGraphUpdates = false;
  bool _includeHidden = false;
  bool _disableLoanMessage = true;
  std::unordered_map<std::string, std::shared_ptr<RosMsgParser::Parser>> _jsonParsers;
  std::atomic<bool> _shuttingDown = false;

  void subscribeConnectionGraph(bool subscribe);

  void subscribe(ChannelId channelId, const foxglove::ClientMetadata& client);

  void unsubscribe(ChannelId channelId, const foxglove::ClientMetadata& client);

  void clientAdvertise(ClientId clientId, const foxglove::ClientChannel& channel);

  void clientUnadvertise(ClientId clientId, ChannelId clientChannelId);

  void clientMessage(ClientId clientId, ChannelId clientChannelId, const std::byte* data,
                     size_t dataLen);

  std::vector<foxglove::Parameter> setParameters(
    const uint32_t clientId, const std::optional<std::string_view>& requestId,
    const std::vector<foxglove::ParameterView>& parameterViews);

  std::vector<foxglove::Parameter> getParameters(
    const uint32_t clientId, const std::optional<std::string_view>& requestId,
    const std::vector<std::string_view>& parameterNames);

  void subscribeParameters(const std::vector<std::string_view>& parameterNames);

  void unsubscribeParameters(const std::vector<std::string_view>& parameterNames);

  void parameterUpdates(const std::vector<foxglove::Parameter>& parameters);

  void rosMessageHandler(ChannelId channelId, SinkId sinkId,
                         std::shared_ptr<const rclcpp::SerializedMessage> msg);

  void handleServiceRequest(const foxglove::ServiceRequest& request,
                            foxglove::ServiceResponder&& responder);

  void fetchAsset(const std::string_view uri, foxglove::FetchAssetResponder&& responder);

  rclcpp::QoS determineQoS(const std::string& topic);
};

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/utils.hpp
================================================
#pragma once

#include <algorithm>
#include <regex>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

namespace foxglove_bridge {

inline bool isWhitelisted(const std::string& name, const std::vector<std::regex>& regexPatterns) {
  return std::find_if(regexPatterns.begin(), regexPatterns.end(), [name](const auto& regex) {
           return std::regex_match(name, regex);
         }) != regexPatterns.end();
}

inline std::pair<std::string, std::string> getNodeAndNodeNamespace(const std::string& fqnNodeName) {
  const std::size_t found = fqnNodeName.find_last_of("/");
  if (found == std::string::npos) {
    throw std::runtime_error("Invalid fully qualified node name: " + fqnNodeName);
  }
  return std::make_pair(fqnNodeName.substr(0, found), fqnNodeName.substr(found + 1));
}

inline std::string trimString(std::string& str) {
  constexpr char whitespaces[] = "\t\n\r ";
  str.erase(0, str.find_first_not_of(whitespaces));  // trim left
  str.erase(str.find_last_not_of(whitespaces) + 1);  // trim right
  return str;
}

inline std::vector<std::string> splitMessageDefinitions(std::istream& stream) {
  std::vector<std::string> definitions;

  std::string line = "";
  std::string definition = "";

  while (std::getline(stream, line)) {
    line = trimString(line);
    if (line == "---") {
      definitions.push_back(trimString(definition));
      definition = "";
    } else {
      definition += line + "\n";
    }
  }

  definitions.push_back(trimString(definition));
  return definitions;
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/version.hpp.in
================================================
#pragma once
namespace foxglove_bridge {

const char FOXGLOVE_BRIDGE_VERSION[] = "@FOXGLOVE_BRIDGE_VERSION@";

const char FOXGLOVE_BRIDGE_GIT_HASH[] = "@FOXGLOVE_BRIDGE_GIT_HASH@";

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/test/protocol_types.hpp
================================================
#pragma once

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <variant>
#include <vector>

#include <foxglove/server/parameter.hpp>

namespace foxglove::test {

// Protocol type aliases
using ChannelId = uint64_t;
using SubscriptionId = uint32_t;
using ClientChannelId = uint32_t;
using ServiceId = uint32_t;
using CallId = uint32_t;

// Protocol opcode and status enums
enum class ClientBinaryOpcode : uint8_t {
  MESSAGE_DATA = 1,
  SERVICE_CALL_REQUEST = 2,
};

enum class ServerBinaryOpcode : uint8_t {
  MESSAGE_DATA = 1,
  TIME = 2,
  SERVICE_CALL_RESPONSE = 3,
  FETCH_ASSET_RESPONSE = 4,
};

enum class FetchAssetStatus : uint8_t {
  Success = 0,
  Error = 1,
};

// Stub data structures corresponding to protocol messages. Used to wrap the values returned by the
// server and use them in test assertions.
struct Channel {
  ChannelId id;
  std::string topic;
  std::string encoding;
  std::string schemaName;
  std::string schema;
  std::optional<std::string> schemaEncoding;
};

struct Service {
  ServiceId id;
  std::string name;
  std::string type;
  std::string requestType;
  std::string requestSchema;
  std::string responseType;
  std::string responseSchema;
};

struct ServiceRequest {
  ServiceId serviceId;
  CallId callId;
  std::string encoding;
  std::vector<std::byte> data;
};

struct ServiceResponse {
  ServiceId serviceId;
  CallId callId;
  std::string encoding;
  std::vector<std::byte> data;
};

struct FetchAssetResponse {
  uint32_t requestId;
  FetchAssetStatus status;
  std::string errorMessage;
  std::vector<uint8_t> data;
};

struct ClientAdvertisement {
  ClientChannelId channelId;
  std::string topic;
  std::string encoding;
  std::string schemaName;
  std::vector<char> schema;
};

}  // namespace foxglove::test



================================================
FILE: ros2_foxglove_bridge_sdk/include/foxglove_bridge/test/test_client.hpp
================================================
#pragma once

#include <functional>
#include <future>
#include <optional>
#include <shared_mutex>
#include <utility>
#include <vector>

#include <nlohmann/json.hpp>
#include <websocketpp/client.hpp>
#include <websocketpp/common/memory.hpp>
#include <websocketpp/common/thread.hpp>

#include "protocol_types.hpp"

namespace foxglove::test {

inline void WriteUint32LE(uint8_t* buf, uint32_t val) {
  buf[0] = static_cast<uint8_t>(val & 0xFF);
  buf[1] = static_cast<uint8_t>((val >> 8) & 0xFF);
  buf[2] = static_cast<uint8_t>((val >> 16) & 0xFF);
  buf[3] = static_cast<uint8_t>((val >> 24) & 0xFF);
}

inline uint32_t ReadUint32LE(const uint8_t* buf) {
  return static_cast<uint32_t>(buf[0]) | (static_cast<uint32_t>(buf[1]) << 8) |
         (static_cast<uint32_t>(buf[2]) << 16) | (static_cast<uint32_t>(buf[3]) << 24);
}

inline void from_json(const nlohmann::json& j, foxglove::ParameterValue& p) {
  if (j.is_string()) {
    p = foxglove::ParameterValue(j.get<std::string>());
  } else if (j.is_number_integer()) {
    p = foxglove::ParameterValue(j.get<int64_t>());
  } else if (j.is_number_float()) {
    p = foxglove::ParameterValue(j.get<double>());
  } else if (j.is_boolean()) {
    p = foxglove::ParameterValue(j.get<bool>());
  } else if (j.is_array()) {
    std::vector<foxglove::ParameterValue> values;
    for (const auto& value : j) {
      foxglove::ParameterValue paramValue("dummy");
      from_json(value, paramValue);
      values.emplace_back(std::move(paramValue));
    }
    p = foxglove::ParameterValue(std::move(values));
  } else {
    throw std::runtime_error("Encountered unknown type for ParameterValue");
  }
}

inline void from_json(const nlohmann::json& j, foxglove::Parameter& p) {
  std::string name = j["name"].get<std::string>();
  if (j["value"].is_string()) {
    p = foxglove::Parameter(name, j["value"].get<std::string>());
  } else if (j["value"].is_number_integer()) {
    p = foxglove::Parameter(name, j["value"].get<int64_t>());
  } else if (j["value"].is_number_float()) {
    p = foxglove::Parameter(name, j["value"].get<double>());
  } else if (j["value"].is_boolean()) {
    p = foxglove::Parameter(name, j["value"].get<bool>());
  } else if (j["value"].is_array()) {
    std::vector<foxglove::ParameterValue> values;
    for (const auto& value : j["value"]) {
      foxglove::ParameterValue paramValue("dummy");
      from_json(value, paramValue);
      values.emplace_back(std::move(paramValue));
    }
    foxglove::ParameterType type = foxglove::ParameterType::None;
    if (j.contains("type")) {
      std::string typeStr = j["type"].get<std::string>();
      if (typeStr == "float64") {
        type = foxglove::ParameterType::Float64;
      } else if (typeStr == "float64_array") {
        type = foxglove::ParameterType::Float64Array;
      } else if (typeStr == "byte_array") {
        type = foxglove::ParameterType::ByteArray;
      } else {
        throw std::runtime_error("Encountered unknown type: " + typeStr);
      }
    }

    p = foxglove::Parameter(name, type, foxglove::ParameterValue(std::move(values)));
  } else {
    throw std::runtime_error("Encountered unknown type for parameter " +
                             j["name"].get<std::string>());
  }
}

inline void from_json(const nlohmann::json& j, std::vector<foxglove::Parameter>& parameters) {
  for (const auto& parameter : j) {
    // Required to pass by reference to from_json, actual initialization will happen there
    foxglove::Parameter param("dummy");
    from_json(parameter, param);
    parameters.push_back(std::move(param));
  }
}

inline void to_json(nlohmann::json& j, const foxglove::ParameterValueView& p) {
  if (p.is<std::string>()) {
    j = p.get<std::string>();
  } else if (p.is<int64_t>()) {
    j = p.get<int64_t>();
  } else if (p.is<double>()) {
    j = p.get<double>();
  } else if (p.is<bool>()) {
    j = p.get<bool>();
  } else if (p.is<std::vector<foxglove::ParameterValueView>>()) {
    j = nlohmann::json::array();
    for (const auto& value : p.get<std::vector<foxglove::ParameterValueView>>()) {
      nlohmann::json valueJson;
      to_json(valueJson, value);
      j.push_back(std::move(valueJson));
    }
  } else {
    throw std::runtime_error("Encountered unknown type for ParameterValueView");
  }
}

inline void to_json(nlohmann::json& j, const foxglove::ParameterValue& p) {
  to_json(j, p.view());
}

inline void to_json(nlohmann::json& j, const foxglove::Parameter& p) {
  j["name"] = p.name();
  if (p.hasValue()) {
    to_json(j["value"], p.value().value());
  }
}

inline void to_json(nlohmann::json& j, const std::vector<foxglove::Parameter>& parameters) {
  j = nlohmann::json::array();
  for (const auto& parameter : parameters) {
    nlohmann::json parameterJson;
    to_json(parameterJson, parameter);
    j.push_back(std::move(parameterJson));
  }
}

inline void to_json(nlohmann::json& j, const ClientAdvertisement& p) {
  j = nlohmann::json{{"id", p.channelId},
                     {"topic", p.topic},
                     {"encoding", p.encoding},
                     {"schemaName", p.schemaName}};
}

inline void from_json(const nlohmann::json& j, Channel& c) {
  c.id = j["id"].get<uint32_t>();
  c.topic = j["topic"].get<std::string>();
  c.encoding = j["encoding"].get<std::string>();
  c.schemaName = j["schemaName"].get<std::string>();
  c.schema = j["schema"].get<std::string>();
  if (j.find("schemaEncoding") != j.end()) {
    c.schemaEncoding = j["schemaEncoding"].get<std::string>();
  }
}

inline void from_json(const nlohmann::json& j, Service& s) {
  s.id = j["id"].get<uint32_t>();
  s.name = j["name"].get<std::string>();
  s.type = j["type"].get<std::string>();
  s.requestType = j["request"]["schemaName"].get<std::string>();
  s.requestSchema = j["request"]["schema"].get<std::string>();
  s.responseType = j["response"]["schemaName"].get<std::string>();
  s.responseSchema = j["response"]["schema"].get<std::string>();
}

using TextMessageHandler = std::function<void(const std::string&)>;
using BinaryMessageHandler = std::function<void(const uint8_t*, size_t)>;
using OpCode = websocketpp::frame::opcode::value;

template <typename ClientConfiguration>
class Client {
public:
  using ClientType = websocketpp::client<ClientConfiguration>;
  using MessagePtr = typename ClientType::message_ptr;
  using ConnectionPtr = typename ClientType::connection_ptr;

  Client() {
    _endpoint.clear_access_channels(websocketpp::log::alevel::all);
    _endpoint.clear_error_channels(websocketpp::log::elevel::all);

    _endpoint.init_asio();
    _endpoint.start_perpetual();

    _endpoint.set_message_handler(
      bind(&Client::messageHandler, this, std::placeholders::_1, std::placeholders::_2));

    _thread.reset(new websocketpp::lib::thread(&ClientType::run, &_endpoint));
  }

  virtual ~Client() {
    close();
    _endpoint.stop_perpetual();
    _thread->join();
  }

  void connect(const std::string& uri,
               std::function<void(websocketpp::connection_hdl)> onOpenHandler,
               std::function<void(websocketpp::connection_hdl)> onCloseHandler = nullptr) {
    std::unique_lock<std::shared_mutex> lock(_mutex);

    websocketpp::lib::error_code ec;
    _con = _endpoint.get_connection(uri, ec);

    if (ec) {
      throw std::runtime_error("Failed to get connection from URI " + uri);
    }

    if (onOpenHandler) {
      _con->set_open_handler(onOpenHandler);
    }
    if (onCloseHandler) {
      _con->set_close_handler(onCloseHandler);
    }

    _con->add_subprotocol(SUPPORTED_SUBPROTOCOL);
    _endpoint.connect(_con);
  }

  std::future<void> connect(const std::string& uri) {
    auto promise = std::make_shared<std::promise<void>>();
    auto future = promise->get_future();

    connect(uri, [p = std::move(promise)](websocketpp::connection_hdl) mutable {
      p->set_value();
    });

    return future;
  }

  void close() {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    if (!_con) {
      return;  // Already disconnected
    }

    _endpoint.close(_con, websocketpp::close::status::going_away, "");
    _con.reset();
  }

  void messageHandler(websocketpp::connection_hdl hdl, MessagePtr msg) {
    (void)hdl;
    const OpCode op = msg->get_opcode();

    switch (op) {
      case OpCode::TEXT: {
        std::shared_lock<std::shared_mutex> lock(_mutex);
        if (_textMessageHandler) {
          _textMessageHandler(msg->get_payload());
        }
      } break;
      case OpCode::BINARY: {
        std::shared_lock<std::shared_mutex> lock(_mutex);
        const auto& payload = msg->get_payload();
        if (_binaryMessageHandler) {
          _binaryMessageHandler(reinterpret_cast<const uint8_t*>(payload.data()), payload.size());
        }
      } break;
      default:
        break;
    }
  }

  void subscribe(const std::vector<std::pair<SubscriptionId, ChannelId>>& subscriptions) {
    nlohmann::json subscriptionsJson;
    for (const auto& [subId, channelId] : subscriptions) {
      subscriptionsJson.push_back({{"id", subId}, {"channelId", channelId}});
    }

    const std::string payload =
      nlohmann::json{{"op", "subscribe"}, {"subscriptions", std::move(subscriptionsJson)}}.dump();
    sendText(payload);
  }

  void unsubscribe(const std::vector<SubscriptionId>& subscriptionIds) {
    const std::string payload =
      nlohmann::json{{"op", "unsubscribe"}, {"subscriptionIds", subscriptionIds}}.dump();
    sendText(payload);
  }

  void advertise(const std::vector<ClientAdvertisement>& channels) {
    const std::string payload = nlohmann::json{{"op", "advertise"}, {"channels", channels}}.dump();
    sendText(payload);
  }

  void unadvertise(const std::vector<ClientChannelId>& channelIds) {
    const std::string payload =
      nlohmann::json{{"op", "unadvertise"}, {"channelIds", channelIds}}.dump();
    sendText(payload);
  }

  void publish(ClientChannelId channelId, const uint8_t* buffer, size_t size) {
    std::vector<uint8_t> payload(1 + 4 + size);
    payload[0] = uint8_t(ClientBinaryOpcode::MESSAGE_DATA);
    WriteUint32LE(payload.data() + 1, channelId);
    std::memcpy(payload.data() + 1 + 4, buffer, size);
    sendBinary(payload.data(), payload.size());
  }

  void sendServiceRequest(const ServiceRequest& request) {
    size_t payloadSize = 1 + 4 + 4 + 4 + request.encoding.size() + request.data.size();
    std::vector<uint8_t> payload(payloadSize);

    payload[0] = uint8_t(ClientBinaryOpcode::SERVICE_CALL_REQUEST);
    size_t offset = 1;
    WriteUint32LE(payload.data() + offset, request.serviceId);
    offset += 4;
    WriteUint32LE(payload.data() + offset, request.callId);
    offset += 4;
    uint32_t encodingLength = request.encoding.size();
    WriteUint32LE(payload.data() + offset, encodingLength);
    offset += 4;
    std::memcpy(payload.data() + offset, request.encoding.data(), encodingLength);
    offset += encodingLength;

    if (request.data.size() > 0) {
      std::memcpy(payload.data() + offset, request.data.data(), request.data.size());
    }

    sendBinary(payload.data(), payload.size());
  }

  void getParameters(const std::vector<std::string>& parameterNames,
                     const std::optional<std::string>& requestId = std::nullopt) {
    nlohmann::json jsonPayload{{"op", "getParameters"}, {"parameterNames", parameterNames}};
    if (requestId) {
      jsonPayload["id"] = requestId.value();
    }
    sendText(jsonPayload.dump());
  }

  void setParameters(const std::vector<foxglove::Parameter>& parameters,
                     const std::optional<std::string>& requestId = std::nullopt) {
    nlohmann::json parametersJson;
    to_json(parametersJson, parameters);
    nlohmann::json jsonPayload{{"op", "setParameters"}, {"parameters", parametersJson}};
    if (requestId) {
      jsonPayload["id"] = requestId.value();
    }
    sendText(jsonPayload.dump());
  }

  void subscribeParameterUpdates(const std::vector<std::string>& parameterNames) {
    nlohmann::json jsonPayload{{"op", "subscribeParameterUpdates"},
                               {"parameterNames", parameterNames}};
    sendText(jsonPayload.dump());
  }

  void unsubscribeParameterUpdates(const std::vector<std::string>& parameterNames) {
    nlohmann::json jsonPayload{{"op", "unsubscribeParameterUpdates"},
                               {"parameterNames", parameterNames}};
    sendText(jsonPayload.dump());
  }

  void fetchAsset(const std::string& uri, uint32_t requestId) {
    nlohmann::json jsonPayload{{"op", "fetchAsset"}, {"uri", uri}, {"requestId", requestId}};
    sendText(jsonPayload.dump());
  }

  void setTextMessageHandler(TextMessageHandler handler) {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    _textMessageHandler = std::move(handler);
  }

  void setBinaryMessageHandler(BinaryMessageHandler handler) {
    std::unique_lock<std::shared_mutex> lock(_mutex);
    _binaryMessageHandler = std::move(handler);
  }

  void sendText(const std::string& payload) {
    std::shared_lock<std::shared_mutex> lock(_mutex);
    _endpoint.send(_con, payload, OpCode::TEXT);
  }

  void sendBinary(const uint8_t* data, size_t dataLength) {
    std::shared_lock<std::shared_mutex> lock(_mutex);
    _endpoint.send(_con, data, dataLength, OpCode::BINARY);
  }

  std::future<std::vector<uint8_t>> waitForChannelMsg(SubscriptionId subscriptionId) {
    // Set up binary message handler to resolve when a binary message has been received
    auto promise = std::make_shared<std::promise<std::vector<uint8_t>>>();
    auto future = promise->get_future();

    setBinaryMessageHandler(
      [promise = std::move(promise), subscriptionId](const uint8_t* data, size_t dataLength) {
        if (ReadUint32LE(data + 1) != subscriptionId) {
          return;
        }
        const size_t offset = 1 + 4 + 8;
        std::vector<uint8_t> dataCopy(dataLength - offset);
        std::memcpy(dataCopy.data(), data + offset, dataLength - offset);
        promise->set_value(std::move(dataCopy));
      });

    return future;
  }

  std::future<std::vector<foxglove::Parameter>> waitForParameters(
    const std::string& requestId = std::string()) {
    auto promise = std::make_shared<std::promise<std::vector<foxglove::Parameter>>>();
    auto future = promise->get_future();

    setTextMessageHandler([promise = std::move(promise), requestId](const std::string& payload) {
      const auto msg = nlohmann::json::parse(payload);
      const auto& op = msg["op"].get<std::string>();
      const auto id = msg.value("id", "");

      if (op == "parameterValues" && (requestId.empty() || requestId == id)) {
        std::vector<foxglove::Parameter> parameters;
        from_json(msg["parameters"], parameters);
        promise->set_value(std::move(parameters));
      }
    });

    return future;
  }

  std::future<ServiceResponse> waitForServiceResponse() {
    auto promise = std::make_shared<std::promise<ServiceResponse>>();
    auto future = promise->get_future();

    setBinaryMessageHandler([promise = std::move(promise)](const uint8_t* data,
                                                           size_t dataLength) mutable {
      if (static_cast<ServerBinaryOpcode>(data[0]) != ServerBinaryOpcode::SERVICE_CALL_RESPONSE) {
        return;
      }

      // Deserialize response
      ServiceResponse response;
      size_t offset = 1;
      response.serviceId = ReadUint32LE(data + offset);
      offset += 4;
      response.callId = ReadUint32LE(data + offset);
      offset += 4;
      const size_t encodingLength = ReadUint32LE(data + offset);
      offset += 4;
      response.encoding = std::string(reinterpret_cast<const char*>(data + offset), encodingLength);
      offset += encodingLength;
      const auto payloadLength = dataLength - offset;
      response.data.resize(payloadLength);
      std::memcpy(response.data.data(), data + offset, payloadLength);

      promise->set_value(response);
    });
    return future;
  }

  std::future<Service> waitForService(const std::string& serviceName) {
    auto promise = std::make_shared<std::promise<Service>>();
    auto future = promise->get_future();

    setTextMessageHandler(
      [promise = std::move(promise), serviceName](const std::string& payload) mutable {
        const auto msg = nlohmann::json::parse(payload);
        const auto& op = msg["op"].get<std::string>();

        if (op == "advertiseServices") {
          const auto services = msg["services"].get<std::vector<Service>>();
          for (const auto& service : services) {
            if (service.name == serviceName) {
              promise->set_value(service);
              break;
            }
          }
        }
      });

    return future;
  }

  std::future<Channel> waitForChannel(const std::string& topicName) {
    auto promise = std::make_shared<std::promise<Channel>>();
    auto future = promise->get_future();

    setTextMessageHandler(
      [promise = std::move(promise), topicName](const std::string& payload) mutable {
        const auto msg = nlohmann::json::parse(payload);
        const auto& op = msg["op"].get<std::string>();

        if (op == "advertise") {
          const auto channels = msg["channels"].get<std::vector<Channel>>();
          for (const auto& channel : channels) {
            if (channel.topic == topicName) {
              promise->set_value(channel);
              break;
            }
          }
        }
      });
    return future;
  }

  std::future<FetchAssetResponse> waitForFetchAssetResponse() {
    auto promise = std::make_shared<std::promise<FetchAssetResponse>>();
    auto future = promise->get_future();

    setBinaryMessageHandler(
      [promise = std::move(promise)](const uint8_t* data, size_t dataLength) mutable {
        if (static_cast<ServerBinaryOpcode>(data[0]) != ServerBinaryOpcode::FETCH_ASSET_RESPONSE) {
          return;
        }

        FetchAssetResponse response;
        size_t offset = 1;
        response.requestId = ReadUint32LE(data + offset);
        offset += 4;
        response.status = static_cast<FetchAssetStatus>(data[offset]);
        offset += 1;
        const size_t errorMsgLength = static_cast<size_t>(ReadUint32LE(data + offset));
        offset += 4;
        response.errorMessage =
          std::string(reinterpret_cast<const char*>(data + offset), errorMsgLength);
        offset += errorMsgLength;
        const auto payloadLength = dataLength - offset;

        response.data.resize(payloadLength);
        if (payloadLength > 0) {
          std::memcpy(response.data.data(), data + offset, payloadLength);
        }

        promise->set_value(response);
      });
    return future;
  }

protected:
  static constexpr char SUPPORTED_SUBPROTOCOL[] = "foxglove.sdk.v1";
  ClientType _endpoint;
  websocketpp::lib::shared_ptr<websocketpp::lib::thread> _thread;
  ConnectionPtr _con;
  std::shared_mutex _mutex;
  TextMessageHandler _textMessageHandler;
  BinaryMessageHandler _binaryMessageHandler;
};

}  // namespace foxglove::test



================================================
FILE: ros2_foxglove_bridge_sdk/launch/foxglove_bridge_launch.xml
================================================
<launch>
  <arg name="port"                            default="8765" />
  <arg name="address"                         default="0.0.0.0" />
  <arg name="tls"                             default="false" />
  <arg name="certfile"                        default="" />
  <arg name="keyfile"                         default="" />
  <arg name="topic_whitelist"                 default="['.*']" />
  <arg name="param_whitelist"                 default="['.*']" />
  <arg name="service_whitelist"               default="['.*']" />
  <arg name="client_topic_whitelist"          default="['.*']" />
  <arg name="min_qos_depth"                   default="1" />
  <arg name="max_qos_depth"                   default="10" />
  <arg name="num_threads"                     default="0" />
  <arg name="send_buffer_limit"               default="10000000" />
  <arg name="use_sim_time"                    default="false" />
  <arg name="capabilities"                    default="[clientPublish,parameters,parametersSubscribe,services,connectionGraph,assets]" />
  <arg name="include_hidden"                  default="false" />
  <arg name="asset_uri_allowlist"             default="['^package://(?:[-\\w%]+/)*[-\\w%.]+\\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$']" />  <!-- Needs double-escape -->
  <arg name="ignore_unresponsive_param_nodes" default="true" />

  <node pkg="foxglove_bridge" exec="foxglove_bridge">
    <param name="port"                            value="$(var port)" />
    <param name="address"                         value="$(var address)" />
    <param name="tls"                             value="$(var tls)" />
    <param name="certfile"                        value="$(var certfile)" />
    <param name="keyfile"                         value="$(var keyfile)" />
    <param name="topic_whitelist"                 value="$(var topic_whitelist)" />
    <param name="service_whitelist"               value="$(var service_whitelist)" />
    <param name="param_whitelist"                 value="$(var param_whitelist)" />
    <param name="client_topic_whitelist"          value="$(var client_topic_whitelist)" />
    <param name="min_qos_depth"                   value="$(var min_qos_depth)" />
    <param name="max_qos_depth"                   value="$(var max_qos_depth)" />
    <param name="num_threads"                     value="$(var num_threads)" />
    <param name="send_buffer_limit"               value="$(var send_buffer_limit)" />
    <param name="use_sim_time"                    value="$(var use_sim_time)" />
    <param name="capabilities"                    value="$(var capabilities)" />
    <param name="include_hidden"                  value="$(var include_hidden)" />
    <param name="asset_uri_allowlist"             value="$(var asset_uri_allowlist)" />
    <param name="ignore_unresponsive_param_nodes" value="$(var ignore_unresponsive_param_nodes)" />
  </node>
</launch>



================================================
FILE: ros2_foxglove_bridge_sdk/src/generic_client.cpp
================================================
#include <iostream>

#include <rclcpp/client.hpp>
#include <rclcpp/serialized_message.hpp>
#include <rclcpp/typesupport_helpers.hpp>
#include <rclcpp/version.h>
#include <rosidl_typesupport_introspection_cpp/field_types.hpp>
#include <rosidl_typesupport_introspection_cpp/service_introspection.hpp>

#include <foxglove_bridge/generic_client.hpp>

namespace {

// Copy of github.com/ros2/rclcpp/blob/33dae5d67/rclcpp/src/rclcpp/typesupport_helpers.cpp#L69-L92
static std::tuple<std::string, std::string, std::string> extract_type_identifier(
  const std::string& full_type) {
  char type_separator = '/';
  auto sep_position_back = full_type.find_last_of(type_separator);
  auto sep_position_front = full_type.find_first_of(type_separator);
  if (sep_position_back == std::string::npos || sep_position_back == 0 ||
      sep_position_back == full_type.length() - 1) {
    throw std::runtime_error(
      "Message type is not of the form package/type and cannot be processed");
  }

  std::string package_name = full_type.substr(0, sep_position_front);
  std::string middle_module = "";
  if (sep_position_back - sep_position_front > 0) {
    middle_module =
      full_type.substr(sep_position_front + 1, sep_position_back - sep_position_front - 1);
  }
  std::string type_name = full_type.substr(sep_position_back + 1);

  return std::make_tuple(package_name, middle_module, type_name);
}
}  // namespace

namespace foxglove_bridge {

constexpr char TYPESUPPORT_INTROSPECTION_LIB_NAME[] = "rosidl_typesupport_introspection_cpp";
constexpr char TYPESUPPORT_LIB_NAME[] = "rosidl_typesupport_cpp";
using rosidl_typesupport_introspection_cpp::MessageMembers;
using rosidl_typesupport_introspection_cpp::ServiceMembers;

std::shared_ptr<void> allocate_message(const MessageMembers* members) {
  void* buffer = malloc(members->size_of_);
  if (buffer == nullptr) {
    throw std::runtime_error("Failed to allocate memory");
  }
  memset(buffer, 0, members->size_of_);
  members->init_function(buffer, rosidl_runtime_cpp::MessageInitialization::ALL);
  return std::shared_ptr<void>(buffer, free);
}

std::string getTypeIntrospectionSymbolName(const std::string& serviceType) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);

  return std::string(TYPESUPPORT_INTROSPECTION_LIB_NAME) + "__get_service_type_support_handle__" +
         pkgName + "__" + (middleModule.empty() ? "srv" : middleModule) + "__" + typeName;
}

/**
 * The default symbol names for getting type support handles for services are missing from the
 * rosidl_typesupport_cpp shared libraries, see
 * https://github.com/ros2/rosidl_typesupport/issues/122
 *
 * We can however, as a (hacky) workaround, use other symbols defined in the shared library.
 * With `nm -C -D /opt/ros/humble/lib/libtest_msgs__rosidl_typesupport_cpp.so` we see that there is
 * `rosidl_service_type_support_t const*
 * rosidl_typesupport_cpp::get_service_type_support_handle<test_msgs::srv::BasicTypes>()` which
 * mangled becomes
 * `_ZN22rosidl_typesupport_cpp31get_service_type_support_handleIN9test_msgs3srv10BasicTypesEEEPK29rosidl_service_type_support_tv`
 * This is the same for galactic, humble and rolling (tested with gcc / clang)
 *
 * This function produces the mangled symbol name for a given service type.
 *
 * \param[in] serviceType The service type, e.g. "test_msgs/srv/BasicTypes"
 * \return Symbol name for getting the service type support handle
 */
std::string getServiceTypeSupportHandleSymbolName(const std::string& serviceType) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);
  const auto lengthPrefixedString = [](const std::string& s) {
    return std::to_string(s.size()) + s;
  };

  return "_ZN" + lengthPrefixedString(TYPESUPPORT_LIB_NAME) +
         lengthPrefixedString("get_service_type_support_handle") + "IN" +
         lengthPrefixedString(pkgName) +
         lengthPrefixedString(middleModule.empty() ? "srv" : middleModule) +
         lengthPrefixedString(typeName) + "EEEPK" +
         lengthPrefixedString("rosidl_service_type_support_t") + "v";
}

GenericClient::GenericClient(rclcpp::node_interfaces::NodeBaseInterface* nodeBase,
                             rclcpp::node_interfaces::NodeGraphInterface::SharedPtr nodeGraph,
                             std::string serviceName, std::string serviceType,
                             rcl_client_options_t& client_options)
    : rclcpp::ClientBase(nodeBase, nodeGraph) {
  const auto [pkgName, middleModule, typeName] = extract_type_identifier(serviceType);
  const auto requestTypeName = serviceType + "_Request";
  const auto responseTypeName = serviceType + "_Response";

  _typeSupportLib = rclcpp::get_typesupport_library(serviceType, TYPESUPPORT_LIB_NAME);
  _typeIntrospectionLib =
    rclcpp::get_typesupport_library(serviceType, TYPESUPPORT_INTROSPECTION_LIB_NAME);
  if (!_typeSupportLib || !_typeIntrospectionLib) {
    throw std::runtime_error("Failed to load shared library for service type " + serviceType);
  }

  const auto typesupportSymbolName = getServiceTypeSupportHandleSymbolName(serviceType);
  if (!_typeSupportLib->has_symbol(typesupportSymbolName)) {
    throw std::runtime_error("Failed to find symbol '" + typesupportSymbolName + "' in " +
                             _typeSupportLib->get_library_path());
  }

  const rosidl_service_type_support_t* (*get_ts)() = nullptr;
  _serviceTypeSupportHdl =
    (reinterpret_cast<decltype(get_ts)>(_typeSupportLib->get_symbol(typesupportSymbolName)))();

  const auto typeinstrospection_symbol_name = getTypeIntrospectionSymbolName(serviceType);

  // This will throw runtime_error if the symbol was not found.
  _typeIntrospectionHdl = (reinterpret_cast<decltype(get_ts)>(
    _typeIntrospectionLib->get_symbol(typeinstrospection_symbol_name)))();

  // get_typesupport_handle is deprecated since rclcpp 25.0.0
  // (https://github.com/ros2/rclcpp/pull/2209)
#if RCLCPP_VERSION_GTE(25, 0, 0)
  _requestTypeSupportHdl =
    rclcpp::get_message_typesupport_handle(requestTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
  _responseTypeSupportHdl = rclcpp::get_message_typesupport_handle(
    responseTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
#else
  _requestTypeSupportHdl =
    rclcpp::get_typesupport_handle(requestTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
  _responseTypeSupportHdl =
    rclcpp::get_typesupport_handle(responseTypeName, TYPESUPPORT_LIB_NAME, *_typeSupportLib);
#endif

  rcl_ret_t ret = rcl_client_init(this->get_client_handle().get(), this->get_rcl_node_handle(),
                                  _serviceTypeSupportHdl, serviceName.c_str(), &client_options);
  if (ret != RCL_RET_OK) {
    if (ret == RCL_RET_SERVICE_NAME_INVALID) {
      auto rcl_node_handle = this->get_rcl_node_handle();
      // this will throw on any validation problem
      rcl_reset_error();
      rclcpp::expand_topic_or_service_name(serviceName, rcl_node_get_name(rcl_node_handle),
                                           rcl_node_get_namespace(rcl_node_handle), true);
    }
    rclcpp::exceptions::throw_from_rcl_error(ret, "could not create client");
  }
}

std::shared_ptr<void> GenericClient::create_response() {
  auto srv_members = static_cast<const ServiceMembers*>(_typeIntrospectionHdl->data);
  return allocate_message(srv_members->response_members_);
}

std::shared_ptr<rmw_request_id_t> GenericClient::create_request_header() {
  return std::shared_ptr<rmw_request_id_t>(new rmw_request_id_t);
}

void GenericClient::handle_response(std::shared_ptr<rmw_request_id_t> request_header,
                                    std::shared_ptr<void> response) {
  std::unique_lock<std::mutex> lock(pending_requests_mutex_);
  int64_t sequence_number = request_header->sequence_number;

  auto ser_response = std::make_shared<rclcpp::SerializedMessage>();
  rmw_ret_t r = rmw_serialize(response.get(), _responseTypeSupportHdl,
                              &ser_response->get_rcl_serialized_message());
  if (r != RMW_RET_OK) {
    RCUTILS_LOG_ERROR_NAMED("foxglove_bridge", "Failed to serialize service response. Ignoring...");
    return;
  }

  // TODO(esteve) this should throw instead since it is not expected to happen in the first place
  if (this->pending_requests_.count(sequence_number) == 0) {
    RCUTILS_LOG_ERROR_NAMED("foxglove_bridge", "Received invalid sequence number. Ignoring...");
    return;
  }
  auto responder = std::move(this->pending_requests_.at(sequence_number));
  this->pending_requests_.erase(sequence_number);
  // Unlock here to allow the service to be called recursively from one of its callbacks.
  lock.unlock();

  std::move(responder).respondOk(
    reinterpret_cast<const std::byte*>(ser_response->get_rcl_serialized_message().buffer),
    ser_response->get_rcl_serialized_message().buffer_length);
}

void GenericClient::async_send_request(SharedRequest request,
                                       foxglove::ServiceResponder&& responder) {
  std::lock_guard<std::mutex> lock(pending_requests_mutex_);
  int64_t sequence_number;

  auto srv_members = static_cast<const ServiceMembers*>(_typeIntrospectionHdl->data);
  auto buf = allocate_message(srv_members->request_members_);

  const rmw_serialized_message_t* sm = &request->get_rcl_serialized_message();
  if (const auto ret = rmw_deserialize(sm, _requestTypeSupportHdl, buf.get()) != RCL_RET_OK) {
    rclcpp::exceptions::throw_from_rcl_error(ret, "failed to desirialize request");
  }
  rcl_ret_t ret = rcl_send_request(get_client_handle().get(), buf.get(), &sequence_number);
  if (RCL_RET_OK != ret) {
    rclcpp::exceptions::throw_from_rcl_error(ret, "failed to send request");
  }

  pending_requests_.emplace(sequence_number, std::move(responder));
}
}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/src/message_definition_cache.cpp
================================================
#include "foxglove_bridge/message_definition_cache.hpp"

#include <filesystem>
#include <fstream>
#include <functional>
#include <optional>
#include <regex>
#include <set>
#include <string>
#include <unordered_set>
#include <utility>

#include <ament_index_cpp/get_package_share_directory.hpp>
#include <ament_index_cpp/get_resource.hpp>
#include <ament_index_cpp/get_resources.hpp>
#include <rcutils/logging_macros.h>

#include "foxglove_bridge/utils.hpp"

namespace foxglove_bridge {

// Match datatype names (foo_msgs/Bar or foo_msgs/msg/Bar or foo_msgs/srv/Bar)
static const std::regex PACKAGE_TYPENAME_REGEX{
  R"(^([a-zA-Z0-9_]+)/(?:(msg|srv|action)/)?([a-zA-Z0-9_]+)$)"};

// Match field types from .msg definitions ("foo_msgs/Bar" in "foo_msgs/Bar[] bar")
static const std::regex MSG_FIELD_TYPE_REGEX{R"((?:^|\n)\s*([a-zA-Z0-9_/]+)(?:\[[^\]]*\])?\s+)"};

// match field types from `.idl` definitions ("foo_msgs/msg/bar" in #include <foo_msgs/msg/Bar.idl>)
static const std::regex IDL_FIELD_TYPE_REGEX{
  R"((?:^|\n)#include\s+(?:"|<)([a-zA-Z0-9_/]+)\.idl(?:"|>))"};

static const std::unordered_set<std::string> PRIMITIVE_TYPES{
  "bool",  "byte",   "char",  "float32", "float64", "int8",   "uint8",
  "int16", "uint16", "int32", "uint32",  "int64",   "uint64", "string"};

enum class DefinitionType {
  Message,
  Service,
  Action,
};

static std::set<std::string> parse_msg_dependencies(const std::string& text,
                                                    const std::string& package_context) {
  std::set<std::string> dependencies;

  for (std::sregex_iterator iter(text.begin(), text.end(), MSG_FIELD_TYPE_REGEX);
       iter != std::sregex_iterator(); ++iter) {
    std::string type = (*iter)[1];
    if (PRIMITIVE_TYPES.find(type) != PRIMITIVE_TYPES.end()) {
      continue;
    }
    if (type.find('/') == std::string::npos) {
      dependencies.insert(package_context + '/' + std::move(type));
    } else {
      dependencies.insert(std::move(type));
    }
  }
  return dependencies;
}

static std::set<std::string> parse_idl_dependencies(const std::string& text) {
  std::set<std::string> dependencies;

  for (std::sregex_iterator iter(text.begin(), text.end(), IDL_FIELD_TYPE_REGEX);
       iter != std::sregex_iterator(); ++iter) {
    dependencies.insert((*iter)[1]);
  }
  return dependencies;
}

std::set<std::string> parse_dependencies(MessageDefinitionFormat format, const std::string& text,
                                         const std::string& package_context) {
  switch (format) {
    case MessageDefinitionFormat::MSG:
      return parse_msg_dependencies(text, package_context);
    case MessageDefinitionFormat::IDL:
      return parse_idl_dependencies(text);
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
}

static const char* extension_for_format(MessageDefinitionFormat format,
                                        DefinitionType definitionType) {
  switch (format) {
    case MessageDefinitionFormat::MSG:
      switch (definitionType) {
        case DefinitionType::Message:
          return ".msg";
        case DefinitionType::Service:
          return ".srv";
        case DefinitionType::Action:
          return ".action";
        default:
          throw std::runtime_error("unknown definition type");
      }
    case MessageDefinitionFormat::IDL:
      return ".idl";
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
}

static std::string delimiter(const DefinitionIdentifier& definition_identifier) {
  std::string result =
    "================================================================================\n";
  switch (definition_identifier.format) {
    case MessageDefinitionFormat::MSG:
      result += "MSG: ";
      break;
    case MessageDefinitionFormat::IDL:
      result += "IDL: ";
      break;
    default:
      throw std::runtime_error("switch is not exhaustive");
  }
  result += definition_identifier.package_resource_name;
  result += "\n";
  return result;
}

static std::vector<std::string> split_string(const std::string& str,
                                             const std::string& delimiter = "\n") {
  std::vector<std::string> strings;
  std::string::size_type pos = 0;
  std::string::size_type prev = 0;

  while ((pos = str.find(delimiter, prev)) != std::string::npos) {
    strings.push_back(str.substr(prev, pos - prev));
    prev = pos + delimiter.size();
  }

  // Get the last substring (or only, if delimiter is not found)
  strings.push_back(str.substr(prev));

  return strings;
}

inline bool ends_with(const std::string& str, const std::string& suffix) {
  return str.size() >= suffix.size() &&
         0 == str.compare(str.size() - suffix.size(), suffix.size(), suffix);
}

std::string remove_action_subtype(const std::string action_type) {
  const auto action_subtype_suffixes = {
    std::string(ACTION_FEEDBACK_MESSAGE_SUFFIX),
    std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
    std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
    std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
    std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
  };

  for (const auto& suffix : action_subtype_suffixes) {
    if (ends_with(action_type, suffix)) {
      return action_type.substr(0, action_type.length() - suffix.length());
    }
  }

  return action_type;
}

std::string remove_service_subtype(const std::string service_type) {
  const std::vector<std::string> service_subtype_suffixes = {
    SERVICE_REQUEST_MESSAGE_SUFFIX,
    SERVICE_RESPONSE_MESSAGE_SUFFIX,
  };

  for (const auto& suffix : service_subtype_suffixes) {
    if (ends_with(service_type, suffix)) {
      return service_type.substr(0, service_type.length() - suffix.length());
    }
  }

  return service_type;
}

MessageSpec::MessageSpec(MessageDefinitionFormat format, std::string text,
                         const std::string& package_context)
    : dependencies(parse_dependencies(format, text, package_context))
    , text(std::move(text))
    , format(format) {}

const MessageSpec& MessageDefinitionCache::load_message_spec(
  const DefinitionIdentifier& definition_identifier) {
  if (auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
      it != msg_specs_by_definition_identifier_.end()) {
    return it->second;
  }

  std::smatch match;
  if (!std::regex_match(definition_identifier.package_resource_name, match,
                        PACKAGE_TYPENAME_REGEX)) {
    throw std::invalid_argument("Invalid package resource name: " +
                                definition_identifier.package_resource_name);
  }
  const std::string package = match[1].str();
  const std::string subfolder = match[2].str();
  const std::string type_name = match[3].str();

  const auto& format = definition_identifier.format;
  std::string filename = "";
  if (subfolder == "action") {
    // The action type name includes the subtype which we have to remove to get the action name.
    // Type name: Fibonacci_FeedbackMessage -> Action name: Fibonacci
    filename =
      remove_action_subtype(type_name) + extension_for_format(format, DefinitionType::Action);
  } else if (subfolder == "srv") {
    // The service type name includes the subtype which we have to remove to get the service name.
    // Type name: SetBool_Request -> Service name: SetBool
    filename =
      remove_service_subtype(type_name) + extension_for_format(format, DefinitionType::Service);
  } else {
    filename = type_name + extension_for_format(format, DefinitionType::Message);
  }

  // Get the package share directory, or throw a PackageNotFoundError
  const std::string share_dir = ament_index_cpp::get_package_share_directory(package);

  // Get the rosidl_interfaces index contents for this package
  std::string index_contents;
  if (!ament_index_cpp::get_resource("rosidl_interfaces", package, index_contents)) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  // Find the first line that ends with the filename we're looking for
  const auto lines = split_string(index_contents);
  const auto it = std::find_if(lines.begin(), lines.end(), [&filename](const std::string& line) {
    std::filesystem::path filePath(line);
    return filePath.filename() == filename;
  });
  if (it == lines.end()) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  // Read the file
  const std::string full_path = share_dir + std::filesystem::path::preferred_separator + *it;
  std::ifstream file{full_path};
  if (!file.good()) {
    throw DefinitionNotFoundError(definition_identifier.package_resource_name);
  }

  if (subfolder == "action") {
    if (definition_identifier.format == MessageDefinitionFormat::IDL) {
      RCUTILS_LOG_ERROR_NAMED("foxglove_bridge",
                              "Action IDL definitions are currently not supported");
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }

    const auto split_definitions = foxglove_bridge::splitMessageDefinitions(file);
    if (split_definitions.size() != 3) {
      throw std::invalid_argument("Invalid action definition in " + filename +
                                  ": Expected 3 definitions, got " +
                                  std::to_string(split_definitions.size()));
    }

    const auto& goalDef = split_definitions[0];
    const auto& resultDef = split_definitions[1];
    const auto& feedbackDef = split_definitions[2];

    // Define type definitions for each action subtype.
    // These type definitions may include additional fields such as the goal_id.
    // See also https://design.ros2.org/articles/actions.html
    const std::map<std::string, std::string> action_type_definitions = {
      {ACTION_FEEDBACK_MESSAGE_SUFFIX, "unique_identifier_msgs/UUID goal_id\n" + feedbackDef},
      {std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
       "unique_identifier_msgs/UUID goal_id\n"},
      {std::string(ACTION_RESULT_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
       "int8 status\n" + resultDef},
      {std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_REQUEST_MESSAGE_SUFFIX,
       "unique_identifier_msgs/UUID goal_id\n" + goalDef},
      {std::string(ACTION_GOAL_SERVICE_SUFFIX) + SERVICE_RESPONSE_MESSAGE_SUFFIX,
       "bool accepted\nbuiltin_interfaces/msg/Time stamp"}};

    // Create a MessageSpec instance for every action subtype and add it to the cache.
    const std::string action_name = remove_action_subtype(type_name);
    for (const auto& [action_suffix, definition] : action_type_definitions) {
      DefinitionIdentifier definition_id;
      definition_id.format = definition_identifier.format;
      definition_id.package_resource_name = package + "/action/" + action_name + action_suffix;
      msg_specs_by_definition_identifier_.emplace(
        definition_id, MessageSpec(definition_id.format, definition, package));
    }

    // Find the the subtype that was originally requested and return it.
    const auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
    if (it == msg_specs_by_definition_identifier_.end()) {
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }
    return it->second;
  } else if (subfolder == "srv") {
    if (definition_identifier.format == MessageDefinitionFormat::IDL) {
      RCUTILS_LOG_ERROR_NAMED("foxglove_bridge",
                              "Service IDL definitions are currently not supported");
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }

    const auto split_definitions = foxglove_bridge::splitMessageDefinitions(file);
    if (split_definitions.size() != 2) {
      throw std::invalid_argument("Invalid service definition in " + filename +
                                  ": Expected 2 definitions, got " +
                                  std::to_string(split_definitions.size()));
    }

    const auto& requestDef = split_definitions[0];
    const auto& responseDef = split_definitions[1];
    const std::map<std::string, std::string> service_type_definitions = {
      {SERVICE_REQUEST_MESSAGE_SUFFIX, requestDef}, {SERVICE_RESPONSE_MESSAGE_SUFFIX, responseDef}};

    // Create a MessageSpec instance for both the request and response subtypes and add it to the
    // cache.
    const std::string service_name = remove_service_subtype(type_name);
    for (const auto& [subType, definition] : service_type_definitions) {
      DefinitionIdentifier definition_id;
      definition_id.format = definition_identifier.format;
      definition_id.package_resource_name = package + "/srv/" + service_name + subType;
      msg_specs_by_definition_identifier_.emplace(
        definition_id, MessageSpec(definition_id.format, definition, package));
    }

    // Find the the subtype that was originally requested and return it.
    const auto it = msg_specs_by_definition_identifier_.find(definition_identifier);
    if (it == msg_specs_by_definition_identifier_.end()) {
      throw DefinitionNotFoundError(definition_identifier.package_resource_name);
    }
    return it->second;
  } else {
    // Normal message type.
    const MessageSpec& spec =
      msg_specs_by_definition_identifier_
        .emplace(definition_identifier,
                 MessageSpec(definition_identifier.format,
                             std::string{std::istreambuf_iterator(file), {}}, package))
        .first->second;

    // "References and pointers to data stored in the container are only invalidated by erasing that
    // element, even when the corresponding iterator is invalidated."
    return spec;
  }
}

std::pair<MessageDefinitionFormat, const std::string&> MessageDefinitionCache::get_full_text(
  const std::string& root_package_resource_name) {
  if (full_text_cache_.find(root_package_resource_name) != full_text_cache_.end()) {
    return {MessageDefinitionFormat::MSG, full_text_cache_[root_package_resource_name]};
  }

  std::unordered_set<DefinitionIdentifier, DefinitionIdentifierHash> seen_deps;

  std::function<std::string(const DefinitionIdentifier&)> append_recursive =
    [&](const DefinitionIdentifier& definition_identifier) {
      const MessageSpec& spec = load_message_spec(definition_identifier);
      std::string result = spec.text;
      for (const auto& dep_name : spec.dependencies) {
        DefinitionIdentifier dep{definition_identifier.format, dep_name};
        bool inserted = seen_deps.insert(dep).second;
        if (inserted) {
          result += "\n";
          result += delimiter(dep);
          result += append_recursive(dep);
        }
      }
      return result;
    };

  std::string result;
  auto format = MessageDefinitionFormat::MSG;
  try {
    result = append_recursive(DefinitionIdentifier{format, root_package_resource_name});
  } catch (const DefinitionNotFoundError& err) {
    // log that we've fallen back
    RCUTILS_LOG_WARN_NAMED("foxglove_bridge", "no .msg definition for %s, falling back to IDL",
                           err.what());
    format = MessageDefinitionFormat::IDL;
    DefinitionIdentifier root_definition_identifier{format, root_package_resource_name};
    result = delimiter(root_definition_identifier) + append_recursive(root_definition_identifier);
  }

  auto [it, _] = full_text_cache_.emplace(root_package_resource_name, result);
  return {format, it->second};
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/src/param_utils.cpp
================================================


#include <foxglove_bridge/common.hpp>
#include <foxglove_bridge/param_utils.hpp>

namespace foxglove_bridge {

void declareParameters(rclcpp::Node* node) {
  auto portDescription = rcl_interfaces::msg::ParameterDescriptor{};
  portDescription.name = PARAM_PORT;
  portDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  portDescription.description = "The TCP port to bind the WebSocket server to";
  portDescription.read_only = true;
  portDescription.additional_constraints =
    "Must be a valid TCP port number, or 0 to use a random port";
  portDescription.integer_range.resize(1);
  portDescription.integer_range[0].from_value = 0;
  portDescription.integer_range[0].to_value = 65535;
  portDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_PORT, DEFAULT_PORT, portDescription);

  auto addressDescription = rcl_interfaces::msg::ParameterDescriptor{};
  addressDescription.name = PARAM_ADDRESS;
  addressDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  addressDescription.description = "The host address to bind the WebSocket server to";
  addressDescription.read_only = true;
  node->declare_parameter(PARAM_ADDRESS, DEFAULT_ADDRESS, addressDescription);

  auto sendBufferLimitDescription = rcl_interfaces::msg::ParameterDescriptor{};
  sendBufferLimitDescription.name = PARAM_SEND_BUFFER_LIMIT;
  sendBufferLimitDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  sendBufferLimitDescription.description =
    "Connection send buffer limit in bytes. Messages will be dropped when a connection's send "
    "buffer reaches this limit to avoid a queue of outdated messages building up.";
  sendBufferLimitDescription.integer_range.resize(1);
  sendBufferLimitDescription.integer_range[0].from_value = 0;
  sendBufferLimitDescription.integer_range[0].to_value = std::numeric_limits<int64_t>::max();
  sendBufferLimitDescription.read_only = true;
  node->declare_parameter(PARAM_SEND_BUFFER_LIMIT, DEFAULT_SEND_BUFFER_LIMIT,
                          sendBufferLimitDescription);

  auto useTlsDescription = rcl_interfaces::msg::ParameterDescriptor{};
  useTlsDescription.name = PARAM_USETLS;
  useTlsDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  useTlsDescription.description = "Use Transport Layer Security for encrypted communication";
  useTlsDescription.read_only = true;
  node->declare_parameter(PARAM_USETLS, false, useTlsDescription);

  auto certfileDescription = rcl_interfaces::msg::ParameterDescriptor{};
  certfileDescription.name = PARAM_CERTFILE;
  certfileDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  certfileDescription.description = "Path to the certificate to use for TLS";
  certfileDescription.read_only = true;
  node->declare_parameter(PARAM_CERTFILE, "", certfileDescription);

  auto keyfileDescription = rcl_interfaces::msg::ParameterDescriptor{};
  keyfileDescription.name = PARAM_KEYFILE;
  keyfileDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
  keyfileDescription.description = "Path to the private key to use for TLS";
  keyfileDescription.read_only = true;
  node->declare_parameter(PARAM_KEYFILE, "", keyfileDescription);

  auto minQosDepthDescription = rcl_interfaces::msg::ParameterDescriptor{};
  minQosDepthDescription.name = PARAM_MIN_QOS_DEPTH;
  minQosDepthDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  minQosDepthDescription.description = "Minimum depth used for the QoS profile of subscriptions.";
  minQosDepthDescription.read_only = true;
  minQosDepthDescription.additional_constraints = "Must be a non-negative integer";
  minQosDepthDescription.integer_range.resize(1);
  minQosDepthDescription.integer_range[0].from_value = 0;
  minQosDepthDescription.integer_range[0].to_value = INT32_MAX;
  minQosDepthDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_MIN_QOS_DEPTH, DEFAULT_MIN_QOS_DEPTH, minQosDepthDescription);

  auto maxQosDepthDescription = rcl_interfaces::msg::ParameterDescriptor{};
  maxQosDepthDescription.name = PARAM_MAX_QOS_DEPTH;
  maxQosDepthDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
  maxQosDepthDescription.description = "Maximum depth used for the QoS profile of subscriptions.";
  maxQosDepthDescription.read_only = true;
  maxQosDepthDescription.additional_constraints = "Must be a non-negative integer";
  maxQosDepthDescription.integer_range.resize(1);
  maxQosDepthDescription.integer_range[0].from_value = 0;
  maxQosDepthDescription.integer_range[0].to_value = INT32_MAX;
  maxQosDepthDescription.integer_range[0].step = 1;
  node->declare_parameter(PARAM_MAX_QOS_DEPTH, DEFAULT_MAX_QOS_DEPTH, maxQosDepthDescription);

  auto bestEffortQosTopicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  bestEffortQosTopicWhiteListDescription.name = PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST;
  bestEffortQosTopicWhiteListDescription.type =
    rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  bestEffortQosTopicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) for topics that should be forced to use "
    "'best_effort' QoS. Unmatched topics will use 'reliable' QoS if ALL publishers are 'reliable', "
    "'best_effort' if any publishers are 'best_effort'.";
  bestEffortQosTopicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST, std::vector<std::string>({"(?!)"}),
                          bestEffortQosTopicWhiteListDescription);

  auto topicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  topicWhiteListDescription.name = PARAM_TOPIC_WHITELIST;
  topicWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  topicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted topic names.";
  topicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_TOPIC_WHITELIST, std::vector<std::string>({".*"}),
                          topicWhiteListDescription);

  auto serviceWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  serviceWhiteListDescription.name = PARAM_SERVICE_WHITELIST;
  serviceWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  serviceWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted service names.";
  serviceWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_SERVICE_WHITELIST, std::vector<std::string>({".*"}),
                          serviceWhiteListDescription);

  auto paramWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  paramWhiteListDescription.name = PARAM_PARAMETER_WHITELIST;
  paramWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  paramWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted parameter names.";
  paramWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_PARAMETER_WHITELIST, std::vector<std::string>({".*"}),
                          paramWhiteListDescription);

  auto useCompressionDescription = rcl_interfaces::msg::ParameterDescriptor{};
  useCompressionDescription.name = PARAM_USE_COMPRESSION;
  useCompressionDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  useCompressionDescription.description =
    "Use websocket compression (permessage-deflate). Suited for connections with smaller bandwith, "
    "at the cost of additional CPU load.";
  useCompressionDescription.read_only = true;
  node->declare_parameter(PARAM_USE_COMPRESSION, false, useCompressionDescription);

  auto paramCapabilities = rcl_interfaces::msg::ParameterDescriptor{};
  paramCapabilities.name = PARAM_CAPABILITIES;
  paramCapabilities.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  paramCapabilities.description = "Server capabilities";
  paramCapabilities.read_only = true;
  node->declare_parameter(PARAM_CAPABILITIES,
                          std::vector<std::string>(std::vector<std::string>(
                            DEFAULT_CAPABILITIES.begin(), DEFAULT_CAPABILITIES.end())),
                          paramCapabilities);

  auto clientTopicWhiteListDescription = rcl_interfaces::msg::ParameterDescriptor{};
  clientTopicWhiteListDescription.name = PARAM_CLIENT_TOPIC_WHITELIST;
  clientTopicWhiteListDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  clientTopicWhiteListDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted client-published topic names.";
  clientTopicWhiteListDescription.read_only = true;
  node->declare_parameter(PARAM_CLIENT_TOPIC_WHITELIST, std::vector<std::string>({".*"}),
                          paramWhiteListDescription);

  auto includeHiddenDescription = rcl_interfaces::msg::ParameterDescriptor{};
  includeHiddenDescription.name = PARAM_INCLUDE_HIDDEN;
  includeHiddenDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  includeHiddenDescription.description = "Include hidden topics and services";
  includeHiddenDescription.read_only = true;
  node->declare_parameter(PARAM_INCLUDE_HIDDEN, false, includeHiddenDescription);

  auto disableLoanMessageDescription = rcl_interfaces::msg::ParameterDescriptor{};
  disableLoanMessageDescription.name = PARAM_DISABLE_LOAN_MESSAGE;
  disableLoanMessageDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  disableLoanMessageDescription.description =
    "Do not publish as loaned message when publishing a client message";
  disableLoanMessageDescription.read_only = true;
  node->declare_parameter(PARAM_DISABLE_LOAN_MESSAGE, true, disableLoanMessageDescription);

  auto assetUriAllowlistDescription = rcl_interfaces::msg::ParameterDescriptor{};
  assetUriAllowlistDescription.name = PARAM_ASSET_URI_ALLOWLIST;
  assetUriAllowlistDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING_ARRAY;
  assetUriAllowlistDescription.description =
    "List of regular expressions (ECMAScript) of whitelisted asset URIs.";
  assetUriAllowlistDescription.read_only = true;
  node->declare_parameter(
    PARAM_ASSET_URI_ALLOWLIST,
    std::vector<std::string>(
      {"^package://(?:[-\\w%]+/"
       ")*[-\\w%.]+\\.(?:dae|fbx|glb|gltf|jpeg|jpg|mtl|obj|png|stl|tif|tiff|urdf|webp|xacro)$"}),
    paramWhiteListDescription);

  auto ignUnresponsiveParamNodes = rcl_interfaces::msg::ParameterDescriptor{};
  ignUnresponsiveParamNodes.name = PARAM_IGN_UNRESPONSIVE_PARAM_NODES;
  ignUnresponsiveParamNodes.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
  ignUnresponsiveParamNodes.description =
    "Avoid requesting parameters from previously unresponsive nodes";
  ignUnresponsiveParamNodes.read_only = true;
  node->declare_parameter(PARAM_IGN_UNRESPONSIVE_PARAM_NODES, true, ignUnresponsiveParamNodes);
}

std::vector<std::regex> parseRegexStrings(rclcpp::Node* node,
                                          const std::vector<std::string>& strings) {
  std::vector<std::regex> regexVector;
  regexVector.reserve(strings.size());

  for (const auto& pattern : strings) {
    try {
      regexVector.push_back(
        std::regex(pattern, std::regex_constants::ECMAScript | std::regex_constants::icase));
    } catch (const std::exception& ex) {
      RCLCPP_ERROR(node->get_logger(), "Ignoring invalid regular expression '%s': %s",
                   pattern.c_str(), ex.what());
    }
  }

  return regexVector;
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/src/parameter_interface.cpp
================================================
#include "foxglove_bridge/parameter_interface.hpp"

#include <nlohmann/json.hpp>
#include <rclcpp/qos.hpp>
#include <rclcpp/version.h>

#include <foxglove_bridge/utils.hpp>

namespace {

constexpr char PARAM_SEP = '.';

#if RCLCPP_VERSION_MAJOR > 16
const rclcpp::ParametersQoS parameterQoS;
#else
const rmw_qos_profile_t& parameterQoS = rmw_qos_profile_parameters;
#endif

static std::pair<std::string, std::string> getNodeAndParamName(
  const std::string_view nodeNameAndParamName) {
  return {std::string(nodeNameAndParamName.substr(0UL, nodeNameAndParamName.find(PARAM_SEP))),
          std::string(nodeNameAndParamName.substr(nodeNameAndParamName.find(PARAM_SEP) + 1UL))};
}

static std::string prependNodeNameToParamName(const std::string& paramName,
                                              const std::string& nodeName) {
  return nodeName + PARAM_SEP + paramName;
}

static std::vector<std::byte> toByteArray(const std::vector<uint8_t>& arr) {
  std::vector<std::byte> result;
  result.reserve(arr.size());
  for (const auto& byte : arr) {
    result.emplace_back(std::byte{byte});
  }
  return result;
}

static std::vector<uint8_t> toUnsignedIntArray(const std::vector<std::byte>& arr) {
  std::vector<uint8_t> result;
  result.reserve(arr.size());
  for (const auto& byte : arr) {
    result.emplace_back(static_cast<uint8_t>(byte));
  }
  return result;
}

static rclcpp::Parameter toRosParam(const foxglove::Parameter& p) {
  using foxglove::Parameter;
  using foxglove::ParameterType;

  // Handle unset parameters
  if (!p.hasValue()) {
    return rclcpp::Parameter(std::string(p.name()));
  }

  // Handle primitive scalar types
  if (p.is<bool>()) {
    return rclcpp::Parameter(std::string(p.name()), p.get<bool>());
  } else if (p.is<double>() && p.type() == foxglove::ParameterType::Float64) {
    return rclcpp::Parameter(std::string(p.name()), p.get<double>());
  } else if (p.is<int64_t>()) {
    if (p.type() == foxglove::ParameterType::Float64) {
      // If the parameter is an integer, but the type flag is explicitly set to Float64, treat as a
      // double.
      return rclcpp::Parameter(std::string(p.name()), static_cast<double>(p.get<int64_t>()));
    }
    return rclcpp::Parameter(std::string(p.name()), p.get<int64_t>());
  } else if (p.is<std::string>()) {
    return rclcpp::Parameter(std::string(p.name()), p.get<std::string>());
  }

  // Handle arrays
  else if (p.isByteArray()) {
    const auto resultOrByteArray = p.getByteArray();
    if (!resultOrByteArray.has_value()) {
      std::string errorMessage = foxglove::strerror(resultOrByteArray.error());
      throw std::runtime_error("Failed to get byte array for parameter " + std::string(p.name()) +
                               ": " + errorMessage);
    }

    return rclcpp::Parameter(std::string(p.name()), toUnsignedIntArray(resultOrByteArray.value()));
  } else if (p.isArray<bool>()) {
    return rclcpp::Parameter(std::string(p.name()), p.getArray<bool>());
  } else if (p.isArray<int64_t>()) {
    if (p.type() == foxglove::ParameterType::Float64Array) {
      std::vector<double> doubleArray;
      for (const auto& value : p.getArray<int64_t>()) {
        doubleArray.emplace_back(static_cast<double>(value));
      }
      return rclcpp::Parameter(std::string(p.name()), std::move(doubleArray));
    }
    return rclcpp::Parameter(std::string(p.name()), p.getArray<int64_t>());
  } else if (p.isArray<double>()) {
    return rclcpp::Parameter(std::string(p.name()), p.getArray<double>());
  } else if (p.isArray<std::string>()) {
    return rclcpp::Parameter(std::string(p.name()), p.getArray<std::string>());
  } else {
    throw std::runtime_error("Unsupported parameter type");
  }

  return rclcpp::Parameter();
}

static foxglove::Parameter fromRosParam(const rclcpp::Parameter& p) {
  const auto type = p.get_type();

  if (type == rclcpp::ParameterType::PARAMETER_NOT_SET) {
    return foxglove::Parameter(p.get_name());
  } else if (type == rclcpp::ParameterType::PARAMETER_BOOL) {
    return foxglove::Parameter(p.get_name(), p.as_bool());
  } else if (type == rclcpp::ParameterType::PARAMETER_INTEGER) {
    foxglove::ParameterValue value(p.as_int());
    return foxglove::Parameter(p.get_name(), foxglove::ParameterType::None, std::move(value));
  } else if (type == rclcpp::ParameterType::PARAMETER_DOUBLE) {
    // All numerical values are serialized as doubles, so explicitly set the type flag to
    // foxglove::ParameterType::Float64 to indicate that this parameter should be interpreted as a
    // double.
    foxglove::ParameterValue value(p.as_double());
    foxglove::ParameterType foxgloveType = foxglove::ParameterType::Float64;
    return foxglove::Parameter(p.get_name(), foxgloveType, std::move(value));
  } else if (type == rclcpp::ParameterType::PARAMETER_STRING) {
    return foxglove::Parameter(p.get_name(), p.as_string());
  } else if (type == rclcpp::ParameterType::PARAMETER_BYTE_ARRAY) {
    return foxglove::Parameter(p.get_name(), toByteArray(p.as_byte_array()));
  }

  // Handle arrays
  else if (type == rclcpp::ParameterType::PARAMETER_BOOL_ARRAY) {
    foxglove::ParameterType foxgloveType = foxglove::ParameterType::None;
    std::vector<foxglove::ParameterValue> paramVec;
    for (const bool value : p.as_bool_array()) {
      paramVec.emplace_back(value);
    }

    return foxglove::Parameter(p.get_name(), foxgloveType,
                               foxglove::ParameterValue(std::move(paramVec)));
  } else if (type == rclcpp::ParameterType::PARAMETER_INTEGER_ARRAY) {
    return foxglove::Parameter(p.get_name(), p.as_integer_array());
  } else if (type == rclcpp::ParameterType::PARAMETER_DOUBLE_ARRAY) {
    return foxglove::Parameter(p.get_name(), p.as_double_array());
  } else if (type == rclcpp::ParameterType::PARAMETER_STRING_ARRAY) {
    std::vector<foxglove::ParameterValue> paramVec;
    foxglove::ParameterType paramType = foxglove::ParameterType::None;
    for (const std::string& value : p.as_string_array()) {
      paramVec.emplace_back(value);
    }
    return foxglove::Parameter(p.get_name(), paramType,
                               foxglove::ParameterValue(std::move(paramVec)));
  } else {
    throw std::runtime_error("Unsupported parameter type");
  }
}

}  // namespace

namespace foxglove_bridge {

using foxglove_bridge::isWhitelisted;

ParameterList ParameterInterface::cloneParameterList(const ParameterList& other) {
  ParameterList result;
  result.reserve(other.size());
  for (const foxglove::Parameter& param : other) {
    result.emplace_back(param.clone());
  }
  return result;
}

ParameterInterface::ParameterInterface(rclcpp::Node* node,
                                       std::vector<std::regex> paramWhitelistPatterns,
                                       UnresponsiveNodePolicy unresponsiveNodePolicy)
    : _node(node)
    , _paramWhitelistPatterns(paramWhitelistPatterns)
    , _callbackGroup(node->create_callback_group(rclcpp::CallbackGroupType::Reentrant))
    , _ignoredNodeNames({node->get_fully_qualified_name()})
    , _unresponsiveNodePolicy(unresponsiveNodePolicy) {}

ParameterList ParameterInterface::getParams(const std::vector<std::string_view>& paramNames,
                                            const std::chrono::duration<double>& timeout) {
  std::lock_guard<std::mutex> lock(_mutex);

  std::unordered_map<std::string, std::vector<std::string>> paramNamesByNodeName;
  const auto thisNode = _node->get_fully_qualified_name();

  if (!paramNames.empty()) {
    // Break apart fully qualified {node_name}.{param_name} strings and build a
    // mape of node names to the list of parameters for each node
    for (const auto& fullParamName : paramNames) {
      const auto& [nodeName, paramName] = getNodeAndParamName(fullParamName);
      paramNamesByNodeName[nodeName].push_back(paramName);
    }

    RCLCPP_DEBUG(_node->get_logger(), "Getting %zu parameters from %zu nodes...", paramNames.size(),
                 paramNamesByNodeName.size());
  } else {
    // Make a map of node names to empty parameter lists
    // Only consider nodes that offer services to list & get parameters.
    for (const auto& fqnNodeName : _node->get_node_names()) {
      if (_ignoredNodeNames.find(fqnNodeName) != _ignoredNodeNames.end()) {
        continue;
      }
      const auto [nodeNs, nodeName] = getNodeAndNodeNamespace(fqnNodeName);
      const auto serviceNamesAndTypes =
        _node->get_service_names_and_types_by_node(nodeName, nodeNs);

      bool listParamsSrvFound = false, getParamsSrvFound = false;
      for (const auto& [serviceName, serviceTypes] : serviceNamesAndTypes) {
        constexpr char GET_PARAMS_SERVICE_TYPE[] = "rcl_interfaces/srv/GetParameters";
        constexpr char LIST_PARAMS_SERVICE_TYPE[] = "rcl_interfaces/srv/ListParameters";

        if (!getParamsSrvFound) {
          getParamsSrvFound = std::find(serviceTypes.begin(), serviceTypes.end(),
                                        GET_PARAMS_SERVICE_TYPE) != serviceTypes.end();
        }
        if (!listParamsSrvFound) {
          listParamsSrvFound = std::find(serviceTypes.begin(), serviceTypes.end(),
                                         LIST_PARAMS_SERVICE_TYPE) != serviceTypes.end();
        }
      }

      if (listParamsSrvFound && getParamsSrvFound) {
        paramNamesByNodeName.insert({fqnNodeName, {}});
      }
    }

    if (!paramNamesByNodeName.empty()) {
      RCLCPP_DEBUG(_node->get_logger(), "Getting all parameters from %zu nodes...",
                   paramNamesByNodeName.size());
    }
  }

  std::unordered_map<std::string, std::future<ParameterList>> getParametersFuture;
  for (const auto& [nodeName, nodeParamNames] : paramNamesByNodeName) {
    if (nodeName == thisNode) {
      continue;
    }

    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    getParametersFuture.emplace(
      nodeName, std::async(std::launch::async, &ParameterInterface::getNodeParameters, this,
                           paramClientIt->second, nodeName, nodeParamNames, timeout));
  }

  ParameterList result;
  for (auto& [nodeName, future] : getParametersFuture) {
    try {
      // Move the parameters from the future into result. Must be done using rvalue reference
      // to avoid copying the parameters.
      for (auto& param : future.get()) {
        result.push_back(param.clone());
      }
    } catch (const std::exception& e) {
      RCLCPP_ERROR(_node->get_logger(), "Failed to retrieve parameters from node '%s': %s",
                   nodeName.c_str(), e.what());

      if (_unresponsiveNodePolicy == UnresponsiveNodePolicy::Ignore) {
        // Certain nodes may fail to handle incoming service requests — for example, if they're
        // stuck in a busy loop or otherwise unresponsive. In such cases, attempting to retrieve
        // parameter names or values can result in timeouts. To avoid repeated failures, these nodes
        // are added to an ignore list, and future parameter-related service calls to them will be
        // skipped.
        _ignoredNodeNames.insert(nodeName);
        RCLCPP_WARN(_node->get_logger(),
                    "Adding node %s to the ignore list to prevent repeated timeouts or failures in "
                    "future parameter requests.",
                    nodeName.c_str());
      }
    }
  }

  return result;
}

void ParameterInterface::setParams(const ParameterList& parameters,
                                   const std::chrono::duration<double>& timeout) {
  std::lock_guard<std::mutex> lock(_mutex);

  rclcpp::ParameterMap paramsByNode;
  for (const auto& param : parameters) {
    if (!isWhitelisted(std::string(param.name()), _paramWhitelistPatterns)) {
      return;
    }

    const auto rosParam = toRosParam(param);
    const auto& [nodeName, paramName] = getNodeAndParamName(rosParam.get_name());
    paramsByNode[nodeName].emplace_back(paramName, rosParam.get_parameter_value());
  }

  std::vector<std::future<void>> setParametersFuture;
  for (const auto& [nodeName, params] : paramsByNode) {
    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    setParametersFuture.emplace_back(std::async(std::launch::async,
                                                &ParameterInterface::setNodeParameters, this,
                                                paramClientIt->second, nodeName, params, timeout));
  }

  for (auto& future : setParametersFuture) {
    try {
      future.get();
    } catch (const std::exception& e) {
      RCLCPP_ERROR(_node->get_logger(), "Exception when setting parameters: %s", e.what());
    }
  }
}

void ParameterInterface::subscribeParams(const std::vector<std::string_view>& paramNames) {
  std::lock_guard<std::mutex> lock(_mutex);

  std::unordered_set<std::string> nodesToSubscribe;
  for (const auto& paramName : paramNames) {
    if (!isWhitelisted(std::string(paramName), _paramWhitelistPatterns)) {
      return;
    }

    const auto& [nodeName, paramN] = getNodeAndParamName(paramName);
    auto [subscribedParamsit, wasNewlyCreated] = _subscribedParamsByNode.try_emplace(nodeName);

    auto& subscribedNodeParams = subscribedParamsit->second;
    subscribedNodeParams.insert(paramN);

    if (wasNewlyCreated) {
      nodesToSubscribe.insert(nodeName);
    }
  }

  for (const auto& nodeName : nodesToSubscribe) {
    auto paramClientIt = _paramClientsByNode.find(nodeName);
    if (paramClientIt == _paramClientsByNode.end()) {
      const auto insertedPair = _paramClientsByNode.emplace(
        nodeName,
        rclcpp::AsyncParametersClient::make_shared(_node, nodeName, parameterQoS, _callbackGroup));
      paramClientIt = insertedPair.first;
    }

    auto& paramClient = paramClientIt->second;

    _paramSubscriptionsByNode[nodeName] = paramClient->on_parameter_event(
      [this, nodeName](rcl_interfaces::msg::ParameterEvent::ConstSharedPtr msg) {
        RCLCPP_DEBUG(_node->get_logger(), "Retrieved param update for node %s: %zu params changed",
                     nodeName.c_str(), msg->changed_parameters.size());

        ParameterList result;
        const auto& subscribedNodeParams = _subscribedParamsByNode[nodeName];
        for (const auto& param : msg->changed_parameters) {
          if (subscribedNodeParams.find(param.name) != subscribedNodeParams.end()) {
            result.push_back(fromRosParam(
              rclcpp::Parameter(prependNodeNameToParamName(param.name, nodeName), param.value)));
          }
        }

        if (!result.empty() && _paramUpdateFunc) {
          _paramUpdateFunc(result);
        }
      });
  }
}

void ParameterInterface::unsubscribeParams(const std::vector<std::string_view>& paramNames) {
  std::lock_guard<std::mutex> lock(_mutex);

  for (const auto& paramName : paramNames) {
    const auto& [nodeName, paramN] = getNodeAndParamName(paramName);

    const auto subscribedNodeParamsIt = _subscribedParamsByNode.find(nodeName);
    if (subscribedNodeParamsIt != _subscribedParamsByNode.end()) {
      subscribedNodeParamsIt->second.erase(subscribedNodeParamsIt->second.find(paramN));

      if (subscribedNodeParamsIt->second.empty()) {
        _subscribedParamsByNode.erase(subscribedNodeParamsIt);
        _paramSubscriptionsByNode.erase(_paramSubscriptionsByNode.find(nodeName));
      }
    }
  }
}

void ParameterInterface::setParamUpdateCallback(ParamUpdateFunc paramUpdateFunc) {
  std::lock_guard<std::mutex> lock(_mutex);
  _paramUpdateFunc = paramUpdateFunc;
}

ParameterList ParameterInterface::getNodeParameters(
  const rclcpp::AsyncParametersClient::SharedPtr paramClient, const std::string& nodeName,
  const std::vector<std::string>& paramNames, const std::chrono::duration<double>& timeout) {
  if (!paramClient->service_is_ready()) {
    throw std::runtime_error("Parameter service for node '" + nodeName + "' is not ready");
  }

  auto paramsToRequest = paramNames;
  if (paramsToRequest.empty()) {
    // `paramNames` is empty, list all parameter names for this node
    auto future = paramClient->list_parameters({}, 0UL);
    if (std::future_status::ready != future.wait_for(timeout)) {
      throw std::runtime_error("Failed to retrieve parameter names for node '" + nodeName + "'");
    }
    paramsToRequest = future.get().names;
  }

  // Start parameter fetches and wait for them to complete
  auto getParamsFuture = paramClient->get_parameters(paramsToRequest);
  if (std::future_status::ready != getParamsFuture.wait_for(timeout)) {
    throw std::runtime_error("Timed out waiting for " + std::to_string(paramsToRequest.size()) +
                             " parameter(s) from node '" + nodeName + "'");
  }
  const auto params = getParamsFuture.get();

  ParameterList result;
  for (const auto& param : params) {
    const auto fullParamName = prependNodeNameToParamName(param.get_name(), nodeName);
    if (isWhitelisted(fullParamName, _paramWhitelistPatterns)) {
      result.push_back(fromRosParam(rclcpp::Parameter(fullParamName, param.get_parameter_value())));
    }
  }
  return result;
}

void ParameterInterface::setNodeParameters(rclcpp::AsyncParametersClient::SharedPtr paramClient,
                                           const std::string& nodeName,
                                           const std::vector<rclcpp::Parameter>& params,
                                           const std::chrono::duration<double>& timeout) {
  if (!paramClient->service_is_ready()) {
    throw std::runtime_error("Parameter service for node '" + nodeName + "' is not ready");
  }

  auto future = paramClient->set_parameters(params);

  std::vector<std::string> paramsToDelete;
  for (const auto& p : params) {
    if (p.get_type() == rclcpp::ParameterType::PARAMETER_NOT_SET) {
      paramsToDelete.push_back(p.get_name());
    }
  }

  if (!paramsToDelete.empty()) {
    auto deleteFuture = paramClient->delete_parameters(paramsToDelete);
    if (std::future_status::ready != deleteFuture.wait_for(timeout)) {
      RCLCPP_WARN(
        _node->get_logger(),
        "Param client failed to delete %zu parameter(s) for node '%s' within the given timeout",
        paramsToDelete.size(), nodeName.c_str());
    }
  }

  if (std::future_status::ready != future.wait_for(timeout)) {
    throw std::runtime_error("Param client failed to set " + std::to_string(params.size()) +
                             " parameter(s) for node '" + nodeName + "' within the given timeout");
  }

  const auto setParamResults = future.get();
  for (auto& result : setParamResults) {
    if (!result.successful) {
      RCLCPP_WARN(_node->get_logger(), "Failed to set one or more parameters for node '%s': %s",
                  nodeName.c_str(), result.reason.c_str());
    }
  }
}

}  // namespace foxglove_bridge



================================================
FILE: ros2_foxglove_bridge_sdk/src/ros2_foxglove_bridge.cpp
================================================
#include <unordered_set>

#include <resource_retriever/retriever.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>
#include <foxglove_bridge/version.hpp>

namespace foxglove_bridge {
namespace {
inline bool isHiddenTopicOrService(const std::string& name) {
  if (name.empty()) {
    throw std::invalid_argument("Topic or service name can't be empty");
  }
  return name.front() == '_' || name.find("/_") != std::string::npos;
}

inline foxglove::WebSocketServerCapabilities processCapabilities(
  const std::vector<std::string>& capabilities) {
  const std::unordered_map<std::string, foxglove::WebSocketServerCapabilities>
    STRING_TO_CAPABILITY = {
      {"clientPublish", foxglove::WebSocketServerCapabilities::ClientPublish},
      {"parameters", foxglove::WebSocketServerCapabilities::Parameters},
      {"parametersSubscribe", foxglove::WebSocketServerCapabilities::Parameters},
      {"services", foxglove::WebSocketServerCapabilities::Services},
      {"connectionGraph", foxglove::WebSocketServerCapabilities::ConnectionGraph},
      {"assets", foxglove::WebSocketServerCapabilities::Assets},
    };
  foxglove::WebSocketServerCapabilities out = foxglove::WebSocketServerCapabilities(0);
  for (const auto& capability : capabilities) {
    if (STRING_TO_CAPABILITY.find(capability) != STRING_TO_CAPABILITY.end()) {
      out = out | STRING_TO_CAPABILITY.at(capability);
    }
  }
  return out;
}

inline bool hasCapability(const foxglove::WebSocketServerCapabilities& capabilities,
                          foxglove::WebSocketServerCapabilities capability) {
  return (capabilities & capability) == capability;
}
}  // namespace

using namespace std::chrono_literals;
using namespace std::placeholders;

FoxgloveBridge::FoxgloveBridge(const rclcpp::NodeOptions& options)
    : Node("foxglove_bridge", options) {
  const char* rosDistro = std::getenv("ROS_DISTRO");
  RCLCPP_INFO(this->get_logger(), "Starting foxglove_bridge (%s, %s@%s)", rosDistro,
              foxglove_bridge::FOXGLOVE_BRIDGE_VERSION, foxglove_bridge::FOXGLOVE_BRIDGE_GIT_HASH);

  declareParameters(this);

  const auto port = static_cast<uint16_t>(this->get_parameter(PARAM_PORT).as_int());
  const auto address = this->get_parameter(PARAM_ADDRESS).as_string();
  _minQosDepth = static_cast<size_t>(this->get_parameter(PARAM_MIN_QOS_DEPTH).as_int());
  _maxQosDepth = static_cast<size_t>(this->get_parameter(PARAM_MAX_QOS_DEPTH).as_int());
  const auto bestEffortQosTopicWhiteList =
    this->get_parameter(PARAM_BEST_EFFORT_QOS_TOPIC_WHITELIST).as_string_array();
  _bestEffortQosTopicWhiteListPatterns = parseRegexStrings(this, bestEffortQosTopicWhiteList);
  const auto topicWhiteList = this->get_parameter(PARAM_TOPIC_WHITELIST).as_string_array();
  _topicWhitelistPatterns = parseRegexStrings(this, topicWhiteList);
  const auto serviceWhiteList = this->get_parameter(PARAM_SERVICE_WHITELIST).as_string_array();
  _serviceWhitelistPatterns = parseRegexStrings(this, serviceWhiteList);
  const auto paramWhiteList = this->get_parameter(PARAM_PARAMETER_WHITELIST).as_string_array();
  const auto paramWhitelistPatterns = parseRegexStrings(this, paramWhiteList);
  _useSimTime = this->get_parameter("use_sim_time").as_bool();
  const auto capabilities = this->get_parameter(PARAM_CAPABILITIES).as_string_array();
  const auto clientTopicWhiteList =
    this->get_parameter(PARAM_CLIENT_TOPIC_WHITELIST).as_string_array();
  const auto clientTopicWhiteListPatterns = parseRegexStrings(this, clientTopicWhiteList);
  _includeHidden = this->get_parameter(PARAM_INCLUDE_HIDDEN).as_bool();
  const auto assetUriAllowlist = this->get_parameter(PARAM_ASSET_URI_ALLOWLIST).as_string_array();
  _assetUriAllowlistPatterns = parseRegexStrings(this, assetUriAllowlist);
  _disableLoanMessage = this->get_parameter(PARAM_DISABLE_LOAN_MESSAGE).as_bool();
  const auto ignoreUnresponsiveParamNodes =
    this->get_parameter(PARAM_IGN_UNRESPONSIVE_PARAM_NODES).as_bool();

  foxglove::WebSocketServerOptions sdkServerOptions;
  _capabilities = processCapabilities(capabilities);
  sdkServerOptions.host = address;
  sdkServerOptions.port = port;
  sdkServerOptions.supported_encodings = {"cdr", "json"};
  sdkServerOptions.capabilities = _capabilities;
  if (_useSimTime) {
    sdkServerOptions.capabilities =
      sdkServerOptions.capabilities | foxglove::WebSocketServerCapabilities::Time;
  }

  // Setup callbacks
  sdkServerOptions.callbacks.onConnectionGraphSubscribe =
    std::bind(&FoxgloveBridge::subscribeConnectionGraph, this, true);
  sdkServerOptions.callbacks.onSubscribe = std::bind(&FoxgloveBridge::subscribe, this, _1, _2);
  sdkServerOptions.callbacks.onUnsubscribe = std::bind(&FoxgloveBridge::unsubscribe, this, _1, _2);

  if (hasCapability(_capabilities, foxglove::WebSocketServerCapabilities::ClientPublish)) {
    sdkServerOptions.callbacks.onClientAdvertise =
      std::bind(&FoxgloveBridge::clientAdvertise, this, _1, _2);
    sdkServerOptions.callbacks.onClientUnadvertise =
      std::bind(&FoxgloveBridge::clientUnadvertise, this, _1, _2);
    sdkServerOptions.callbacks.onMessageData =
      std::bind(&FoxgloveBridge::clientMessage, this, _1, _2, _3, _4);
  }

  if (hasCapability(_capabilities, foxglove::WebSocketServerCapabilities::Assets)) {
    sdkServerOptions.fetch_asset = std::bind(&FoxgloveBridge::fetchAsset, this, _1, _2);
  }

  if (hasCapability(sdkServerOptions.capabilities,
                    foxglove::WebSocketServerCapabilities::Parameters)) {
    sdkServerOptions.callbacks.onParametersSubscribe =
      std::bind(&FoxgloveBridge::subscribeParameters, this, _1);
    sdkServerOptions.callbacks.onParametersUnsubscribe =
      std::bind(&FoxgloveBridge::unsubscribeParameters, this, _1);
    sdkServerOptions.callbacks.onGetParameters =
      std::bind(&FoxgloveBridge::getParameters, this, _1, _2, _3);
    sdkServerOptions.callbacks.onSetParameters =
      std::bind(&FoxgloveBridge::setParameters, this, _1, _2, _3);

    _paramInterface = std::make_shared<ParameterInterface>(this, paramWhitelistPatterns,
                                                           ignoreUnresponsiveParamNodes
                                                             ? UnresponsiveNodePolicy::Ignore
                                                             : UnresponsiveNodePolicy::Retry);
    _paramInterface->setParamUpdateCallback(std::bind(&FoxgloveBridge::parameterUpdates, this, _1));
  }

  auto maybeSdkServer = foxglove::WebSocketServer::create(std::move(sdkServerOptions));

  if (!maybeSdkServer.has_value()) {
    throw std::runtime_error(std::string("Couldn't initialize websocket server: ") +
                             foxglove::strerror(maybeSdkServer.error()));
  }

  // Constructing an SDK server also starts it listening automatically
  _server = std::make_unique<foxglove::WebSocketServer>(std::move(maybeSdkServer.value()));
  this->set_parameter(rclcpp::Parameter{PARAM_PORT, _server->port()});
  RCLCPP_INFO(this->get_logger(), "Server listening on port %d", _server->port());

  // Start the thread polling for rosgraph changes
  _rosgraphPollThread =
    std::make_unique<std::thread>(std::bind(&FoxgloveBridge::rosgraphPollThread, this));

  _subscriptionCallbackGroup = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);
  _clientPublishCallbackGroup =
    this->create_callback_group(rclcpp::CallbackGroupType::MutuallyExclusive);
  _servicesCallbackGroup = this->create_callback_group(rclcpp::CallbackGroupType::Reentrant);

  if (_useSimTime) {
    _clockSubscription = this->create_subscription<rosgraph_msgs::msg::Clock>(
      "/clock", rclcpp::QoS{rclcpp::KeepLast(1)}.best_effort(),
      [&](std::shared_ptr<const rosgraph_msgs::msg::Clock> msg) {
        const auto timestamp = rclcpp::Time{msg->clock}.nanoseconds();
        assert(timestamp >= 0 && "Timestamp is negative");
        _server->broadcastTime(static_cast<uint64_t>(timestamp));
      });
  }
}

FoxgloveBridge::~FoxgloveBridge() {
  _shuttingDown = true;
  RCLCPP_INFO(this->get_logger(), "Shutting down %s", this->get_name());
  if (_rosgraphPollThread) {
    _rosgraphPollThread->join();
  }
  _server->stop();
  RCLCPP_INFO(this->get_logger(), "Shutdown complete");
}

void FoxgloveBridge::rosgraphPollThread() {
  updateAdvertisedTopics(get_topic_names_and_types());
  updateAdvertisedServices();

  auto graphEvent = this->get_graph_event();
  while (!_shuttingDown && rclcpp::ok()) {
    try {
      this->wait_for_graph_change(graphEvent, 200ms);
      bool triggered = graphEvent->check_and_clear();
      if (triggered) {
        RCLCPP_DEBUG(this->get_logger(), "rosgraph change detected");
        const auto topicNamesAndTypes = get_topic_names_and_types();
        updateAdvertisedTopics(topicNamesAndTypes);
        updateAdvertisedServices();
        if (_subscribeGraphUpdates) {
          updateConnectionGraph(topicNamesAndTypes);
        }
        // Graph changes tend to come in batches, so wait a bit before checking again
        std::this_thread::sleep_for(500ms);
      }
    } catch (const std::exception& ex) {
      RCLCPP_ERROR(this->get_logger(), "Exception thrown in rosgraphPollThread: %s", ex.what());
    }
  }

  RCLCPP_DEBUG(this->get_logger(), "rosgraph polling thread exiting");
}

void FoxgloveBridge::updateAdvertisedTopics(
  const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes) {
  if (!rclcpp::ok()) {
    return;
  }

  std::unordered_set<TopicAndDatatype, PairHash> latestTopics;
  latestTopics.reserve(topicNamesAndTypes.size());
  for (const auto& topicNamesAndType : topicNamesAndTypes) {
    const auto& topicName = topicNamesAndType.first;
    const auto& datatypes = topicNamesAndType.second;

    // Ignore hidden topics if not explicitly included
    if (!_includeHidden && isHiddenTopicOrService(topicName)) {
      continue;
    }

    // Ignore the topic if it is not on the topic whitelist
    if (isWhitelisted(topicName, _topicWhitelistPatterns)) {
      for (const auto& datatype : datatypes) {
        latestTopics.emplace(topicName, datatype);
      }
    }
  }

  if (const auto numIgnoredTopics = topicNamesAndTypes.size() - latestTopics.size()) {
    RCLCPP_DEBUG(
      this->get_logger(),
      "%zu topics have been ignored as they do not match any pattern on the topic whitelist",
      numIgnoredTopics);
  }

  std::lock_guard<std::mutex> lock(_subscriptionsMutex);

  // Remove channels for which the topic does not exist anymore
  for (auto channelIt = _channels.begin(); channelIt != _channels.end();) {
    auto& channel = channelIt->second;
    std::string schemaName = channel.schema().value().name;
    std::string topic(channel.topic());
    const TopicAndDatatype topicAndSchemaName = {topic, schemaName};
    if (latestTopics.find(topicAndSchemaName) == latestTopics.end()) {
      RCLCPP_INFO(this->get_logger(), "Removing channel %lu for topic \"%s\" (%s)", channel.id(),
                  topic.c_str(), schemaName.c_str());
      channel.close();
      channelIt = _channels.erase(channelIt);
    } else {
      channelIt++;
    }
  }

  // Advertise new topics
  for (const auto& topicAndDatatype : latestTopics) {
    const auto& topic = topicAndDatatype.first;
    const auto& schemaName = topicAndDatatype.second;

    if (std::find_if(_channels.begin(), _channels.end(), [&topic, &schemaName](const auto& kvp) {
          const auto& [channelId, channel] = kvp;
          return channel.topic() == topic && channel.schema().value().name == schemaName;
        }) != _channels.end()) {
      continue;
    }

    // Load actual schema and encoding from disk
    // TODO: (FG-10638): Add support for reading schemas from the wire if available
    std::optional<foxglove::Schema> schema = foxglove::Schema();
    schema->name = schemaName;
    std::string messageEncoding;

    try {
      auto [format, msgDefinition] = _messageDefinitionCache.get_full_text(schemaName);
      schema->data_len = msgDefinition.size();
      schema->data = reinterpret_cast<const std::byte*>(msgDefinition.data());

      switch (format) {
        case foxglove_bridge::MessageDefinitionFormat::MSG:
          messageEncoding = "cdr";
          schema->encoding = "ros2msg";
          break;
        case foxglove_bridge::MessageDefinitionFormat::IDL:
          messageEncoding = "cdr";
          schema->encoding = "ros2idl";
          break;
        default:
          RCLCPP_WARN(this->get_logger(), "Unsupported message definition format for type %s",
                      schemaName.c_str());
          continue;
      }
    } catch (const foxglove_bridge::DefinitionNotFoundError& err) {
      // If the definition isn't found, advertise the channel with an empty schema as a fallback
      RCLCPP_WARN(this->get_logger(), "Could not find definition for type %s: %s",
                  schemaName.c_str(), err.what());
      schema = std::nullopt;
    } catch (const std::exception& err) {
      RCLCPP_ERROR(this->get_logger(), "Failed to load schemaDefinition for topic \"%s\" (%s): %s",
                   topic.c_str(), schemaName.c_str(), err.what());
      continue;
    }

    // Create the new SDK channel
    auto channelResult = foxglove::RawChannel::create(topic, messageEncoding, schema);
    if (!channelResult.has_value()) {
      RCLCPP_ERROR(this->get_logger(), "Failed to create channel for topic \"%s\" (%s)",
                   topic.c_str(), foxglove::strerror(channelResult.error()));
      continue;
    }

    const ChannelId channelId = channelResult.value().id();
    RCLCPP_INFO(this->get_logger(), "Advertising new channel %lu for topic \"%s\"", channelId,
                topic.c_str());
    _channels.insert({channelId, std::move(channelResult.value())});
  }
}

void FoxgloveBridge::updateAdvertisedServices() {
  if (!rclcpp::ok()) {
    return;
  } else if (!hasCapability(_capabilities, foxglove::WebSocketServerCapabilities::Services)) {
    return;
  }

  // Get the current list of visible services and datatypes from the ROS graph
  const auto serviceNamesAndTypes = this->get_node_graph_interface()->get_service_names_and_types();

  std::lock_guard<std::mutex> lock(_servicesMutex);

  // Remove advertisements for services that have been removed
  std::vector<std::string> servicesToRemove;
  for (const auto& [serviceName, _] : _advertisedServices) {
    if (serviceNamesAndTypes.find(serviceName) == serviceNamesAndTypes.end()) {
      servicesToRemove.push_back(serviceName);
    }
  }
  for (const auto& serviceName : servicesToRemove) {
    _advertisedServices.erase(serviceName);
    _serviceClients.erase(serviceName);
    _serviceHandlers.erase(serviceName);
    auto error = _server->removeService(serviceName);
    if (error != foxglove::FoxgloveError::Ok) {
      RCLCPP_ERROR(this->get_logger(), "Failed to remove service %s: %s", serviceName.c_str(),
                   foxglove::strerror(error));
    }
  }

  // Advertise new services
  for (const auto& serviceNamesAndType : serviceNamesAndTypes) {
    const auto& serviceName = serviceNamesAndType.first;
    const auto& datatypes = serviceNamesAndType.second;
    const auto& serviceType = datatypes.front();

    // Ignore the service if it's already advertised
    if (_advertisedServices.find(serviceName) != _advertisedServices.end()) {
      continue;
    }

    // Ignore hidden services if not explicitly included
    if (!_includeHidden && isHiddenTopicOrService(serviceName)) {
      continue;
    }

    // Ignore the service if it is not on the service whitelist
    if (!isWhitelisted(serviceName, _serviceWhitelistPatterns)) {
      continue;
    }

    foxglove::ServiceSchema serviceSchema;
    serviceSchema.name = serviceType;

    // Read and initialize the service schema
    try {
      const auto requestTypeName = serviceType + foxglove_bridge::SERVICE_REQUEST_MESSAGE_SUFFIX;
      const auto responseTypeName = serviceType + foxglove_bridge::SERVICE_RESPONSE_MESSAGE_SUFFIX;
      const auto& [format, reqSchema] = _messageDefinitionCache.get_full_text(requestTypeName);
      const auto& resSchema = _messageDefinitionCache.get_full_text(responseTypeName).second;
      std::string schemaEncoding = "";
      std::string messageEncoding = "";
      switch (format) {
        case foxglove_bridge::MessageDefinitionFormat::MSG:
          schemaEncoding = "ros2msg";
          messageEncoding = "cdr";
          break;
        case foxglove_bridge::MessageDefinitionFormat::IDL:
          // REVIEW: Is this still true in the SDK?
          RCLCPP_WARN(this->get_logger(),
                      "IDL message definition format cannot be communicated over ws-protocol. "
                      "Service \"%s\" (%s) may not decode correctly in clients",
                      serviceName.c_str(), serviceType.c_str());
          schemaEncoding = "ros2idl";
          messageEncoding = "cdr";
          break;
        default:
          RCLCPP_ERROR(this->get_logger(), "Unsupported message definition format for type %s",
                       requestTypeName.c_str());
          continue;
      }
      serviceSchema.request = std::make_optional<foxglove::ServiceMessageSchema>();
      serviceSchema.request->encoding = messageEncoding;
      serviceSchema.request->schema = foxglove::Schema{
        requestTypeName,
        schemaEncoding,
        reinterpret_cast<const std::byte*>(reqSchema.data()),
        reqSchema.size(),
      };

      serviceSchema.response = std::make_optional<foxglove::ServiceMessageSchema>();
      serviceSchema.response->encoding = messageEncoding;
      serviceSchema.response->schema = foxglove::Schema{
        responseTypeName,
        schemaEncoding,
        reinterpret_cast<const std::byte*>(resSchema.data()),
        resSchema.size(),
      };
    } catch (const foxglove_bridge::DefinitionNotFoundError& err) {
      RCLCPP_WARN(this->get_logger(), "Could not find definition for type %s: %s",
                  serviceType.c_str(), err.what());
      // We still advertise the service, but with an empty schema
      serviceSchema.request = std::nullopt;
      serviceSchema.response = std::nullopt;
    } catch (const std::exception& err) {
      RCLCPP_WARN(this->get_logger(), "Failed to add service \"%s\" (%s): %s", serviceName.c_str(),
                  serviceType.c_str(), err.what());
      continue;
    }

    // Set up ROS service client
    try {
      auto clientOptions = rcl_client_get_default_options();
      auto [it, _] = _serviceClients.insert(
        {serviceName, std::make_shared<GenericClient>(this->get_node_base_interface().get(),
                                                      this->get_node_graph_interface(), serviceName,
                                                      serviceType, clientOptions)});
      this->get_node_services_interface()->add_client(it->second, _servicesCallbackGroup);
    } catch (const std::exception& ex) {
      RCLCPP_ERROR(this->get_logger(), "Failed to create service client for service %s: %s",
                   serviceName.c_str(), ex.what());
      continue;
    }

    auto handler = std::make_unique<foxglove::ServiceHandler>(
      [this](const foxglove::ServiceRequest& req, foxglove::ServiceResponder&& res) {
        this->handleServiceRequest(req, std::move(res));
      });

    _serviceHandlers.insert({serviceName, std::move(handler)});

    auto serviceResult =
      foxglove::Service::create(serviceName, serviceSchema, *_serviceHandlers.at(serviceName));
    if (!serviceResult.has_value()) {
      RCLCPP_ERROR(this->get_logger(), "Failed to create service %s: %s", serviceName.c_str(),
                   foxglove::strerror(serviceResult.error()));
      continue;
    }

    auto addServiceError = _server->addService(std::move(serviceResult.value()));
    if (addServiceError != foxglove::FoxgloveError::Ok) {
      RCLCPP_ERROR(this->get_logger(), "Failed to add service %s to server: %s",
                   serviceName.c_str(), foxglove::strerror(addServiceError));
      continue;
    }

    _advertisedServices.insert({serviceName, serviceType});
  }
}

void FoxgloveBridge::updateConnectionGraph(
  const std::map<std::string, std::vector<std::string>>& topicNamesAndTypes) {
  MapOfSets publishers, subscribers;
  foxglove::ConnectionGraph connectionGraph;

  for (const auto& topicNameAndType : topicNamesAndTypes) {
    const auto& topicName = topicNameAndType.first;
    if (!isWhitelisted(topicName, _topicWhitelistPatterns)) {
      continue;
    }

    const auto publishersInfo = get_publishers_info_by_topic(topicName);
    const auto subscribersInfo = get_subscriptions_info_by_topic(topicName);
    std::unordered_set<std::string> publisherIds, subscriberIds;
    for (const auto& publisher : publishersInfo) {
      const auto& ns = publisher.node_namespace();
      const auto sep = (!ns.empty() && ns.back() == '/') ? "" : "/";
      publisherIds.insert(ns + sep + publisher.node_name());
    }
    for (const auto& subscriber : subscribersInfo) {
      const auto& ns = subscriber.node_namespace();
      const auto sep = (!ns.empty() && ns.back() == '/') ? "" : "/";
      subscriberIds.insert(ns + sep + subscriber.node_name());
    }
    publishers.emplace(topicName, publisherIds);
    subscribers.emplace(topicName, subscriberIds);

    std::vector<std::string> publisherIdsVec(publisherIds.begin(), publisherIds.end());
    std::vector<std::string> subscriberIdsVec(subscriberIds.begin(), subscriberIds.end());
    connectionGraph.setPublishedTopic(topicName, publisherIdsVec);
    connectionGraph.setSubscribedTopic(topicName, subscriberIdsVec);
  }

  MapOfSets services;
  for (const auto& fqnNodeName : get_node_names()) {
    const auto [nodeNs, nodeName] = getNodeAndNodeNamespace(fqnNodeName);
    const auto serviceNamesAndTypes = get_service_names_and_types_by_node(nodeName, nodeNs);

    for (const auto& [serviceName, serviceTypes] : serviceNamesAndTypes) {
      (void)serviceTypes;
      if (isWhitelisted(serviceName, _serviceWhitelistPatterns)) {
        services[serviceName].insert(fqnNodeName);
      }
    }
  }
  for (const auto& [serviceName, providerIds] : services) {
    connectionGraph.setAdvertisedService(serviceName,
                                         std::vector(providerIds.begin(), providerIds.end()));
  }

  RCLCPP_INFO(this->get_logger(), "publishing connection graph");
  _server->publishConnectionGraph(connectionGraph);
}

void FoxgloveBridge::subscribeConnectionGraph(bool subscribe) {
  RCLCPP_INFO(this->get_logger(), "received connection graph subscribe request");
  if ((_subscribeGraphUpdates = subscribe)) {
    // TODO: This causes a deadlock in the SDK implementation
    // updateConnectionGraph(get_topic_names_and_types());
  };
}

void FoxgloveBridge::subscribe(ChannelId channelId, const foxglove::ClientMetadata& client) {
  if (!client.sink_id.has_value()) {
    RCLCPP_ERROR(this->get_logger(),
                 "received subscribe request from client %u for channel %lu but client "
                 "has no sink ID",
                 client.id, channelId);
    return;
  }

  RCLCPP_INFO(this->get_logger(),
              "received subscribe request for channel %lu from client %u (sink %lu)", channelId,
              client.id, client.sink_id.value());
  std::lock_guard<std::mutex> lock(_subscriptionsMutex);

  // REVIEW: Is this necessary if the SDK server is checking that the channel exists before
  // calling this callback?
  auto it = _channels.find(channelId);
  if (it == _channels.end()) {
    RCLCPP_ERROR(this->get_logger(), "received subscribe request for unknown channel: %lu",
                 channelId);
    return;
  }

  auto& channel = it->second;
  const std::string topic(channel.topic());
  const std::string datatype = channel.schema().value().name;

  const rclcpp::QoS qos = determineQoS(topic);

  rclcpp::SubscriptionEventCallbacks eventCallbacks;
  eventCallbacks.incompatible_qos_callback = [&](const rclcpp::QOSRequestedIncompatibleQoSInfo&) {
    RCLCPP_ERROR(this->get_logger(), "Incompatible subscriber QoS settings for topic \"%s\" (%s)",
                 topic.c_str(), datatype.c_str());
  };

  rclcpp::SubscriptionOptions subscriptionOptions;
  subscriptionOptions.event_callbacks = eventCallbacks;
  subscriptionOptions.callback_group = _subscriptionCallbackGroup;

  auto subscription = this->create_generic_subscription(
    topic, datatype, qos,
    [this, channelId, client](std::shared_ptr<const rclcpp::SerializedMessage> msg) {
      this->rosMessageHandler(channelId, client.sink_id.value(), msg);
    },
    subscriptionOptions);

  if (!client.sink_id.has_value()) {
    RCLCPP_ERROR(this->get_logger(),
                 "received subscribe request for channel %lu but client "
                 "has no sink ID",
                 channelId);
    return;
  }

  _subscriptions.insert({{channelId, client.id}, subscription});
  RCLCPP_INFO(this->get_logger(),
              "created ROS subscription on %s (%s) successfully for channel %lu (client "
              "%u, sink %lu)",
              topic.c_str(), datatype.c_str(), channelId, client.id, client.sink_id.value());
}

void FoxgloveBridge::unsubscribe(ChannelId channelId, const foxglove::ClientMetadata& client) {
  std::lock_guard<std::mutex> lock(_subscriptionsMutex);

  RCLCPP_INFO(this->get_logger(), "received unsubscribe request for channel %lu", channelId);

  auto it = _channels.find(channelId);
  if (it == _channels.end()) {
    RCLCPP_ERROR(this->get_logger(), "received unsubscribe request for unknown channel %lu",
                 channelId);
    return;
  }

  auto subscriptionIt = _subscriptions.find({channelId, client.id});
  if (subscriptionIt == _subscriptions.end()) {
    RCLCPP_ERROR(this->get_logger(),
                 "Client %u tried unsubscribing from channel %lu but a corresponding ROS "
                 "subscription doesn't exist",
                 client.id, channelId);
    return;
  }

  const std::string& topic = subscriptionIt->second->get_topic_name();
  RCLCPP_INFO(this->get_logger(),
              "Cleaned up subscription to topic %s for client %u on channel %lu", topic.c_str(),
              client.id, channelId);
  _subscriptions.erase(subscriptionIt);
}

void FoxgloveBridge::clientAdvertise(ClientId clientId, const foxglove::ClientChannel& channel) {
  std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

  ChannelAndClientId key = {channel.id, clientId};
  const std::string topicName(channel.topic);
  const std::string topicType(channel.schema_name);
  const std::string encoding(channel.encoding);

  if (_clientAdvertisedTopics.find(key) != _clientAdvertisedTopics.end()) {
    throw ClientChannelError("Received client advertisement from client ID " +
                             std::to_string(clientId) + " for channel " +
                             std::to_string(channel.id) + " it had already advertised");
  }

  if (channel.schema_name.empty()) {
    throw ClientChannelError("Received client advertisement from client ID " +
                             std::to_string(clientId) + " for channel " +
                             std::to_string(channel.id) + " with empty schema name");
  }

  if (encoding == "json") {
    // register the JSON parser for this schemaName
    std::string schemaName(channel.schema_name);
    auto parserIt = _jsonParsers.find(schemaName);
    if (parserIt == _jsonParsers.end()) {
      std::string schema = "";
      if (channel.schema_len > 0) {
        // Schema is given by the advertisement
        schema = std::string(reinterpret_cast<const char*>(channel.schema), channel.schema_len);
      } else {
        // Schema not given, look it up.
        auto [format, msgDefinition] = _messageDefinitionCache.get_full_text(schemaName);
        if (format != foxglove_bridge::MessageDefinitionFormat::MSG) {
          throw ClientChannelError("Message definition (.msg) for schema " + schemaName +
                                   " for channel " + std::to_string(channel.id) + " not found.");
        }

        schema = msgDefinition;
      }

      auto parser = std::make_shared<RosMsgParser::Parser>(
        topicName, RosMsgParser::ROSType(schemaName), schema);
      _jsonParsers.insert({schemaName, parser});
    }
  }

  try {
    // Create a new topic advertisement

    // Lookup if there are publishers from other nodes for that topic. If that's the case, we
    // use a matching QoS profile.
    const auto otherPublishers = get_publishers_info_by_topic(topicName);
    const auto otherPublisherIt =
      std::find_if(otherPublishers.begin(), otherPublishers.end(),
                   [this](const rclcpp::TopicEndpointInfo& endpoint) {
                     return endpoint.node_name() != this->get_name() ||
                            endpoint.node_namespace() != this->get_namespace();
                   });
    rclcpp::QoS qos = otherPublisherIt == otherPublishers.end() ? rclcpp::SystemDefaultsQoS()
                                                                : otherPublisherIt->qos_profile();

    // When the QoS profile is copied from another existing publisher, it can happen that the
    // history policy is Unknown, leading to an error when subsequently trying to create a
    // publisher with that QoS profile. As a fix, we explicitly set the history policy to the
    // system default.
    if (qos.history() == rclcpp::HistoryPolicy::Unknown) {
      qos.history(rclcpp::HistoryPolicy::SystemDefault);
    }
    rclcpp::PublisherOptions publisherOptions{};
    publisherOptions.callback_group = _clientPublishCallbackGroup;
    auto publisher = this->create_generic_publisher(topicName, topicType, qos, publisherOptions);

    RCLCPP_INFO(this->get_logger(),
                "Client ID %d is advertising \"%s\" (%s) on channel %d with encoding \"%s\"",
                clientId, topicName.c_str(), topicType.c_str(), channel.id, encoding.c_str());

    // Store the new topic advertisement
    ClientAdvertisement clientAdvertisement{std::move(publisher), topicName, topicType, encoding};
    _clientAdvertisedTopics.emplace(key, std::move(clientAdvertisement));
  } catch (const std::exception& ex) {
    throw ClientChannelError("Failed to create publisher for client channel " +
                             std::to_string(channel.id) + ": " + ex.what());
  }
}

void FoxgloveBridge::clientUnadvertise(ClientId clientId, ChannelId clientChannelId) {
  std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

  ChannelAndClientId key = {clientChannelId, clientId};

  auto it = _clientAdvertisedTopics.find(key);
  if (it == _clientAdvertisedTopics.end()) {
    throw ClientChannelError("Ignoring client unadvertisement from client ID " +
                             std::to_string(clientId) + " for unknown channel " +
                             std::to_string(clientChannelId));
  }

  const auto& publisher = it->second.publisher;
  RCLCPP_INFO(this->get_logger(),
              "Client ID %u is no longer advertising %s (%zu subscribers) on channel %lu", clientId,
              publisher->get_topic_name(), publisher->get_subscription_count(), clientChannelId);

  _clientAdvertisedTopics.erase(it);

  // Create a timer that immedeately goes out of scope (so it never fires) which will trigger
  // the previously destroyed publisher to be cleaned up. This is a workaround for
  // https://github.com/ros2/rclcpp/issues/2146
  this->create_wall_timer(1s, []() {});
}

void FoxgloveBridge::clientMessage(ClientId clientId, ChannelId clientChannelId,
                                   const std::byte* data, size_t dataLen) {
  // Get the publisher
  rclcpp::GenericPublisher::SharedPtr publisher;
  std::string encoding;
  std::string schemaName;
  {
    const ChannelAndClientId key = {clientChannelId, clientId};
    std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);

    auto it = _clientAdvertisedTopics.find(key);
    if (it == _clientAdvertisedTopics.end()) {
      throw ClientChannelError("Dropping client message from client ID " +
                               std::to_string(clientId) + " for unknown channel " +
                               std::to_string(clientChannelId) +
                               ", client has no advertised topics");
    }

    publisher = it->second.publisher;
    encoding = it->second.encoding;
    schemaName = it->second.topicType;
  }

  auto publishMessage = [publisher, this](const void* data, size_t size) {
    // Copy the message payload into a SerializedMessage object
    rclcpp::SerializedMessage serializedMessage{size};
    auto& rclSerializedMsg = serializedMessage.get_rcl_serialized_message();
    std::memcpy(rclSerializedMsg.buffer, data, size);
    rclSerializedMsg.buffer_length = size;
    // Publish the message
    if (_disableLoanMessage || !publisher->can_loan_messages()) {
      publisher->publish(serializedMessage);
    } else {
      publisher->publish_as_loaned_msg(serializedMessage);
    }
  };

  if (encoding == "cdr") {
    publishMessage(data, dataLen);
  } else if (encoding == "json") {
    // get the specific parser for this schemaName
    std::shared_ptr<RosMsgParser::Parser> parser;
    {
      std::lock_guard<std::mutex> lock(_clientAdvertisementsMutex);
      auto parserIt = _jsonParsers.find(schemaName);
      if (parserIt != _jsonParsers.end()) {
        parser = parserIt->second;
      }
    }
    if (!parser) {
      throw ClientChannelError(
        "Dropping client message on client channel " + std::to_string(clientChannelId) +
        " from client ID " + std::to_string(clientId) + " with encoding \"json\": no parser found");
    } else {
      thread_local RosMsgParser::ROS2_Serializer serializer;
      serializer.reset();
      const std::string jsonMessage(reinterpret_cast<const char*>(data), dataLen);
      try {
        parser->serializeFromJson(jsonMessage, &serializer);
        publishMessage(serializer.getBufferData(), serializer.getBufferSize());
      } catch (const std::exception& ex) {
        throw ClientChannelError(
          "Dropping client message on client channel " + std::to_string(clientChannelId) +
          " from client ID " + std::to_string(clientId) + " with encoding \"json\": " + ex.what());
      }
    }
  } else {
    throw ClientChannelError("Dropping client message on client channel " +
                             std::to_string(clientChannelId) + " from client ID " +
                             std::to_string(clientId) + " with unknown encoding \"" + encoding +
                             "\"");
  }
}

std::vector<foxglove::Parameter> FoxgloveBridge::setParameters(
  const ClientId clientId [[maybe_unused]], const std::optional<std::string_view>& requestId,
  const std::vector<foxglove::ParameterView>& parameterViews) {
  // Copy parameters to a vector
  std::vector<foxglove::Parameter> parameters;
  std::transform(parameterViews.cbegin(), parameterViews.cend(), std::back_inserter(parameters),
                 [](const foxglove::ParameterView& pv) {
                   return pv.clone();
                 });

  _paramInterface->setParams(parameters, std::chrono::seconds(5));

  // REVIEW: The previous implementation would publish updated parameters to the client only if a
  // request ID was passed. Since the SDK server publishes any parameters returned from this
  // function, to maintain the same behavior, we only return a non-empty vector if a request ID was
  // passed. If feels like too much of a kludge, we can remove this check but will need to either:
  //
  // (1) Update tests/client implementations to be robust to multiple parameter updates being
  // received if they are subscribed to parameter updates AND set a parameter, or (2) Update the SDK
  // server to avoid double-publishing parameters to a client that's setting a param and is
  // subscribed to parameter updates.
  if (requestId.has_value()) {
    // Get parameters again and publish them to the SDK server
    std::vector<std::string_view> parameterNames;
    parameterNames.reserve(parameters.size());
    for (const auto& param : parameters) {
      parameterNames.push_back(param.name());
    }

    auto updatedParameters = _paramInterface->getParams(parameterNames, std::chrono::seconds(5));
    return updatedParameters;
  }

  return {};
}

std::vector<foxglove::Parameter> FoxgloveBridge::getParameters(
  const ClientId clientId [[maybe_unused]],
  const std::optional<std::string_view>& requestId [[maybe_unused]],
  const std::vector<std::string_view>& parameterNames) {
  return _paramInterface->getParams(parameterNames, std::chrono::seconds(5));
}

void FoxgloveBridge::subscribeParameters(const std::vector<std::string_view>& parameterNames) {
  _paramInterface->subscribeParams(parameterNames);
}

void FoxgloveBridge::unsubscribeParameters(const std::vector<std::string_view>& parameterNames) {
  _paramInterface->unsubscribeParams(parameterNames);
}

void FoxgloveBridge::parameterUpdates(const std::vector<foxglove::Parameter>& parameters) {
  _server->publishParameterValues(ParameterInterface::cloneParameterList(parameters));
}

void FoxgloveBridge::rosMessageHandler(ChannelId channelId, SinkId sinkId,
                                       std::shared_ptr<const rclcpp::SerializedMessage> msg) {
  // NOTE: Do not call any RCLCPP_* logging functions from this function. Otherwise, subscribing
  // to `/rosout` will cause a feedback loop
  const auto timestamp = this->now().nanoseconds();
  assert(timestamp >= 0 && "Timestamp is negative");
  const auto rclSerializedMsg = msg->get_rcl_serialized_message();

  std::lock_guard<std::mutex> lock(_subscriptionsMutex);
  if (_channels.find(channelId) == _channels.end()) {
    return;
  }

  auto& channel = _channels.at(channelId);
  // TODO: Change to log() when the released SDK is updated to make this a public overload
  channel.log_(reinterpret_cast<const std::byte*>(rclSerializedMsg.buffer),
               rclSerializedMsg.buffer_length, timestamp, sinkId);
}

void FoxgloveBridge::handleServiceRequest(const foxglove::ServiceRequest& request,
                                          foxglove::ServiceResponder&& responder) {
  RCLCPP_DEBUG(this->get_logger(), "Received a request for service %s",
               request.service_name.c_str());

  std::lock_guard<std::mutex> lock(_servicesMutex);
  auto serviceIt = _advertisedServices.find(request.service_name);
  if (serviceIt == _advertisedServices.end()) {
    std::string errorMessage = "Service " + request.service_name + " does not exist";
    RCLCPP_ERROR(this->get_logger(), "%s", errorMessage.c_str());
    std::move(responder).respondError(errorMessage);
    return;
  }

  const auto& [serviceName, serviceType] = *serviceIt;

  if (_serviceClients.find(serviceName) == _serviceClients.end()) {
    std::string errorMessage =
      "Service " + request.service_name + " is advertised but no client exists for it";
    RCLCPP_ERROR(this->get_logger(), "%s", errorMessage.c_str());
    std::move(responder).respondError(errorMessage);
    return;
  }

  auto client = _serviceClients.at(serviceName);
  if (!client->wait_for_service(1s)) {
    std::string errorMessage = "Service " + serviceName + " is not available";
    RCLCPP_ERROR(this->get_logger(), "%s", errorMessage.c_str());
    std::move(responder).respondError(errorMessage);
    return;
  }

  if (request.encoding != "cdr") {
    std::string errorMessage = "Service " + serviceName +
                               " received a request with an unsupported encoding " +
                               request.encoding;
    RCLCPP_ERROR(this->get_logger(), "%s", errorMessage.c_str());
    std::move(responder).respondError(errorMessage);
    return;
  }

  auto reqMessage = std::make_shared<rclcpp::SerializedMessage>(request.payload.size());
  std::memcpy(reqMessage->get_rcl_serialized_message().buffer, request.payload.data(),
              request.payload.size());
  reqMessage->get_rcl_serialized_message().buffer_length = request.payload.size();

  client->async_send_request(reqMessage, std::move(responder));
}

void FoxgloveBridge::fetchAsset(const std::string_view uriView,
                                foxglove::FetchAssetResponder&& responder) {
  std::string uri(uriView);
  try {
    // We reject URIs that are not on the allowlist or that contain two consecutive dots. The
    // latter can be utilized to construct URIs for retrieving confidential files that should
    // not be accessible over the WebSocket connection. Example:
    // `package://<pkg_name>/../../../secret.txt`. This is an extra security measure and should
    // not be necessary if the allowlist is strict enough.
    if (uri.find("..") != std::string::npos || !isWhitelisted(uri, _assetUriAllowlistPatterns)) {
      throw std::runtime_error("Asset URI not allowed: " + uri);
    }

    resource_retriever::Retriever resource_retriever;

    // The resource_retriever API has changed from 3.7 onwards.
#if RESOURCE_RETRIEVER_VERSION_MAJOR > 3 || \
  (RESOURCE_RETRIEVER_VERSION_MAJOR == 3 && RESOURCE_RETRIEVER_VERSION_MINOR > 6)
    const auto memoryResource = resource_retriever.get_shared(uri);
    std::vector<std::byte> data(memoryResource->data.size());
    std::memcpy(data.data(), memoryResource->data.data(), memoryResource->data.size());
    std::move(responder).respondOk(data);
#else
    const resource_retriever::MemoryResource memoryResource = resource_retriever.get(uri);
    std::vector<std::byte> data(memoryResource.size);
    std::memcpy(data.data(), memoryResource.data.get(), memoryResource.size);
    std::move(responder).respondOk(data);
#endif
  } catch (const std::exception& ex) {
    RCLCPP_WARN(this->get_logger(), "Failed to retrieve asset '%s': %s", uri.c_str(), ex.what());
    std::move(responder).respondError("Failed to retrieve asset " + uri);
  }
}

rclcpp::QoS FoxgloveBridge::determineQoS(const std::string& topic) {
  // Select an appropriate subscription QOS profile. This is similar to how ros2 topic echo
  // does it:
  // https://github.com/ros2/ros2cli/blob/619b3d1c9/ros2topic/ros2topic/verb/echo.py#L137-L194
  size_t depth = 0;
  size_t reliabilityReliableEndpointsCount = 0;
  size_t durabilityTransientLocalEndpointsCount = 0;

  const auto publisherInfo = this->get_publishers_info_by_topic(topic);
  for (const auto& publisher : publisherInfo) {
    const auto& qos = publisher.qos_profile();
    if (qos.reliability() == rclcpp::ReliabilityPolicy::Reliable) {
      ++reliabilityReliableEndpointsCount;
    }
    if (qos.durability() == rclcpp::DurabilityPolicy::TransientLocal) {
      ++durabilityTransientLocalEndpointsCount;
    }
    // Some RMWs do not retrieve history information of the publisher endpoint in which case the
    // history depth is 0. We use a lower limit of 1 here, so that the history depth is at least
    // equal to the number of publishers. This covers the case where there are multiple
    // transient_local publishers with a depth of 1 (e.g. multiple tf_static transform
    // broadcasters). See also
    // https://github.com/foxglove/ros-foxglove-bridge/issues/238 and
    // https://github.com/foxglove/ros-foxglove-bridge/issues/208
    const size_t publisherHistoryDepth = std::max(static_cast<size_t>(1), qos.depth());
    depth = depth + publisherHistoryDepth;
  }

  depth = std::max(depth, _minQosDepth);
  if (depth > _maxQosDepth) {
    RCLCPP_WARN(this->get_logger(),
                "Limiting history depth for topic '%s' to %zu (was %zu). You may want to increase "
                "the max_qos_depth parameter value.",
                topic.c_str(), _maxQosDepth, depth);
    depth = _maxQosDepth;
  }

  rclcpp::QoS qos{rclcpp::KeepLast(depth)};

  // Force the QoS to be "best_effort" if in the whitelist
  if (isWhitelisted(topic, _bestEffortQosTopicWhiteListPatterns)) {
    qos.best_effort();
  } else if (!publisherInfo.empty() && reliabilityReliableEndpointsCount == publisherInfo.size()) {
    // If all endpoints are reliable, ask for reliable
    qos.reliable();
  } else {
    if (reliabilityReliableEndpointsCount > 0) {
      RCLCPP_WARN(
        this->get_logger(),
        "Some, but not all, publishers on topic '%s' are offering "
        "QoSReliabilityPolicy.RELIABLE. "
        "Falling back to QoSReliabilityPolicy.BEST_EFFORT as it will connect to all publishers",
        topic.c_str());
    }
    qos.best_effort();
  }

  // If all endpoints are transient_local, ask for transient_local
  if (!publisherInfo.empty() && durabilityTransientLocalEndpointsCount == publisherInfo.size()) {
    qos.transient_local();
  } else {
    if (durabilityTransientLocalEndpointsCount > 0) {
      RCLCPP_WARN(this->get_logger(),
                  "Some, but not all, publishers on topic '%s' are offering "
                  "QoSDurabilityPolicy.TRANSIENT_LOCAL. Falling back to "
                  "QoSDurabilityPolicy.VOLATILE as it will connect to all publishers",
                  topic.c_str());
    }
    qos.durability_volatile();
  }

  return qos;
}

}  // namespace foxglove_bridge

#include <rclcpp_components/register_node_macro.hpp>

// Register the component with class_loader.
// This acts as a sort of entry point, allowing the component to be discoverable when its library
// is being loaded into a running process.
RCLCPP_COMPONENTS_REGISTER_NODE(foxglove_bridge::FoxgloveBridge)



================================================
FILE: ros2_foxglove_bridge_sdk/src/ros2_foxglove_bridge_node.cpp
================================================
#include <rclcpp_components/component_manager.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>

int main(int argc, char* argv[]) {
  rclcpp::init(argc, argv);

  size_t numThreads = 0;
  {
    // Temporary dummy node to get num_threads param.
    auto dummyNode = std::make_shared<rclcpp::Node>("dummy");
    auto numThreadsDescription = rcl_interfaces::msg::ParameterDescriptor{};
    numThreadsDescription.name = "num_threads";
    numThreadsDescription.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
    numThreadsDescription.description =
      "The number of threads to use for the ROS node executor. 0 means one thread per CPU core.";
    numThreadsDescription.read_only = true;
    numThreadsDescription.additional_constraints = "Must be a non-negative integer";
    numThreadsDescription.integer_range.resize(1);
    numThreadsDescription.integer_range[0].from_value = 0;
    numThreadsDescription.integer_range[0].to_value = INT32_MAX;
    numThreadsDescription.integer_range[0].step = 1;
    constexpr int DEFAULT_NUM_THREADS = 0;
    dummyNode->declare_parameter(numThreadsDescription.name, DEFAULT_NUM_THREADS,
                                 numThreadsDescription);
    numThreads = static_cast<size_t>(dummyNode->get_parameter(numThreadsDescription.name).as_int());
  }

  auto executor =
    rclcpp::executors::MultiThreadedExecutor::make_shared(rclcpp::ExecutorOptions{}, numThreads);

  foxglove_bridge::FoxgloveBridge node;
  executor->add_node(node.get_node_base_interface());
  executor->spin();
  rclcpp::shutdown();

  return EXIT_SUCCESS;
}



================================================
FILE: ros2_foxglove_bridge_sdk/tests/smoke_test.cpp
================================================
#include <chrono>
#include <filesystem>
#include <future>
#include <thread>

#include <gtest/gtest.h>
#include <std_msgs/msg/string.hpp>
#include <std_srvs/srv/set_bool.hpp>
#include <websocketpp/config/asio_client.hpp>

#include <foxglove_bridge/ros2_foxglove_bridge.hpp>
#include <foxglove_bridge/test/test_client.hpp>

constexpr char URI[] = "ws://localhost:8765";

// Binary representation of std_msgs/msg/String for "hello world"
constexpr uint8_t HELLO_WORLD_CDR[] = {0,   1,   0,   0,  12,  0,   0,   0,   104, 101,
                                       108, 108, 111, 32, 119, 111, 114, 108, 100, 0};
constexpr char HELLO_WORLD_JSON[] = "{\"data\": \"hello world\"}";
constexpr char STD_MSGS_STRING_SCHEMA[] = "data string";

constexpr auto ONE_SECOND = std::chrono::seconds(1);
constexpr auto DEFAULT_TIMEOUT = std::chrono::seconds(10);

class TestWithExecutor : public testing::Test {
protected:
  TestWithExecutor() {
    this->_executorThread = std::thread([this]() {
      this->executor.spin();
    });
  }

  ~TestWithExecutor() override {
    this->executor.cancel();
    this->_executorThread.join();
  }

  rclcpp::executors::SingleThreadedExecutor executor;

private:
  std::thread _executorThread;
};

class ParameterTest : public TestWithExecutor {
public:
  using PARAM_1_TYPE = std::string;
  inline static const std::string NODE_1_NAME = "node_1";
  inline static const std::string PARAM_1_NAME = "string_param";
  inline static const PARAM_1_TYPE PARAM_1_DEFAULT_VALUE = "hello";
  inline static const std::string DELETABLE_PARAM_NAME = "deletable_param";

  using PARAM_2_TYPE = std::vector<int64_t>;
  inline static const std::string NODE_2_NAME = "node_2";
  inline static const std::string PARAM_2_NAME = "int_array_param";
  inline static const PARAM_2_TYPE PARAM_2_DEFAULT_VALUE = {1, 2, 3};

  using PARAM_3_TYPE = double;
  inline static const std::string PARAM_3_NAME = "float_param";
  inline static const PARAM_3_TYPE PARAM_3_DEFAULT_VALUE = 1.123;

  using PARAM_4_TYPE = std::vector<double>;
  inline static const std::string PARAM_4_NAME = "float_array_param";
  inline static const PARAM_4_TYPE PARAM_4_DEFAULT_VALUE = {1.1, 2.2, 3.3};

  using PARAM_5_TYPE = int64_t;
  inline static const std::string PARAM_5_NAME = "int_param";
  inline static const PARAM_5_TYPE PARAM_5_DEFAULT_VALUE = 123;

protected:
  void SetUp() override {
    auto nodeOptions = rclcpp::NodeOptions();
    nodeOptions.allow_undeclared_parameters(true);
    _paramNode1 = rclcpp::Node::make_shared(NODE_1_NAME, nodeOptions);
    auto p1Param = rcl_interfaces::msg::ParameterDescriptor{};
    p1Param.name = PARAM_1_NAME;
    p1Param.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
    p1Param.read_only = false;
    _paramNode1->declare_parameter(p1Param.name, PARAM_1_DEFAULT_VALUE, p1Param);
    _paramNode1->set_parameter(rclcpp::Parameter(DELETABLE_PARAM_NAME, true));

    _paramNode2 = rclcpp::Node::make_shared(NODE_2_NAME);
    auto p2Param = rcl_interfaces::msg::ParameterDescriptor{};
    p2Param.name = PARAM_2_NAME;
    p2Param.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER_ARRAY;
    p2Param.read_only = false;
    _paramNode2->declare_parameter(p2Param.name, PARAM_2_DEFAULT_VALUE, p2Param);
    _paramNode2->declare_parameter(PARAM_3_NAME, PARAM_3_DEFAULT_VALUE);
    _paramNode2->declare_parameter(PARAM_4_NAME, PARAM_4_DEFAULT_VALUE);
    _paramNode2->declare_parameter(PARAM_5_NAME, PARAM_5_DEFAULT_VALUE);

    executor.add_node(_paramNode1);
    executor.add_node(_paramNode2);

    _wsClient = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
    ASSERT_EQ(std::future_status::ready, _wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));
  }

  void TearDown() override {
    executor.remove_node(_paramNode1);
    executor.remove_node(_paramNode2);
  }

  rclcpp::Node::SharedPtr _paramNode1;
  rclcpp::Node::SharedPtr _paramNode2;
  std::shared_ptr<foxglove::test::Client<websocketpp::config::asio_client>> _wsClient;
};

// TODO: FG-12234: Enable when Service functionality is implemented
class ServiceTest : public TestWithExecutor {
public:
  inline static const std::string SERVICE_NAME = "/foo_service";

protected:
  void SetUp() override {
    _node = rclcpp::Node::make_shared("node");
    _service = _node->create_service<std_srvs::srv::SetBool>(
      SERVICE_NAME, [&](std::shared_ptr<std_srvs::srv::SetBool::Request> req,
                        std::shared_ptr<std_srvs::srv::SetBool::Response> res) {
        res->message = "hello";
        res->success = req->data;
      });
    executor.add_node(_node);
  }

  void TearDown() override {
    executor.remove_node(_node);
  }

  rclcpp::Node::SharedPtr _node;
  rclcpp::ServiceBase::SharedPtr _service;
  std::shared_ptr<foxglove::test::Client<websocketpp::config::asio_client>> _wsClient;
};

class PublisherTest
    : public TestWithExecutor,
      public testing::WithParamInterface<std::pair<std::string, std::vector<uint8_t>>> {};

class ExistingPublisherTest : public PublisherTest {
public:
  inline static const std::string TOPIC_NAME = "/some_topic";

protected:
  void SetUp() override {
    _node = rclcpp::Node::make_shared("node");
    _publisher =
      _node->create_publisher<std_msgs::msg::String>(TOPIC_NAME, rclcpp::SystemDefaultsQoS());
    executor.add_node(_node);
  }

  void TearDown() override {
    executor.remove_node(_node);
  }

  rclcpp::Node::SharedPtr _node;
  rclcpp::PublisherBase::SharedPtr _publisher;
};

template <class T>
std::shared_ptr<rclcpp::SerializedMessage> serializeMsg(const T* msg) {
  using rosidl_typesupport_cpp::get_message_type_support_handle;
  auto typeSupportHdl = get_message_type_support_handle<T>();
  auto result = std::make_shared<rclcpp::SerializedMessage>();
  rmw_ret_t ret = rmw_serialize(msg, typeSupportHdl, &result->get_rcl_serialized_message());
  EXPECT_EQ(ret, RMW_RET_OK);
  return result;
}

template <class T>
std::shared_ptr<T> deserializeMsg(const rcl_serialized_message_t* msg) {
  using rosidl_typesupport_cpp::get_message_type_support_handle;
  auto typeSupportHdl = get_message_type_support_handle<T>();
  auto result = std::make_shared<T>();
  rmw_ret_t ret = rmw_deserialize(msg, typeSupportHdl, result.get());
  EXPECT_EQ(ret, RMW_RET_OK);
  return result;
}

TEST(SmokeTest, testConnection) {
  foxglove::test::Client<websocketpp::config::asio_client> wsClient;
  EXPECT_EQ(std::future_status::ready, wsClient.connect(URI).wait_for(DEFAULT_TIMEOUT));
}

TEST(SmokeTest, testSubscription) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  std_msgs::msg::String rosMsg;
  rosMsg.data = "hello world";

  auto node = rclcpp::Node::make_shared("tester");
  rclcpp::QoS qos = rclcpp::QoS{rclcpp::KeepLast(1lu)};
  qos.reliable();
  qos.transient_local();
  auto pub = node->create_publisher<std_msgs::msg::String>(topic_name, qos);
  pub->publish(rosMsg);

  // Connect a few clients and make sure that they receive the correct message
  const auto clientCount = 3;
  for (auto i = 0; i < clientCount; ++i) {
    // Set up a client and subscribe to the channel.
    auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
    auto channelFuture = client->waitForChannel(topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
    const foxglove::test::Channel channel = channelFuture.get();
    const foxglove::test::SubscriptionId subscriptionId = 1;

    // Subscribe to the channel and confirm that the promise resolves
    auto msgFuture = client->waitForChannelMsg(subscriptionId);
    client->subscribe({{subscriptionId, channel.id}});
    ASSERT_EQ(std::future_status::ready, msgFuture.wait_for(ONE_SECOND));
    const auto msgData = msgFuture.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_CDR), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_CDR, msgData.data(), msgData.size()));

    // Unsubscribe from the channel again.
    client->unsubscribe({subscriptionId});
  }
}

TEST(SmokeTest, testSubscriptionParallel) {
  // Publish a string message on a latched ros topic
  const std::string topic_name = "/pub_topic";
  std_msgs::msg::String rosMsg;
  rosMsg.data = "hello world";

  auto node = rclcpp::Node::make_shared("tester");
  rclcpp::QoS qos = rclcpp::QoS{rclcpp::KeepLast(1lu)};
  qos.reliable();
  qos.transient_local();
  auto pub = node->create_publisher<std_msgs::msg::String>(topic_name, qos);
  pub->publish(rosMsg);

  // Connect a few clients (in parallel) and make sure that they receive the correct message
  const foxglove::test::SubscriptionId subscriptionId = 1;
  auto clients = {
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<uint8_t>>> futures;
  for (auto client : clients) {
    futures.push_back(client->waitForChannelMsg(subscriptionId));
  }

  for (auto client : clients) {
    auto channelFuture = client->waitForChannel(topic_name);
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
    ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
    const foxglove::test::Channel channel = channelFuture.get();
    client->subscribe({{subscriptionId, channel.id}});
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    auto msgData = future.get();
    ASSERT_EQ(sizeof(HELLO_WORLD_CDR), msgData.size());
    EXPECT_EQ(0, std::memcmp(HELLO_WORLD_CDR, msgData.data(), msgData.size()));
  }

  for (auto client : clients) {
    client->unsubscribe({subscriptionId});
  }
}

TEST_P(PublisherTest, testPublishing) {
  const auto& [encoding, message] = GetParam();
  // use a unique topic for each test to prevent tests from interfering with each other
  static size_t testPublishingCount = 0;
  ++testPublishingCount;

  foxglove::test::ClientAdvertisement advertisement;
  advertisement.channelId = 1;
  advertisement.topic = "/testPublishing_" + std::to_string(testPublishingCount);
  advertisement.encoding = encoding;
  advertisement.schemaName = "std_msgs/msg/String";
  advertisement.schema =
    std::vector<char>(STD_MSGS_STRING_SCHEMA, std::end(STD_MSGS_STRING_SCHEMA));

  // Set up a ROS node with a subscriber
  std::promise<std::string> msgPromise;
  auto msgFuture = msgPromise.get_future();
  auto node = rclcpp::Node::make_shared("tester");
  auto sub = node->create_subscription<std_msgs::msg::String>(
    advertisement.topic, 10, [&msgPromise](std::shared_ptr<const std_msgs::msg::String> msg) {
      msgPromise.set_value(msg->data);
    });
  this->executor.add_node(node);

  // Set up the client, advertise and publish the binary message
  auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  auto channelFuture = client->waitForChannel(advertisement.topic);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  client->advertise({advertisement});

  // Wait until the advertisement got advertised as channel by the server
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));

  // Publish the message and unadvertise again
  client->publish(advertisement.channelId, message.data(), message.size());
  client->unadvertise({advertisement.channelId});

  // Ensure that we have received the correct message via our ROS subscriber
  ASSERT_EQ(std::future_status::ready, msgFuture.wait_for(DEFAULT_TIMEOUT));
  this->executor.remove_node(node);
  EXPECT_EQ("hello world", msgFuture.get());
}

INSTANTIATE_TEST_SUITE_P(
  TestPublishingCDR, PublisherTest,
  testing::Values(std::make_pair("cdr", std::vector<uint8_t>(HELLO_WORLD_CDR,
                                                             std::end(HELLO_WORLD_CDR)))));

INSTANTIATE_TEST_SUITE_P(
  TestPublishingJSON, PublisherTest,
  testing::Values(std::make_pair("json", std::vector<uint8_t>(HELLO_WORLD_JSON,
                                                              std::end(HELLO_WORLD_JSON)))));

TEST_P(ExistingPublisherTest, testPublishingWithExistingPublisher) {
  const auto& [encoding, message] = GetParam();

  foxglove::test::ClientAdvertisement advertisement;
  advertisement.channelId = 1;
  advertisement.topic = TOPIC_NAME;
  advertisement.encoding = encoding;
  advertisement.schemaName = "std_msgs/msg/String";
  advertisement.schema = {};  // Schema intentionally left empty.

  // Set up a ROS node with a subscriber
  std::promise<std::string> msgPromise;
  auto msgFuture = msgPromise.get_future();
  auto node = rclcpp::Node::make_shared("tester");
  auto sub = node->create_subscription<std_msgs::msg::String>(
    advertisement.topic, 10, [&msgPromise](std::shared_ptr<const std_msgs::msg::String> msg) {
      msgPromise.set_value(msg->data);
    });
  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);

  // Set up the client, advertise and publish the binary message
  auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  auto channelFuture = client->waitForChannel(advertisement.topic);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  client->advertise({advertisement});

  // Wait until the advertisement got advertised as channel by the server
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));

  // Publish the message and unadvertise again
  client->publish(advertisement.channelId, message.data(), message.size());
  client->unadvertise({advertisement.channelId});

  // Ensure that we have received the correct message via our ROS subscriber
  const auto ret = executor.spin_until_future_complete(msgFuture, ONE_SECOND);
  ASSERT_EQ(rclcpp::FutureReturnCode::SUCCESS, ret);
  EXPECT_EQ("hello world", msgFuture.get());
}

INSTANTIATE_TEST_SUITE_P(
  ExistingPublisherTestCDR, ExistingPublisherTest,
  testing::Values(std::make_pair("cdr", std::vector<uint8_t>(HELLO_WORLD_CDR,
                                                             std::end(HELLO_WORLD_CDR)))));

INSTANTIATE_TEST_SUITE_P(
  ExistingPublisherTestJSON, ExistingPublisherTest,
  testing::Values(std::make_pair("json", std::vector<uint8_t>(HELLO_WORLD_JSON,
                                                              std::end(HELLO_WORLD_JSON)))));
TEST_F(ParameterTest, testGetAllParams) {
  const std::string requestId = "req-testGetAllParams";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->getParameters({}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_GE(params.size(), 2UL);
}

TEST_F(ParameterTest, testGetNonExistingParameters) {
  const std::string requestId = "req-testGetNonExistingParameters";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->getParameters(
    {"/foo_1.non_existing_parameter", "/foo_2.non_existing.nested_parameter"}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_TRUE(params.empty());
}

TEST_F(ParameterTest, testGetIntParameter) {
  const std::string requestId = "req-testGetIntParameter";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->getParameters({NODE_2_NAME + "." + PARAM_5_NAME}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_EQ(1UL, params.size());
  EXPECT_EQ(PARAM_5_DEFAULT_VALUE, params.front().get<PARAM_5_TYPE>());
}

TEST_F(ParameterTest, testGetParameters) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const auto p2 = NODE_2_NAME + "." + PARAM_2_NAME;

  const std::string requestId = "req-testGetParameters";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->getParameters({p1, p2}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [&p1](const auto& param) {
    return param.name() == p1;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [&p2](const auto& param) {
    return param.name() == p2;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(PARAM_1_DEFAULT_VALUE, p1Iter->get<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<int64_t> int_array_val;
  const auto array_params = p2Iter->get<std::vector<foxglove::ParameterValueView>>();
  for (const auto& paramValue : array_params) {
    int_array_val.push_back(paramValue.get<int64_t>());
  }
  EXPECT_EQ(int_array_val, PARAM_2_DEFAULT_VALUE);
}

TEST_F(ParameterTest, testSetParameters) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const auto p2 = NODE_2_NAME + "." + PARAM_2_NAME;
  const PARAM_1_TYPE newP1value = "world";

  // Create ParameterValue array properly
  std::vector<foxglove::ParameterValue> paramValueVec;
  paramValueVec.emplace_back(foxglove::ParameterValue(4L));
  paramValueVec.emplace_back(foxglove::ParameterValue(5L));
  paramValueVec.emplace_back(foxglove::ParameterValue(6L));
  foxglove::ParameterValue newP2value(std::move(paramValueVec));

  std::vector<foxglove::Parameter> parameters;
  parameters.emplace_back(foxglove::Parameter(p1, newP1value));
  parameters.emplace_back(
    foxglove::Parameter(p2, foxglove::ParameterType::None, std::move(newP2value)));

  _wsClient->setParameters(parameters);
  const std::string requestId = "req-testSetParameters";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->getParameters({p1, p2}, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_EQ(2UL, params.size());
  auto p1Iter = std::find_if(params.begin(), params.end(), [&p1](const auto& param) {
    return param.name() == p1;
  });
  auto p2Iter = std::find_if(params.begin(), params.end(), [&p2](const auto& param) {
    return param.name() == p2;
  });
  ASSERT_NE(p1Iter, params.end());
  EXPECT_EQ(newP1value, p1Iter->get<PARAM_1_TYPE>());
  ASSERT_NE(p2Iter, params.end());

  std::vector<int64_t> int_array_val;
  const auto array_params = p2Iter->get<std::vector<foxglove::ParameterValueView>>();
  for (const auto& paramValue : array_params) {
    int_array_val.push_back(paramValue.get<int64_t>());
  }
  const std::vector<int64_t> expected_value = {4, 5, 6};
  EXPECT_EQ(int_array_val, expected_value);
}

TEST_F(ParameterTest, testSetParametersWithReqId) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;
  const PARAM_1_TYPE newP1value = "world";
  std::vector<foxglove::Parameter> parameters;
  parameters.emplace_back(foxglove::Parameter(p1, newP1value));

  const std::string requestId = "req-testSetParameters";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_EQ(1UL, params.size());
}

TEST_F(ParameterTest, testSetFloatParametersWithIntegers) {
  const auto floatParamName = NODE_2_NAME + "." + PARAM_3_NAME;
  const auto floatArrayParamName = NODE_2_NAME + "." + PARAM_4_NAME;
  const int64_t floatParamVal = 10;
  const std::vector<int64_t> floatArrayParamVal = {3, 2, 1};
  const std::string requestId = "req-testSetFloatParametersWithIntegers";
  auto future = _wsClient->waitForParameters(requestId);
  const nlohmann::json::array_t parameters = {
    {{"name", floatParamName}, {"value", floatParamVal}, {"type", "float64"}},
    {{"name", floatArrayParamName}, {"value", floatArrayParamVal}, {"type", "float64_array"}},
  };
  _wsClient->sendText(
    nlohmann::json{{"op", "setParameters"}, {"id", requestId}, {"parameters", parameters}}.dump());
  ASSERT_EQ(std::future_status::ready, future.wait_for(ONE_SECOND));
  std::vector<foxglove::Parameter> params = future.get();

  {
    const auto param =
      std::find_if(params.begin(), params.end(), [floatParamName](const foxglove::Parameter& p) {
        return p.name() == floatParamName;
      });
    ASSERT_NE(param, params.end());
    EXPECT_EQ(param->type(), foxglove::ParameterType::Float64);
    EXPECT_NEAR(param->get<double>(), static_cast<double>(floatParamVal), 1e-9);
  }
  {
    const auto param = std::find_if(params.begin(), params.end(),
                                    [floatArrayParamName](const foxglove::Parameter& p) {
                                      return p.name() == floatArrayParamName;
                                    });
    ASSERT_NE(param, params.end());
    EXPECT_EQ(param->type(), foxglove::ParameterType::Float64Array);
    const auto paramValue = param->get<std::vector<foxglove::ParameterValueView>>();
    ASSERT_EQ(paramValue.size(), floatArrayParamVal.size());
    for (size_t i = 0; i < paramValue.size(); ++i) {
      EXPECT_NEAR(paramValue[i].get<double>(), static_cast<double>(floatArrayParamVal[i]), 1e-9);
    }
  }
}

TEST_F(ParameterTest, testUnsetParameter) {
  const auto p1 = NODE_1_NAME + "." + DELETABLE_PARAM_NAME;
  std::vector<foxglove::Parameter> parameters;
  parameters.emplace_back(foxglove::Parameter(p1));

  const std::string requestId = "req-testUnsetParameter";
  auto future = _wsClient->waitForParameters(requestId);
  _wsClient->setParameters(parameters, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  EXPECT_EQ(0UL, params.size());
}

TEST_F(ParameterTest, testParameterSubscription) {
  const auto p1 = NODE_1_NAME + "." + PARAM_1_NAME;

  _wsClient->subscribeParameterUpdates({p1});
  auto future = _wsClient->waitForParameters();
  std::vector<foxglove::Parameter> setParams;
  setParams.emplace_back(foxglove::Parameter(p1, "foo"));
  _wsClient->setParameters(setParams);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  std::vector<foxglove::Parameter> params = future.get();

  ASSERT_EQ(1UL, params.size());
  EXPECT_EQ(params.front().name(), p1);

  _wsClient->unsubscribeParameterUpdates({p1});
  std::vector<foxglove::Parameter> setParams2;
  setParams2.emplace_back(foxglove::Parameter(p1, "bar"));
  _wsClient->setParameters(setParams2);

  future = _wsClient->waitForParameters();
  ASSERT_EQ(std::future_status::timeout, future.wait_for(ONE_SECOND));
}

TEST_F(ParameterTest, testGetParametersParallel) {
  // Connect a few clients (in parallel) and make sure that they all receive parameters
  auto clients = {
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
  };

  std::vector<std::future<std::vector<foxglove::Parameter>>> futures;
  for (auto client : clients) {
    futures.push_back(
      std::async(std::launch::async, [client]() -> std::vector<foxglove::Parameter> {
        if (std::future_status::ready == client->connect(URI).wait_for(DEFAULT_TIMEOUT)) {
          const std::string requestId = "req-123";
          auto future = client->waitForParameters(requestId);
          client->getParameters({}, requestId);
          future.wait_for(DEFAULT_TIMEOUT);
          if (future.valid()) {
            return future.get();
          }
        }
        return {};
      }));
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    std::vector<foxglove::Parameter> parameters;
    EXPECT_NO_THROW(parameters = future.get());
    EXPECT_GE(parameters.size(), 2UL);
  }
}

TEST_F(ServiceTest, testAdvertiseService) {
  auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  auto serviceFuture = client->waitForService(SERVICE_NAME);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  ASSERT_EQ(std::future_status::ready, serviceFuture.wait_for(DEFAULT_TIMEOUT));
  const foxglove::test::Service service = serviceFuture.get();

  EXPECT_EQ(service.name, SERVICE_NAME);
  EXPECT_EQ(service.type, "std_srvs/srv/SetBool");
  EXPECT_EQ(service.requestSchema, "bool data # e.g. for hardware enabling / disabling");
  EXPECT_EQ(service.responseSchema,
            "bool success   # indicate successful run of triggered service\nstring message # "
            "informational, e.g. for error messages");
}

TEST_F(ServiceTest, testCallServiceParallel) {
  // Connect a few clients (in parallel) and make sure that they can all call the service
  auto clients = {
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
    std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>(),
  };

  auto clientIt = clients.begin();
  auto serviceFuture = (*clientIt)->waitForService(SERVICE_NAME);
  for (auto client : clients) {
    ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  }
  ASSERT_EQ(std::future_status::ready, serviceFuture.wait_for(DEFAULT_TIMEOUT));
  const foxglove::test::Service service = serviceFuture.get();

  std_srvs::srv::SetBool::Request requestMsg;
  requestMsg.data = true;
  const auto serializedRequest = serializeMsg(&requestMsg);
  const auto& serRequestMsg = serializedRequest->get_rcl_serialized_message();

  foxglove::test::ServiceRequest request;
  request.serviceId = service.id;
  request.callId = 123lu;
  request.encoding = "cdr";
  request.data.resize(serRequestMsg.buffer_length);
  std::memcpy(request.data.data(), serRequestMsg.buffer, serRequestMsg.buffer_length);

  std::vector<std::future<foxglove::test::ServiceResponse>> futures;
  for (auto client : clients) {
    futures.push_back(client->waitForServiceResponse());
    client->sendServiceRequest(request);
  }

  for (auto& future : futures) {
    ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
    foxglove::test::ServiceResponse response;
    EXPECT_NO_THROW(response = future.get());
    EXPECT_EQ(response.serviceId, request.serviceId);
    EXPECT_EQ(response.callId, request.callId);
    EXPECT_EQ(response.encoding, request.encoding);

    rclcpp::SerializedMessage serializedResponseMsg(response.data.size());
    auto& serMsg = serializedResponseMsg.get_rcl_serialized_message();
    std::memcpy(serMsg.buffer, response.data.data(), response.data.size());
    serMsg.buffer_length = response.data.size();
    const auto resMsg = deserializeMsg<std_srvs::srv::SetBool::Response>(&serMsg);

    EXPECT_EQ(resMsg->message, "hello");
    EXPECT_EQ(resMsg->success, requestMsg.data);
  }
}

TEST_F(ServiceTest, testCallNonexistentService) {
  auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(std::chrono::seconds(5)));

  std::promise<nlohmann::json> promise;
  auto serviceFailureFuture = promise.get_future();
  client->setTextMessageHandler([&promise](const std::string& payload) mutable {
    const auto msg = nlohmann::json::parse(payload);
    if (msg["op"].get<std::string>() == "serviceCallFailure") {
      promise.set_value(msg);
    }
  });

  foxglove::test::ServiceRequest request;
  request.serviceId = 99u;
  request.callId = 123u;
  request.encoding = "";
  request.data = {};
  client->sendServiceRequest(request);

  ASSERT_EQ(std::future_status::ready, serviceFailureFuture.wait_for(std::chrono::seconds(5)));
  const auto failureMsg = serviceFailureFuture.get();
  EXPECT_EQ(failureMsg["serviceId"].get<foxglove::test::ServiceId>(), request.serviceId);
  EXPECT_EQ(failureMsg["callId"].get<uint32_t>(), request.callId);
}

TEST(SmokeTest, receiveMessagesOfMultipleTransientLocalPublishers) {
  const std::string topicName = "/latched";
  auto node = rclcpp::Node::make_shared("node");
  rclcpp::QoS qos = rclcpp::QoS(rclcpp::KeepLast(1));
  qos.transient_local();
  qos.reliable();

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(node);
  auto spinnerThread = std::thread([&executor]() {
    executor.spin();
  });

  constexpr size_t nPubs = 15;
  std::vector<rclcpp::Publisher<std_msgs::msg::String>::SharedPtr> pubs;
  for (size_t i = 0; i < nPubs; ++i) {
    auto pub = pubs.emplace_back(node->create_publisher<std_msgs::msg::String>(topicName, qos));
    std_msgs::msg::String msg;
    msg.data = "Hello";
    pub->publish(msg);
  }

  // Set up a client and subscribe to the channel.
  auto client = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  auto channelFuture = client->waitForChannel(topicName);
  ASSERT_EQ(std::future_status::ready, client->connect(URI).wait_for(ONE_SECOND));
  ASSERT_EQ(std::future_status::ready, channelFuture.wait_for(ONE_SECOND));
  const foxglove::test::Channel channel = channelFuture.get();
  const foxglove::test::SubscriptionId subscriptionId = 1;

  // Set up binary message handler to resolve the promise when all nPub message have been received
  std::promise<void> promise;
  std::atomic<size_t> nReceivedMessages = 0;
  client->setBinaryMessageHandler([&promise, &nReceivedMessages](const uint8_t*, size_t) {
    if (++nReceivedMessages == nPubs) {
      promise.set_value();
    }
  });

  // Subscribe to the channel and confirm that the promise resolves
  client->subscribe({{subscriptionId, channel.id}});
  EXPECT_EQ(std::future_status::ready, promise.get_future().wait_for(DEFAULT_TIMEOUT));
  EXPECT_EQ(nReceivedMessages, nPubs);
  client->unsubscribe({subscriptionId});

  pubs.clear();
  executor.remove_node(node);
  executor.cancel();
  spinnerThread.join();
}

TEST(FetchAssetTest, fetchExistingAsset) {
  auto wsClient = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const auto millisSinceEpoch = std::chrono::duration_cast<std::chrono::milliseconds>(
    std::chrono::system_clock::now().time_since_epoch());
  const auto tmpFilePath =
    std::filesystem::temp_directory_path() / std::to_string(millisSinceEpoch.count());
  constexpr char content[] = "Hello, world";
  FILE* tmpAssetFile = std::fopen(tmpFilePath.c_str(), "w");
  std::fputs(content, tmpAssetFile);
  std::fclose(tmpAssetFile);

  const std::string uri = std::string("file://") + tmpFilePath.string();
  const uint32_t requestId = 123;

  auto future = wsClient->waitForFetchAssetResponse();
  wsClient->fetchAsset(uri, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove::test::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove::test::FetchAssetStatus::Success);
  // +1 since NULL terminator is not written to file.
  ASSERT_EQ(response.data.size() + 1ul, sizeof(content));
  EXPECT_EQ(0, std::memcmp(content, response.data.data(), response.data.size()));
  std::remove(tmpFilePath.c_str());
}

TEST(FetchAssetTest, fetchNonExistingAsset) {
  auto wsClient = std::make_shared<foxglove::test::Client<websocketpp::config::asio_client>>();
  EXPECT_EQ(std::future_status::ready, wsClient->connect(URI).wait_for(DEFAULT_TIMEOUT));

  const std::string assetId = "file:///foo/bar";
  const uint32_t requestId = 456;

  auto future = wsClient->waitForFetchAssetResponse();
  wsClient->fetchAsset(assetId, requestId);
  ASSERT_EQ(std::future_status::ready, future.wait_for(DEFAULT_TIMEOUT));
  const foxglove::test::FetchAssetResponse response = future.get();

  EXPECT_EQ(response.requestId, requestId);
  EXPECT_EQ(response.status, foxglove::test::FetchAssetStatus::Error);
  EXPECT_FALSE(response.errorMessage.empty());
}

// Run all the tests that were declared with TEST()
int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  rclcpp::init(argc, argv);

  rclcpp::executors::SingleThreadedExecutor executor;
  rclcpp::NodeOptions nodeOptions;
  // Explicitly allow file:// asset URIs for testing purposes.
  nodeOptions.append_parameter_override("asset_uri_allowlist",
                                        std::vector<std::string>({"file://.*"}));
  foxglove_bridge::FoxgloveBridge node(nodeOptions);
  executor.add_node(node.get_node_base_interface());

  std::thread spinnerThread([&executor]() {
    executor.spin();
  });

  const auto testResult = RUN_ALL_TESTS();

  executor.cancel();
  spinnerThread.join();
  executor.remove_node(node.get_node_base_interface());

  return testResult;
}



================================================
FILE: ros2_foxglove_bridge_sdk/tests/utils_test.cpp
================================================
#include <gtest/gtest.h>

#include <foxglove_bridge/utils.hpp>

TEST(SplitDefinitionsTest, EmptyMessageDefinition) {
  const std::string messageDef = "";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 1u);
  EXPECT_EQ(definitions[0], "");
}

TEST(SplitDefinitionsTest, ServiceDefinition) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "bool success ";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "bool success");
}

TEST(SplitDefinitionsTest, ServiceDefinitionEmptyRequest) {
  const std::string messageDef =
    "---\n"
    "bool success ";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "");
  EXPECT_EQ(definitions[1], "bool success");
}

TEST(SplitDefinitionsTest, ServiceDefinitionEmptyResponse) {
  const std::string messageDef =
    "bool data\n"
    "---";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "");
}

TEST(SplitDefinitionsTest, ActionDefinition) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "bool success\n"
    "---\n"
    "bool feedback";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 3u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "bool success");
  EXPECT_EQ(definitions[2], "bool feedback");
}

TEST(SplitDefinitionsTest, ActionDefinitionNoGoal) {
  const std::string messageDef =
    "bool data\n"
    "---\n"
    "---\n"
    "bool feedback";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 3u);
  EXPECT_EQ(definitions[0], "bool data");
  EXPECT_EQ(definitions[1], "");
  EXPECT_EQ(definitions[2], "bool feedback");
}

TEST(SplitDefinitionsTest, HandleCarriageReturn) {
  const std::string messageDef =
    "---\r\n"
    "string device_name\n";
  std::istringstream stream(messageDef);
  const auto definitions = foxglove_bridge::splitMessageDefinitions(stream);
  ASSERT_EQ(definitions.size(), 2u);
  EXPECT_EQ(definitions[0], "");
  EXPECT_EQ(definitions[1], "string device_name");
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}



================================================
FILE: scripts/format.py
================================================
import argparse
import difflib
import os
import subprocess
import sys
from typing import List

IGNORE_DIRS = ["build"]
EXTENSIONS = [".cpp", ".hpp"]


def main(dirs: List[str], fix: bool):
    changed_paths: List[str] = []
    for root in dirs:
        for dirpath, dirnames, filenames in os.walk(root):
            # Filter out directories to skip
            dirnames[:] = filter(lambda d: d not in IGNORE_DIRS, dirnames)

            for name in filenames:
                path = os.path.join(dirpath, name)
                if any(name.endswith(ext) for ext in EXTENSIONS):
                    if fix:
                        subprocess.check_call(["clang-format", "-i", path])
                        continue

                    stdout = (
                        subprocess.check_output(["clang-format", path])
                        .decode("utf-8")
                        .splitlines()
                    )

                    with open(path, "r") as f:
                        orig = [line.rstrip("\n") for line in f]
                    diff = difflib.unified_diff(
                        orig,
                        stdout,
                        fromfile=path,
                        tofile=f"clang-format {path}",  # cspell:disable-line
                        lineterm="",
                    )
                    had_diff = False
                    for line in diff:
                        had_diff = True
                        print(line)
                    if had_diff:
                        changed_paths.append(path)
                        print("\n")

    if changed_paths:
        print(f"{len(changed_paths)} files need to be formatted:")
        for path in changed_paths:
            print(f"  {path}")
        return 1
    return 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Run clang-format and display changed files."
    )
    parser.add_argument(
        "dirs", help="List of directories to search", nargs="+")
    parser.add_argument("--fix", action="store_true")
    args = parser.parse_args()
    sys.exit(main(**vars(args)))



================================================
FILE: .devcontainer/colcon_defaults.yaml
================================================
"":
  log-base: /ros_ws/log_ros2

build:
  symlink-install: True
  build-base: /ros_ws/build_ros2
  install-base: /ros_ws/install_ros2
  event-handlers: ["console_direct+"]

test:
  build-base: /ros_ws/build_ros2
  install-base: /ros_ws/install_ros2
  return-code-on-test-failure: True
  event-handlers: ["console_direct+"]



================================================
FILE: .devcontainer/devcontainer.json
================================================
// -*- jsonc -*-
{
  "name": "ROS 2",
  "workspaceFolder": "/ros_ws/src/ros-foxglove-bridge",
  "workspaceMount": "source=${localWorkspaceFolder},target=/ros_ws/src/ros-foxglove-bridge,type=bind,consistency=cached",
  "dockerFile": "./Dockerfile",
  "context": "..",
  "forwardPorts": [
    8765
  ],
  "customizations": {
    "vscode": {
      "extensions": [
        "llvm-vs-code-extensions.vscode-clangd",
        "ms-vscode.cpptools",
        "xaver.clang-format",
        "twxs.cmake"
      ],
      "settings": {
        "terminal.integrated.defaultProfile.linux": "bash",
        "terminal.integrated.profiles.linux": {
          "bash": {
            "path": "/bin/bash",
            "args": [
              "-l"
            ],
            "icon": "terminal-bash"
          }
        },
        "clangd.arguments": [
          "-log=verbose",
          "-pretty",
          "--background-index",
          "--compile-commands-dir=/ros_ws/build_ros2"
        ]
      }
    }
  },
  "capAdd": [
    "SYS_PTRACE"
  ],
  // More info: <https://aka.ms/dev-containers-non-root>
  "remoteUser": "vscode"
}



================================================
FILE: .devcontainer/Dockerfile
================================================
ARG ROS_DISTRIBUTION=humble
FROM ros:$ROS_DISTRIBUTION-ros-base

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
  bash-completion \
  build-essential \
  clang \
  clang-format \
  clangd-14 \
  curl \
  gdb \
  git \
  git-lfs \
  gnupg \
  libasio-dev \
  libboost-all-dev \
  libssl-dev \
  libwebsocketpp-dev \
  nlohmann-json3-dev \
  strace \
  sudo \
  && rm -rf /var/lib/apt/lists/*

# Set clang as default compiler
ENV CC=clang
ENV CXX=clang++

# Configure clangd
RUN update-alternatives --install /usr/local/bin/clangd clangd $(which clangd-14) 1000

# Create a non-root user
# Taken from https://code.visualstudio.com/remote/advancedcontainers/add-nonroot-user#_creating-a-nonroot-user
ARG USERNAME=vscode
ARG USER_UID=1000
ARG USER_GID=$USER_UID

# Create the user and add them to sudoers
RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && echo $USERNAME ALL=\(root\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME \
    && chmod 0440 /etc/sudoers.d/$USERNAME

USER $USERNAME

# Set environment and working directory
ENV ROS_WS=/ros_ws
WORKDIR $ROS_WS
RUN sudo mkdir -p $ROS_WS/src && sudo chown -R $USERNAME:$USERNAME $ROS_WS

# Add package.xml so we can install package dependencies
COPY --chown=$USERNAME:$USERNAME package.xml src/ros-foxglove-bridge/

# Update rosdep and install dependencies
RUN rosdep update --include-eol-distros
RUN sudo apt-get update && rosdep install -y \
      --from-paths \
        src \
      --ignore-src \
    && sudo rm -rf /var/lib/apt/lists/*

ENV COLCON_DEFAULTS_FILE=/$ROS_WS/src/ros-foxglove-bridge/.devcontainer/colcon_defaults.yaml

SHELL ["/bin/bash", "-c"]

# Add aliases to .bashrc
RUN echo $'\
alias ros2_build_debug="source /opt/ros/humble/setup.bash && colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"\n\
alias ros2_build_release="source /opt/ros/humble/setup.bash && colcon build --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo"\n\
alias ros2_build_debug_sdk="source /opt/ros/humble/setup.bash && colcon build --cmake-args -DCMAKE_BUILD_TYPE=Debug -DUSE_FOXGLOVE_SDK=ON"\n\
alias ros2_build_release_sdk="source /opt/ros/humble/setup.bash && colcon build --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_FOXGLOVE_SDK=ON"\n\
alias ros2_foxglove_bridge="source /ros_ws/install_ros2/setup.bash && ros2 run foxglove_bridge foxglove_bridge --ros-args --log-level debug --log-level rcl:=INFO"\n\
' >> ~/.bashrc



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  push:
    branches: [main, release/*]
  pull_request:

jobs:
  lint:
    strategy:
      fail-fast: false

    name: Lint
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - run: make lint

  test:
    strategy:
      fail-fast: false
      matrix:
        ros_distribution: [melodic, noetic, humble, jazzy, kilted, rolling]

    name: Test (ROS ${{ matrix.ros_distribution }})
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: make ${{ matrix.ros_distribution }}-test

  test-boost-asio:
    strategy:
      fail-fast: false
      matrix:
        ros_distribution: [noetic, humble, rolling]

    name: Test (ROS ${{ matrix.ros_distribution }}, Boost Asio)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: make ${{ matrix.ros_distribution }}-test-boost-asio

  test-sdk:
    strategy:
      fail-fast: false
      matrix:
        ros_distribution: [jazzy, kilted, rolling]

    name: Test (ROS ${{ matrix.ros_distribution }}, SDK Server)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      - run: make USE_FOXGLOVE_SDK=ON ${{ matrix.ros_distribution }}-test


