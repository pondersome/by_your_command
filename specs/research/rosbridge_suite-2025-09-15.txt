Directory structure:
└── robotwebtools-rosbridge_suite/
    ├── README.md
    ├── AUTHORS.md
    ├── LICENSE
    ├── pyproject.toml
    ├── QUALITY_DECLARATION.md
    ├── ROSBRIDGE_PROTOCOL.md
    ├── setup.cfg
    ├── TROUBLESHOOTING.md
    ├── .pre-commit-config.yaml
    ├── rosapi/
    │   ├── README.md
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── mapping_rules.yaml
    │   ├── package.xml
    │   ├── scripts/
    │   │   └── rosapi_node
    │   ├── src/
    │   │   └── rosapi/
    │   │       ├── __init__.py
    │   │       ├── async_helper.py
    │   │       ├── glob_helper.py
    │   │       ├── objectutils.py
    │   │       ├── params.py
    │   │       ├── proxy.py
    │   │       └── stringify_field_types.py
    │   └── test/
    │       ├── __init__.py
    │       ├── test_stringify_field_types.py
    │       └── test_typedefs.py
    ├── rosapi_msgs/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── msg/
    │   │   └── TypeDef.msg
    │   └── srv/
    │       ├── ActionFeedbackDetails.srv
    │       ├── ActionGoalDetails.srv
    │       ├── ActionResultDetails.srv
    │       ├── ActionType.srv
    │       ├── DeleteParam.srv
    │       ├── GetActionServers.srv
    │       ├── GetParam.srv
    │       ├── GetParamNames.srv
    │       ├── GetROSVersion.srv
    │       ├── GetTime.srv
    │       ├── HasParam.srv
    │       ├── Interfaces.srv
    │       ├── MessageDetails.srv
    │       ├── NodeDetails.srv
    │       ├── Nodes.srv
    │       ├── Publishers.srv
    │       ├── ServiceNode.srv
    │       ├── ServiceProviders.srv
    │       ├── ServiceRequestDetails.srv
    │       ├── ServiceResponseDetails.srv
    │       ├── Services.srv
    │       ├── ServicesForType.srv
    │       ├── ServiceType.srv
    │       ├── SetParam.srv
    │       ├── Subscribers.srv
    │       ├── Topics.srv
    │       ├── TopicsAndRawTypes.srv
    │       ├── TopicsForType.srv
    │       └── TopicType.srv
    ├── rosbridge_library/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── doc/
    │   │   └── conf.py
    │   ├── src/
    │   │   └── rosbridge_library/
    │   │       ├── __init__.py
    │   │       ├── capability.py
    │   │       ├── protocol.py
    │   │       ├── rosbridge_protocol.py
    │   │       ├── capabilities/
    │   │       │   ├── __init__.py
    │   │       │   ├── action_feedback.py
    │   │       │   ├── action_result.py
    │   │       │   ├── advertise.py
    │   │       │   ├── advertise_action.py
    │   │       │   ├── advertise_service.py
    │   │       │   ├── call_service.py
    │   │       │   ├── defragmentation.py
    │   │       │   ├── fragmentation.py
    │   │       │   ├── publish.py
    │   │       │   ├── send_action_goal.py
    │   │       │   ├── service_response.py
    │   │       │   ├── subscribe.py
    │   │       │   ├── unadvertise_action.py
    │   │       │   └── unadvertise_service.py
    │   │       ├── internal/
    │   │       │   ├── __init__.py
    │   │       │   ├── actions.py
    │   │       │   ├── cbor_conversion.py
    │   │       │   ├── exceptions.py
    │   │       │   ├── message_conversion.py
    │   │       │   ├── outgoing_message.py
    │   │       │   ├── pngcompression.py
    │   │       │   ├── publishers.py
    │   │       │   ├── ros_loader.py
    │   │       │   ├── services.py
    │   │       │   ├── subscribers.py
    │   │       │   ├── subscription_modifiers.py
    │   │       │   └── topics.py
    │   │       └── util/
    │   │           ├── __init__.py
    │   │           ├── cbor.py
    │   │           └── ros.py
    │   └── test/
    │       ├── __init__.py
    │       ├── test_all.test
    │       ├── capabilities/
    │       │   ├── __init__.py
    │       │   ├── test_action_capabilities.py
    │       │   ├── test_advertise.py
    │       │   ├── test_call_service.py
    │       │   ├── test_publish.py
    │       │   ├── test_service_capabilities.py
    │       │   └── test_subscribe.py
    │       ├── experimental/
    │       │   ├── complex_srv+tcp/
    │       │   │   ├── test_non-ros_service_client_complex-srv.py
    │       │   │   └── test_non-ros_service_server_complex-srv.py
    │       │   └── fragmentation+srv+tcp/
    │       │       ├── test_non-ros_service_client_fragmented.py
    │       │       └── test_non-ros_service_server_fragmented.py
    │       └── internal/
    │           ├── __init__.py
    │           ├── test_cbor_conversion.py
    │           ├── test_compression.py
    │           ├── test_message_conversion.py
    │           ├── test_outgoing_message.py
    │           ├── test_ros_loader.py
    │           ├── actions/
    │           │   └── test_actions.py
    │           ├── publishers/
    │           │   ├── __init__.py
    │           │   ├── test_multi_publisher.py
    │           │   └── test_publisher_manager.py
    │           ├── services/
    │           │   └── test_services.py
    │           └── subscribers/
    │               ├── __init__.py
    │               ├── test_multi_subscriber.py
    │               ├── test_subscriber_manager.py
    │               └── test_subscription_modifiers.py
    ├── rosbridge_msgs/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   └── msg/
    │       ├── ConnectedClient.msg
    │       └── ConnectedClients.msg
    ├── rosbridge_server/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── launch/
    │   │   └── rosbridge_websocket_launch.xml
    │   ├── scripts/
    │   │   ├── rosbridge_websocket.py
    │   │   └── rosbridge_websocket -> rosbridge_websocket.py
    │   ├── src/
    │   │   └── rosbridge_server/
    │   │       ├── __init__.py
    │   │       ├── client_manager.py
    │   │       └── websocket_handler.py
    │   └── test/
    │       └── websocket/
    │           ├── advertise_action.test.py
    │           ├── advertise_action_feedback.test.py
    │           ├── advertise_service.test.py
    │           ├── advertise_service_duplicate.test.py
    │           ├── best_effort_publisher.test.py
    │           ├── call_service.test.py
    │           ├── common.py
    │           ├── multiple_subscribers.test.py
    │           ├── multiple_subscribers_raw.test.py
    │           ├── send_action_goal.test.py
    │           ├── smoke.test.py
    │           └── transient_local_publisher.test.py
    ├── rosbridge_suite/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   └── package.xml
    ├── rosbridge_test_msgs/
    │   ├── CHANGELOG.rst
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── action/
    │   │   ├── TestEmpty.action
    │   │   ├── TestFeedbackAndResult.action
    │   │   ├── TestGoalAndResult.action
    │   │   ├── TestGoalFeedbackAndResult.action
    │   │   ├── TestGoalOnly.action
    │   │   ├── TestMultipleGoalFields.action
    │   │   └── TestResultOnly.action
    │   ├── msg/
    │   │   ├── Num.msg
    │   │   ├── TestChar.msg
    │   │   ├── TestDurationArray.msg
    │   │   ├── TestFloat32Array.msg
    │   │   ├── TestFloat32BoundedArray.msg
    │   │   ├── TestHeader.msg
    │   │   ├── TestHeaderArray.msg
    │   │   ├── TestHeaderTwo.msg
    │   │   ├── TestNestedBoundedArray.msg
    │   │   ├── TestTimeArray.msg
    │   │   ├── TestUInt8.msg
    │   │   └── TestUInt8FixedSizeArray16.msg
    │   └── srv/
    │       ├── AddTwoInts.srv
    │       ├── SendBytes.srv
    │       ├── TestArrayRequest.srv
    │       ├── TestEmpty.srv
    │       ├── TestMultipleRequestFields.srv
    │       ├── TestMultipleResponseFields.srv
    │       ├── TestNestedService.srv
    │       ├── TestRequestAndResponse.srv
    │       ├── TestRequestOnly.srv
    │       └── TestResponseOnly.srv
    └── .github/
        ├── dependabot.yml
        ├── ISSUE_TEMPLATE.md
        └── workflows/
            ├── ci.yml
            └── stale.yml

================================================
FILE: README.md
================================================
rosbridge_suite
===============

[![ROS Humble version](https://img.shields.io/ros/v/humble/rosbridge_suite)](https://index.ros.org/p/rosbridge_suite/github-RobotWebTools-rosbridge_suite/#humble)
[![ROS Jazzy version](https://img.shields.io/ros/v/jazzy/rosbridge_suite)](https://index.ros.org/p/rosbridge_suite/github-RobotWebTools-rosbridge_suite/#jazzy)
[![ROS Rolling version](https://img.shields.io/ros/v/rolling/rosbridge_suite)](https://index.ros.org/p/rosbridge_suite/github-RobotWebTools-rosbridge_suite/#rolling)


#### Server Implementations of the rosbridge v2 Protocol

rosbridge provides a JSON interface to ROS, allowing any client to send JSON to publish or subscribe to ROS topics, call ROS services, and more. rosbridge supports a variety of transport layers, including WebSockets and TCP. For information on the protocol itself, see the [rosbridge protocol specification](ROSBRIDGE_PROTOCOL.md).

For full documentation, see [the ROS wiki](http://ros.org/wiki/rosbridge_suite).

This project is released as part of the [Robot Web Tools](https://robotwebtools.github.io/) effort.

### Packages

 * [rosbridge_suite](rosbridge_suite) is a [ROS meta-package](http://www.ros.org/wiki/catkin/conceptual_overview#Metapackages_and_the_Elimination_of_Stacks) including all the rosbridge packages.

 * [rosbridge_library](rosbridge_library) contains the Python API that receives JSON-formatted strings as input and controls ROS publishers/subscribers/service calls according to the content of the JSON strings.

 * [rosbridge_server](rosbridge_server) contains a WebSocket server implementation that exposes the rosbridge_library.

 * [rosapi](rosapi) provides service calls for getting meta-information related to ROS like topic lists as well as interacting with the Parameter Server.

### Clients

A rosbridge client is a program that communicates with rosbridge using its JSON API. rosbridge clients include:

 * [roslibjs](https://github.com/RobotWebTools/roslibjs) - A JavaScript API, which communicates with rosbridge over WebSockets.
 * [jrosbridge](https://github.com/WPI-RAIL/jrosbridge) - A Java API, which communicates with rosbridge over WebSockets.
 * [roslibpy](https://github.com/gramaziokohler/roslibpy) - A Python API, which communicates with rosbridge over WebSockets.
 * [roslibrust](https://github.com/Carter12s/roslibrust) - A Rust API, which communicates with rosbridge over WebSockets.

### License
rosbridge_suite is released with a BSD license. For full terms and conditions, see the [LICENSE](LICENSE) file.

### Authors
See the [AUTHORS](AUTHORS.md) file for a full list of contributors.

### Quality Declaration
This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](/QUALITY_DECLARATION.md) for more details.

### Troubleshooting

See the [TROUBLESHOOTING](TROUBLESHOOTING.md) doc for common problems and solutions.

### Release process

Releasing requires push access to [RobotWebTools/rosbridge_suite](https://github.com/RobotWebTools/rosbridge_suite) as well as [ros2-gbp/rosbridge_suite-release](https://github.com/ros2-gbp/rosbridge_suite-release). For more details on how the release process works, see the [bloom tutorial](https://docs.ros.org/en/galactic/How-To-Guides/Releasing-a-ROS-2-package-with-bloom.html).

1. Run `catkin_generate_changelog` to update CHANGELOG.rst files.
2. Manually edit and clean up the changelogs. Commit the changes.
3. Run `catkin_prepare_release --bump [major/minor/patch]` to bump versions in package.xml and push changes to origin.
4. Run bloom-release commands to create PRs to update rosdistro:
    - `bloom-release --rosdistro humble rosbridge_suite`
    - `bloom-release --rosdistro jazzy rosbridge_suite`
    - `bloom-release --rosdistro rolling rosbridge_suite`

Note that right now, the Humble release is tracked in the `humble` branch, while Jazzy and later are tracked in the `ros2` branch.

Once the PRs are merged, packages will be available for each distro after the next sync.
Build/sync status can be viewed at: [humble](http://repo.ros2.org/status_page/ros_humble_default.html), [jazzy](http://repo.ros2.org/status_page/ros_jazzy_default.html), and [rolling](http://repo.ros2.org/status_page/ros_rolling_default.html).



================================================
FILE: AUTHORS.md
================================================
## Contributors

- Brandon Alexander <baalexander@gmail.com>
- David Bertram <davidbertram@gmx.de>
- Hans-Joachim Krauch <achim@foxglove.dev>
- Jacob Bandes-Storch <jacob@foxglove.dev>
- Jihoon Lee <jihoonlee.in@gmail.com>
- Jonathan Mace <jonathan.c.mace@gmail.com>
- Matthias Gruhler <matthias.gruhler@ipa.fraunhofer.de>
- Russell Toris <rctoris@wpi.edu>
- Travis Prosser <travisprosser@gmail.com>
- Błażej Sowa <blazej@fictionlab.pl>



================================================
FILE: LICENSE
================================================
BSD 3-Clause License

Copyright (c) The Rosbridge Authors

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: pyproject.toml
================================================
[tool.black]
# We use ruff for formatting, but black formatter should be compatible with ruff.
line-length = 100

[tool.ruff]
line-length = 100

[tool.ruff.lint]
select = [
    # "AIR",  # Airflow, We don't use this framework
    # "ERA",  # Eradicate, We allow commented-out code
    # "FAST", # FastAPI, We don't use this framework

    # flake8 extensions
    "YTT",    # flake8-2020
    # "ANN",  # flake8-annotations, There are too many missing annotations right now (TODO)
    "ASYNC",  # flake8-async
    "S",      # flake8-bandit
    # "BLE",  # flake8-blind-except, Too much hassle to fix (TODO)
    # "FBT",  # flake8-boolean-trap, We allow boolean traps
    "B",      # flake8-bugbear
    "A",      # flake8-builtins
    # "COM",  # flake8-commas, We don't require trailing commas
    "C4",     # flake8-comprehensions
    # "CPY",  # flake8-copyright, preview feature
    "DTZ",    # flake8-datetimez
    "T10",    # flake8-debugger
    # "DJ",   # flake8-django, We don't use this framework
    "EM",     # flake8-errmsg
    "EXE",    # flake8-executable
    # "FIX",  # flake8-fixme, too many TODOs to fix them now
    "FA",     # flake8-future-annotations
    "INT",    # flake8-gettext
    "ISC",    # flake8-implicit-str-concat
    "ICN",    # flake8-import-conventions
    "LOG",    # flake8-logging
    "G",      # flake8-logging-format
    # "INP",  # flake8-no-pep420, false positives with launch tests
    "PIE",    # flake8-pie
    # "T20",  # flake8-print, We allow some print statements
    "PYI",    # flake8-pyi
    # "PT",   # flake8-pytest-style, Too many errors to fix for now (TODO)
    "Q",      # flake8-quotes
    "RSE",    # flake8-raise
    "RET",    # flake8-return
    # "SLF",  # flake8-self, Too many "Private member accessed" errors (TODO)
    "SIM",    # flake8-simplify
    "SLOT",   # flake8-slots
    "TID",    # flake8-tidy-imports
    # "TD",   # flake8-todos, We don't enforce format for TODO comments
    "TC",     # flake8-type-checking
    "ARG",    # flake8-unused-arguments
    "PTH",    # flake8-use-pathlib

    "FLY",    # flynt
    "I",      # isort
    "C90",    # mccabe
    "NPY",    # numpy
    "PD",     # pandas-vet
    # "N",    # pep8-naming, Can't fix without breaking API
    "PERF",   # Perflint
    "E",      # pycodestyle errors
    "W",      # pycodestyle warnings
    # "DOC",  # pydoclint, preview feature
    "D",      # pydocstyle
    "F",      # pyflakes
    "PGH",    # pygrep-hooks
    "PL",     # pylint
    "UP",     # pyupgrade
    "FURB",   # refurb
    "RUF",    # ruff
    # "TRY",  # tryceratops, Too many "Create your own exception" errors (TODO)
]
ignore = [
    "SIM108", # Opinionated: ternary operator does not always look simpler

    # Undocumented code
    "D100",
    "D101",
    "D102",
    "D103",
    "D104",
    "D105",
    "D106",
    "D107",

    # Conflicting pydocstyle rules
    "D203", # incorrect-blank-line-before-class
    "D212", # multi-line-summary-first-line

    "S101", # assert
    "S110", # try-except-pass
    "S311", # suspicious-non-cryptographic-random-usage

    # Pylint "too-many" errors
    "PLR0911",
    "PLR0912",
    "PLR0913",
    "PLR0914",
    "PLR0915",
    "PLR0916",
    "PLR0917",

    "PLR2004", # magic-value-comparison, Too many to fix for now (TODO)
    "PLW0603", # global-statement, Will need a more sophisticated solution to fix this (TODO)
]

mccabe.max-complexity = 36

pycodestyle.max-line-length = 120



================================================
FILE: QUALITY_DECLARATION.md
================================================
This document is a declaration of software quality for the `rosbridge_suite` packages, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html). The following packages are covered by this declaration:

- rosapi
- rosapi_msgs
- rosbridge_library
- rosbridge_msgs
- rosbridge_server
- rosbridge_suite
- rosbridge_test_msgs

# `rosbridge_suite` Quality Declaration

The package `rosbridge_suite` claims to be in the **Quality Level 3** category.

Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level N in REP-2004](https://www.ros.org/reps/rep-2004.html).

## Version Policy [1]

### Version Scheme [1.i]

`rosbridge_suite` uses [semver](https://semver.org/) according to the recommendation in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#versioning).

### Version Stability [1.ii]

`rosbridge_suite` is at a stable version, i.e. `>= 1.0.0`. The current version can be found in its [package.xml](/rosbridge_server/package.xml), and its change history can be found in its [CHANGELOG](/rosbridge_server/CHANGELOG.rst).

### Public API Declaration [1.iii]

The public API is not explicitly defined.

### API Stability Within a Released ROS Distribution [1.iv]/[1.vi]

The public API is not guaranteed to be stable within a released ROS distribution.

### ABI Stability Within a Released ROS Distribution [1.v]/[1.vi]

`rosbridge_suite` is written in Python and therefore is not concerned with ABI stability.

## Change Control Process [2]

`rosbridge_suite` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://docs.ros.org/en/rolling/Contributing/Developer-Guide.html#change-control-process).

### Change Requests [2.i]

All changes will occur through a pull request, check [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#change-control-process) for additional information.

### Continuous Integration [2.ii]

All pull request must pass CI on all supported platforms.

## Documentation [3]

### License [3.i]

The license for `rosbridge_suite` is BSD 3-clause, and a full copy is in the [LICENSE](/LICENSE) file.

### Copyright Statement [3.ii]

The copyright statement is in the [LICENSE](/LICENSE) file.

## Testing [4]

New features are required to have tests before being added.

## Dependencies [5]


`rosbridge_suite` has a runtime dependency on `rclpy`, which does not have a quality declaration.

## Platform Support [6]

`rosbridge_suite` supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers). Tests are currently only run against Ubuntu Linux.

## Security [7]

### Vulnerability Disclosure Policy [7.i]

This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).



================================================
FILE: ROSBRIDGE_PROTOCOL.md
================================================
# rosbridge v2.0 Protocol Specification

> This document describes the ROS 2 version of rosbridge. For ROS 1, please see the [ros1 branch](https://github.com/RobotWebTools/rosbridge_suite/blob/ros1/ROSBRIDGE_PROTOCOL.md).

This document outlines the rosbridge v2.0 protocol. The v2.0 protocol
incorporates a number of requirements which have arisen since the first version
of rosbridge was released, and makes a small number of modifications to
facilitate greater extensibility to the protocol. At its core, the protocol
still contains the same operations with the same semantics as the prior
versions of rosbridge. The main change is to the structure of messages,
separating control information from message information. The main new additions
are fragmentation, compression, and logging.

This document outlines the protocol specification, but also touches upon the
intended direction for the rosbridge server implementation. The rosbridge v2.0
server implementation is architected in a way to make it easy to add and modify
protocol operations. Furthermore, the rosbridge v2.0 server decouples
JSON-handling from the websockets server, allowing users to arbitrarily change
the specific websockets server implementation they are using.

The message transport of rosbridge is JSON objects. The only required field is
the 'op' field, which specifies the operation of that message. Each 'op' then
specifies its own message semantics.

The rosbridge protocol is a set of 'op' codes which define a number of
operations, along with the semantics for each operation.

The rosbridge server is a server which accepts websockets connections and
implements the rosbridge protocol.

The full source code of rosbridge is located in the rosbridge_suite package.
The package is located at https://github.com/robotwebtools/rosbridge_suite, and
the full breakdown of the stack and its packages is detailed in section 4.5 of
this document.

## 1. The rosbridge transport

A rosbridge message is, in the base case, a JSON object with a string field
called "op". For example:

```json
{ "op": "Example" }
```

The op field indicates the type of message that this is. Messages with
different values for op may be handled differently.

So long as the message is a JSON object with the op field, it is a valid
rosbridge message.

Optionally, a message can also provide an arbitrary string or integer ID:

```json
{ "op": "Example",
  "id": "fred"
}
```

If an ID is provided with a message to the server, then related response
messages will typically contain that ID as well. Log messages caused by this
operation will also contain the ID.

Semantically, the ID is not an identifier of the specific message that it is
in, but instead is an identifier for an interaction which may consist of a
number of operations in back-and-forth messages. Thus, the ID may be used by
multiple messages referring to the same transaction.

## 2. The rosbridge protocol

The rosbridge protocol defines a number of different operations. They are as follows:

Message compression / transformation:

  * **fragment** - a part of a fragmented message
  * **png** - a part of a PNG compressed fragmented message

Rosbridge status messages:

  * **set_status_level** - a request to set the reporting level for rosbridge status messages
  * **status** - a status message

ROS operations:

  * Topics:
    * **advertise** – advertise that you are publishing a topic
    * **unadvertise** – stop advertising that you are publishing topic
    * **publish** - a published ROS-message
    * **subscribe** - a request to subscribe to a topic
    * **unsubscribe** - a request to unsubscribe from a topic
  * Services:
    * **advertise_service** - advertise an external service server
    * **unadvertise_service** - unadvertise an external service server
    * **call_service** - a service call
    * **service_response** - a service response
  * Actions:
    * **advertise_action** - advertise an external action server
    * **unadvertise_action** - unadvertise an external action server
    * **send_action_goal** - a goal sent to an action server
    * **cancel_action_goal** - cancel an in-progress action goal
    * **action_feedback** - feedback messages from an action server
    * **action_result** - an action result

In general, actions or operations that the client takes (such as publishing and
subscribing) have opcodes which are verbs (subscribe, call_service, unadvertise
etc.).

Response messages from the server are things that the client is giving back, so
they are nouns (fragment, status, service_response etc.)

(The only slight exception to this naming convention is publish)

## 3. Details of the rosbridge protocol

Following is the specification of operations in the rosbridge protocol,
supported by the rosbridge server. Anything marked with [experimental] may be
subject to change after review.

### 3.1 Data Encoding and Transformation

The rosbridge protocol provides the ability to fragment messages and to compress messages.

#### 3.1.1 Fragmentation ( _fragment_ ) [experimental]

Messages may be fragmented if they are particularly large, or if the client
requests fragmentation. A fragmented message has the following format:

```json
{ "op": "fragment",
  "id": <string>,
  "data": <string>,
  "num": <int>,
  "total": <int>
}
```

**id** - an id is required for fragmented messages, in order to identify
corresponding fragments for the fragmented message:

 * **data** - a fragment of data that, when combined with other fragments of data, makes up another message
 * **num** - the index of the fragment in the message
 * **total** - the total number of fragments

To fragment a message, its JSON string is taken and split up into multiple
substrings. For each substring, a fragment message is constructed, with the
data field of the fragment populated by the substring.

To reconstruct an original message, the data fields of the fragments are
concatenated, resulting in the JSON string of the original message.

#### 3.1.2 PNG compression ( _png_ ) [experimental]

Some messages (such as images and maps) can be extremely large, and for efficiency
reasons we may wish to transfer them as PNG-encoded bytes. The PNG opcode
duplicates the fragmentation logic of the FRG opcode (and it is possible and
reasonable to only have a single fragment), except that the data field consists
of ASCII-encoded PNG bytes.

```json
{ "op": "png",
  (optional) "id": <string>,
  "data": <string>,
  (optional) "num": <int>,
  (optional) "total": <int>
}
```

 * **id** – only required if the message is fragmented. Identifies the
    fragments for the fragmented message.
 * **data** – a fragment of a PNG-encoded message or an entire message.
 * **num** – only required if the message is fragmented. The index of the fragment.
 * **total** – only required if the message is fragmented. The total number of fragments.

To construct a PNG compressed message, take the JSON string of the original
message and read the bytes of the string into a PNG image. Then, ASCII-encode
the image. This string is now used as the data field. If fragmentation is
necessary, then fragment the data and set the ID, num and total fields to the
appropriate values in the fragments. Otherwise these fields can be left out.

#### 3.1.3 CBOR encoding ( _cbor_ )

[CBOR](https://tools.ietf.org/html/rfc7049) encoding is the fastest
compression method for messages containing large blobs of data, such as
byte arrays and numeric typed arrays.

When CBOR compression is requested by a subscriber, a binary message will be
produced instead of a JSON string.  Once decoded, the message will contain
a normal protocol message.

The implementation uses [draft typed array tags] for efficient packing of
homogeneous arrays.  At the moment, only little-endian packing is supported.

[draft typed array tags]: https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00

#### 3.1.4 CBOR-RAW encoding ( _cbor-raw_ )

While CBOR encodes the entire message as CBOR, sometimes it's desirable to get the raw binary message in the
[ROS serialization format](https://wiki.ros.org/roscpp/Overview/MessagesSerializationAndAdaptingTypes),
which is the same format as sent between ROS nodes and stored in [Bag files](http://wiki.ros.org/Bags/Format/2.0).

This can be useful in several cases:
- Your application already knows how to parse messages in bag files (e.g. using
  [rosbag.js](https://github.com/cruise-automation/rosbag.js), which means that now you can use
  consistent code paths for both bags and live messages.
- You want to parse messages as late as possible, or in parallel, e.g. only in the thread
  or WebWorker that cares about the message. Delaying the parsing of the message means that moving
  or copying the message to the thread is cheaper when its in binary form, since no serialization
  between threads is necessary.
- You only care about part of the message, and don't need to parse the rest of it.
- You really care about performance; no conversion between the ROS binary format and CBOR is done in
  the rosbridge_sever.

The format is similar to CBOR above, but instead of the "msg" field containing the message itself
in CBOR format, instead it contains an object with a "bytes" field which is a byte array containing
the raw message. The "msg" object also includes "secs" and "nsecs" of the `get_rostime()` upon
receiving the message, which is especially useful when `use_sim_time` is set, since it will give you
the simulated time the message was received.

When using this encoding, a client application will need to know exactly how to parse the raw
message. For this it's useful to use the `/rosapi/get_topics_and_raw_types` service, which will give
you all topics and their raw message definitions, similar to `gendeps --cat`. This is the same
format as used by bag files.

### 3.2 Status messages

rosbridge sends status messages to the client relating to the successes and
failures of rosbridge protocol commands. There are four status levels: info,
warning, error, none. By default, rosbridge uses a status level of error.

A rough guide for what causes the levels of status message:

 * **error** – Whenever a user sends a message that is invalid or requests
    something that does not exist (ie. Sending an incorrect opcode or publishing
    to a topic that doesn't exist)
 * **warning** – error, plus, whenever a user does something that may succeed
    but the user has still done something incorrectly (ie. Providing a
    partially-complete published message)
 * **info** – warning, plus messages indicating success of various operations

#### 3.2.1 Set Status Level ( _status_level_ ) [experimental]

```json
{ "op": "set_level",
  (optional) "id": <string>,
  "level": <string>
}
```

 * **level** – one of 'info', 'warning', 'error', or 'none'

Sets the status level to the level specified. If a bad string is specified, the
message is dropped.

#### 3.2.2 Status message ( _status_ ) [experimental]

```json
{ "op": "status",
  (optional) "id": <string>,
  "level": <string>,
  "msg": <string>
}
```

 * **level** – the level of this status message
 * **msg** – the string message being logged
 * **id** – if the status message was the result of some operation that had an
    id, then that id is included

### 3.3 ROS messages

These rosbridge messages interact with ROS, and correspond roughly to the
messages that already exist in the current version of rosbridge.

#### 3.3.1 Advertise ( _advertise_ )

If you wish to advertise that you are or will be publishing a topic, then use the advertise command.

```json
{ "op": "advertise",
  (optional) "id": <string>,
  "topic": <string>,
  "type": <string>
}
```

 * **topic** – the string name of the topic to advertise
 * **type** – the string type to advertise for the topic

   * If the topic does not already exist, and the type specified is a valid
     type, then the topic will be established with this type.
   * If the topic already exists with a different type, an error status message
     is sent and this message is dropped.
   * If the topic already exists with the same type, the sender of this message
     is registered as another publisher.
   * If the topic doesn't already exist but the type cannot be resolved, then
     an error status message is sent and this message is dropped.

#### 3.3.2 Unadvertise ( _unadvertise_ )

This stops advertising that you are publishing a topic.

```json
{ "op": "unadvertise",
  (optional) "id": <string>,
  "topic": <string>
}
```

 * **topic** – the string name of the topic being unadvertised

   * If the topic does not exist, a warning status message is sent and this
     message is dropped
   * If the topic exists and there are still clients left advertising it,
     rosbridge will continue to advertise it until all of them have unadvertised
   * If the topic exists but rosbridge is not advertising it, a warning status
     message is sent and this message is dropped

#### 3.3.3 Publish ( _publish_ )

The publish message is used to send data on a topic.

```json
{ "op": "publish",
  (optional) "id": <string>,
  "topic": <string>,
  "msg": <json>
}
```

The publish command publishes a message on a topic.

 * **topic** - the string name of the topic to publish to
 * **msg** - the message to publish on the topic

   * If the topic does not exist, then an error status message is sent and this
     message is dropped
   * If the msg does not conform to the type of the topic, then an error status
     message is sent and this message is dropped
   * If the msg is a subset of the type of the topic, then a warning status
     message is sent and the unspecified fields are filled in with defaults

Special case: if the type being published has a 'header' field, then the client
can optionally omit the header from the msg. If this happens, rosbridge will
automatically populate the header with a frame id of "" and the timestamp as
the current time. Alternatively, just the timestamp field can be omitted, and
then the current time will be automatically inserted.

#### 3.3.4 Subscribe

```json
{ "op": "subscribe",
  (optional) "id": <string>,
  "topic": <string>,
  (optional) "type": <string>,
  (optional) "throttle_rate": <int>,
  (optional) "queue_length": <int>,
  (optional) "fragment_size": <int>,
  (optional) "compression": <string>
}
```

This command subscribes the client to the specified topic. It is recommended
that if the client has multiple components subscribing to the same topic, that
each component makes its own subscription request providing an ID. That way,
each can individually unsubscribe and rosbridge can select the correct rate at
which to send messages.

 * **type** – the (expected) type of the topic to subscribe to. If left off,
    type will be inferred, and if the topic doesn't exist then the command to
    subscribe will fail
 * **topic** – the name of the topic to subscribe to
 * **throttle_rate** – the minimum amount of time (in ms) that must elapse
    between messages being sent. Defaults to 0
 * **queue_length** – the size of the queue to buffer messages. Messages are
    buffered as a result of the throttle_rate. Defaults to 0 (no queueing).
 * **id** – if specified, then this specific subscription can be unsubscribed
    by referencing the ID.
 * **fragment_size** – the maximum size that a message can take before it is to
    be fragmented.
 * **compression** – an optional string to specify the compression scheme to be
    used on messages. Valid values are "none", "png", "cbor", and "cbor-raw".

If queue_length is specified, then messages are placed into the queue before
being sent. Messages are sent from the head of the queue. If the queue gets
full, the oldest message is removed and replaced by the newest message.

If a client has multiple subscriptions to the same topic, then messages are
sent at the lowest throttle_rate, with the lowest fragmentation size, and
highest queue_length. It is recommended that the client provides IDs for its
subscriptions, to enable rosbridge to effectively choose the appropriate
fragmentation size and publishing rate.

#### 3.3.5 Unsubscribe

```json
{ "op": "unsubscribe",
  (optional) "id": <string>,
  "topic": <string>
}
```

 * **topic** – the name of the topic to unsubscribe from
 * **id** – an id of the subscription to unsubscribe

If an id is provided, then only the corresponding subscription is unsubscribed.
If no ID is provided, then all subscriptions are unsubscribed.

#### 3.3.6 Advertise Service

```json
{ "op": "advertise_service",
  "type": <string>,
  "service": <string>
}
```

Advertises an external ROS service server. Requests come to the client via Call Service.

 * **service** – the name of the service to advertise
 * **type** – the advertised service message type

#### 3.3.7 Unadvertise Service

```json
{ "op": "unadvertise_service",
  "service": <string>
}
```

#### 3.3.8 Call Service

Calls a ROS service.

```json
{ "op": "call_service",
  (optional) "id": <string>,
  "service": <string>,
  (optional) "args": <list<json>>,
  (optional) "fragment_size": <int>,
  (optional) "compression": <string>,
  (optional) "timeout": <float>
}
```

 * **service** – the name of the service to call
 * **args** – if the service has no args, then args does not have to be
    provided, though an empty list is equally acceptable. Args should be a list
    of json objects representing the arguments to the service
 * **id** – an optional id to distinguish this service call
 * **fragment_size** – the maximum size that the response message can take
    before it is fragmented
 * **compression** – an optional string to specify the compression scheme to be
    used on messages. Valid values are "none" and "png"
 * **timeout** – the time, in seconds, to wait for a response from the server


Stops advertising an external ROS service server

 * **service** – the name of the service to unadvertise

#### 3.3.9 Service Response

A response to a ROS service call.

```json
{ "op": "service_response",
  (optional) "id": <string>,
  "service": <string>,
  (optional) "values": <list<json>>,
  "result": <boolean>
}
```

 * **service** – the name of the service that was called
 * **values** – the return values. If the service had no return values, then
    this field can be omitted (and will be by the rosbridge server)
 * **id** – if an ID was provided to the service request, then the service
    response will contain the ID
 * **result** - return value of service callback. true means success, false failure.

#### 3.3.10 Advertise Action

Advertises an external ROS action server.

```json
{ "op": "advertise_action",
  "type": <string>,
  "action": <string>
}
```

Goals come to the client via the Send Action Goal capability.

 * **action** – the name of the action to advertise
 * **type** – the advertised action message type

#### 3.3.11 Unadvertise Action

```json
{ "op": "unadvertise_action",
  "action": <string>
}
```

#### 3.3.12 Send Action Goal

Sends a goal to a ROS action server.

```json
{ "op": "send_action_goal",
  (optional) "id": <string>,
  "action": <string>,
  "action_type": <string>,
  (optional) "args": <list<json>>,
  (optional) "feedback": <boolean>,
  (optional) "fragment_size": <int>,
  (optional) "compression": <string>
}
```

 * **action** – the name of the action to send a goal to
 * **action_type** – the action message type
 * **args** – if the goal has no args, then args does not have to be
    provided, though an empty list is equally acceptable. Args should be a list of json objects representing the arguments to the service.
 * **feedback** – if true, sends feedback messages over rosbridge. Defaults to false.
 * **id** – an optional id to distinguish this goal handle
 * **fragment_size** – the maximum size that the result and feedback messages can take before they are fragmented
 * **compression** – an optional string to specify the compression scheme to be used on messages. Valid values are "none" and "png"

#### 3.3.13 Cancel Action Goal

Cancels an action goal.

```json
{ "op": "cancel_action_goal",
  "id": <string>,
  "action": <string>
}
```

The `id` field must match an already in-progress goal.

#### 3.3.14 Action Feedback

Used to send action feedback for a specific goal handle.

```json
{ "op": "action_feedback",
  "id": <string>,
  "action": <string>,
  "values": <json>
}
```

The `id` field must match an already in-progress goal.

#### 3.3.15 Action Result

A result for a ROS action.

```json
{ "op": "action_result",
  "id": <string>,
  "action": <string>,
  "values": <json>,
  "status": <int>,
  "result": <boolean>
}
```

 * **action** – the name of the action that was executed
 * **id** – if an ID was provided to the action goal, then the action result will contain the ID
 * **values** – the result values. If the service had no return values, then
    this field can be omitted (and will be by the rosbridge server)
 * **status** - return status of the action. This matches the enumeration in the [`action_msgs/msg/GoalStatus`](https://docs.ros2.org/latest/api/action_msgs/msg/GoalStatus.html) ROS message.
 * **result** - return value of action. True means success, false failure.

---

## 4 Further considerations

Further considerations for the rosbridge protocol are listed below.

### 4.1 Rosbridge pseudo-services

Rosbridge no longer provides the ROS-api introspection pseudo services that it
previously did. These are, for example rosbridge/topics and rosbridge/services.
Instead, these services are provided as proper ROS services by the new rosapi
package.

### 4.2 Sampling

It has been suggested that rosbridge may be extended to provide an operation to
sample a single message from a topic.

### 4.3 Latching

Rosbridge will support messages that were latched to topics internally in ROS.
It is possible that the publish opcode will be extended so that remote clients
can latch messages too.

### 4.5 Rosbridge package structure

Rosbridge 2.0 resides in a package named rosbridge_suite, located at
https://github.com/robotwebtools/rosbridge_suite.

The meta-package will contain the following packages:

 * **rosbridge_library** – the core rosbridge JSON-to-ROS implementation. This
    is be a Python library.
 * **rosbridge_server** – depends on the rosbridge library, and implements the
    WebSockets server, passing incoming messages to the API and outgoing
    messages back to the WebSockets connection. The default server uses
    tornado, a python server implementation.
 * **rosapi** – provides ROS services for various master API calls, such as
    listing all the topics, services, types currently in ROS



================================================
FILE: setup.cfg
================================================
[codespell]
ignore-words-list = miror



================================================
FILE: TROUBLESHOOTING.md
================================================
### Tornado Version

Often the server breaks because it is using the wrong version of Tornado.  Tornado's interfaces and behavior change very quickly, Rosbridge is only tested against the version installed by rosdep.  On Debian-based systems, this is the apt package python-tornado.

To check your imported Tornado version, run:

```
python -c 'import tornado; print tornado.version'
```

The imported version should the `apt` version:

```
apt-cache show python-tornado | grep Version
```

If the versions don't match, it's likely that the wrong version of Tornado was installed with `pip`.  Try uninstalling it:

```
pip uninstall tornado
```

If the wrong version is still imported, you will need to find it and remove it.  You might find it with something like:

```
find /usr/local/lib/python*/*-packages/ -type d | grep '/tornado/'
```



================================================
FILE: .pre-commit-config.yaml
================================================
# See https://pre-commit.com for more information
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: check-added-large-files
      - id: check-case-conflict
      - id: check-merge-conflict
      - id: check-symlinks
      - id: check-yaml
      - id: debug-statements
      - id: destroyed-symlinks
      - id: detect-private-key
      - id: end-of-file-fixer
      - id: mixed-line-ending
      - id: trailing-whitespace

  - repo: https://github.com/codespell-project/codespell
    rev: v2.3.0
    hooks:
      - id: codespell

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.12.7
    hooks:
      - id: ruff-format
      - id: ruff-check



================================================
FILE: rosapi/README.md
================================================
rosapi
===============

## Nodes

### rosapi (Executable: `rosapi_node`)
Provides services for getting various ROS meta-information, including ROS topic, services, interfaces or
action servers and managing ROS parameters.

#### Services

  * `~/topics` (type: `rosapi_msgs/srv/Topics`)

    Return a list of all the topics being published.

  * `~/interfaces` (type: `rosapi_msgs/srv/Interfaces`)

    Return a list of all the interfaces in the system.

  * `~/topics_for_type` (type: `rosapi_msgs/srv/TopicsForType`)

    Return a list of all the topics that are publishing a given type.

  * `~/topics_and_raw_types` (type: `rosapi_msgs/srv/TopicsAndRawTypes`)

    Return a list of all the topics being published, and their raw types.

  * `~/services` (type: `rosapi_msgs/srv/Services`)

    Return a list of all the services being advertised.

  * `~/services_for_type` (type: `rosapi_msgs/srv/ServicesForType`)

    Return a list of all the services that are publishing a given type.

  * `~/nodes` (type: `rosapi_msgs/srv/Nodes`)

    Return a list of all the nodes that are registered.

  * `~/node_details` (type: `rosapi_msgs/srv/NodeDetails`)

    Return a node description including subscribing, publishing, and services.

  * `~/action_servers` (type: `rosapi_msgs/srv/GetActionServers`)

    Return a list of action servers based on actions standard topics.

  * `~/action_type` (type: `rosapi_msgs/srv/ActionType`)

    Given the name of an action, return its type.

  * `~/topic_type` (type: `rosapi_msgs/srv/TopicType`)

    Given the name of a topic, return the name of the type of that topic.

  * `~/service_type` (type: `rosapi_msgs/srv/ServiceType`)

    Given the name of a service, return the type of that service.

  * `~/publishers` (type: `rosapi_msgs/srv/Publishers`)

    Given the name of a topic, return a list of node names that are publishing on that topic.

  * `~/subscribers` (type: `rosapi_msgs/srv/Subscribers`)

    Given the name of a topic, return a list of node names that are subscribing to that topic.

  * `~/service_providers` (type: `rosapi_msgs/srv/ServiceProviders`)

    Given the name of a service, returns a list of node names that are advertising that service type.

  * `~/service_node` (type: `rosapi_msgs/srv/ServiceNode`)

    Given the name of a service, returns the name of the node that is providing that service.

  * `~/message_details` (type: `rosapi_msgs/srv/MessageDetails`)

    Given the name of a message type, return the TypeDef for that type.

  * `~/service_request_details` (type: `rosapi_msgs/srv/ServiceRequestDetails`)

    Given the name of a service type, return the TypeDef for the request message of that service type.

  * `~/service_response_details` (type: `rosapi_msgs/srv/ServiceResponseDetails`)

    Given the name of a service type, return the TypeDef for the response message of that service type.

  * `~/action_goal_details` (type: `rosapi_msgs/srv/ActionGoalDetails`)

    Given the name of an action type, return the TypeDef for the goal message of that action type.

  * `~/action_result_details` (type: `rosapi_msgs/srv/ActionResultDetails`)

    Given the name of an action type, return the TypeDef for the result message of that action type.

  * `~/action_feedback_details` (type: `rosapi_msgs/srv/ActionFeedbackDetails`)

    Given the name of an action type, return the TypeDef for the feedback message of that action type.

  * `~/set_param` (type: `rosapi_msgs/srv/SetParam`)

    Set a parameter value on a specific node.

  * `~/get_param` (type: `rosapi_msgs/srv/GetParam`)

    Get a parameter value from a specific node.

  * `~/has_param` (type: `rosapi_msgs/srv/HasParam`)

    Check if a parameter exists on a specific node.

  * `~/delete_param` (type: `rosapi_msgs/srv/DeleteParam`)

    Delete a parameter from a specific node.

  * `~/get_param_names` (type: `rosapi_msgs/srv/GetParamNames`)

    Get a list of all parameter names.

  * `~/get_time` (type: `rosapi_msgs/srv/GetTime`)

    Get the current ROS time.

  * `~/get_ros_version` (type: `rosapi_msgs/srv/GetROSVersion`)

    Get the ROS version and distribution name.

#### Parameters

  * `params_timeout` (float, default: `5.0`)

    Timeout in seconds for param-related services.

  * `topics_glob` (string, default: `[*]`)
  * `services_glob` (string, default: `[*]`)
  * `params_glob` (string, default: `[*]`)

    Each of the glob parameters may contain an array of one or more match patterns. Resources that match any of the specified patterns will be returned by calls to the rosapi services.

    An example launch file which enables all information to be returned:

    ```
    <launch>
      <node name="rosapi" pkg="rosapi" exec="rosapi_node">
        <param name="topics_glob" value="'[*]'" />
        <param name="services_glob" value="'[*]'" />
        <param name="params_glob" value="'[*]'" />
      </node>
    </launch>
    ```

    This example launch file enables only rosout and certain camera topics:
    ```
    <launch>
      <node name="rosapi" pkg="rosapi" exec="rosapi_node">
        <param name="topics_glob" value="'[/rosout, /camera/rgb/*]'" />
      </node>
    </launch>
    ```



================================================
FILE: rosapi/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosapi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------
* Handle extra IDL slots when doing array introspection (`#1031 <https://github.com/RobotWebTools/rosbridge_suite/issues/1031>`_)
* Add services to return Action interface details (`#1021 <https://github.com/RobotWebTools/rosbridge_suite/issues/1021>`_)
* Fix array-like parameter serialization in rosbridge get_param (`#1018 <https://github.com/RobotWebTools/rosbridge_suite/issues/1018>`_)
* Contributors: David Fernàndez López, Noah Wardlow, Scott Bell, Błażej Sowa

2.2.0 (2025-02-26)
------------------
* New async rosapi params module implementation (`#1001 <https://github.com/RobotWebTools/rosbridge_suite/issues/1001>`_)
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Prevent parameter retrieval crashes (`#978 <https://github.com/RobotWebTools/rosbridge_suite/issues/978>`_)
* Add namespace to services names (`#992 <https://github.com/RobotWebTools/rosbridge_suite/issues/992>`_)
* Add new service to retrieve the different interfaces in the ROS Network (`#988 <https://github.com/RobotWebTools/rosbridge_suite/issues/988>`_)
* Add ament_mypy test and fix all mypy errors (`#980 <https://github.com/RobotWebTools/rosbridge_suite/issues/980>`_)
* Contributors: Błażej Sowa, Lebecque Florian, Mehsias, Matthias Rathauscher, Lebecque Florian

2.1.0 (2024-10-08)
------------------
* Fix invalid import of get_parameter_value in rosapi for ROS2 Jazzy. (`#932 <https://github.com/RobotWebTools/rosbridge_suite/issues/932>`_)
* Contributors: David Oberacker

2.0.0 (2024-10-08)
------------------
* rosapi: Don't start parameter services that aren't spun (`#944 <https://github.com/RobotWebTools/rosbridge_suite/issues/944>`_)
* Handle ROS 2 types properly (`#883 <https://github.com/RobotWebTools/rosbridge_suite/issues/883>`_)
* Port unit tests to ROS 2 + Fix CBOR conversion and PNG compression (`#882 <https://github.com/RobotWebTools/rosbridge_suite/issues/882>`_)
* Contributors: Brad Martin, Scott Bell, Sebastian Castro

1.3.2 (2023-09-27)
------------------
* Fix ROS2 CI for iron & rolling (`#875 <https://github.com/RobotWebTools/rosbridge_suite/issues/875>`_)
* Contributors: Hans-Joachim Krauch

1.3.1 (2022-10-21)
------------------
* Add graceful shutdown (`#794 <https://github.com/RobotWebTools/rosbridge_suite/issues/794>`_)
* Contributors: Hans-Joachim Krauch

1.3.0 (2022-08-16)
------------------
* Fixed /get_param service for arrays (`#776 <https://github.com/RobotWebTools/rosbridge_suite/issues/776>`_)
* Contributors: p0rys

1.2.0 (2022-05-20)
------------------
* Added `/rosapi/get_ros_version` service (`#708 <https://github.com/RobotWebTools/rosbridge_suite/issues/708>`_)
* Fixed node name collision with websocket launch file (`#707 <https://github.com/RobotWebTools/rosbridge_suite/issues/707>`_)
* Contributors: Jacob Bandes-Storch, Kedus Mathewos, rob-clarke

1.1.2 (2022-01-03)
------------------

1.1.1 (2021-12-09)
------------------

1.1.0 (2021-10-22)
------------------
* Move msg/srv from rosapi and rosbridge_library into separate packages; enable Rolling in CI (`#665 <https://github.com/RobotWebTools/rosbridge_suite/issues/665>`_)
* Exit cleanly on SIGINT; remove sleep in test (`#667 <https://github.com/RobotWebTools/rosbridge_suite/issues/667>`_)
* Remove unused service_host and search_param services (`#660 <https://github.com/RobotWebTools/rosbridge_suite/issues/660>`_)
* Migrate remaining linters to pre-commit (`#657 <https://github.com/RobotWebTools/rosbridge_suite/issues/657>`_)
* Add pre-commit, format with black and isort (`#648 <https://github.com/RobotWebTools/rosbridge_suite/issues/648>`_)
* Contributors: Adrian Macneil, Jacob Bandes-Storch, Kenji Miyake

1.0.8 (2021-08-26)
------------------
* Add missing test_depends and buildtool_depends (`#617 <https://github.com/RobotWebTools/rosbridge_suite/issues/617>`_)
* Fix various Python code style and lint issues
* Contributors: Christian Clauss, Jacob Bandes-Storch

1.0.7 (2021-08-18)
------------------
* Load message definitions from .msg files; exclude /msg/ and include builtin_interfaces in combined definitions (`#597 <https://github.com/RobotWebTools/rosbridge_suite/issues/597>`_)
* Fix typos discovered by codespell (`#600 <https://github.com/RobotWebTools/rosbridge_suite/issues/600>`_)
* Contributors: Christian Clauss, Jacob Bandes-Storch

1.0.6 (2021-08-17)
------------------
* Include /msg/ in type names (`#591 <https://github.com/RobotWebTools/rosbridge_suite/issues/591>`_)
* Fix broken links in changelogs
* Contributors: Jacob Bandes-Storch

1.0.5 (2021-08-12)
------------------

1.0.4 (2021-08-11)
------------------
* Include /msg/ in type names (`#584 <https://github.com/RobotWebTools/rosbridge_suite/issues/584>`_)
  It's more canonical for ROS 2 type names to be of the form `foo_msgs/msg/Bar` rather than just `foo_msgs/Bar`. This is occasionally reflected in documentation and command line tooling: https://docs.ros.org/en/galactic/Tutorials/Topics/Understanding-ROS2-Topics.html#ros2-interface-show
  So rather than stripping out `/msg/`, we include it in the type definitions.
  See also: https://github.com/RobotWebTools/rosmsg/pull/12
* Contributors: Jacob Bandes-Storch

1.0.3 (2021-08-03)
------------------
* Add TopicsAndRawTypes service (`#574 <https://github.com/RobotWebTools/rosbridge_suite/issues/574>`_, adapted from ROS 1 implementation `#452 <https://github.com/RobotWebTools/rosbridge_suite/issues/452>`_)
* fix: remove json encoding before setting string params (`#521 <https://github.com/RobotWebTools/rosbridge_suite/issues/521>`_)
* Update rosapi/proxy.py to match eloquent API (`#447 <https://github.com/RobotWebTools/rosbridge_suite/issues/447>`_)
* Contributors: Jacob Bandes-Storch, justinscorringe, travipross

1.0.2 (2019-09-24)
------------------

1.0.1 (2019-09-20)
------------------
* fix missing dependency

1.0.0 (2019-09-19)
------------------
* Port to ROS 2

0.11.3 (2019-08-07)
-------------------
* Travis CI: Look for Python syntax errors and undefined name (`#420 <https://github.com/RobotWebTools/rosbridge_suite/issues/420>`_)
  * Travis CI: Look for Python syntax errors and undefined name
  _It would be prudent to start running the tests in both 2 and 3._  https://github.com/RobotWebTools/rosbridge_suite/issues/401#issuecomment-512069249
  * Add names to protect the guilty
  * Five jobs, not six
  * Identity is not the same thing as equality in Python
  * Flake8 tests now pass on Python 2
* Contributors: cclauss

0.11.2 (2019-07-08)
-------------------
* constnames and constvalues in typedef (`#412 <https://github.com/RobotWebTools/rosbridge_suite/issues/412>`_)
* Contributors: Kad91

0.11.1 (2019-05-08)
-------------------

0.11.0 (2019-03-29)
-------------------

0.10.2 (2019-03-04)
-------------------
* Use Master.getTopicTypes() in /rosapi/topics to increase performance (`#381 <https://github.com/RobotWebTools/rosbridge_suite/issues/381>`_)
* Contributors: Affonso, Guilherme

0.10.1 (2018-12-16)
-------------------

0.10.0 (2018-12-14)
-------------------
* Drop use of ros Python module (`#374 <https://github.com/RobotWebTools/rosbridge_suite/issues/374>`_)
* Fixes passing of globs to proxy (`#355 <https://github.com/RobotWebTools/rosbridge_suite/issues/355>`_)
  * Fixes handling and passing of globs to proxy
  * Removes some confusing imports
* Fix a few problems (`#350 <https://github.com/RobotWebTools/rosbridge_suite/issues/350>`_)
  * xrange is not available in Python3, range works for both Python versions
  * the variable v is undefined in search_param, comparing the implementation with the sibling functions I expect name to be the intended variable
  * The module udp_handler is using the Authentication service but wasn't importing the module
* use package format 2, remove unnecessary dependencies (`#348 <https://github.com/RobotWebTools/rosbridge_suite/issues/348>`_)
* Contributors: Anwar, Dirk Thomas, Jochen Sprickerhof

0.9.0 (2018-04-09)
------------------

0.8.6 (2017-12-08)
------------------
* Fixed action_servers filter to allow more than one namespace (`#305 <https://github.com/RobotWebTools/rosbridge_suite/issues/305>`_)
  * Modified action_servers filter to detect topics with more than one namespace
  * Fixed to return the full namespace
* Contributors: milesial

0.8.5 (2017-11-23)
------------------
* Add Python3 compatibility (`#300 <https://github.com/RobotWebTools/rosbridge_suite/issues/300>`_)
  * First pass at Python 3 compatibility
  * message_conversion: Only call encode on a Python2 str or bytes type
  * protocol.py: Changes for dict in Python3. Compatible with Python 2 too.
  * More Python 3 fixes, all tests pass
  * Move definition of string_types to rosbridge_library.util
* Contributors: Kartik Mohta

0.8.4 (2017-10-16)
------------------
* Handles empty globes properly (`#297 <https://github.com/RobotWebTools/rosbridge_suite/issues/297>`_)
  * Refactors get_globs function to a separate module
  * Refactors the filtering that uses the globs
  * Some linting
  * Handles topic types for empty globs
  * Refactors out an any_match function
  * Simplifies filter_action_servers
  * Imports socket for the errors
  * Uses import .glob_helper
* Contributors: Anwar

0.8.3 (2017-09-11)
------------------

0.8.2 (2017-09-11)
------------------
* Removes array delimiters while parsing parameters (`#292 <https://github.com/RobotWebTools/rosbridge_suite/issues/292>`_)
* Contributors: Anwar

0.8.1 (2017-08-30)
------------------

0.8.0 (2017-08-30)
------------------
* fix delete_param in rosapi (`#284 <https://github.com/RobotWebTools/rosbridge_suite/issues/284>`_)
* Merge pull request `#276 <https://github.com/RobotWebTools/rosbridge_suite/issues/276>`_ from sevenbitbyte/DOCUMENT_GLOB
  Document glob
* Update README.md
  Formatting and examples
* Create README.md
* Contributors: 7bit, Jihoon Lee

0.7.17 (2017-01-25)
-------------------
* Added bug fix in rosapi
* no rospy needed, just for debug logging
* new service: get actionlib servers
* adjust log level for security globs
  Normal operation (i.e. no globs or successful verification of requests) is now silent, with illegal requests producing a warning.
* correct default values for security globs
  also accept empty list as the default "do not check globs" value in addition to None.
  Finally, append rosapi service glob after processing command line input so it's not overwritten
* Added services_glob to CallServices, added globs to rosbridge_tcp and rosbridge_udp, and other miscellaneous fixes.
* As per the suggestions of @T045T, fixed several typos, improved logging, and made some style fixes.
* Fixed time object field definitions to match documentation.
* Two minor fixes.
* Added new parameters for topic and service security.
  Added 3 new parameters to rosapi and rosbridge_server which filter the
  topics, services, and parameters broadcast by the server to match an
  array of glob strings.
* Contributors: Devon Ash, Eric, Marco Arruda, Nils Berg

0.7.16 (2016-08-15)
-------------------
* new srv: topics types and details
* Contributors: Marco Arruda

0.7.15 (2016-04-25)
-------------------
* changelog updated
* Contributors: Russell Toris

0.7.14 (2016-02-11)
-------------------
* Update proxy.py
  Fixes an issue when call the service "/rosapi/service_type"
* Contributors: Robert Codd-Downey

0.7.13 (2015-08-14)
-------------------
* Fix catkin_lint issues
* Contributors: Matt Vollrath

0.7.12 (2015-04-07)
-------------------

0.7.11 (2015-03-23)
-------------------
* rename rosapi script to rosapi_node to address `#170 <https://github.com/RobotWebTools/rosbridge_suite/issues/170>`_
* Contributors: Jihoon Lee

0.7.10 (2015-02-25)
-------------------
* Make get_topics() and get_topic_type() reference the full list of active topics.
* Contributors: Justin Huang

0.7.9 (2015-02-24)
------------------
* add findding service function as specific service type
* Contributors: dwlee

0.7.8 (2015-01-16)
------------------

0.7.7 (2015-01-06)
------------------

0.7.6 (2014-12-26)
------------------
* 0.7.5
* update changelog
* 0.7.4
* changelog updated
* 0.7.3
* changelog updated
* 0.7.2
* changelog updated
* 0.7.1
* update changelog
* 0.7.0
* changelog updated
* Contributors: Jihoon Lee, Russell Toris

0.7.5 (2014-12-26)
------------------

0.7.4 (2014-12-16)
------------------

0.7.3 (2014-12-15)
------------------

0.7.2 (2014-12-15)
------------------
* 0.7.1
* update changelog
* Contributors: Jihoon Lee

0.7.1 (2014-12-09)
------------------

0.7.0 (2014-12-02)
------------------

0.6.8 (2014-11-05)
------------------

0.6.7 (2014-10-22)
------------------
* updated package manifests
* Contributors: Russell Toris

0.6.6 (2014-10-21)
------------------

0.6.5 (2014-10-14)
------------------
* 0.6.4
* update changelog
* 0.6.3
* update change log
* Contributors: Jihoon Lee

0.6.4 (2014-10-08)
------------------

0.6.3 (2014-10-07)
------------------

0.6.2 (2014-10-06)
------------------

0.6.1 (2014-09-01)
------------------
* make rosapis use absolute namespace
* Contributors: Jihoon Lee

0.6.0 (2014-05-23)
------------------
* Ensure proper locking for Parameter Server access
* Contributors: Lasse Rasinen

0.5.4 (2014-04-17)
------------------
* add rosnode and rosgraph
* Contributors: Jihoon Lee

0.5.3 (2014-03-28)
------------------

0.5.2 (2014-03-14)
------------------

0.5.1 (2013-10-31)
------------------

0.5.0 (2013-07-17)
------------------
* 0.5.0 preparation for hydro release
* Removes trailing commas.
* removing global bin installation in setup.py
* Contributors: Brandon Alexander, Jihoon Lee

0.4.4 (2013-04-08)
------------------

0.4.3 (2013-04-03 08:24)
------------------------

0.4.2 (2013-04-03 08:12)
------------------------
* eclipse projects removed
* Contributors: Russell Toris

0.4.1 (2013-03-07)
------------------
* fixes import issue in rosapi
* Contributors: Russell Toris

0.4.0 (2013-03-05)
------------------
* Fixes ambiguous params class reference.
* Uses only 1 .gitignore to avoid confusion.
* Fixing rosapi's "Cannot include proxy..." errors.
* Adds BSD license header to code files.
  See Issue `#13 <https://github.com/RobotWebTools/rosbridge_suite/issues/13>`_.
* rosbridge_server requires rosapi.
* Adds message and service generation to rosapi.
* Adding setup.py to rosapi.
* Clarifies name of rosapi is rosapi.
* Catkinizes rosapi.
* Collapse directory structure.
* Contributors: Austin Hendrix, Brandon Alexander



================================================
FILE: rosapi/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosapi)

find_package(ament_cmake REQUIRED)
find_package(ament_cmake_python REQUIRED)

if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

ament_python_install_package(
  ${PROJECT_NAME} PACKAGE_DIR "src/${PROJECT_NAME}")

ament_package()

install(PROGRAMS scripts/rosapi_node
  DESTINATION lib/${PROJECT_NAME}
)

install(
  FILES mapping_rules.yaml
  DESTINATION share/${PROJECT_NAME}
)

if(BUILD_TESTING)
  find_package(ament_cmake_pytest REQUIRED)
  ament_add_pytest_test(${PROJECT_NAME}_test_stringify_field_types test/test_stringify_field_types.py)
  ament_add_pytest_test(${PROJECT_NAME}_test_typedefs test/test_typedefs.py)

  find_package(ament_cmake_mypy REQUIRED)
  ament_mypy()
endif()



================================================
FILE: rosapi/mapping_rules.yaml
================================================
-
  ros1_package_name: 'rosapi'
  ros1_service_name: 'GetParam'
  ros2_package_name: 'rosapi'
  ros2_service_name: 'GetParam'
  request_fields_1_to_2:
    name: 'name'
    default: 'default_value'



================================================
FILE: rosapi/package.xml
================================================
<?xml version="1.0"?>
<package format="3">
  <name>rosapi</name>
  <version>2.3.0</version>
  <description>
Provides services for getting various ROS meta-information, including ROS topic, services, interfaces or
action servers and managing ROS parameters.
  </description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosapi</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>ament_cmake_python</buildtool_depend>

  <exec_depend>builtin_interfaces</exec_depend>
  <exec_depend>rcl_interfaces</exec_depend>
  <exec_depend>rclpy</exec_depend>
  <exec_depend>ros2action</exec_depend>
  <exec_depend>ros2interface</exec_depend>
  <exec_depend>ros2node</exec_depend>
  <exec_depend>ros2service</exec_depend>
  <exec_depend>ros2topic</exec_depend>
  <exec_depend>rosapi_msgs</exec_depend>
  <exec_depend>rosbridge_library</exec_depend>
  <exec_depend>rosidl_adapter</exec_depend>
  <exec_depend>rosidl_runtime_py</exec_depend>

  <test_depend>ament_cmake_mypy</test_depend>
  <test_depend>ament_cmake_pytest</test_depend>
  <test_depend>geometry_msgs</test_depend>
  <test_depend>rmw_dds_common</test_depend>
  <test_depend>sensor_msgs</test_depend>
  <test_depend>shape_msgs</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
    <ros1_bridge mapping_rules="mapping_rules.yaml"/>
  </export>
</package>



================================================
FILE: rosapi/scripts/rosapi_node
================================================
#!/usr/bin/env python3
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import os
import sys
from json import dumps, loads

import rclpy
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.clock import Clock, ClockType
from rclpy.node import Node
from rclpy.qos import qos_profile_parameters

from rosapi import glob_helper, objectutils, params, proxy
from rosapi_msgs.msg import TypeDef
from rosapi_msgs.srv import (
    ActionFeedbackDetails,
    ActionGoalDetails,
    ActionResultDetails,
    ActionType,
    DeleteParam,
    GetActionServers,
    GetParam,
    GetParamNames,
    GetROSVersion,
    GetTime,
    HasParam,
    Interfaces,
    MessageDetails,
    NodeDetails,
    Nodes,
    Publishers,
    ServiceNode,
    ServiceProviders,
    ServiceRequestDetails,
    ServiceResponseDetails,
    Services,
    ServicesForType,
    ServiceType,
    SetParam,
    Subscribers,
    Topics,
    TopicsAndRawTypes,
    TopicsForType,
    TopicType,
)


class Rosapi(Node):
    NAME = "rosapi"

    def __init__(self):
        super().__init__(self.NAME)
        self.declare_parameter("topics_glob", "[*]")
        self.declare_parameter("services_glob", "[*]")
        self.declare_parameter("params_glob", "[*]")
        self.declare_parameter("params_timeout", 5.0)
        self.globs = self.get_globs()
        self.register_services()

    # Initialises the ROS node
    def register_services(self):
        proxy.init(self)

        timeout_sec = self.get_parameter("params_timeout").value
        params.init(self, timeout_sec)

        self.create_service(Topics, "~/topics", self.get_topics)
        self.create_service(Interfaces, "~/interfaces", self.get_interfaces)
        self.create_service(TopicsForType, "~/topics_for_type", self.get_topics_for_type)
        self.create_service(
            TopicsAndRawTypes,
            "~/topics_and_raw_types",
            self.get_topics_and_raw_types,
        )
        self.create_service(Services, "~/services", self.get_services)
        self.create_service(
            ServicesForType,
            "~/services_for_type",
            self.get_services_for_type,
        )
        self.create_service(Nodes, "~/nodes", self.get_nodes)
        self.create_service(NodeDetails, "~/node_details", self.get_node_details)
        self.create_service(GetActionServers, "~/action_servers", self.get_action_servers)
        self.create_service(ActionType, "~/action_type", self.get_action_type)
        self.create_service(TopicType, "~/topic_type", self.get_topic_type)
        self.create_service(ServiceType, "~/service_type", self.get_service_type)
        self.create_service(Publishers, "~/publishers", self.get_publishers)
        self.create_service(Subscribers, "~/subscribers", self.get_subscribers)
        self.create_service(
            ServiceProviders,
            "~/service_providers",
            self.get_service_providers,
        )
        self.create_service(ServiceNode, "~/service_node", self.get_service_node)
        self.create_service(MessageDetails, "~/message_details", self.get_message_details)
        self.create_service(
            ServiceRequestDetails,
            "~/service_request_details",
            self.get_service_request_details,
        )
        self.create_service(
            ServiceResponseDetails,
            "~/service_response_details",
            self.get_service_response_details,
        )
        self.create_service(
            ActionGoalDetails,
            "~/action_goal_details",
            self.get_action_goal_details,
        )
        self.create_service(
            ActionResultDetails,
            "~/action_result_details",
            self.get_action_result_details,
        )
        self.create_service(
            ActionFeedbackDetails,
            "~/action_feedback_details",
            self.get_action_feedback_details,
        )
        self.create_service(
            SetParam,
            "~/set_param",
            self.set_param,
            callback_group=ReentrantCallbackGroup(),
            qos_profile=qos_profile_parameters,
        )
        self.create_service(
            GetParam,
            "~/get_param",
            self.get_param,
            callback_group=ReentrantCallbackGroup(),
            qos_profile=qos_profile_parameters,
        )
        self.create_service(
            HasParam,
            "~/has_param",
            self.has_param,
            callback_group=ReentrantCallbackGroup(),
            qos_profile=qos_profile_parameters,
        )
        self.create_service(
            DeleteParam,
            "~/delete_param",
            self.delete_param,
            callback_group=ReentrantCallbackGroup(),
            qos_profile=qos_profile_parameters,
        )
        self.create_service(
            GetParamNames,
            "~/get_param_names",
            self.get_param_names,
            callback_group=ReentrantCallbackGroup(),
            qos_profile=qos_profile_parameters,
        )
        self.create_service(GetTime, "~/get_time", self.get_time)
        self.create_service(GetROSVersion, "~/get_ros_version", self.get_ros_version)

    def get_globs(self):
        return glob_helper.get_globs(self)

    def get_topics(self, _request, response):
        """
        Return a list of all the topics being published.

        Called by the rosapi/Topics service.
        """
        response.topics, response.types = proxy.get_topics_and_types(self.globs.topics)
        return response

    def get_interfaces(self, _request, response):
        """
        Return a list of all the interfaces in the system.

        Called by the rosapi/Interfaces service.
        """
        response.interfaces = proxy.get_interfaces()
        return response

    def get_topics_for_type(self, request, response):
        """
        Return a list of all the topics that are publishing a given type.

        Called by the rosapi/TopicsForType service.
        """
        response.topics = proxy.get_topics_for_type(request.type, self.globs.topics)
        return response

    def get_topics_and_raw_types(self, _request, response):
        """
        Return a list of all the topics being published, and their raw types.

        Similar to `gendeps --cat`.

        Called by the rosapi/TopicsAndRawTypes service.
        """
        response.topics, response.types = proxy.get_topics_and_types(self.globs.topics)
        response.typedefs_full_text = [
            objectutils.get_typedef_full_text(type_name) for type_name in response.types
        ]
        return response

    def get_services(self, _request, response):
        """
        Return a list of all the services being advertised.

        Called by the rosapi/Services service.
        """
        response.services = proxy.get_services(self.globs.services)
        return response

    def get_services_for_type(self, request, response):
        """
        Return a list of all the services that are publishing a given type.

        Called by the rosapi/ServicesForType service.
        """
        response.services = proxy.get_services_for_type(request.type, self.globs.services)
        return response

    def get_nodes(self, _request, response):
        """
        Return a list of all the nodes that are registered.

        Called by the rosapi/Nodes service.
        """
        response.nodes = proxy.get_nodes()
        return response

    def get_node_details(self, request, response):
        """
        Return a node description.

        Called by the rosapi/Nodes service.
        """
        (
            response.subscribing,
            response.publishing,
            response.services,
        ) = proxy.get_node_info(request.node)
        return response

    def get_action_servers(self, _request, response):
        """
        Return a list of action servers based on actions standard topics.

        Called by the rosapi/GetActionServers service.
        """
        topics = proxy.get_topics(self.globs.topics, include_hidden=True)
        response.action_servers = proxy.filter_action_servers(topics)
        return response

    def get_topic_type(self, request, response):
        """
        Given the name of a topic, return the name of the type of that topic.

        Request class has one field, 'topic', which is a string value (the name of the topic).
        Response class has one field, 'type', which is a string value (the type of the topic).
        If the topic does not exist, an empty string is returned.

        Called by the rosapi/TopicType service.
        """
        response.type = proxy.get_topic_type(request.topic, self.globs.topics)
        return response

    def get_service_type(self, request, response):
        """
        Given the name of a service, return the type of that service.

        Request class has one field, 'service', which is a string value (the name of the service).
        Response class has one field, 'type', which is a string value (the type of the service).
        If the service does not exist, an empty string is returned.

        Called by the rosapi/ServiceType service.
        """
        response.type = proxy.get_service_type(request.service, self.globs.services)
        return response

    def get_publishers(self, request, response):
        """
        Given the name of a topic, return a list of node names that are publishing on that topic.

        Called by the rosapi/Publishers service.
        """
        response.publishers = proxy.get_publishers(request.topic, self.globs.topics)
        return response

    def get_subscribers(self, request, response):
        """
        Given the name of a topic, return a list of node names that are subscribing to that topic.

        Called by the rosapi/Subscribers service.
        """
        response.subscribers = proxy.get_subscribers(request.topic, self.globs.topics)
        return response

    def get_service_providers(self, request, response):
        """
        Given the name of a topic, returns a list of node names that are advertising that service type.

        Called by the rosapi/ServiceProviders service.
        """
        response.providers = proxy.get_service_providers(request.service, self.globs.services)
        return response

    def get_service_node(self, request, response):
        """
        Given the name of a service, returns the name of the node that is providing that service.

        Called by the rosapi/ServiceNode service.
        """
        response.node = proxy.get_service_node(request.service, self.globs.services)
        return response

    def get_message_details(self, request, response):
        """
        Given the name of a message type, return the TypeDef for that type.

        Called by the rosapi/MessageDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d) for d in objectutils.get_typedef_recursive(request.type)
        ]
        return response

    def get_service_request_details(self, request, response):
        """
        Given the name of a service type, return the TypeDef for the request message of that service type.

        Called by the rosapi/ServiceRequestDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d)
            for d in objectutils.get_service_request_typedef_recursive(request.type)
        ]
        return response

    def get_service_response_details(self, request, response):
        """
        Given the name of a service type, return the TypeDef for the response message of that service type.

        Called by the rosapi/ServiceResponseDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d)
            for d in objectutils.get_service_response_typedef_recursive(request.type)
        ]
        return response

    def get_action_goal_details(self, request, response):
        """
        Given the name of an action type, return the TypeDef for the goal message of that action type.

        Called by the rosapi/ActionGoalDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d) for d in objectutils.get_action_goal_typedef_recursive(request.type)
        ]
        return response

    def get_action_result_details(self, request, response):
        """
        Given the name of an action type, return the TypeDef for the result message of that action type.

        Called by the rosapi/ActionResultDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d)
            for d in objectutils.get_action_result_typedef_recursive(request.type)
        ]
        return response

    def get_action_feedback_details(self, request, response):
        """
        Given the name of an action type, return the TypeDef for the feedback message of that action type.

        Called by the rosapi/ActionFeedbackDetails service.
        """
        response.typedefs = [
            dict_to_typedef(d)
            for d in objectutils.get_action_feedback_typedef_recursive(request.type)
        ]
        return response

    def get_action_type(self, request, response):
        """
        Given the name of an action, return its type.

        If the action does not exist, an empty string is returned.

        Called by the rosapi/ActionType service.
        """
        response.type = proxy.get_action_type(request.action)
        return response

    async def set_param(self, request, response):
        try:
            node_name, param_name = self._get_node_and_param_name(request.name)
        except ValueError:
            self._print_malformed_param_name_warning(request.name)

        try:
            await params.set_param(node_name, param_name, request.value, self.globs.params)
        except Exception as e:
            response.successful = False
            response.reason = str(e)
        else:
            response.successful = True

        return response

    async def get_param(self, request, response):
        try:
            node_name, param_name = self._get_node_and_param_name(request.name)
        except ValueError:
            self._print_malformed_param_name_warning(request.name)

        try:
            response.value = await params.get_param(node_name, param_name, self.globs.params)
        except Exception as e:
            response.successful = False
            response.reason = str(e)

            default = ""
            if request.default_value != "":
                try:
                    default = loads(request.default_value)
                except ValueError:
                    self.get_logger().error(
                        f"Failed to parse default value: {request.default_value}"
                    )

            response.value = dumps(default)
        else:
            response.successful = True

        return response

    async def has_param(self, request, response):
        try:
            node_name, param_name = self._get_node_and_param_name(request.name)
        except ValueError:
            self._print_malformed_param_name_warning(request.name)

        response.exists = await params.has_param(node_name, param_name, self.globs.params)

        return response

    async def delete_param(self, request, response):
        try:
            node_name, param_name = self._get_node_and_param_name(request.name)
        except ValueError:
            self._print_malformed_param_name_warning(request.name)

        try:
            await params.delete_param(node_name, param_name, self.globs.params)
        except Exception as e:
            response.successful = False
            response.reason = str(e)
        else:
            response.successful = True

        return response

    async def get_param_names(self, _request, response):
        response.names = await params.get_param_names(self.globs.params)
        return response

    def get_time(self, _request, response):
        response.time = Clock(clock_type=ClockType.ROS_TIME).now().to_msg()
        return response

    def _get_node_and_param_name(self, param):
        return tuple(param.split(":"))

    def _print_malformed_param_name_warning(self, param_name):
        self.get_logger().warning(
            f"Malformed parameter name: {param_name}; expecting <node_name>:<param_name>"
        )

    def get_ros_version(self, _request, response):
        response.version = 2
        response.distro = str(os.environ["ROS_DISTRO"])
        return response


def dict_to_typedef(typedefdict):
    typedef = TypeDef()
    typedef.type = typedefdict["type"]
    typedef.fieldnames = typedefdict["fieldnames"]
    typedef.fieldtypes = typedefdict["fieldtypes"]
    typedef.fieldarraylen = typedefdict["fieldarraylen"]
    typedef.examples = typedefdict["examples"]
    typedef.constnames = typedefdict["constnames"]
    typedef.constvalues = typedefdict["constvalues"]
    return typedef


def main(args=None):
    if args is None:
        args = sys.argv

    rclpy.init(args=args)
    node = Rosapi()
    try:
        rclpy.spin(node)
        node.destroy_node()
        rclpy.shutdown()
    except KeyboardInterrupt:
        print("Exiting due to SIGINT")


if __name__ == "__main__":
    main()



================================================
FILE: rosapi/src/rosapi/__init__.py
================================================
[Empty file]


================================================
FILE: rosapi/src/rosapi/async_helper.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2025, Fictionlab sp. z o.o.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from rclpy.node import Node
from rclpy.task import Future


async def futures_wait_for(node: Node, futures: list[Future], timeout_sec: float):
    """Await a list of futures with a timeout."""
    first_done_future: Future = Future()

    def timeout_callback():
        first_done_future.set_result(None)

    timer = node.create_timer(timeout_sec, timeout_callback)

    def future_done_callback(_arg):
        if all(future.done() for future in futures):
            first_done_future.set_result(None)

    for future in futures:
        future.add_done_callback(future_done_callback)

    await first_done_future

    timer.cancel()
    timer.destroy()


async def async_sleep(node: Node, delay_sec: float):
    """Block the coroutine for a given time."""
    sleep_future: Future = Future()

    def timeout_callback():
        sleep_future.set_result(None)

    timer = node.create_timer(delay_sec, timeout_callback)

    await sleep_future

    timer.cancel()
    timer.destroy()



================================================
FILE: rosapi/src/rosapi/glob_helper.py
================================================
import fnmatch
from typing import NamedTuple

from rcl_interfaces.msg import ParameterType


class Globs(NamedTuple):
    topics: list
    services: list
    params: list


def get_globs(node):
    def get_param(parameter_name):
        parameter_value = node.get_parameter(parameter_name).get_parameter_value()
        if parameter_value.type == ParameterType.PARAMETER_STRING:
            parameter_value = parameter_value.string_value
        else:
            parameter_value = ""
        # strips array delimiters in case of an array style value
        return [
            element.strip().strip("'")
            for element in parameter_value.strip("[").strip("]").split(",")
            if len(element.strip().strip("'")) > 0
        ]

    topics_glob = get_param("topics_glob")
    services_glob = get_param("services_glob")
    params_glob = get_param("params_glob")
    return Globs(topics_glob, services_glob, params_glob)


def filter_globs(globs, full_list):
    # If the globs are empty (weren't defined in the params), return the full list
    if globs is not None and len(globs) > 0:
        return list(filter(lambda x: any_match(x, globs), full_list))
    return full_list


def any_match(query, globs):
    return (
        globs is None or len(globs) == 0 or any(fnmatch.fnmatch(str(query), glob) for glob in globs)
    )



================================================
FILE: rosapi/src/rosapi/objectutils.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import inspect
import logging
import re

from rosapi.stringify_field_types import stringify_field_types
from rosbridge_library.internal import ros_loader

logger = logging.getLogger(__name__)

# Keep track of atomic types and special types
atomics = [
    "bool",
    "boolean",
    "byte",
    "int8",
    "uint8",
    "int16",
    "uint16",
    "int32",
    "uint32",
    "int64",
    "uint64",
    "float",
    "float32",
    "float64",
    "double",
    "string",
    "octet",
]
specials = ["time", "duration"]


def get_typedef(type_name):
    """
    Get the typedef for a message type.

    A typedef is a dict containing the following fields:
        - string type
        - string[] fieldnames
        - string[] fieldtypes
        - int[] fieldarraylen
        - string[] examples
        - string[] constnames
        - string[] constvalues

    get_typedef will return a typedef dict for the specified message type.
    """
    # Check if the type string indicates a sequence (array) type
    if matches := re.findall("sequence<([^<]+)>", type_name):
        # Extract the inner type and continue processing
        type_name = matches[0]

    if type_name in atomics:
        # Atomics don't get a typedef
        return None

    if type_name in specials:
        # Specials get their type def mocked up
        return _get_special_typedef(type_name)

    # Fetch an instance and return its typedef
    try:
        instance = ros_loader.get_message_instance(type_name)
        return _get_typedef(instance)
    except (ros_loader.InvalidModuleException, ros_loader.InvalidClassException) as e:
        logger.error("An error occurred trying to get the type definition for %s: %s", type_name, e)
        return None


def get_service_request_typedef(servicetype):
    """Return a typedef dict for the service request class for the specified service type."""
    # Get an instance of the service request class and return its typedef
    instance = ros_loader.get_service_request_instance(servicetype)
    return _get_typedef(instance)


def get_service_response_typedef(servicetype):
    """Return a typedef dict for the service response class for the specified service type."""
    # Get an instance of the service response class and return its typedef
    instance = ros_loader.get_service_response_instance(servicetype)
    return _get_typedef(instance)


def get_typedef_recursive(type_name):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Just go straight into the recursive method
    return _get_typedefs_recursive(type_name, [])


def get_service_request_typedef_recursive(servicetype):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Get an instance of the service request class and get its typedef
    instance = ros_loader.get_service_request_instance(servicetype)
    typedef = _get_typedef(instance)

    # Return the list of sub-typedefs
    return _get_subtypedefs_recursive(typedef, [])


def get_service_response_typedef_recursive(servicetype):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Get an instance of the service response class and get its typedef
    instance = ros_loader.get_service_response_instance(servicetype)
    typedef = _get_typedef(instance)

    # Return the list of sub-typedefs
    return _get_subtypedefs_recursive(typedef, [])


def get_action_goal_typedef_recursive(actiontype):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Get an instance of the action goal class and get its typedef
    instance = ros_loader.get_action_goal_instance(actiontype)
    typedef = _get_typedef(instance)

    # Return the list of sub-typedefs
    return _get_subtypedefs_recursive(typedef, [])


def get_action_result_typedef_recursive(actiontype):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Get an instance of the action result class and get its typedef
    instance = ros_loader.get_action_result_instance(actiontype)
    typedef = _get_typedef(instance)

    # Return the list of sub-typedefs
    return _get_subtypedefs_recursive(typedef, [])


def get_action_feedback_typedef_recursive(actiontype):
    """Return a list of typedef dicts for this type and all contained type fields."""
    # Get an instance of the action feedback class and get its typedef
    instance = ros_loader.get_action_feedback_instance(actiontype)
    typedef = _get_typedef(instance)

    # Return the list of sub-typedefs
    return _get_subtypedefs_recursive(typedef, [])


def get_typedef_full_text(ty):
    """Return the full text (similar to `gendeps --cat`) for the specified message type."""
    try:
        return stringify_field_types(ty)
    except Exception as e:
        return f"# failed to get full definition text for {ty}: {e!s}"


def _get_typedef(instance):
    """Get a typedef dict for the specified instance."""
    if _valid_instance(instance):
        fieldnames, fieldtypes, fieldarraylen, examples = _handle_array_information(instance)
        constnames, constvalues = _handle_constant_information(instance)
        return _build_typedef_dictionary(
            instance, fieldnames, fieldtypes, fieldarraylen, examples, constnames, constvalues
        )
    return None


def _valid_instance(instance):
    """
    Check if instance is valid.

    A valid instance is not None, has __slots__ and _fields_and_field_types attributes.
    """
    return not (
        instance is None
        or not hasattr(instance, "__slots__")
        or not hasattr(instance, "_fields_and_field_types")
    )


def _handle_array_information(instance):
    """
    Handle extraction of array information.

    Handles extraction of field names, types, lengths and examples.
    """
    fieldnames = []
    fieldtypes = []
    fieldarraylen = []
    examples = []
    for slot in instance.__slots__:
        key = slot.removeprefix("_")
        if key not in instance._fields_and_field_types:
            continue

        fieldnames.append(key)
        field_type, arraylen = _handle_type_and_array_len(instance, slot)
        fieldarraylen.append(arraylen)

        value = getattr(instance, slot)
        fieldtypes.append(_type_name(field_type, value))
        examples.append(str(_handle_example(arraylen, field_type, value)))

    return fieldnames, fieldtypes, fieldarraylen, examples


def _handle_type_and_array_len(instance, name):
    """Extract field type and determine its length if it's an array."""
    # Get original field type using instance's _fields_and_field_types property
    field_type = instance._fields_and_field_types[name[1:]]

    # Initialize arraylen
    arraylen = -1

    # If field_type is a sequence, update the `field_type` variable.
    if matches := re.findall("sequence<([^<]+)>", field_type):
        # Extract the inner type and continue processing
        field_type = matches[0]
        arraylen = 0
    elif field_type[-1:] == "]":
        if field_type[-2:-1] == "[":
            arraylen = 0
            field_type = field_type[:-2]
        else:
            split = field_type.find("[")
            arraylen = int(field_type[split + 1 : -1])
            field_type = field_type[:split]

    return field_type, arraylen


def _handle_example(arraylen, field_type, field_instance):
    """Determine the example of a field instance, whether it's an array or atomic type."""
    if arraylen >= 0:
        example = []
    elif field_type not in atomics:
        example = {}
    else:
        example = field_instance
    return example


def _handle_constant_information(instance):
    """Handle extraction of constants information including constant names and values."""
    constnames = []
    constvalues = []
    attributes = inspect.getmembers(instance)
    for attribute in attributes:
        if (
            attribute[0] not in instance.__slots__
            and not attribute[0].startswith("_")
            and not inspect.isroutine(attribute[1])
        ):
            constnames.append(str(attribute[0]))
            constvalues.append(str(attribute[1]))
    return constnames, constvalues


def _build_typedef_dictionary(
    instance, fieldnames, fieldtypes, fieldarraylen, examples, constnames, constvalues
):
    """Build the typedef dictionary from multiple inputs collected from instance."""
    return {
        "type": _type_name_from_instance(instance),
        "fieldnames": fieldnames,
        "fieldtypes": fieldtypes,
        "fieldarraylen": fieldarraylen,
        "examples": examples,
        "constnames": constnames,
        "constvalues": constvalues,
    }


def _get_special_typedef(type_name):
    example = None
    if type_name in {"time", "duration"}:
        example = {
            "type": type,
            "fieldnames": ["secs", "nsecs"],
            "fieldtypes": ["int32", "int32"],
            "fieldarraylen": [-1, -1],
            "examples": ["0", "0"],
            "constnames": [],
            "constvalues": [],
        }
    return example


def _get_typedefs_recursive(type_name, typesseen):
    """Return the type def for this type as well as the type defs for any fields within the type."""
    if type_name in typesseen:
        # Don't put a type if it's already been seen
        return []

    # Note that we have now seen this type
    typesseen.append(type_name)

    # Get the typedef for this type and make sure it's not None
    typedef = get_typedef(type_name)

    return _get_subtypedefs_recursive(typedef, typesseen)


def _get_subtypedefs_recursive(typedef, typesseen):
    if typedef is None:
        return []

    # Create the list of subtypes and get the typedefs for fields
    typedefs = [typedef]
    for fieldtype in typedef["fieldtypes"]:
        typedefs = typedefs + _get_typedefs_recursive(fieldtype, typesseen)

    return typedefs


def _type_name(type_name, instance):
    """Get the fully qualified type name for a given type and instance."""
    # The fully qualified type of atomic and special types is just their original name
    if type_name in atomics or type_name in specials:
        return type_name

    # If the instance is a list, then we can get no more information from the instance.
    # However, luckily, the 'type' field for list types is usually already inflated to the full type.
    if isinstance(instance, list):
        return type_name

    # Otherwise, the type will come from the module and class name of the instance
    return _type_name_from_instance(instance)


def _type_name_from_instance(instance):
    mod = instance.__module__
    return mod[0 : mod.find(".")] + "/" + instance.__class__.__name__



================================================
FILE: rosapi/src/rosapi/params.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# Copyright (c) 2025, Fictionlab sp. z o.o.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

import fnmatch
from json import dumps, loads
from typing import TYPE_CHECKING

from rcl_interfaces.msg import Parameter, ParameterType, ParameterValue
from rcl_interfaces.srv import GetParameters, ListParameters, SetParameters
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
from rclpy.parameter import get_parameter_value
from ros2node.api import get_absolute_node_name

from rosapi.async_helper import futures_wait_for
from rosapi.proxy import get_nodes

if TYPE_CHECKING:
    from rclpy.client import Client
    from rclpy.node import Node
    from rclpy.task import Future

""" Methods to interact with the param server.  Values have to be passed
as JSON in order to facilitate dynamically typed SRV messages """

# Constants
DEFAULT_PARAM_TIMEOUT_SEC = 5.0

_node = None
_timeout_sec = DEFAULT_PARAM_TIMEOUT_SEC

_parameter_type_mapping = [
    "",
    "bool_value",
    "integer_value",
    "double_value",
    "string_value",
    "byte_array_value",
    "bool_array_value",
    "integer_array_value",
    "double_array_value",
    "string_array_value",
]


def init(node: Node, timeout_sec: float = DEFAULT_PARAM_TIMEOUT_SEC):
    """
    Initialize params module with a rclpy.node.Node for further use.

    This function has to be called before any other for the module to work.

    :param node: The rclpy node to use for service calls.
    :type node: Node
    :param timeout_sec: The timeout in seconds for service calls.
    :type timeout_sec: float | int, optional
    :raises ValueError: If the timeout is not a positive number.
    """
    global _node, _timeout_sec
    _node = node

    if not isinstance(timeout_sec, (int, float)) or timeout_sec <= 0:
        msg = "Parameter timeout must be a positive number"
        raise ValueError(msg)
    _timeout_sec = timeout_sec


async def set_param(node_name: str, name: str, value: str, params_glob: list[str]):
    """Set a parameter in a given node."""
    if params_glob and not any(fnmatch.fnmatch(str(name), glob) for glob in params_glob):
        # If the glob list is not empty and there are no glob matches,
        # stop the attempt to set the parameter.
        return
    # If the glob list is empty (i.e. false) or the parameter matches
    # one of the glob strings, continue to set the parameter.
    d = None
    try:
        d = loads(value)
        value = d if isinstance(d, str) else value
    except ValueError as exc:
        msg = (
            "Due to the type flexibility of the ROS parameter server, "
            "the value argument to set_param must be a JSON-formatted string."
        )
        raise Exception(msg) from exc

    node_name = get_absolute_node_name(node_name)
    await _set_param(node_name, name, value)


async def _set_param(node_name: str, name: str, value: str, parameter_type=None):
    """
    Set a parameter in a given node.

    Internal helper function for set_param.
    Attempts to set the given parameter in the target node with the desired value,
    deducing the parameter type if it's not specified.
    parameter_type allows forcing a type for the given value; this is useful to delete parameters.
    """
    parameter = Parameter()
    parameter.name = name
    if parameter_type is None:
        parameter.value = get_parameter_value(string_value=value)
    else:
        parameter.value = ParameterValue()
        parameter.value.type = parameter_type
        if parameter_type != ParameterType.PARAMETER_NOT_SET:
            setattr(parameter.value, _parameter_type_mapping[parameter_type], loads(value))

    assert _node is not None
    client: Client = _node.create_client(
        SetParameters,
        f"{node_name}/set_parameters",
        callback_group=MutuallyExclusiveCallbackGroup(),
    )

    if not client.service_is_ready():
        _node.destroy_client(client)
        msg = f"Service {client.srv_name} is not available"
        raise Exception(msg)

    request = SetParameters.Request()
    request.parameters = [parameter]

    future = client.call_async(request)

    await futures_wait_for(_node, [future], _timeout_sec)

    _node.destroy_client(client)

    if not future.done():
        future.cancel()
        msg = "Timeout occurred"
        raise Exception(msg)

    result = future.result()

    assert result is not None
    if not result.results[0].successful:
        raise Exception(result.results[0].reason)


async def get_param(node_name: str, name: str, params_glob: str) -> str:
    """Get a parameter from a given node."""
    if params_glob and not any(fnmatch.fnmatch(str(name), glob) for glob in params_glob):
        # If the glob list is not empty and there are no glob matches,
        # stop the attempt to get the parameter.
        msg = f"Parameter {name} does not match any of the glob strings"
        raise Exception(msg)
    # If the glob list is empty (i.e. false) or the parameter matches
    # one of the glob strings, continue to get the parameter.

    node_name = get_absolute_node_name(node_name)
    pvalue = await _get_param(node_name, name)
    value = getattr(pvalue, _parameter_type_mapping[pvalue.type])

    # Convert array types to lists for JSON serialization
    if hasattr(value, "tolist"):  # This will catch numpy arrays and Python arrays
        value = value.tolist()

    return dumps(value)


async def _get_param(node_name: str, name: str) -> ParameterValue:
    """
    Get a parameter from a given node.

    Internal helper function for get_param.
    """
    assert _node is not None
    client: Client = _node.create_client(
        GetParameters,
        f"{node_name}/get_parameters",
        callback_group=MutuallyExclusiveCallbackGroup(),
    )

    if not client.service_is_ready():
        _node.destroy_client(client)
        msg = f"Service {client.srv_name} is not available"
        raise Exception(msg)

    request = GetParameters.Request()
    request.names = [name]

    future = client.call_async(request)

    await futures_wait_for(_node, [future], _timeout_sec)

    _node.destroy_client(client)

    if not future.done():
        future.cancel()
        msg = "Timeout occurred"
        raise Exception(msg)

    result = future.result()

    assert result is not None
    if len(result.values) == 0:
        msg = f"Parameter {name} not found"
        raise Exception(msg)

    return result.values[0]


async def has_param(node_name: str, name: str, params_glob: str) -> bool:
    """Check whether a given node has a parameter or not."""
    if params_glob and not any(fnmatch.fnmatch(str(name), glob) for glob in params_glob):
        # If the glob list is not empty and there are no glob matches,
        # stop the attempt to set the parameter.
        return False
    # If the glob list is empty (i.e. false) or the parameter matches
    # one of the glob strings, check whether the parameter exists.
    node_name = get_absolute_node_name(node_name)
    try:
        pvalue = await _get_param(node_name, name)
    except Exception:
        return False

    return 0 < pvalue.type < len(_parameter_type_mapping)


async def delete_param(node_name, name, params_glob):
    """Delete a parameter in a given node."""
    if params_glob and not any(fnmatch.fnmatch(str(name), glob) for glob in params_glob):
        # If the glob list is not empty and there are no glob matches,
        # stop the attempt to delete the parameter.
        return
    # If the glob list is empty (i.e. false) or the parameter matches
    # one of the glob strings, continue to delete the parameter.
    node_name = get_absolute_node_name(node_name)
    if await has_param(node_name, name, params_glob):
        await _set_param(node_name, name, None, ParameterType.PARAMETER_NOT_SET)


async def get_param_names(params_glob: str | None) -> list[str]:
    assert _node is not None

    nodes = [get_absolute_node_name(node) for node in get_nodes()]

    futures: list[tuple[str, Future]] = []
    clients = []
    for node_name in nodes:
        if node_name == _node.get_fully_qualified_name():
            continue

        client: Client = _node.create_client(
            ListParameters,
            f"{node_name}/list_parameters",
            callback_group=MutuallyExclusiveCallbackGroup(),
        )
        if client.service_is_ready():
            future = client.call_async(ListParameters.Request())
            futures.append((node_name, future))
            clients.append(client)
        else:
            _node.destroy_client(client)

    params = []

    await futures_wait_for(_node, [future for _, future in futures], _timeout_sec)

    for client in clients:
        _node.destroy_client(client)

    for node_name, future in futures:
        if not future.done():
            future.cancel()
            continue

        if future.exception() is not None:
            continue

        result = future.result()
        if result is not None:
            params.extend([f"{node_name}:{param_name}" for param_name in result.result.names])

    if params_glob:
        return list(
            filter(lambda x: any(fnmatch.fnmatch(str(x), glob) for glob in params_glob), params)
        )
    return params



================================================
FILE: rosapi/src/rosapi/proxy.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from ros2action.api import get_action_names_and_types
from ros2interface.api import type_completer
from ros2node.api import (
    get_node_names,
    get_publisher_info,
    get_service_server_info,
    get_subscriber_info,
)
from ros2service.api import get_service_names, get_service_names_and_types
from ros2topic.api import get_topic_names, get_topic_names_and_types

from .glob_helper import any_match, filter_globs

_node = None


def init(node):
    """
    Initialize proxy module with a rclpy.node.Node for further use.

    This function has to be called before any other for the module to work.

    :param node: The rclpy node to use for service calls.
    :type node: Node
    """
    global _node
    _node = node


def get_topics(topics_glob, include_hidden=False):
    """Return a list of all the active topics in the ROS system."""
    topic_names = get_topic_names(node=_node, include_hidden_topics=include_hidden)
    return filter_globs(topics_glob, topic_names)


def get_interfaces():
    """Return a list of all the types in the ROS system."""
    return type_completer()


def get_topics_and_types(topics_glob, include_hidden=False):
    return get_publications_and_types(
        topics_glob, get_topic_names_and_types, include_hidden_topics=include_hidden
    )


def get_topics_for_type(topic_type, topics_glob, include_hidden=False):
    topic_names_and_types = get_topic_names_and_types(
        node=_node, include_hidden_topics=include_hidden
    )
    # topic[0] has the topic name and topic[1] has the type wrapped in a list.
    topics_for_type = [topic[0] for topic in topic_names_and_types if topic[1][0] == topic_type]
    return filter_globs(topics_glob, topics_for_type)


def get_services(services_glob, include_hidden=False):
    """Return a list of all the services advertised in the ROS system."""
    # Filter the list of services by whether they are public before returning.
    service_names = get_service_names(node=_node, include_hidden_services=include_hidden)
    return filter_globs(services_glob, service_names)


def get_services_and_types(services_glob, include_hidden=False):
    return get_publications_and_types(
        services_glob,
        get_service_names_and_types,
        include_hidden_services=include_hidden,
    )


def get_services_for_type(service_type, services_glob, include_hidden=False):
    """Return a list of services as specific service type."""
    # Filter the list of services by whether they are public before returning.
    services_names_and_types = get_service_names_and_types(
        node=_node, include_hidden_services=include_hidden
    )
    # service[0] has the topic name and service[1] has the type wrapped in a list.
    services_for_type = [
        service[0] for service in services_names_and_types if service[1][0] == service_type
    ]
    return filter_globs(services_glob, services_for_type)


def get_publications_and_types(glob, getter_function, **include_hidden_publications):
    """
    Get a list of topic or service publications and their types.

    :param glob: A glob pattern to filter the publications.
    :type glob: str
    :param getter_function: A function to get the names and types of publications.
    :type getter_function: Callable
    :param include_hidden_publications: Keyword arguments to specify whether to include hidden publications.
    :type include_hidden_publications: dict
    :return: A tuple of filtered publication names and their types.
    :rtype: tuple
    """
    publication_names_and_types = getter_function(node=_node, **include_hidden_publications)
    # publication[0] has the publication name and publication[1] has the type wrapped in a list.
    all_publications = [publication[0] for publication in publication_names_and_types]
    filtered_publications = filter_globs(glob, all_publications)
    filtered_publication_types = [
        publication[1][0]
        for publication in publication_names_and_types
        if publication[0] in filtered_publications
    ]
    return filtered_publications, filtered_publication_types


def get_nodes(include_hidden=False):
    """Return a list of all the nodes registered in the ROS system."""
    node_names = get_node_names(node=_node, include_hidden_nodes=include_hidden)
    return [node_name.full_name for node_name in node_names]


def get_node_info(node_name, include_hidden=False):
    node_names = get_node_names(node=_node, include_hidden_nodes=include_hidden)
    if node_name in [n.full_name for n in node_names]:
        # Only the name of each item is required as output.
        subscribers = get_node_subscriptions(node_name)
        publishers = get_node_publications(node_name)
        services = get_node_services(node_name)

        return subscribers, publishers, services
    return None


def get_node_publications(node_name):
    """Return a list of topic names that are being published by the specified node."""
    publishers = get_publisher_info(node=_node, remote_node_name=node_name)
    return [publisher.name for publisher in publishers]


def get_node_subscriptions(node_name):
    """Return a list of topic names that are being subscribed by the specified node."""
    subscribers = get_subscriber_info(node=_node, remote_node_name=node_name)
    return [subscriber.name for subscriber in subscribers]


def get_node_services(node_name):
    """Return a list of service names that are being hosted by the specified node."""
    services = get_service_server_info(node=_node, remote_node_name=node_name)
    return [service.name for service in services]


def get_node_service_types(node_name):
    """Return a list of service types that are being hosted by the specified node."""
    services = get_service_server_info(node=_node, remote_node_name=node_name)
    return [service.types[0] for service in services]


def get_topic_type(topic, topics_glob):
    """Return the type of the specified ROS topic."""
    # Note: this doesn't consider hidden topics.
    topics, types = get_topics_and_types(topics_glob)
    try:
        return types[topics.index(topic)]
    except ValueError:
        # Return empty string if the topic is not present.
        return ""


def filter_action_servers(topics):
    """Return a list of action servers."""
    # Note(@jubeira): filtering by topic should be enough; services can be taken into account as well.
    action_servers = []
    possible_action_server = ""
    possibility = [0, 0]

    action_topics = ["feedback", "status"]
    for topic in sorted(topics):
        split = topic.split("/")
        if len(split) >= 4:
            topic_name = split.pop()
            action_prefix = split.pop()
            if action_prefix != "_action":
                continue

            namespace = "/".join(split)
            if possible_action_server != namespace:
                possible_action_server = namespace
                possibility = [0, 0]
            if possible_action_server == namespace and topic_name in action_topics:
                possibility[action_topics.index(topic_name)] = 1
            if all(p == 1 for p in possibility):
                action_servers.append(possible_action_server)
                possibility = [0, 0]

    return action_servers


def get_service_type(service, services_glob):
    """Return the type of the specified ROS service,."""
    # Note: this doesn't consider hidden services.
    services, types = get_services_and_types(services_glob)
    try:
        return types[services.index(service)]
    except ValueError:
        # Return empty string if the service is not present.
        return ""


def get_channel_info(channel, channels_glob, getter_function, include_hidden=False):
    """
    Return a list of node names that are publishing on a specified channel.

    A channel may include topic publishers, subscribers, or service providers.

    :param channel: The name of the channel to query.
    :type channel: str
    :param channels_glob: A list of glob patterns to filter the channels.
    :type channels_glob: list[str]
    :param getter_function: A function to get the channel information for a given node.
    :type getter_function: Callable
    :param include_hidden: Whether to include hidden nodes in the search.
    :type include_hidden: bool
    :return: A list of node names that match the specified channel.
    :rtype: list[str]
    """
    if any_match(str(channel), channels_glob):
        channel_info_list = []
        node_list = get_nodes(include_hidden)
        for node in node_list:
            channel_info = getter_function(node)
            if channel in channel_info:
                channel_info_list.append(node)
        return channel_info_list
    return []


def get_publishers(topic, topics_glob, include_hidden=False):
    """Return a list of node names that are publishing the specified topic."""
    return get_channel_info(
        topic, topics_glob, get_node_publications, include_hidden=include_hidden
    )


def get_subscribers(topic, topics_glob, include_hidden=False):
    """Return a list of node names that are subscribing to the specified topic."""
    return get_channel_info(
        topic, topics_glob, get_node_subscriptions, include_hidden=include_hidden
    )


def get_service_providers(queried_type, services_glob, include_hidden=False):
    """Return a list of node names that are advertising a service with the specified type."""
    return get_channel_info(
        queried_type,
        services_glob,
        get_node_service_types,
        include_hidden=include_hidden,
    )


def get_service_node(queried_type, services_glob, include_hidden=False):
    """Return the name of the node that is providing the given service, or empty string."""
    node_name = get_channel_info(
        queried_type, services_glob, get_node_services, include_hidden=include_hidden
    )
    if node_name:
        return node_name[0]
    return ""


def get_action_type(action_name, include_hidden=False):
    """
    Return the type of the specified ROS action.

    If the action does not exist, an empty string is returned.
    """
    names_and_types = get_action_names_and_types(node=_node, include_hidden_actions=include_hidden)

    for name, types in names_and_types:
        if name == action_name and types:
            return types[0]

    return ""



================================================
FILE: rosapi/src/rosapi/stringify_field_types.py
================================================
from pathlib import Path

from rosidl_adapter.parser import parse_message_string
from rosidl_runtime_py import get_interface_path


def stringify_field_types(root_type):
    definition = ""
    seen_types = set()
    deps = [root_type]
    is_root = True
    while deps:
        ty = deps.pop()
        parts = ty.split("/")
        if not is_root:
            definition += "\n================================================================================\n"
            definition += f"MSG: {ty}\n"
        is_root = False

        msg_name = parts[2] if len(parts) == 3 else parts[1]
        interface_name = ty if len(parts) == 3 else f"{parts[0]}/msg/{parts[1]}"
        with Path(get_interface_path(interface_name)).open(encoding="utf-8") as msg_file:
            msg_definition = msg_file.read()
        definition += msg_definition

        spec = parse_message_string(parts[0], msg_name, msg_definition)
        for field in spec.fields:
            is_builtin = field.type.pkg_name is None
            if not is_builtin:
                field_ty = f"{field.type.pkg_name}/{field.type.type}"
                if field_ty not in seen_types:
                    deps.append(field_ty)
                    seen_types.add(field_ty)

    return definition



================================================
FILE: rosapi/test/__init__.py
================================================
[Empty file]


================================================
FILE: rosapi/test/test_stringify_field_types.py
================================================
import contextlib
import unittest

from rosapi.stringify_field_types import stringify_field_types
from rosbridge_library.internal.ros_loader import InvalidModuleException


class TestObjectUtils(unittest.TestCase):
    def test_stringify_field_types(self) -> None:
        self.maxDiff = None

        self.assertRegex(
            stringify_field_types("std_msgs/String"),
            r"(?ms)^string data",
        )

        self.assertRegex(
            stringify_field_types("std_msgs/msg/String"),
            r"(?ms)^string data",
        )

        self.assertRegex(
            stringify_field_types("std_msgs/ByteMultiArray"),
            r"""(?s)
MultiArrayLayout  layout.*
byte\[\]            data.*

================================================================================
MSG: std_msgs/MultiArrayLayout
.*
MultiArrayDimension\[\] dim.*
uint32 data_offset.*

================================================================================
MSG: std_msgs/MultiArrayDimension
.*
string label.*
uint32 size.*
uint32 stride.*
""",
        )
        self.assertRegex(
            stringify_field_types("sensor_msgs/Image"),
            r"""(?s)
std_msgs/Header header.*
.*
uint32 height.*
uint32 width.*
.*
string encoding.*
.*
uint8 is_bigendian.*
uint32 step.*
uint8\[\] data.*

================================================================================
MSG: std_msgs/Header
.*
builtin_interfaces/Time stamp.*
string frame_id

================================================================================
MSG: builtin_interfaces/Time
.*
int32 sec.*
uint32 nanosec
""",
        )
        self.assertRegex(
            stringify_field_types("sensor_msgs/CameraInfo"),
            r"""(?s)
std_msgs/Header header.*
uint32 height.*
uint32 width.*
string distortion_model.*
float64\[\] d.*
float64\[9\]  k.*
float64\[9\]  r.*
float64\[12\] p.*
uint32 binning_x.*
uint32 binning_y.*
RegionOfInterest roi.*

================================================================================
MSG: sensor_msgs/RegionOfInterest
.*
uint32 x_offset.*
uint32 y_offset.*
uint32 height.*
uint32 width.*
bool do_rectify

================================================================================
MSG: std_msgs/Header
.*
builtin_interfaces/Time stamp.*
string frame_id

================================================================================
MSG: builtin_interfaces/Time
.*
int32 sec.*
uint32 nanosec
""",
        )

        self.assertRegex(
            stringify_field_types("shape_msgs/SolidPrimitive"),
            r"""(?s)
uint8 BOX=1.*
uint8 SPHERE=2.*
uint8 CYLINDER=3.*
uint8 CONE=4.*
uint8 type.*
float64\[<=3\] dimensions.*
uint8 BOX_X=0.*
uint8 BOX_Y=1.*
uint8 BOX_Z=2.*
uint8 SPHERE_RADIUS=0.*
uint8 CYLINDER_HEIGHT=0.*
uint8 CYLINDER_RADIUS=1.*
uint8 CONE_HEIGHT=0.*
uint8 CONE_RADIUS=1.*
""",
        )

        self.assertEqual(
            stringify_field_types("geometry_msgs/Quaternion"),
            """\
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
""",
        )

        # This message is not present on older ROS distributions
        cm = contextlib.suppress(InvalidModuleException)
        with cm:
            # We match against a regex here as the Gid.msg differs between distros:
            # Distros up to humble use 24 bytes, more recent distros use 16 bytes.
            # See https://github.com/ros2/rmw_dds_common/pull/68
            self.assertRegex(
                stringify_field_types("rmw_dds_common/NodeEntitiesInfo"),
                r"""string<=256 node_namespace
string<=256 node_name
Gid\[\] reader_gid_seq
Gid\[\] writer_gid_seq

================================================================================
MSG: rmw_dds_common/Gid
char\[(24|16)\] data
""",
            )



================================================
FILE: rosapi/test/test_typedefs.py
================================================
import unittest
from typing import Any, ClassVar

from rosapi import objectutils

# Globally defined ros_loader, used inside the setUp and teardown functions
ros_loader = None


class TestUtils(unittest.TestCase):
    def setUp(self) -> None:
        global ros_loader
        self.original_ros_loader = ros_loader
        ros_loader = self._mock_get_message_instance("default")

    def tearDown(self) -> None:
        global ros_loader
        ros_loader = self.original_ros_loader

    def _mock_get_message_instance(self, type_name: str) -> Any:
        class MockInstance:
            __slots__ = ["_" + type_name]
            _fields_and_field_types: ClassVar = {type_name: type_name}

        return MockInstance()

    def test_get_typedef_for_atomic_types(self) -> None:
        # Test for boolean type
        actual_typedef = objectutils.get_typedef("boolean")
        # should be None for an atomic
        self.assertEqual(actual_typedef, None)

        # Test for float type
        actual_typedef = objectutils.get_typedef("float")
        # should be None for an atomic
        self.assertEqual(actual_typedef, None)

    def test_handle_sequences(self) -> None:
        # Test for boolean sequence type
        actual_typedef = objectutils.get_typedef("sequence<boolean>")
        # should be None for an atomic
        self.assertEqual(actual_typedef, None)

    def test_skip_private_slots_in_array_info(self) -> None:
        # create a fake msg with one real field ('data') and one internal slot
        class MockMsg:
            __slots__ = ["_check_fields", "_important_data"]
            _fields_and_field_types: ClassVar = {"important_data": "int32"}

            def __init__(self):
                self._important_data = 123
                self._check_fields = None

        inst = MockMsg()
        # call the private helper directly
        names, types, lens, examples = objectutils._handle_array_information(inst)

        # should only see our single '_important_data' field
        self.assertEqual(names, ["important_data"])
        # raw type should be 'int32' (no array)
        self.assertEqual(types, ["int32"])
        self.assertEqual(lens, [-1])
        # example should be the stringified value of 123
        self.assertEqual(examples, ["123"])


if __name__ == "__main__":
    unittest.main()



================================================
FILE: rosapi_msgs/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosapi_msgs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------
* Add services to return Action interface details (`#1021 <https://github.com/RobotWebTools/rosbridge_suite/issues/1021>`_)
* Contributors: David Fernàndez López

2.2.0 (2025-02-26)
------------------
* New async rosapi params module implementation (`#1001 <https://github.com/RobotWebTools/rosbridge_suite/issues/1001>`_)
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Add new service to retrieve the different interfaces in the ROS Network (`#988 <https://github.com/RobotWebTools/rosbridge_suite/issues/988>`_)
* Contributors: Błażej Sowa, Lebecque Florian

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------

1.3.2 (2023-09-27)
------------------

1.3.1 (2022-10-21)
------------------

1.3.0 (2022-08-16)
------------------

1.2.0 (2022-05-20)
------------------
* Added `/rosapi/get_ros_version` service (`#708 <https://github.com/RobotWebTools/rosbridge_suite/issues/708>`_)
* Contributors: Jacob Bandes-Storch, Kedus Mathewos

1.1.2 (2022-01-03)
------------------

1.1.1 (2021-12-09)
------------------

1.1.0 (2021-10-22)
------------------
* Move msg/srv from rosapi and rosbridge_library into separate packages; enable Rolling in CI (`#665 <https://github.com/RobotWebTools/rosbridge_suite/issues/665>`_)
* Contributors: Jacob Bandes-Storch



================================================
FILE: rosapi_msgs/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosapi_msgs)

find_package(ament_cmake REQUIRED)
find_package(builtin_interfaces REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  msg/TypeDef.msg
  srv/DeleteParam.srv
  srv/GetActionServers.srv
  srv/GetParam.srv
  srv/GetParamNames.srv
  srv/GetROSVersion.srv
  srv/GetTime.srv
  srv/HasParam.srv
  srv/Interfaces.srv
  srv/MessageDetails.srv
  srv/Nodes.srv
  srv/NodeDetails.srv
  srv/Publishers.srv
  srv/ServiceNode.srv
  srv/ServiceProviders.srv
  srv/ServiceRequestDetails.srv
  srv/ServiceResponseDetails.srv
  srv/ActionGoalDetails.srv
  srv/ActionResultDetails.srv
  srv/ActionFeedbackDetails.srv
  srv/ActionType.srv
  srv/Services.srv
  srv/ServicesForType.srv
  srv/ServiceType.srv
  srv/SetParam.srv
  srv/Subscribers.srv
  srv/Topics.srv
  srv/TopicsAndRawTypes.srv
  srv/TopicsForType.srv
  srv/TopicType.srv
  DEPENDENCIES builtin_interfaces
)

ament_export_dependencies(builtin_interfaces rosidl_default_runtime)

ament_package()



================================================
FILE: rosapi_msgs/package.xml
================================================
<?xml version="1.0"?>
<package format="3">
  <name>rosapi_msgs</name>
  <version>2.3.0</version>
  <description>Interface definitions for rosapi package.</description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosapi</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>builtin_interfaces</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosapi_msgs/msg/TypeDef.msg
================================================
string type
string[] fieldnames
string[] fieldtypes
int32[] fieldarraylen
string[] examples
string[] constnames
string[] constvalues



================================================
FILE: rosapi_msgs/srv/ActionFeedbackDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/ActionGoalDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/ActionResultDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/ActionType.srv
================================================
string action
---
string type



================================================
FILE: rosapi_msgs/srv/DeleteParam.srv
================================================
string name
---
bool successful
string reason



================================================
FILE: rosapi_msgs/srv/GetActionServers.srv
================================================

---
string[] action_servers



================================================
FILE: rosapi_msgs/srv/GetParam.srv
================================================
string name
string default_value
---
string value
bool successful
string reason



================================================
FILE: rosapi_msgs/srv/GetParamNames.srv
================================================
---
string[] names



================================================
FILE: rosapi_msgs/srv/GetROSVersion.srv
================================================
---
uint8 version
string distro



================================================
FILE: rosapi_msgs/srv/GetTime.srv
================================================
---
builtin_interfaces/Time time



================================================
FILE: rosapi_msgs/srv/HasParam.srv
================================================
string name
---
bool exists



================================================
FILE: rosapi_msgs/srv/Interfaces.srv
================================================
---
string[] interfaces



================================================
FILE: rosapi_msgs/srv/MessageDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/NodeDetails.srv
================================================
string node
---
string[] subscribing
string[] publishing
string[] services



================================================
FILE: rosapi_msgs/srv/Nodes.srv
================================================

---
string[] nodes



================================================
FILE: rosapi_msgs/srv/Publishers.srv
================================================
string topic
---
string[] publishers



================================================
FILE: rosapi_msgs/srv/ServiceNode.srv
================================================
string service
---
string node



================================================
FILE: rosapi_msgs/srv/ServiceProviders.srv
================================================
string service
---
string[] providers



================================================
FILE: rosapi_msgs/srv/ServiceRequestDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/ServiceResponseDetails.srv
================================================
string type
---
TypeDef[] typedefs



================================================
FILE: rosapi_msgs/srv/Services.srv
================================================

---
string[] services



================================================
FILE: rosapi_msgs/srv/ServicesForType.srv
================================================
string type
---
string[] services



================================================
FILE: rosapi_msgs/srv/ServiceType.srv
================================================
string service
---
string type



================================================
FILE: rosapi_msgs/srv/SetParam.srv
================================================
string name
string value
---
bool successful
string reason



================================================
FILE: rosapi_msgs/srv/Subscribers.srv
================================================
string topic
---
string[] subscribers



================================================
FILE: rosapi_msgs/srv/Topics.srv
================================================

---
string[] topics
string[] types



================================================
FILE: rosapi_msgs/srv/TopicsAndRawTypes.srv
================================================

---
string[] topics
string[] types
string[] typedefs_full_text



================================================
FILE: rosapi_msgs/srv/TopicsForType.srv
================================================
string type
---
string[] topics



================================================
FILE: rosapi_msgs/srv/TopicType.srv
================================================
string topic
---
string type



================================================
FILE: rosbridge_library/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosbridge_library
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------
* Don't subscribe with Transient local QoS when there are volatile publishers (`#1023 <https://github.com/RobotWebTools/rosbridge_suite/issues/1023>`_)
* Contributors: Talha Işık

2.2.0 (2025-02-26)
------------------
* Default subscriber QOS to BestEffort, account for TRANSIENT_LOCAL (`#991 <https://github.com/RobotWebTools/rosbridge_suite/issues/991>`_)
* Fix action cancelling/aborting (`#1013 <https://github.com/RobotWebTools/rosbridge_suite/issues/1013>`_)
* Fix randomly failing subscribe unsubscribe test (`#1008 <https://github.com/RobotWebTools/rosbridge_suite/issues/1008>`_)
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Add timeout option to call_service messages (`#984 <https://github.com/RobotWebTools/rosbridge_suite/issues/984>`_)
* Fix infinite loop in QueueMessageHandler (`#983 <https://github.com/RobotWebTools/rosbridge_suite/issues/983>`_)
* Use monotonic clock for time measuring (`#982 <https://github.com/RobotWebTools/rosbridge_suite/issues/982>`_)
* Add ament_mypy test and fix all mypy errors (`#980 <https://github.com/RobotWebTools/rosbridge_suite/issues/980>`_)
* Drop support for ROS 2 Iron (`#981 <https://github.com/RobotWebTools/rosbridge_suite/issues/981>`_)
* Remove first handler update as queue update is blocked (`#974 <https://github.com/RobotWebTools/rosbridge_suite/issues/974>`_)
* Contributors: Błażej Sowa, Sebastian Castro, ewak, William Wedler, Mike Wake, Daisuke Sato, lboorman

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------
* Fix action cancellation by passing status from JSON (`#953 <https://github.com/RobotWebTools/rosbridge_suite/issues/953>`_)
* Update pre-commit and fix issues (`#954 <https://github.com/RobotWebTools/rosbridge_suite/issues/954>`_)
* Fix length-limited list types (`#840 <https://github.com/RobotWebTools/rosbridge_suite/issues/840>`_)
* fix: update new subs with dds from publisher (`#940 <https://github.com/RobotWebTools/rosbridge_suite/issues/940>`_)
* Avoid stale subscription when unsubscribing during resubscription (`#948 <https://github.com/RobotWebTools/rosbridge_suite/issues/948>`_)
* Changed type hints in ros_loader.py to use imports from Typing (`#938 <https://github.com/RobotWebTools/rosbridge_suite/issues/938>`_)
* Avoid stack traces when aborting an advertised action goal (`#906 <https://github.com/RobotWebTools/rosbridge_suite/issues/906>`_)
* Timeout if service server not available within server_timeout_time (`#905 <https://github.com/RobotWebTools/rosbridge_suite/issues/905>`_)
* Use ROS 2 Node Clock in Message Conversion (`#900 <https://github.com/RobotWebTools/rosbridge_suite/issues/900>`_)
* Fix issues when canceling and unadvertising actions (`#896 <https://github.com/RobotWebTools/rosbridge_suite/issues/896>`_)
* Support actions in rosbridge protocol (`#886 <https://github.com/RobotWebTools/rosbridge_suite/issues/886>`_)
* Port unit tests to ROS 2 + Fix CBOR conversion and PNG compression (`#882 <https://github.com/RobotWebTools/rosbridge_suite/issues/882>`_)
* Contributors: Brad Martin, Dimitri Nikitopoulos, EricGallimore, Ezra Brooks, Paul Gesel, Sebastian Castro, michael-cmt

1.3.2 (2023-09-27)
------------------
* Interpret call_services_in_new_thread as boolean (`#857 <https://github.com/RobotWebTools/rosbridge_suite/issues/857>`_)
* Add option to call services in a separate thread (`#847 <https://github.com/RobotWebTools/rosbridge_suite/issues/847>`_)
* fix memory leak on service call (`#774 <https://github.com/RobotWebTools/rosbridge_suite/issues/774>`_)
* Contributors: Sebastian Castro, hiroyuki obinata, rwhitney456

1.3.1 (2022-10-21)
------------------
* Optimized large binary array publishing (`#819 <https://github.com/RobotWebTools/rosbridge_suite/issues/819>`_)
* Skip unnecessary conversion for cbor/cbor-raw compression (`#792 <https://github.com/RobotWebTools/rosbridge_suite/issues/792>`_) (`#800 <https://github.com/RobotWebTools/rosbridge_suite/issues/800>`_)
* Improve robustness for multiple client connections (`#803 <https://github.com/RobotWebTools/rosbridge_suite/issues/803>`_)
* Minor performance improvements (`#809 <https://github.com/RobotWebTools/rosbridge_suite/issues/809>`_)
* Remove unnecessary checking of topic globs. (`#793 <https://github.com/RobotWebTools/rosbridge_suite/issues/793>`_) (`#799 <https://github.com/RobotWebTools/rosbridge_suite/issues/799>`_)
* Fix duplicate subscription created with wrong 'raw' attribute. (`#798 <https://github.com/RobotWebTools/rosbridge_suite/issues/798>`_)
* Contributors: Hans-Joachim Krauch, Steffen Nattke, Ted Sender

1.3.0 (2022-08-16)
------------------
* Allow integers in conversion to float array messages (`#777 <https://github.com/RobotWebTools/rosbridge_suite/issues/777>`_)
* Non standard msg modules (`#735 <https://github.com/RobotWebTools/rosbridge_suite/issues/735>`_)
* Contributors: Jacob Bandes-Storch, Will

1.2.0 (2022-05-20)
------------------
* Fixed float arrays conversion (`#730 <https://github.com/RobotWebTools/rosbridge_suite/issues/730>`_)
* Fixed multiple subscriber on transient_local topic (`#723 <https://github.com/RobotWebTools/rosbridge_suite/issues/723>`_)
* Fix translation of time and time arrays (`#691 <https://github.com/RobotWebTools/rosbridge_suite/issues/691>`_)
* Fix array behavior (`#692 <https://github.com/RobotWebTools/rosbridge_suite/issues/692>`_)
* Contributors: Jacob Bandes-Storch, José Castelo, Kenji Miyake, Will, p0rys

1.1.2 (2022-01-03)
------------------
* [694] update DurabilityPolicy api that are being deprecated (`#695 <https://github.com/RobotWebTools/rosbridge_suite/issues/695>`_)
* Fix byte behavior (`#693 <https://github.com/RobotWebTools/rosbridge_suite/issues/693>`_)
* Fix test_message_conversion.py (`#645 <https://github.com/RobotWebTools/rosbridge_suite/issues/645>`_)
* Fix test_ros_loader.py (`#644 <https://github.com/RobotWebTools/rosbridge_suite/issues/644>`_)
* Fix CI test configuration and temporarily disable rosbridge_library test (`#686 <https://github.com/RobotWebTools/rosbridge_suite/issues/686>`_)
* Contributors: Evan Flynn, Jacob Bandes-Storch, Kenji Miyake

1.1.1 (2021-12-09)
------------------
* Allow subscribing to any qos profile when creating a subscriber (`#690 <https://github.com/RobotWebTools/rosbridge_suite/issues/690>`_)
* Fix and add test for multiple subscribers to same topic (`#687 <https://github.com/RobotWebTools/rosbridge_suite/issues/687>`_)
* Fix error when advertising duplicate service (`#683 <https://github.com/RobotWebTools/rosbridge_suite/issues/683>`_)
* Fix incoming service calls (`#669 <https://github.com/RobotWebTools/rosbridge_suite/issues/669>`_)
* Replace busy wait in AdvertiseService with async handler (`#666 <https://github.com/RobotWebTools/rosbridge_suite/issues/666>`_)
* Contributors: Domenic Rodriguez, Jacob Bandes-Storch, Roman Shtylman

1.1.0 (2021-10-22)
------------------
* Fix test imports from rosbridge_test_msgs (`#668 <https://github.com/RobotWebTools/rosbridge_suite/issues/668>`_)
* Move msg/srv from rosapi and rosbridge_library into separate packages; enable Rolling in CI (`#665 <https://github.com/RobotWebTools/rosbridge_suite/issues/665>`_)
* Fix test_services.py (`#653 <https://github.com/RobotWebTools/rosbridge_suite/issues/653>`_)
* Fix unused variables: flake8 --select=F841 (`#623 <https://github.com/RobotWebTools/rosbridge_suite/issues/623>`_)
* Remove get_service_instance from ros_loader (`#647 <https://github.com/RobotWebTools/rosbridge_suite/issues/647>`_)
* Fix test settings for rosbridge_library (`#643 <https://github.com/RobotWebTools/rosbridge_suite/issues/643>`_)
* Fix DOS line endings (`#658 <https://github.com/RobotWebTools/rosbridge_suite/issues/658>`_)
* Port `#464 <https://github.com/RobotWebTools/rosbridge_suite/issues/464>`_, `#478 <https://github.com/RobotWebTools/rosbridge_suite/issues/478>`_, `#496 <https://github.com/RobotWebTools/rosbridge_suite/issues/496>`_, and `#502 <https://github.com/RobotWebTools/rosbridge_suite/issues/502>`_ from ROS1 branch (`#663 <https://github.com/RobotWebTools/rosbridge_suite/issues/663>`_)
* Add pre-commit, format with black and isort (`#648 <https://github.com/RobotWebTools/rosbridge_suite/issues/648>`_)
* Contributors: Adrian Macneil, Christian Clauss, Domenic Rodriguez, Jacob Bandes-Storch, Kenji Miyake

1.0.8 (2021-08-26)
------------------
* Fix various Python code style and lint issues
* Contributors: Christian Clauss, Jacob Bandes-Storch

1.0.7 (2021-08-18)
------------------
* Fix typos discovered by codespell (`#600 <https://github.com/RobotWebTools/rosbridge_suite/issues/600>`_)
* Contributors: Christian Clauss

1.0.6 (2021-08-17)
------------------
* Fix broken links in changelogs
* Contributors: Jacob Bandes-Storch

1.0.5 (2021-08-12)
------------------

1.0.4 (2021-08-11)
------------------

1.0.3 (2021-08-03)
------------------
* Add cbor-raw compression support (`#574 <https://github.com/RobotWebTools/rosbridge_suite/issues/574>`_, adapted from ROS 1 implementation `#452 <https://github.com/RobotWebTools/rosbridge_suite/issues/452>`_)
* Adaptations to Eloquent [Again] (`#533 <https://github.com/RobotWebTools/rosbridge_suite/issues/533>`_)
  * increase spin period to 1000Hz to allow 1000 messages per second into the websocket
  * allow interpreting int as float when needed
  * better handling array.array and numpy arrays
  * allow bytes and str websocket messages
  * add boolean type
  * handle type extraction of static array rostypes
  * missing cls variable
  Co-authored-by: Maximilian Matthe <maxi.matthe@googlemail.com>
  Co-authored-by: CoRoLa generic <corola@bi>
  Co-authored-by: joshwapohlmann <joshwa.pohlmann@barkhauseninstitut.org>
* Fix for type error caused by appending byte arrays to empty string buffer (`#507 <https://github.com/RobotWebTools/rosbridge_suite/issues/507>`_)
* Contributors: Connor Brooks, Jacob Bandes-Storch, travipross

1.0.2 (2019-09-24)
------------------
* use Python 3 dependency keys (`#436 <https://github.com/RobotWebTools/rosbridge_suite/issues/436>`_)

1.0.1 (2019-09-20)
------------------

1.0.0 (2019-09-19)
------------------
* Port to ROS 2

0.11.3 (2019-08-07)
-------------------

0.11.2 (2019-07-08)
-------------------

0.11.1 (2019-05-08)
-------------------
* fixed logwarn msg formatting in publishers (`#398 <https://github.com/RobotWebTools/rosbridge_suite/issues/398>`_)
* Contributors: Gautham P Das

0.11.0 (2019-03-29)
-------------------
* BSON can send Nan and Inf (`#391 <https://github.com/RobotWebTools/rosbridge_suite/issues/391>`_)
* Contributors: akira_you

0.10.2 (2019-03-04)
-------------------
* Fix typo (`#379 <https://github.com/RobotWebTools/rosbridge_suite/issues/379>`_)
* Contributors: David Weis

0.10.1 (2018-12-16)
-------------------
* Inline cbor library (`#377 <https://github.com/RobotWebTools/rosbridge_suite/issues/377>`_)
  Prefer system version with C speedups, but include pure Python implementation.
* Contributors: Matt Vollrath

0.10.0 (2018-12-14)
-------------------
* CBOR encoding (`#364 <https://github.com/RobotWebTools/rosbridge_suite/issues/364>`_)
  * Add CBOR encoding
  * Fix value extraction performance regression
  Extract message values once per message.
  * Fix typed array tags
  Was using big-endian tags and encoding little-endian.
  Always use little-endian for now since Intel is prevalent for desktop.
  Add some comments to this effect.
  * Update CBOR protocol documentation
  More information about draft typed arrays and when to use CBOR.
  * Fix 64-bit integer CBOR packing
  Use an actual 64-bit format.
* use package format 2, remove unnecessary dependencies (`#348 <https://github.com/RobotWebTools/rosbridge_suite/issues/348>`_)
* removing has_key for python3, keeping backwards compatibility (`#337 <https://github.com/RobotWebTools/rosbridge_suite/issues/337>`_)
  * removing has_key for python3, keeping backwards compatibility
  * py3 change for itervalues, keeping py2 compatibility
* Contributors: Andreas Klintberg, Dirk Thomas, Matt Vollrath

0.9.0 (2018-04-09)
------------------
* Fix typo in function call
* Add missing argument to InvalidMessageException (`#323 <https://github.com/RobotWebTools/rosbridge_suite/issues/323>`_)
  Add missing argument to InvalidMessageException constructor
* Make unregister_timeout configurable (`#322 <https://github.com/RobotWebTools/rosbridge_suite/issues/322>`_)
  Pull request `#247 <https://github.com/RobotWebTools/rosbridge_suite/issues/247>`_ introduces a 10 second delay to mitigate issue `#138 <https://github.com/RobotWebTools/rosbridge_suite/issues/138>`_.
  This change makes this delay configurable by passing an argument either
  on the command line or when including a launch file.
  Usage example:
  ```xml
  <launch>
  <include file="$(find rosbridge_server)/launch/rosbridge_websocket.launch">
  <arg name="unregister_timeout" value="5.0"/>
  </include>
  </launch>
  ```
  Closes `#320 <https://github.com/RobotWebTools/rosbridge_suite/issues/320>`_
* message_conversion: create stand-alone object inst (`#319 <https://github.com/RobotWebTools/rosbridge_suite/issues/319>`_)
  Catching the ROSInitException allows to create object
  instances without an initialized ROS state
* Fixes `#313 <https://github.com/RobotWebTools/rosbridge_suite/issues/313>`_ by fixing has_binary in protocol.py (`#315 <https://github.com/RobotWebTools/rosbridge_suite/issues/315>`_)
  * Fixes `#313 <https://github.com/RobotWebTools/rosbridge_suite/issues/313>`_ by fixing has_binary in protocol.py
  Checks for lists that have binary content as well as dicts
  * Minor refactoring for protocol.py
* fix fragment bug (`#316 <https://github.com/RobotWebTools/rosbridge_suite/issues/316>`_)
  * fix bug that lost data while sending large packets
  * fixed travis ci failed by @T045T
  * fixed travis ci failed by @T045T
  * travis ci failed
  * fix rosbridge_library/test/experimental/fragmentation+srv+tcp test bug
  * sync .travis.yaml
  * fix the service_response message bug
  * fix the fragment paring error
  * fix indentation of "service" line
* add graceful_shutdown() method to advertise_service capability
  This gives the service a bit of time to cancel any in-flight service requests (which should fix `#265 <https://github.com/RobotWebTools/rosbridge_suite/issues/265>`_).
  This is important because we busy-wait for a rosbridge response for service calls and those threads do not get stopped otherwise.
  Also, rospy service clients do not currently support timeouts, so any clients would be stuck too.
  A new test case in test_service_capabilities.py verifies the fix works
* Add rostest for service capabilities and fix bugs
  also fixed some typos
* Fix Travis config (`#311 <https://github.com/RobotWebTools/rosbridge_suite/issues/311>`_)
  * fix Travis config
  dist: kinetic is currently unsupported
  * fix rostests
  for some reason, rostest seems to hide the rosout node - changed tests to use other services
* Contributors: Anwar, Johannes Rothe, Jørgen Borgesen, Nils Berg, Phil, WH-0501, elgarlepp

0.8.6 (2017-12-08)
------------------
* Import StringIO from StringIO if python2 and from io if python3 fixes `#306 <https://github.com/RobotWebTools/rosbridge_suite/issues/306>`_ (`#307 <https://github.com/RobotWebTools/rosbridge_suite/issues/307>`_)
* Contributors: Jihoon Lee

0.8.5 (2017-11-23)
------------------
* Raise if inappropriate bson module is installed (Appease `#198 <https://github.com/RobotWebTools/rosbridge_suite/issues/198>`_) (`#270 <https://github.com/RobotWebTools/rosbridge_suite/issues/270>`_)
  * Raise Exception if inappropriate bson module is installed (Related to `#198 <https://github.com/RobotWebTools/rosbridge_suite/issues/198>`_)
* Add Python3 compatibility (`#300 <https://github.com/RobotWebTools/rosbridge_suite/issues/300>`_)
  * First pass at Python 3 compatibility
  * message_conversion: Only call encode on a Python2 str or bytes type
  * protocol.py: Changes for dict in Python3. Compatible with Python 2 too.
  * More Python 3 fixes, all tests pass
  * Move definition of string_types to rosbridge_library.util
* Contributors: Junya Hayashi, Kartik Mohta

0.8.4 (2017-10-16)
------------------

0.8.3 (2017-09-11)
------------------
* Type conversion convention correction, correcting issue `#240 <https://github.com/RobotWebTools/rosbridge_suite/issues/240>`_
* Contributors: Alexis Paques

0.8.2 (2017-09-11)
------------------

0.8.1 (2017-08-30)
------------------
* remove ujson from dependency to build in trusty (`#290 <https://github.com/RobotWebTools/rosbridge_suite/issues/290>`_)
* Contributors: Jihoon Lee

0.8.0 (2017-08-30)
------------------
* Cleaning up travis configuration (`#283 <https://github.com/RobotWebTools/rosbridge_suite/issues/283>`_)
  configure travis to use industial ci configuration. Now it uses xenial and kinetic
* Merge pull request `#272 <https://github.com/RobotWebTools/rosbridge_suite/issues/272>`_ from ablakey/patch-1
  Prevent a KeyError when bson_only_mode is unset.
* Update protocol.py
  Prevent a KeyError when bson_only_mode is unset.
* Merge pull request `#257 <https://github.com/RobotWebTools/rosbridge_suite/issues/257>`_ from Sanic/bson-only-mode
  Implemented a bson_only_mode flag for the TCP version of rosbridge
* Merge pull request `#247 <https://github.com/RobotWebTools/rosbridge_suite/issues/247>`_ from v-lopez/develop
  Delay unregister to mitigate `#138 <https://github.com/RobotWebTools/rosbridge_suite/issues/138>`_
* Change class constant to module constant
* Reduce timeout for tests
  Tests will sleep for 10% extra of the timeout to prevent some situations
  were the test sleep ended right before the unregister timer fired
* Fix test advertise errors after delayed unregister changes
* Fix missing tests due to delayed unregistration
* Move UNREGISTER_TIMEOUT to member class so it's accessible from outside
* minor change in variable usage
* Implemented a bson_only_mode flag for the TCP version of rosbridge; This allows you to switch to a full-duplex transmission of BSON messages and therefore eliminates the need for a base64 encoding of binary data; Use the new mode by starting:'roslaunch rosbridge_server rosbridge_tcp.launch bson_only_mode:=True' or passing '--bson_only_mode' to the rosbridge_tcp.py script
* Delay unregister to mitigate !138
* Contributors: Andrew Blakey, Jihoon Lee, Nils Berg, Patrick Mania, Victor Lopez

0.7.17 (2017-01-25)
-------------------
* adjust log level for security globs
  Normal operation (i.e. no globs or successful verification of requests) is now silent, with illegal requests producing a warning.
* add missing import
* correct default values for security globs
  also accept empty list as the default "do not check globs" value in addition to None.
  Finally, append rosapi service glob after processing command line input so it's not overwritten
* Added services_glob to CallServices, added globs to rosbridge_tcp and rosbridge_udp, and other miscellaneous fixes.
* As per the suggestions of @T045T, fixed several typos, improved logging, and made some style fixes.
* Added new parameters for topic and service security.
  Added 3 new parameters to rosapi and rosbridge_server which filter the
  topics, services, and parameters broadcast by the server to match an
  array of glob strings.
* Contributors: Eric, Nils Berg

0.7.16 (2016-08-15)
-------------------
* Fixed deprecated code in pillow
* Contributors: vladrotea

0.7.15 (2016-04-25)
-------------------
* changelog updated
* Contributors: Russell Toris

0.7.14 (2016-02-11)
-------------------
* Another fix for code
* Replaced += with ''.join() for python code
* Default Protocol delay_between_messages = 0
  This prevents performance problems when multiple clients are subscribing to high frequency topics.
  Fixes `#203 <https://github.com/RobotWebTools/rosbridge_suite/issues/203>`_
* Contributors: Matt Vollrath, kiloreux

0.7.13 (2015-08-14)
-------------------
* Nevermind o_O
* Add test_depend too (just in case)
* Add dependency on python bson
* Get parameter at encode time
* Add flag for using the bson encoding
* revert comment regarding unpublisher
* avoiding racing condition
* Add bson encoding to the server side
* Fix catkin_lint issues
* don't unregister topic from rosbridge. It creates md5 sum warning.. #138
* Contributors: David Lu, Jihoon Lee, Matt Vollrath, dwlee

0.7.12 (2015-04-07)
-------------------
* use <test_depend> for test dependencies
* use rospy.resolve_name for namespaced service calls
* fix resolving namespaced service calls
* Contributors: Ramon Wijnands

0.7.11 (2015-03-23)
-------------------

0.7.10 (2015-02-25)
-------------------

0.7.9 (2015-02-24)
------------------

0.7.8 (2015-01-16)
------------------

0.7.7 (2015-01-06)
------------------

0.7.6 (2014-12-26)
------------------
* 0.7.5
* update changelog
* 0.7.4
* changelog updated
* 0.7.3
* changelog updated
* 0.7.2
* changelog updated
* 0.7.1
* update changelog
* 0.7.0
* changelog updated
* rewrite of advertise service
* cleanup init function
* matches original call_service
* matches original call_service
* service_request --> reuse of call_service (previously defined)
* stop_service --> unadvertise_service
* service_name --> service
* service_type --> type
* removed service_module
* request_id --> id
* Contributors: Jihoon Lee, Russell Toris

0.7.5 (2014-12-26)
------------------

0.7.4 (2014-12-16)
------------------

0.7.3 (2014-12-15)
------------------

0.7.2 (2014-12-15)
------------------
* 0.7.1
* update changelog
* Contributors: Jihoon Lee

0.7.1 (2014-12-09)
------------------

0.7.0 (2014-12-02)
------------------
* rewrite of advertise service
* cleanup init function
* matches original call_service
* matches original call_service
* service_request --> reuse of call_service (previously defined)
* stop_service --> unadvertise_service
* service_name --> service
* service_type --> type
* removed service_module
* request_id --> id
* Contributors: Russell Toris

0.6.8 (2014-11-05)
------------------
* add a lock to calls to load_manifest - apparently, it's not thread safe
  fixes #103 and #108
* Contributors: Nils Berg

0.6.7 (2014-10-22)
------------------
* updated package manifests
* Contributors: Russell Toris

0.6.6 (2014-10-21)
------------------

0.6.5 (2014-10-14)
------------------
* 0.6.4
* update changelog
* modify tests
  less duplicated code, some other changes to (hopefully) improve reliability. Tested locally about 30 times without encountering any failures.
* Change the behavior of MessageHandler.transition()
  Now reflects usage in the tests, i.e. a QueueMessageHandler only needs queue_length to be defined, not throttle_rate.
* 0.6.3
* update change log
* install util python module to fix #128
* Contributors: Jihoon Lee, Nils Berg

0.6.4 (2014-10-08)
------------------

0.6.3 (2014-10-07)
------------------
* install util python module to fix `#128 <https://github.com/RobotWebTools/rosbridge_suite/issues/128>`_
* Contributors: Jihoon Lee

0.6.2 (2014-10-06)
------------------
* Remove unused json imports; move json imports to utility
  Fixes #7
* Contributors: Graeme Yeates

0.6.1 (2014-09-01)
------------------
* Handle float infinity and NAN s
* Windows-related fix for PIL Image module import
* Fixed typo in raising type errors.
* something messed up indentation
  not sure how that could happen, worked here.
* map Inf and NaN to null
  JSON does not support Inf and NaN values. Currently they are just written into the JSON and JSON.parse on the client side will fail. Correct is to map them to null which will then be parsed correctly by JSON.parse on the client side.
  The issue with that is that the shortcut for lists of floats might be impossible (maybe someone else with more experience in python comes up with something else?). Maybe something similar is necessary in the to_inst case, but I can not really test them.
  Real world application is to process laser scans, they contain inf and nan values for some drivers if the measurements are invalid or out of range.
* Update .travis.yml and package.xml for rosbridge_library tests
* Put back unregister for the publisher and clarify the reconnect behavior
  of the test case. The exponential backoff of the client causes hard to
  understand timing of the events.
  All specs passed locally on hydro:
  SUMMARY
  * RESULT: SUCCESS
  * TESTS: 103
  * ERRORS: 0
  * FAILURES: 0
* Add copyright notice to the file
* Remove extra whitespace
* Make the test more deterministic
* Remove circular dependency.
* Contributors: Achim Konigs, Alex Sorokin, Alexander Sorokin, Jonathan Wade, jon-weisz

0.6.0 (2014-05-23)
------------------
* Ensure that service name is a string
  Closes `#104 <https://github.com/RobotWebTools/rosbridge_suite/issues/104>`_
* Contributors: Piyush Khandelwal

0.5.4 (2014-04-17)
------------------
* removing wrong import
* test case for fixed size of uint8 array
* uses regular expression to match uint8 array and char array.
* logerr when it fails while message_conversion
* Contributors: Jihoon Lee

0.5.3 (2014-03-28)
------------------
* use queue_size for publishers
* Contributors: Jon Binney

0.5.2 (2014-03-14)
------------------
* First attempt adding latching support for topic publishers
* merging changes of groovy-devel into hydro-devel
* adding missing dependency in rosbridge_library `#70 <https://github.com/RobotWebTools/rosbridge_suite/issues/70>`_
* Fixed wrong unicode encoding
* support publishing non-ascii letters
* Added error message on result=False
  When call_service returns False as result, values contains the error message.
* added parameter lookup to rosbridge_tcp.py, modules where those are used, and default parameters to launch file; internal default-values still get used when launch-file does not provide them; internal defaults can be changed within rosbridge_tcp.py
* Merge branch 'experimental_branch' into new_features
* fix handling of partial/multiple/broken json by avoiding to pass nested json (without op-field) to rosbridge.. probably still needs more complex handling of incoming 'broken' json
* nested service not MiRoR related anymore
* added singleton for request-list; allows provider to send service response without specifying module and type, they get looked up when response is received via request_id
* fix for nested service responses - use ros_loader and message_conversion for populating an according instance
* use message_conversion in handle_servie_request
* snapshot for branch to show to genpy devs
* using float64 instead of std_msgs/Float64 lets scripts run fine.. ; next: fix with using std_msgs/Float64 --> need nested data field
* nested srv uses now message_conversion.extract_values
* adapted test scripted to ros_loader; (removed .srv from module_name
* use rosloader for finding service_class
* fixed calculation of fragment_count
* cleanup: files, notes, some code
* added message_field <message_intervall> to allow client to control delay between messages from rosbridge
* added TODO: check if service successfully registered in ros
* ..
* ..
* added description of new opcodes
* tests, comments, description, ..
* tested rosbridge_websocket with new capabilities; websocket test scripts not working yet..; but new caps are working when using rosbridge_websocket and tcp2ws wrapper --> so only testscripts need to be fixed for websockets.
* updated websocket test service server and client script to use websocket
* updated websocket test service server script to use websocket
* added files to test new caps with websocket server
* feierabend.. morgen weiter mit server & client JSON-decoder, see notes
* fixed parsing of incomplete/multiple JSON in incoming buffer; so clients do not need to use an interval when sending to rosbridge
* only current changes; not yet done..
* code cleanup, not yet finished..; rosbridge logging much cleaner now
* fixed test_server_defragment - recodegit status
* minor
* linuxonandroid
* fixed some parts; ..still better do some redesign for queueing of messages..
* forced tcp_send to use queue and use delay between sends
* blocking behavior for service requests to non-ros; test-scripts use get-ip4 helper function; ..needs a lot cleanup before next steps..
* need to implement server side blocking of multiple requests, to keep implementation of service provider as easy and simple as possible
* not finished
* some changes.. still needs several fixes
* unique request_ids
* fixed deserialization of multiple fragments in incoming-data; was caused by too short delay between socket-sends (<0.2 seconds); maybe only temp. fixed
* added fragment sorting to test-client and test-server
* message_size debugging; TODO: sort list of received fragments! ; make sure receive_buffers are big enough for fragment_size + header..
* minor changes
* testing: service server fragmentsizes receive: 1  send: 1; client fragmentsize receive: 1; is working..
* fixed an error that caused service_response to appear quoted as string once too often; should be ok now
* fragmentation basically working; service_server can request fragmented service_calls, service_client can request fragmented responses; fragmentation can be requested by adding fragmentation_size parameter to any message sent to rosbridge
* some code cleanup
* set service_request_timeout back to 60 seconds; had 2s from timeout_tests..
* fixed example: non-ros_service_server.py to use only 1 socket; commented and structured code and comments in test-scripts
* some minor changes: comments, debug-output, ..
* added test script for non-ros_service_client calling service from non-ros_service_server
* added msg and srv files
* fixed (removed) dependency to beginner_tutorials for service_server test-scripts. beginner_tutorials package not needed anymore.
* behaviour on advertising existing service: replace service-provider, similar to ROS-groovy behaviour, see issues..
* behaviour on advertising existing service: replace service-provider, similar to ROS-groovy behaviour, see issues..
* removed obsolete test-scripts
* stop service added
* first working classes: service_server
* should use its own branch: service_server.py;  add initial thoughts and code-base for developing ServiceServer capability
* fixed errors in protocol.py and defragmentation.py
* added test-scripts for defragmentation AND tcp-server
* change json imports to try to use ujson or simplejson
* change json imports to try to use ujson or simplejson; correct log_message to show length of content/data instead of overall length
* fixed variable name in finish()
* Clean up of defragmentation.py.
* add defragmentation capability
* merge with fuerte-devel
* add defragmentation capability
* commented out that problematic unregister line
* Contributors: Brandon Alexander, Jihoon Lee, Julian Cerruti, Kaijen Hsiao, Stefan Profanter, dave, furushchev, fxm-db, ipa-fxm, root, unknown

0.5.1 (2013-10-31)
------------------
* Implement multiple subscriptions to latched topics (fixes `#1 <https://github.com/RobotWebTools/rosbridge_suite/issues/1>`_).
* generate more natural json for service call result
* add result field to service response
* Contributors: Siegfried-A. Gevatter Pujals, Takashi Ogura

0.5.0 (2013-07-17)
------------------
* 0.5.0 preparation for hydro release
* even more missing depends for unit tests
* more missing test packages
* missing depends added when running tests
* rostest now uses devel instead of install
* rostest added to package
* Contributors: Jihoon Lee, Russell Toris

0.4.4 (2013-04-08)
------------------

0.4.3 (2013-04-03 08:24)
------------------------

0.4.2 (2013-04-03 08:12)
------------------------
* eclipse projects removed
* Contributors: Russell Toris

0.4.1 (2013-03-07)
------------------
* adding message generation build dependency
* Contributors: Jihoon Lee

0.4.0 (2013-03-05)
------------------
* removing rostest
* Commenting out rostest
* Update rosbridge_library/package.xml
  removed <test_depend>rospy</test_depend>
* Fixes "'int' is not iterable" bug.
* Adds test_all.test launch file.
* Error fix from wrong package name.
* Moves test package tests into rosbridge_library.
  I learned about NOINSTALL for msg and srv generation in CMakeList.
* Resolves submodule issues.
* Uses only 1 .gitignore to avoid confusion.
* Merge pull request `#15 <https://github.com/RobotWebTools/rosbridge_suite/issues/15>`_ from baalexander/remove_unregister
  Removes buggy unregister call.
* Removes buggy unregister call.
  Fixes Issue `#12 <https://github.com/RobotWebTools/rosbridge_suite/issues/12>`_.
* Adds BSD license header to code files.
  See Issue `#13 <https://github.com/RobotWebTools/rosbridge_suite/issues/13>`_.
* Removing ultrajson from rosbridge.
  If JSON parsing becomes a performance bottle neck, we can re-add it.
* Catkinizing rosbridge_library and server.
* PNG compression now creates a square RGB image padded with new-line characters
* Add stack dependencies and rosdeps.
* Collapse directory structure.
* Moved the packages inside a folder called rosbridge
* Initial commit of rosbridge_library
* Contributors: Austin Hendrix, Brandon Alexander, David Gossow, Jihoon Lee, Jonathan Mace, Russell Toris



================================================
FILE: rosbridge_library/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosbridge_library)

find_package(ament_cmake_ros REQUIRED)
find_package(ament_cmake_python REQUIRED)

ament_python_install_package(
  ${PROJECT_NAME} PACKAGE_DIR "src/${PROJECT_NAME}")

ament_package()

if (BUILD_TESTING)
  ament_add_ros_isolated_pytest_test(test_capabilities "test/capabilities/")
  ament_add_ros_isolated_pytest_test(test_internal "test/internal/")

  find_package(ament_cmake_mypy REQUIRED)
  ament_mypy()
endif()



================================================
FILE: rosbridge_library/package.xml
================================================
<?xml version="1.0"?>
<package format="3">
  <name>rosbridge_library</name>
  <version>2.3.0</version>
  <description>
The core rosbridge package, responsible for interpreting JSON and performing the appropriate
ROS action, like subscribe, publish, call service, and interact with params.
  </description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosbridge_library</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake_ros</buildtool_depend>
  <buildtool_depend>ament_cmake_python</buildtool_depend>

  <exec_depend>python3-bson</exec_depend>
  <exec_depend>python3-numpy</exec_depend>
  <exec_depend>python3-pil</exec_depend>
  <exec_depend>python3-ujson</exec_depend>
  <exec_depend>rcl_interfaces</exec_depend>
  <exec_depend>rclpy</exec_depend>

  <test_depend>action_msgs</test_depend>
  <test_depend>ament_cmake_mypy</test_depend>
  <test_depend>builtin_interfaces</test_depend>
  <test_depend>control_msgs</test_depend>
  <test_depend>diagnostic_msgs</test_depend>
  <test_depend>example_interfaces</test_depend>
  <test_depend>geometry_msgs</test_depend>
  <test_depend>nav_msgs</test_depend>
  <test_depend>rosbridge_test_msgs</test_depend>
  <test_depend>sensor_msgs</test_depend>
  <test_depend>std_msgs</test_depend>
  <test_depend>std_srvs</test_depend>
  <test_depend>stereo_msgs</test_depend>
  <test_depend>tf2_msgs</test_depend>
  <test_depend>trajectory_msgs</test_depend>
  <test_depend>visualization_msgs</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosbridge_library/doc/conf.py
================================================
autodoc_mock_imports = ["action_msgs", "PIL"]



================================================
FILE: rosbridge_library/src/rosbridge_library/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/src/rosbridge_library/capability.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)


class Capability:
    """
    Handles the operation-specific logic of a rosbridge message.

    May define one or more opcodes to handle, for example 'publish' or
    'call_service'

    Each connected client receives its own capability instance, which are
    managed by the client's own protocol instance.

    Protocol.send() is available to send messages back to the client.
    """

    def __init__(self, protocol):
        """
        Abstract class constructor.

        All capabilities require a handle to the containing protocol.

        :param protocol: The protocol instance for this capability instance
        """
        self.protocol = protocol

    def handle_message(self, message):
        """
        Handle an incoming message.

        Called by the protocol after having already checked the message op code.

        :param message: The incoming message, deserialized into a dictionary
        """

    def finish(self):
        """
        Notify this capability that the client is finished.

        Tells the capability that it's time to free up resources.
        """

    def basic_type_check(self, msg, types_info):
        """
        Perform basic typechecking on fields in msg.

        :param msg: A message, deserialized into a dictionary
        :param types_info: A list of tuples (mandatory, fieldname, fieldtype) where

            - mandatory - boolean, is the field mandatory
            - fieldname - the name of the field in the message
            - fieldtypes - the expected python type of the field or list of types

        :raises MissingArgumentException: If a field is mandatory but not present in the message
        :raises InvalidArgumentException: If a field is present but not of the type specified by
            fieldtype
        """
        for mandatory, fieldname, fieldtypes in types_info:
            if mandatory and fieldname not in msg:
                msg = f"Expected a {fieldname} field but none was found."
                raise MissingArgumentException(msg)
            if fieldname in msg:
                current_fieldtypes = fieldtypes
                if not isinstance(current_fieldtypes, tuple):
                    current_fieldtypes = (current_fieldtypes,)
                valid = False
                for typ in current_fieldtypes:
                    if isinstance(msg[fieldname], typ):
                        valid = True
                if not valid:
                    msg = (
                        f"Expected field {fieldname} to be one of {current_fieldtypes}. "
                        f"Invalid value: {msg[fieldname]}"
                    )
                    raise InvalidArgumentException(msg)



================================================
FILE: rosbridge_library/src/rosbridge_library/protocol.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import time
from typing import Any

from rosbridge_library.capabilities.fragmentation import Fragmentation
from rosbridge_library.util import bson, json


def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False


def has_binary(obj):
    """Return True if obj is a binary or contains a binary attribute."""
    if isinstance(obj, list):
        return any(has_binary(item) for item in obj)

    if isinstance(obj, dict):
        return any(has_binary(obj[item]) for item in obj)

    return isinstance(obj, bson.binary.Binary)


class Protocol:
    """
    The interface for a single client to interact with ROS.

    See rosbridge_protocol for the default protocol used by rosbridge

    The lifecycle for a Protocol instance is as follows:
    - Pass incoming messages from the client to incoming
    - Propagate outgoing messages to the client by overriding outgoing
    - Call finish to clean up resources when the client is finished
    """

    # fragment_size can be set per client (each client has its own instance of protocol)
    # ..same for other parameters
    fragment_size = None
    png = None
    # buffer used to gather partial JSON-objects (could be caused by small tcp-buffers or similar..)
    buffer = ""
    old_buffer = ""
    busy = False
    # if this is too low, ("simple")clients network stacks will get flooded (when sending fragments of a huge message..)
    # .. depends on message_size/bandwidth/performance/client_limits/...
    # !! this might be related to (or even be avoided by using) throttle_rate !!
    delay_between_messages = 0
    # global list of non-ros advertised services
    external_service_list: dict[str, Any]
    # global list of non-ros advertised actions
    external_action_list: dict[str, Any]
    # Use only BSON for the whole communication if the server has been started with bson_only_mode:=True
    bson_only_mode = False

    parameters = None

    def __init__(self, client_id, node_handle):
        """
        Initialize the protocol with a client ID and a ROS2 node handle.

        :param client_id: A unique ID for this client to take. Uniqueness is important, otherwise
            there will be conflicts between multiple clients with shared resources
        :param node_handle: A ROS2 node handle
        """
        self.client_id = client_id
        self.capabilities = []
        self.operations = {}
        self.node_handle = node_handle
        self.external_service_list = {}
        self.external_action_list = {}

        if self.parameters:
            self.fragment_size = self.parameters["max_message_size"]
            self.delay_between_messages = self.parameters["delay_between_messages"]
            self.bson_only_mode = self.parameters.get("bson_only_mode", False)

    # added default message_string="" to allow recalling incoming until buffer is empty without giving a parameter
    # --> allows to get rid of (..or minimize) delay between client-side sends
    def incoming(self, message_string=""):
        """
        Process an incoming message from the client.

        :param message_string: The wire-level message sent by the client
        """
        if len(self.buffer) > 0:
            self.buffer = self.buffer + message_string
        else:
            self.buffer = message_string
        msg = None

        # take care of having multiple JSON-objects in receiving buffer
        # ..first, try to load the whole buffer as a JSON-object
        try:
            msg = self.deserialize(self.buffer)
            self.buffer = ""

        # if loading the whole object fails, try to load a part of it
        # (from first opening bracket "{" to next closing bracket "}")
        # .. this causes Exceptions on "inner" closing brackets --> so I suppressed logging of deserialization errors
        except Exception:
            if self.bson_only_mode:
                # Since BSON should be used in conjunction with a network handler that receives exactly one full BSON
                # message. This will then be passed to self.deserialize and shouldn't cause any exceptions because of
                # fragmented messages (broken or invalid messages might still be sent tough)
                self.log("error", "Exception in deserialization of BSON")

            else:
                # TODO: handling of partial/multiple/broken json data in incoming buffer
                # This way is problematic when json contains nested json-objects
                # ( e.g. { ... { "config": [0,1,2,3] } ...  } )
                # If outer json is not fully received, stepping through opening brackets will find { "config" : ... }
                # as a valid json object and pass this "inner" object to rosbridge and throw away the leading part of
                # the "outer" object. Solution for now: check for "op"-field. I can still imagine cases where a nested
                # message (e.g. complete service_response fits into the data field of a fragment..) would cause trouble,
                # but if a response fits as a whole into a fragment, simply do not pack it into a fragment.
                #
                # --> from that follows current limitation:
                #     fragment data must NOT (!) contain a complete json-object that has an "op-field"
                #
                # An alternative solution would be to only check from first opening bracket and have a time out on data
                # in input buffer (to handle broken data)
                opening_brackets = [i for i, letter in enumerate(self.buffer) if letter == "{"]
                closing_brackets = [i for i, letter in enumerate(self.buffer) if letter == "}"]

                for start in opening_brackets:
                    for end in closing_brackets:
                        try:
                            msg = self.deserialize(self.buffer[start : end + 1])
                            if msg.get("op", None) is not None:
                                # TODO: check if throwing away leading data like this is okay.. loops look okay..
                                self.buffer = self.buffer[end + 1 : len(self.buffer)]
                                # jump out of inner loop if json-decode succeeded
                                break
                        except Exception:
                            # debug json-decode errors with this line
                            # print e
                            pass
                    # if load was successful break outer loop, too.
                    # No need to check if json begins at a "later" opening bracket.
                    if msg is not None:
                        break

        # if decoding of buffer failed .. simply return
        if msg is None:
            return

        # process fields JSON-message object that "control" rosbridge
        mid = None
        if "id" in msg:
            mid = msg["id"]
        if "op" not in msg:
            if "receiver" in msg:
                self.log(
                    "error",
                    "Received a rosbridge v1.0 message. "
                    "Please refer to rosbridge.org for the correct format of rosbridge v2.0 messages. "
                    f"Original message was: {message_string}",
                )
            else:
                self.log(
                    "error",
                    "Received a message without an op. "
                    f"All messages require 'op' field with value one of: {list(self.operations.keys())}. "
                    "Original message was: {message_string}",
                    mid,
                )
            return
        op = msg["op"]
        if op not in self.operations:
            self.log(
                "error",
                f"Unknown operation: {op}.  Allowed operations: {list(self.operations.keys())}",
                mid,
            )
            return
        # This way, a client can change/overwrite its active values anytime by just including parameter field in any
        # message sent to rosbridge. Maybe need to be improved to bind parameter values to specific operation.
        if "fragment_size" in msg:
            self.fragment_size = msg["fragment_size"]
            # print "fragment size set to:", self.fragment_size
        if "message_intervall" in msg and is_number(msg["message_intervall"]):
            self.delay_between_messages = msg["message_intervall"]
        if "png" in msg:
            self.png = msg["msg"]

        # now try to pass message to according operation
        try:
            self.operations[op](msg)
        except Exception as exc:
            self.log("error", f"{op}: {exc!s}", mid)

        # if anything left in buffer, re-call self.incoming
        # TODO: check what happens if we have "garbage" on tcp-stack. Infinite loop might be triggered! Might get out of
        # it when next valid JSON arrives since only data after last 'valid' closing bracket is kept.
        if len(self.buffer) > 0 and self.old_buffer != self.buffer:
            # try to avoid infinite loop..
            self.old_buffer = self.buffer
            self.incoming()

    def outgoing(self, message, compression="none"):
        """
        Pass an outgoing message to the client.

        This method should be overridden.

        :param message: The wire-level message to send to the client
        """

    def send(self, message, cid=None, compression="none"):
        """
        Prepare a message for sending to the client.

        Called internally in preparation for sending messages to the client.

        This method pre-processes the message then passes it to the overridden
        outgoing method.

        :param message: A dict of message values to be marshalled and sent
        :param cid: (optional) An associated id
        """
        serialized = (
            message if compression in ["cbor", "cbor-raw"] else self.serialize(message, cid)
        )
        if serialized is not None:
            if self.png == "png":
                # TODO: png compression on outgoing messages
                # encode message
                pass

            fragment_list = None
            if self.fragment_size is not None and len(serialized) > self.fragment_size:
                mid = message.get("id", None)

                # TODO: think about splitting into fragments that have specified size including header-fields!
                # --> estimate header size --> split content into fragments that have the requested overall size,
                # rather than requested content size
                fragment_list = Fragmentation(self).fragment(message, self.fragment_size, mid)

            # fragment list not empty -> send fragments
            if fragment_list is not None:
                for fragment in fragment_list:
                    if self.bson_only_mode:
                        self.outgoing(bson.BSON.encode(fragment), compression)
                    else:
                        self.outgoing(json.dumps(fragment), compression)
                    # okay to use delay here (sender's send()-function) because rosbridge is sending next request only
                    # to service provider when last one had finished. If this was not the case, this delay would need to
                    # be implemented in service-provider's (meaning message receiver's) send_message()-function in
                    # rosbridge_tcp.py)
                    time.sleep(self.delay_between_messages)
            # else send message as it is
            else:
                self.outgoing(serialized, compression)
                time.sleep(self.delay_between_messages)

    def finish(self):
        """
        Indicate that the client is finished and clean up resources.

        All clients should call this method after disconnecting.
        """
        for capability in self.capabilities:
            capability.finish()

    def serialize(self, msg, cid=None):  # noqa: ARG002
        """
        Turn a dictionary of values into the appropriate wire-level representation.

        Default behaviour uses JSON. Override to use a different container.

        :param msg: The dictionary of values to serialize
        :param cid: (optional) An ID associated with this. Will be logged on err.

        :return: a JSON string representing the dictionary
        """
        try:
            if isinstance(msg, bytearray):
                return msg
            if has_binary(msg) or self.bson_only_mode:
                return bson.BSON.encode(msg)
            return json.dumps(msg)
        except Exception as e:
            self.log("error", f"Unable to serialize message '{msg}': {e}")
            return None

    def deserialize(self, msg, cid=None):  # noqa: ARG002
        """
        Turn the wire-level representation into a dictionary of values.

        Default behaviour assumes JSON. Override to use a different container.

        :param msg: The wire-level message to deserialize
        :param cid: (optional) An ID associated with this. Is logged on error

        :return: a dictionary of values
        """
        try:
            if self.bson_only_mode:
                bson_message = bson.BSON(msg)
                return bson_message.decode()
            return json.loads(msg)
        except Exception:
            # if we did try to deserialize the whole buffer, first try to let self.incoming check for multiple/partial
            # json-decodes before logging error. This means, if buffer is not == msg --> we tried to decode part of
            # the buffer.

            # TODO: implement a way to have a final Exception when nothing works out to decode
            # (multiple/broken/partial JSON..)

            # suppressed logging of exception on json-decode to keep rosbridge-logs "clean",
            # otherwise console logs would get spammed for every failed json-decode try
            #            if msg != self.buffer:
            #                error_msg = "Unable to deserialize message from client: %s"  % msg
            #                error_msg += "\nException was: " +str(e)
            #
            #                self.log("error", error_msg, cid)

            # re-raise Exception to allow handling outside of deserialize function instead of returning None
            raise
            # return None

    def register_operation(self, opcode, handler):
        """
        Register a handler for an opcode.

        :param opcode: The opcode to register this handler for
        :param handler: A callback function to call for messages with this opcode
        """
        self.operations[opcode] = handler

    def unregister_operation(self, opcode):
        """
        Unregister a handler for an opcode.

        :param opcode: The opcode to unregister the handler for
        """
        if opcode in self.operations:
            del self.operations[opcode]

    def add_capability(self, capability_class):
        """
        Add a capability to the protocol.

        This method is for convenience; assumes the default capability constructor.

        :param capability_class: The class of the capability to add
        """
        self.capabilities.append(capability_class(self))

    def log(self, level, message, lid=None):
        """
        Log a message to the client.

        By default just sends the message to the node logger.

        :param level: The logger level of this message
        :param message: The string message to send to the user
        :param lid: An associated for this log message
        """
        stdout_formatted_msg = None
        stdout_formatted_msg = (
            f"[Client {self.client_id}] [id: {lid}] {message}"
            if lid is not None
            else f"[Client {self.client_id}] {message}"
        )

        if level in {"error", "err"}:
            self.node_handle.get_logger().error(stdout_formatted_msg)
        elif level in {"warning", "warn"}:
            self.node_handle.get_logger().warning(stdout_formatted_msg)
        elif level in {"info", "information"}:
            self.node_handle.get_logger().info(stdout_formatted_msg)
        else:
            self.node_handle.get_logger().debug(stdout_formatted_msg)



================================================
FILE: rosbridge_library/src/rosbridge_library/rosbridge_protocol.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from rosbridge_library.capabilities.action_feedback import ActionFeedback
from rosbridge_library.capabilities.action_result import ActionResult
from rosbridge_library.capabilities.advertise import Advertise
from rosbridge_library.capabilities.advertise_action import AdvertiseAction
from rosbridge_library.capabilities.advertise_service import AdvertiseService
from rosbridge_library.capabilities.call_service import CallService
from rosbridge_library.capabilities.defragmentation import Defragment
from rosbridge_library.capabilities.publish import Publish
from rosbridge_library.capabilities.send_action_goal import SendActionGoal
from rosbridge_library.capabilities.service_response import ServiceResponse
from rosbridge_library.capabilities.subscribe import Subscribe
from rosbridge_library.capabilities.unadvertise_action import UnadvertiseAction
from rosbridge_library.capabilities.unadvertise_service import UnadvertiseService
from rosbridge_library.protocol import Protocol


class RosbridgeProtocol(Protocol):
    """Adds the handlers for the rosbridge opcodes."""

    rosbridge_capabilities = (
        Advertise,
        Publish,
        Subscribe,
        Defragment,
        AdvertiseService,
        CallService,
        ServiceResponse,
        UnadvertiseService,
        AdvertiseAction,
        ActionFeedback,
        ActionResult,
        SendActionGoal,
        UnadvertiseAction,
    )

    print("registered capabilities (classes):")
    for cap in rosbridge_capabilities:
        print(" -", str(cap))

    parameters = None

    def __init__(self, client_id, node_handle, parameters=None):
        self.parameters = parameters
        Protocol.__init__(self, client_id, node_handle)
        for capability_class in self.rosbridge_capabilities:
            self.add_capability(capability_class)



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/action_feedback.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from rosbridge_library.capability import Capability
from rosbridge_library.internal import message_conversion, ros_loader
from rosbridge_library.protocol import Protocol


class ActionFeedback(Capability):
    action_feedback_msg_fields = (
        (True, "action", str),
        (False, "id", str),
        (False, "values", dict),
    )

    def __init__(self, protocol: Protocol) -> None:
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("action_feedback", self.action_feedback)

    def action_feedback(self, message: dict) -> None:
        # Typecheck the args
        self.basic_type_check(message, self.action_feedback_msg_fields)

        # check for the action
        action_name = message["action"]
        if action_name in self.protocol.external_action_list:
            action_handler = self.protocol.external_action_list[action_name]
            # parse the message
            goal_id = message["id"]
            values = message["values"]
            # create a message instance
            feedback = ros_loader.get_action_feedback_instance(action_handler.action_type)
            message_conversion.populate_instance(values, feedback)
            # pass along the feedback
            action_handler.handle_feedback(goal_id, feedback)
        else:
            self.protocol.log(
                "error",
                f"Action {action_name} has not been advertised via rosbridge.",
            )



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/action_result.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from rosbridge_library.capability import Capability
from rosbridge_library.internal import message_conversion, ros_loader
from rosbridge_library.protocol import Protocol


class ActionResult(Capability):
    action_result_msg_fields = (
        (True, "action", str),
        (False, "id", str),
        (False, "values", dict),
        (True, "status", int),
        (True, "result", bool),
    )

    def __init__(self, protocol: Protocol) -> None:
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("action_result", self.action_result)

    def action_result(self, message: dict) -> None:
        # Typecheck the args
        self.basic_type_check(message, self.action_result_msg_fields)

        # check for the action
        action_name = message["action"]
        if action_name in self.protocol.external_action_list:
            action_handler = self.protocol.external_action_list[action_name]
            goal_id = message["id"]
            if message["result"]:
                # parse the message
                values = message["values"]
                status = message["status"]
                # create a message instance
                result = ros_loader.get_action_result_instance(action_handler.action_type)
                message_conversion.populate_instance(values, result)
                # pass along the result and status
                action_handler.handle_result(goal_id, result, status)
            else:
                # Abort the goal
                action_handler.handle_abort(goal_id)
        else:
            self.protocol.log(
                "error",
                f"Action {action_name} has not been advertised via rosbridge.",
            )



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/advertise.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# Copyright (c) 2014, Creativa 77 SRL
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch

from rosbridge_library.capability import Capability
from rosbridge_library.internal.publishers import manager


class Registration:
    """
    Keeps track of how many times a client has requested to advertise a publisher.

    A client could advertise and unadvertise a topic multiple times, and we
    must make sure that the underlying publisher is only created and destroyed
    at the appropriate moments
    """

    def __init__(self, client_id, topic, node_handle):
        # Initialise variables
        self.client_id = client_id
        self.topic = topic
        self.clients = {}
        self.node_handle = node_handle

    def unregister(self):
        manager.unregister(self.client_id, self.topic)

    def register_advertisement(self, msg_type, adv_id=None, latch=False, queue_size=100):
        # Register with the publisher manager, propagating any exception
        manager.register(
            self.client_id,
            self.topic,
            self.node_handle,
            msg_type=msg_type,
            latch=latch,
            queue_size=queue_size,
        )

        self.clients[adv_id] = True

    def unregister_advertisement(self, adv_id=None):
        if adv_id is None:
            self.clients.clear()
        elif adv_id in self.clients:
            del self.clients[adv_id]

    def is_empty(self):
        return len(self.clients) == 0


class Advertise(Capability):
    advertise_msg_fields = ((True, "topic", str), (True, "type", str))
    unadvertise_msg_fields = ((True, "topic", str),)

    topics_glob = None

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("advertise", self.advertise)
        protocol.register_operation("unadvertise", self.unadvertise)

        # Initialize class variables
        self._registrations = {}

        if protocol.parameters and "unregister_timeout" in protocol.parameters:
            manager.unregister_timeout = protocol.parameters.get("unregister_timeout")

    def advertise(self, message):
        # Pull out the ID
        aid = message.get("id", None)

        self.basic_type_check(message, self.advertise_msg_fields)
        topic = message["topic"]
        msg_type = message["type"]
        latch = message.get("latch", False)
        queue_size = message.get("queue_size", 100)

        if Advertise.topics_glob is not None and Advertise.topics_glob:
            self.protocol.log("debug", "Topic security glob enabled, checking topic: " + topic)
            match = False
            for glob in Advertise.topics_glob:
                if fnmatch.fnmatch(topic, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing advertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for topic, cancelling advertisement of: " + topic,
                )
                return
        else:
            self.protocol.log("debug", "No topic security glob, not checking advertisement.")

        # Create the Registration if one doesn't yet exist
        if topic not in self._registrations:
            client_id = self.protocol.client_id
            self._registrations[topic] = Registration(client_id, topic, self.protocol.node_handle)

        # Register, propagating any exceptions
        self._registrations[topic].register_advertisement(msg_type, aid, latch, queue_size)

    def unadvertise(self, message):
        # Pull out the ID
        aid = message.get("id", None)

        self.basic_type_check(message, self.unadvertise_msg_fields)
        topic = message["topic"]

        if Advertise.topics_glob is not None and Advertise.topics_glob:
            self.protocol.log("debug", "Topic security glob enabled, checking topic: " + topic)
            match = False
            for glob in Advertise.topics_glob:
                if fnmatch.fnmatch(topic, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing unadvertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for topic, cancelling unadvertisement of: " + topic,
                )
                return
        else:
            self.protocol.log("debug", "No topic security glob, not checking unadvertisement.")

        # Now unadvertise the topic
        if topic not in self._registrations:
            return
        self._registrations[topic].unregister_advertisement(aid)

        # Check if the registration is now finished with
        if self._registrations[topic].is_empty():
            self._registrations[topic].unregister()
            del self._registrations[topic]

    def finish(self):
        for registration in self._registrations.values():
            registration.unregister()
        self._registrations.clear()
        self.protocol.unregister_operation("advertise")
        self.protocol.unregister_operation("unadvertise")



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/advertise_action.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch
from typing import Any

from action_msgs.msg import GoalStatus
from rclpy.action import ActionServer
from rclpy.action.server import CancelResponse, ServerGoalHandle
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.task import Future

from rosbridge_library.capability import Capability
from rosbridge_library.internal import message_conversion
from rosbridge_library.internal.ros_loader import get_action_class
from rosbridge_library.protocol import Protocol


class AdvertisedActionHandler:
    id_counter = 1

    def __init__(
        self, action_name: str, action_type: str, protocol: Protocol, sleep_time: float = 0.001
    ) -> None:
        self.goal_futures: dict[str, Future] = {}
        self.goal_handles: dict[str, Any] = {}
        self.goal_statuses: dict[str, GoalStatus] = {}

        self.action_name = action_name
        self.action_type = action_type
        self.protocol = protocol
        self.sleep_time = sleep_time
        # setup the action
        self.action_server = ActionServer(
            protocol.node_handle,
            get_action_class(action_type),
            action_name,
            self.execute_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup(),  # https://github.com/ros2/rclpy/issues/834#issuecomment-961331870
        )

    def next_id(self) -> int:
        next_id_value = self.id_counter
        self.id_counter += 1
        return next_id_value

    async def execute_callback(self, goal: Any) -> Any:
        """
        Execute action goal.

        ActionServer callback for executing an action goal.
        """
        # generate a unique ID
        goal_id = f"action_goal:{self.action_name}:{self.next_id()}"

        def done_callback(fut: Future) -> None:
            if fut.cancelled():
                goal.abort()
                self.protocol.log("info", f"Aborted goal {goal_id}")
                # Send an empty result to avoid stack traces
                fut.set_result(get_action_class(self.action_type).Result())
            else:
                if goal_id not in self.goal_statuses:
                    goal.abort()
                    return

                status = self.goal_statuses[goal_id]
                if status == GoalStatus.STATUS_SUCCEEDED:
                    goal.succeed()
                elif status == GoalStatus.STATUS_CANCELED:
                    goal.canceled()
                else:
                    goal.abort()

        future: Future = Future()
        future.add_done_callback(done_callback)
        self.goal_handles[goal_id] = goal
        self.goal_futures[goal_id] = future

        # build a request to send to the external client
        goal_message = {
            "op": "send_action_goal",
            "id": goal_id,
            "action": self.action_name,
            "action_type": self.action_type,
            "args": message_conversion.extract_values(goal.request),
            "feedback": True,
        }
        self.protocol.send(goal_message)

        try:
            return await future
        finally:
            del self.goal_futures[goal_id]
            del self.goal_handles[goal_id]

    def cancel_callback(self, cancel_request: ServerGoalHandle) -> CancelResponse:
        """
        Cancel action goal.

        ActionServer callback for canceling an action goal.
        """
        for goal_id, goal_handle in self.goal_handles.items():
            if cancel_request.goal_id == goal_handle.goal_id:
                self.protocol.log("warning", f"Canceling action {goal_id}")
                cancel_message = {
                    "op": "cancel_action_goal",
                    "id": goal_id,
                    "action": self.action_name,
                }
                self.protocol.send(cancel_message)
        return CancelResponse.ACCEPT

    def handle_feedback(self, goal_id: str, feedback: Any) -> None:
        """
        Handle action feedback.

        Called by the ActionFeedback capability to handle action feedback from the external client.
        """
        if goal_id in self.goal_handles:
            self.goal_handles[goal_id].publish_feedback(feedback)
        else:
            self.protocol.log("warning", f"Received action feedback for unrecognized id: {goal_id}")

    def handle_result(self, goal_id: str, result: dict, status: int) -> None:
        """
        Handle action result.

        Called by the ActionResult capability to handle a successful action result from the external client.
        """
        if goal_id in self.goal_futures:
            self.goal_statuses[goal_id] = status
            self.goal_futures[goal_id].set_result(result)
        else:
            self.protocol.log("warning", f"Received action result for unrecognized id: {goal_id}")

    def handle_abort(self, goal_id: str) -> None:
        """
        Handle action abort.

        Called by the ActionResult capability to handle aborting action result from the external client.
        """
        if goal_id in self.goal_futures:
            self.goal_futures[goal_id].cancel()
        else:
            self.protocol.log(
                "warning", f"Received action abort request for unrecognized id: {goal_id}"
            )

    def graceful_shutdown(self) -> None:
        """Signal the AdvertisedActionHandler to shutdown."""
        if self.goal_futures:
            incomplete_ids = ", ".join(self.goal_futures.keys())
            self.protocol.log(
                "warning",
                f"Action {self.action_name} was unadvertised with an action in progress, "
                f"aborting action goals with request IDs {incomplete_ids}",
            )
            for future_id in self.goal_futures:
                future = self.goal_futures[future_id]
                future.set_exception(RuntimeError(f"Action {self.action_name} was unadvertised"))

        # Uncommenting this, you may get a segfault.
        # See https://github.com/ros2/rclcpp/issues/2163#issuecomment-1850925883
        # self.action_server.destroy()


class AdvertiseAction(Capability):
    actions_glob = None

    advertise_action_msg_fields = ((True, "action", str), (True, "type", str))

    def __init__(self, protocol: Protocol) -> None:
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("advertise_action", self.advertise_action)

    def advertise_action(self, message: dict) -> None:
        # Typecheck the args
        self.basic_type_check(message, self.advertise_action_msg_fields)

        # parse the incoming message
        action_name = message["action"]

        if AdvertiseAction.actions_glob is not None and AdvertiseAction.actions_glob:
            self.protocol.log(
                "debug",
                "Action security glob enabled, checking action: " + action_name,
            )
            match = False
            for glob in AdvertiseAction.actions_glob:
                if fnmatch.fnmatch(action_name, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing action advertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for action, cancelling action advertisement for: "
                    + action_name,
                )
                return
        else:
            self.protocol.log(
                "debug", "No action security glob, not checking action advertisement."
            )

        # check for an existing entry
        if action_name in self.protocol.external_action_list:
            self.protocol.log("warn", f"Duplicate action advertised. Overwriting {action_name}.")
            self.protocol.external_action_list[action_name].graceful_shutdown()
            del self.protocol.external_action_list[action_name]

        # setup and store the action information
        action_type = message["type"]
        action_handler = AdvertisedActionHandler(action_name, action_type, self.protocol)
        self.protocol.external_action_list[action_name] = action_handler
        self.protocol.log("info", f"Advertised action {action_name}")



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/advertise_service.py
================================================
import fnmatch

import rclpy
from rclpy.callback_groups import ReentrantCallbackGroup

from rosbridge_library.capability import Capability
from rosbridge_library.internal import message_conversion
from rosbridge_library.internal.ros_loader import get_service_class


class AdvertisedServiceHandler:
    id_counter = 1

    def __init__(self, service_name, service_type, protocol):
        self.request_futures = {}
        self.service_name = service_name
        self.service_type = service_type
        self.protocol = protocol
        # setup the service
        self.service_handle = protocol.node_handle.create_service(
            get_service_class(service_type),
            service_name,
            self.handle_request,
            callback_group=ReentrantCallbackGroup(),  # https://github.com/ros2/rclpy/issues/834#issuecomment-961331870
        )

    def next_id(self):
        next_id_value = self.id_counter
        self.id_counter += 1
        return next_id_value

    async def handle_request(self, req, _res):
        # generate a unique ID
        request_id = f"service_request:{self.service_name}:{self.next_id()}"

        future = rclpy.task.Future()
        self.request_futures[request_id] = future

        # build a request to send to the external client
        request_message = {
            "op": "call_service",
            "id": request_id,
            "service": self.service_name,
            "args": message_conversion.extract_values(req),
        }
        self.protocol.send(request_message)

        try:
            return await future
        finally:
            del self.request_futures[request_id]

    def handle_response(self, request_id, res):
        """
        Handle service response.

        Called by the ServiceResponse capability to handle a service response from the external client.
        """
        if request_id in self.request_futures:
            self.request_futures[request_id].set_result(res)
        else:
            self.protocol.log(
                "warning", f"Received service response for unrecognized id: {request_id}"
            )

    def graceful_shutdown(self):
        """
        Signal the AdvertisedServiceHandler to shutdown.

        Using this, rather than just node_handle.destroy_service, allows us
        time to stop any active service requests, ending their busy wait
        loops.
        """
        if self.request_futures:
            incomplete_ids = ", ".join(self.request_futures.keys())
            self.protocol.log(
                "warning",
                f"Service {self.service_name} was unadvertised with a service call in progress, "
                f"aborting service calls with request IDs {incomplete_ids}",
            )
            for future_id in self.request_futures:
                future = self.request_futures[future_id]
                future.set_exception(RuntimeError(f"Service {self.service_name} was unadvertised"))
        self.service_handle.destroy()


class AdvertiseService(Capability):
    services_glob = None

    advertise_service_msg_fields = ((True, "service", str), (True, "type", str))

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("advertise_service", self.advertise_service)

    def advertise_service(self, message):
        # Typecheck the args
        self.basic_type_check(message, self.advertise_service_msg_fields)

        # parse the incoming message
        service_name = message["service"]

        if AdvertiseService.services_glob is not None and AdvertiseService.services_glob:
            self.protocol.log(
                "debug",
                "Service security glob enabled, checking service: " + service_name,
            )
            match = False
            for glob in AdvertiseService.services_glob:
                if fnmatch.fnmatch(service_name, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing service advertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for service, cancelling service advertisement for: "
                    + service_name,
                )
                return
        else:
            self.protocol.log(
                "debug", "No service security glob, not checking service advertisement."
            )

        # check for an existing entry
        if service_name in self.protocol.external_service_list:
            self.protocol.log("warn", f"Duplicate service advertised. Overwriting {service_name}.")
            self.protocol.external_service_list[service_name].graceful_shutdown()
            del self.protocol.external_service_list[service_name]

        # setup and store the service information
        service_type = message["type"]
        service_handler = AdvertisedServiceHandler(service_name, service_type, self.protocol)
        self.protocol.external_service_list[service_name] = service_handler
        self.protocol.log("info", f"Advertised service {service_name}")



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/call_service.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch
from functools import partial
from threading import Thread

from rosbridge_library.capability import Capability
from rosbridge_library.internal.services import ServiceCaller


class CallService(Capability):
    call_service_msg_fields = (
        (True, "service", str),
        (False, "fragment_size", (int, type(None))),
        (False, "compression", str),
    )

    services_glob = None

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        self.default_timeout = (
            protocol.node_handle.get_parameter("default_call_service_timeout")
            .get_parameter_value()
            .double_value
        )

        # Register the operations that this capability provides
        call_services_in_new_thread = (
            protocol.node_handle.get_parameter("call_services_in_new_thread")
            .get_parameter_value()
            .bool_value
        )
        if call_services_in_new_thread:
            # Calls the service in a separate thread so multiple services can be processed simultaneously.
            protocol.node_handle.get_logger().info("Calling services in new thread")
            protocol.register_operation(
                "call_service", lambda msg: Thread(target=self.call_service, args=(msg,)).start()
            )
        else:
            # Calls the service in this thread, so services block and must be processed sequentially.
            protocol.node_handle.get_logger().info("Calling services in existing thread")
            protocol.register_operation("call_service", self.call_service)

    def call_service(self, message):
        # Pull out the ID
        cid = message.get("id", None)

        # Typecheck the args
        self.basic_type_check(message, self.call_service_msg_fields)

        # Extract the args
        service = message["service"]
        fragment_size = message.get("fragment_size", None)
        compression = message.get("compression", "none")
        args = message.get("args", [])
        timeout = message.get("timeout", self.default_timeout)

        if CallService.services_glob is not None and CallService.services_glob:
            self.protocol.log(
                "debug", "Service security glob enabled, checking service: " + service
            )
            match = False
            for glob in CallService.services_glob:
                if fnmatch.fnmatch(service, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing service call...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for service, cancelling service call for: " + service,
                )
                return
        else:
            self.protocol.log("debug", "No service security glob, not checking service call.")

        # Check for deprecated service ID, eg. /rosbridge/topics#33
        cid = extract_id(service, cid)

        # Create the callbacks
        s_cb = partial(self._success, cid, service, fragment_size, compression)
        e_cb = partial(self._failure, cid, service)

        # Run service caller in the same thread.
        ServiceCaller(
            trim_servicename(service),
            args,
            timeout,
            s_cb,
            e_cb,
            self.protocol.node_handle,
        ).run()

    def _success(self, cid, service, _fragment_size, _compression, message):
        outgoing_message = {
            "op": "service_response",
            "service": service,
            "values": message,
            "result": True,
        }
        if cid is not None:
            outgoing_message["id"] = cid
        # TODO: fragmentation, compression
        self.protocol.send(outgoing_message)

    def _failure(self, cid, service, exc):
        self.protocol.log("error", f"call_service {type(exc).__name__}: {exc!s}", cid)
        # send response with result: false
        outgoing_message = {
            "op": "service_response",
            "service": service,
            "values": str(exc),
            "result": False,
        }
        if cid is not None:
            outgoing_message["id"] = cid
        self.protocol.send(outgoing_message)


def trim_servicename(service):
    if "#" in service:
        return service[: service.find("#")]
    return service


def extract_id(service, cid):
    if cid is not None:
        return cid
    if "#" in service:
        return service[service.find("#") + 1 :]
    return None



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/defragmentation.py
================================================
import threading
import time

from rosbridge_library.capability import Capability


class ReceivedFragments:
    """Singleton class to hold lists of received fragments in one 'global' object."""

    class __impl:
        """Implementation of the singleton interface."""

        def spam(self):
            """Test method, return singleton id."""
            return id(self)

    __instance = None
    # List of defragmentation instances
    # Format:
    # {
    #   <<message1_ID>> : {
    #     "timestamp_last_append" : <<datetime-object>>,
    #     "total" : <<total_fragments>>,
    #     "fragment_list" : {
    #       <<fragment1ID>>: <<fragment1_data>>,
    #       <<fragment2ID>>: <<fragment2_data>>,
    #       ...
    #     }
    # },
    # ...
    lists: dict[str, dict]

    def __init__(self):
        """Create singleton instance."""
        if ReceivedFragments.__instance is None:
            ReceivedFragments.__instance = ReceivedFragments.__impl()
            self.lists = {}

        self.__dict__["_ReceivedFragments__instance"] = ReceivedFragments.__instance

    def __getattr__(self, attr):
        """Delegate access to implementation."""
        return getattr(self.__instance, attr)

    def __setattr__(self, attr, value):
        """Delegate access to implementation."""
        return setattr(self.__instance, attr, value)


class Defragment(Capability, threading.Thread):
    fragment_timeout = 600
    opcode = "fragment"

    protocol = None

    def __init__(self, protocol):
        Capability.__init__(self, protocol)

        self.protocol = protocol

        # populate parameters
        if self.protocol.parameters is not None:
            self.fragment_timeout = self.protocol.parameters["fragment_timeout"]

        protocol.register_operation(self.opcode, self.defragment)

        self.received_fragments = ReceivedFragments().lists
        threading.Thread.__init__(self)

    # defragment() does:
    #   1) take any incoming message with op-code "fragment"
    #   2) check all existing fragment lists for time out
    #       (could be done by a thread but should be okay this way)
    #   2.a) remove timed out lists (only if new fragment is not for this list)
    #       (checking whenever a new fragment is received should suffice)
    #   3) create a new fragment list for new message ids
    #       (to have control over growth of fragment lists)
    #   3.a) check message fields
    #   3.b) append the new fragment to 'the' list
    #   3.c) add time stamp (last_fragment_appended) to 'this' list
    #   4) check if the list of current fragment (message id) is complete
    #   4.a) reconstruct the original message by concatenating the fragments
    #   4.b) pass the reconstructed message string to protocol.incoming()
    #       (protocol.incoming is checking message fields by itself, so no need to do this before
    #       passing the reconstructed message to protocol)
    #   4.c) remove the fragment list to free up memory
    def defragment(self, message):
        now = time.monotonic()

        if self.received_fragments is not None:
            for frag_id in self.received_fragments:
                time_diff = now - self.received_fragments[frag_id]["timestamp_last_append"]
                if (
                    time_diff > self.fragment_timeout
                    and not self.received_fragments[frag_id]["is_reconstructing"]
                ):
                    log_msg = ["fragment list ", str(frag_id), " timed out.."]

                    if message["id"] != frag_id:
                        log_msg.append(" -> removing it..")
                        del self.received_fragments[frag_id]
                    else:
                        log_msg.extend([" -> but we're just about to add fragment #"])
                        log_msg.extend([str(message.get("num")), " of "])
                        log_msg.extend([str(self.received_fragments[message.get("id")]["total"])])
                        log_msg.extend([" ..keeping the list"])
                    self.protocol.log("warning", "".join(log_msg))

        msg_opcode = message.get("op")
        msg_id = message.get("id")
        msg_num = message.get("num")
        msg_total = message.get("total")
        msg_data = message.get("data")

        # Abort if any message field is missing
        if None in (msg_opcode, msg_id, msg_num, msg_total, msg_data):
            self.protocol.log("error", "received invalid fragment!")
            return

        log_msg = "fragment for messageID: " + str(msg_id) + " received."
        self.protocol.log("debug", log_msg)

        # Create fragment container if none exists yet
        if msg_id not in self.received_fragments:
            self.received_fragments[msg_id] = {
                "is_reconstructing": False,
                "total": message["total"],
                "timestamp_last_append": now,
                "fragment_list": {},
            }
            log_msg = "opened new fragment list for messageID " + str(msg_id)
            self.protocol.log("debug", log_msg)

        # print "received fragments:", len(self.received_fragments[msg_id]["fragment_list"].keys())

        # Add fragment to fragment container's list if not already in list
        if (
            msg_num not in self.received_fragments[msg_id]["fragment_list"]
            and msg_num <= self.received_fragments[msg_id]["total"]
            and msg_total == self.received_fragments[msg_id]["total"]
        ):
            self.received_fragments[msg_id]["fragment_list"][msg_num] = msg_data
            self.received_fragments[msg_id]["timestamp_last_append"] = now
            log_msg = ["appended fragment #" + str(msg_num)]
            log_msg.extend(
                [
                    " (total: ",
                    str(msg_total),
                    ") to fragment list for messageID ",
                    str(msg_id),
                ]
            )
            self.protocol.log("debug", "".join(log_msg))
        else:
            log_msg = "error while trying to append fragment " + str(msg_num)
            self.protocol.log("error", log_msg)
            return

        received_all_fragments = False
        existing_fragments = len(self.received_fragments[msg_id]["fragment_list"])
        announced_total = self.received_fragments[msg_id]["total"]

        # Make sure total number of fragments received
        if existing_fragments == announced_total:
            log_msg = ["enough/all fragments for messageID " + str(msg_id) + " received"]
            log_msg.extend([" [", str(existing_fragments), "]"])
            log_msg = "".join(log_msg)
            self.protocol.log("debug", log_msg)
            # Check each fragment matches up
            received_all_fragments = True
            for i in range(announced_total):
                if i not in self.received_fragments[msg_id]["fragment_list"]:
                    received_all_fragments = False
                    log_msg = "fragment #" + str(i)
                    log_msg += " for messageID " + str(msg_id) + " is missing! "
                    self.protocol.log("error", log_msg)

        self.received_fragments[msg_id]["is_reconstructing"] = received_all_fragments

        if received_all_fragments:
            log_msg = "reconstructing original message " + str(msg_id)
            self.protocol.log("debug", log_msg)

            # Reconstruct the message
            reconstructed_msg = "".join(self.received_fragments[msg_id]["fragment_list"].values())

            log_msg = ["reconstructed original message:\n"]
            log_msg.append(reconstructed_msg)
            log_msg = "".join(log_msg)
            self.protocol.log("debug", log_msg)

            duration = time.monotonic() - now

            # Pass the reconstructed message to rosbridge
            self.protocol.incoming(reconstructed_msg)
            log_msg = ["reconstructed message (ID:" + str(msg_id) + ") from "]
            log_msg.extend([str(msg_total), " fragments. "])
            # cannot access msg.data if message is a service_response or else!
            # log_msg += "[message length: " + str(len(str(json.loads(reconstructed_msg)["msg"]["data"]))) +"]"
            log_msg.extend(["[duration: ", str(duration), " s]"])
            log_msg = "".join(log_msg)
            self.protocol.log("info", log_msg)

            # Remove fragmentation container
            del self.received_fragments[msg_id]
            log_msg = "removed fragment list for messageID " + str(msg_id)
            self.protocol.log("debug", log_msg)

    def finish(self):
        self.received_fragments = None
        self.protocol.unregister_operation("fragment")



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/fragmentation.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import math

from rosbridge_library.capability import Capability


class Fragmentation(Capability):
    """
    A capability to fragment outgoing messages into smaller parts.

    The Fragmentation capability doesn't define any incoming operation
    handlers, but provides methods to fragment outgoing messages.
    """

    fragmentation_seed = 0

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

    def fragment(self, message, fragment_size, mid=None):
        """
        Fragment a message into smaller parts.

        Serializes the provided message, then splits the serialized
        message according to fragment_size, then sends the fragments.

        If the size of the message is less than the fragment size, then
        the original message is returned rather than a single fragment

        Since fragmentation is typically only used for very large messages,
        this method returns a generator for fragments rather than a list

        :param message: the message dict object to be fragmented
        :param fragment_size: the max size for the fragments
        :param mid: (optional) if provided, the fragment messages will be given this id.
            Otherwise an id will be auto-generated.

        :return: A generator of message dict objects representing the fragments
        """
        # All fragmented messages need an ID so they can be reconstructed
        if mid is None:
            mid = self.fragmentation_seed
            self.fragmentation_seed = self.fragmentation_seed + 1

        serialized = self.protocol.serialize(message, mid)

        if serialized is None:
            return []

        message_length = len(serialized)
        if message_length <= fragment_size:
            return [message]

        expected_duration = int(
            math.ceil(math.ceil(message_length / float(fragment_size)))
            * self.protocol.delay_between_messages
        )

        log_msg = (
            "sending "
            + str(math.ceil(message_length / float(fragment_size)))
            + " parts [fragment size: "
            + str(fragment_size)
            + "; expected duration: ~"
            + str(expected_duration)
            + "s]"
        )
        self.protocol.log("info", log_msg)

        return self._fragment_generator(serialized, fragment_size, mid)

    def _fragment_generator(self, msg, size, mid):
        """Return a generator of fragment messages."""
        total = ((len(msg) - 1) / size) + 1
        n = 0
        for i in range(0, len(msg), size):
            fragment = msg[i : i + size]
            yield self._create_fragment(fragment, n, total, mid)
            n = n + 1

    def _create_fragment(self, fragment, num, total, mid):
        """
        Create a fragment message.

        Given a string fragment of the original message, creates
        the appropriate fragment message.
        """
        return {
            "op": "fragment",
            "id": mid,
            "data": fragment,
            "num": num,
            "total": total,
        }



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/publish.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# Copyright (c) 2014, Creativa 77 SRL
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch

from rosbridge_library.capability import Capability
from rosbridge_library.internal.publishers import manager


class Publish(Capability):
    publish_msg_fields = ((True, "topic", str),)

    topics_glob = None

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("publish", self.publish)

        # Save the topics that are published on for the purposes of unregistering
        self._published = {}

        if protocol.parameters and "unregister_timeout" in protocol.parameters:
            manager.unregister_timeout = protocol.parameters.get("unregister_timeout")

    def publish(self, message):
        # Do basic type checking
        self.basic_type_check(message, self.publish_msg_fields)
        topic = message["topic"]
        latch = message.get("latch", False)
        queue_size = message.get("queue_size", 100)

        if Publish.topics_glob is not None and Publish.topics_glob:
            self.protocol.log("debug", "Topic security glob enabled, checking topic: " + topic)
            match = False
            for glob in Publish.topics_glob:
                if fnmatch.fnmatch(topic, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing publish...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn", "No match found for topic, cancelling publish to: " + topic
                )
                return
        else:
            self.protocol.log("debug", "No topic security glob, not checking publish.")

        # Register as a publishing client, propagating any exceptions
        client_id = self.protocol.client_id
        manager.register(
            client_id,
            topic,
            self.protocol.node_handle,
            latch=latch,
            queue_size=queue_size,
        )
        self._published[topic] = True

        # Get the message if one was provided
        msg = message.get("msg", {})

        # Publish the message
        manager.publish(
            client_id,
            topic,
            msg,
            self.protocol.node_handle,
            latch=latch,
            queue_size=queue_size,
        )

    def finish(self):
        client_id = self.protocol.client_id
        for topic in self._published:
            manager.unregister(client_id, topic)
        self._published.clear()



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/send_action_goal.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from __future__ import annotations

import fnmatch
from functools import partial
from threading import Thread
from typing import TYPE_CHECKING, Any

from action_msgs.msg import GoalStatus

from rosbridge_library.capability import Capability
from rosbridge_library.internal.actions import ActionClientHandler
from rosbridge_library.internal.message_conversion import extract_values

if TYPE_CHECKING:
    from rosbridge_library.protocol import Protocol


class SendActionGoal(Capability):
    send_action_goal_msg_fields = (
        (True, "action", str),
        (True, "action_type", str),
        (False, "fragment_size", (int, type(None))),
        (False, "compression", str),
    )
    cancel_action_goal_msg_fields = ((True, "action", str),)

    actions_glob = None
    client_handler_list: dict[str, ActionClientHandler]

    def __init__(self, protocol: Protocol) -> None:
        # Call superclass constructor
        Capability.__init__(self, protocol)

        self.client_handler_list = {}

        # Register the operations that this capability provides
        send_action_goals_in_new_thread = (
            protocol.node_handle.get_parameter("send_action_goals_in_new_thread")
            .get_parameter_value()
            .bool_value
        )
        if send_action_goals_in_new_thread:
            # Sends the action goal in a separate thread so multiple actions can be processed simultaneously.
            protocol.node_handle.get_logger().info("Sending action goals in new thread")
            protocol.register_operation(
                "send_action_goal",
                lambda msg: Thread(target=self.send_action_goal, args=(msg,)).start(),
            )
        else:
            # Sends the actions goal in this thread, so actions block and must be processed sequentially.
            protocol.node_handle.get_logger().info("Sending action goals in existing thread")
            protocol.register_operation("send_action_goal", self.send_action_goal)

        # Always register goal canceling in a new thread.
        protocol.register_operation(
            "cancel_action_goal",
            lambda msg: Thread(target=self.cancel_action_goal, args=(msg,)).start(),
        )

    def send_action_goal(self, message: dict) -> None:
        # Pull out the ID
        cid = message.get("id")

        # Typecheck the args
        self.basic_type_check(message, self.send_action_goal_msg_fields)

        # Extract the args
        action = message["action"]
        action_type = message["action_type"]
        fragment_size = message.get("fragment_size")
        compression = message.get("compression", "none")
        args = message.get("args", [])

        if SendActionGoal.actions_glob is not None and SendActionGoal.actions_glob:
            self.protocol.log("debug", f"Action security glob enabled, checking action: {action}")
            match = False
            for glob in SendActionGoal.actions_glob:
                if fnmatch.fnmatch(action, glob):
                    self.protocol.log(
                        "debug",
                        f"Found match with glob {glob}, continuing sending action goal...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    f"No match found for action, cancelling sending action goal for: {action}",
                )
                return
        else:
            self.protocol.log("debug", "No action security glob, not checking sending action goal.")

        # Check for deprecated action ID, eg. /rosbridge/topics#33
        cid = extract_id(action, cid)

        # Create the callbacks
        s_cb = partial(self._success, cid, action, fragment_size, compression)
        e_cb = partial(self._failure, cid, action)
        f_cb = partial(self._feedback, cid, action) if message.get("feedback", False) else None

        # Run action client handler in the same thread.
        client_handler = ActionClientHandler(
            trim_action_name(action), action_type, args, s_cb, e_cb, f_cb, self.protocol.node_handle
        )

        if cid is not None:
            self.client_handler_list[cid] = client_handler

        client_handler.run()

        if cid is not None:
            del self.client_handler_list[cid]

    def cancel_action_goal(self, message: dict) -> None:
        # Extract the args
        cid = message.get("id")
        action = message["action"]

        # Typecheck the args
        self.basic_type_check(message, self.cancel_action_goal_msg_fields)

        # Pull out the ID
        # Check for deprecated action ID, eg. /rosbridge/topics#33
        cid = extract_id(action, cid)

        # Cancel the action
        if cid in self.client_handler_list:
            client_handler = self.client_handler_list[cid]
            if client_handler.send_goal_helper is not None:
                client_handler.send_goal_helper.cancel_goal()

    def _success(
        self, cid: str | None, action: str, _fragment_size: int, _compression: bool, message: dict
    ) -> None:
        outgoing_message = {
            "op": "action_result",
            "action": action,
            "values": message["result"],
            "status": message["status"],
            "result": True,
        }
        if cid is not None:
            outgoing_message["id"] = cid
        # TODO: fragmentation, compression
        self.protocol.send(outgoing_message)

    def _failure(self, cid: str | None, action: str, exc: Exception) -> None:
        self.protocol.log("error", f"send_action_goal {type(exc).__name__}: {cid}")
        # send response with result: false
        outgoing_message = {
            "op": "action_result",
            "action": action,
            "values": str(exc),
            "status": GoalStatus.STATUS_UNKNOWN,
            "result": False,
        }
        if cid is not None:
            outgoing_message["id"] = cid
        self.protocol.send(outgoing_message)

    def _feedback(self, cid: str | None, action: str, message: Any) -> None:
        outgoing_message = {
            "op": "action_feedback",
            "action": action,
            "values": extract_values(message.feedback),
        }
        if cid is not None:
            outgoing_message["id"] = cid
        # TODO: fragmentation, compression
        self.protocol.send(outgoing_message)


def trim_action_name(action: str) -> str:
    if "#" in action:
        return action[: action.find("#")]
    return action


def extract_id(action: str, cid: str | None) -> str | None:
    if cid is not None:
        return cid
    if "#" in action:
        return action[action.find("#") + 1 :]
    return None



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/service_response.py
================================================
from rosbridge_library.capability import Capability
from rosbridge_library.internal import message_conversion, ros_loader


class ServiceResponse(Capability):
    service_response_msg_fields = (
        (True, "service", str),
        (False, "id", str),
        (False, "values", dict),
        (True, "result", bool),
    )

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("service_response", self.service_response)

    def service_response(self, message):
        # Typecheck the args
        self.basic_type_check(message, self.service_response_msg_fields)

        # check for the service
        service_name = message["service"]
        if service_name in self.protocol.external_service_list:
            service_handler = self.protocol.external_service_list[service_name]
            # parse the message
            request_id = message["id"]
            values = message["values"]
            # create a message instance
            resp = ros_loader.get_service_response_instance(service_handler.service_type)
            message_conversion.populate_instance(values, resp)
            # pass along the response
            service_handler.handle_response(request_id, resp)
        else:
            self.protocol.log(
                "error",
                f"Service {service_name} has not been advertised via rosbridge.",
            )



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/subscribe.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch
from functools import partial
from threading import Lock

from rosbridge_library.capability import Capability
from rosbridge_library.internal.pngcompression import encode as encode_png
from rosbridge_library.internal.subscribers import manager
from rosbridge_library.internal.subscription_modifiers import MessageHandler

try:
    from ujson import dumps as encode_json  # type: ignore[import-untyped]
except ImportError:
    try:
        from simplejson import dumps as encode_json  # type: ignore[import-untyped]
    except ImportError:
        from json import dumps as encode_json


class Subscription:
    """
    Keeps track of the clients multiple calls to subscribe.

    Chooses the most appropriate settings to send messages.
    """

    def __init__(self, client_id, topic, publish, node_handle):
        """
        Create a subscription.

        Create a subscription for the specified client on the specified
        topic, with callback publish.

        :param client_id: The ID of the client making this subscription
        :param topic: The name of the topic to subscribe to
        :param publish: The callback function for incoming messages
        :param node_handle: Handle to a rclpy node to create the publisher.
        """
        self.client_id = client_id
        self.topic = topic
        self.publish = publish
        self.node_handle = node_handle

        self.clients = {}

        self.handler = MessageHandler(None, self._publish)
        self.handler_lock = Lock()
        self.update_params()

    def unregister(self):
        """Unsubscribe this subscription and clean up resources."""
        manager.unsubscribe(self.client_id, self.topic)
        with self.handler_lock:
            self.handler.finish(block=False)
        self.clients.clear()

    def subscribe(
        self,
        sid=None,
        msg_type=None,
        throttle_rate=0,
        queue_length=0,
        fragment_size=None,
        compression="none",
    ):
        """
        Add another client's subscription request.

        If there are multiple calls to subscribe, the values actually used for
        queue_length, fragment_size, compression and throttle_rate are
        chosen to encompass all subscriptions' requirements

        :param sid: The subscription id from the client
        :param msg_type: The type of the message to subscribe to
        :param throttle_rate: The minimum time (in ms) allowed between messages
            being sent. If multiple subscriptions, the lower of these is used
        :param queue_length: The number of messages that can be buffered.  If
            multiple subscriptions, the lower of these is used
        :param fragment_size: None if no fragmentation, or the maximum length of
            allowed outgoing messages
        :param compression: "none" if no compression, or some other value if
            compression is to be used (current valid values are 'png')
        """
        client_details = {
            "throttle_rate": throttle_rate,
            "queue_length": queue_length,
            "fragment_size": fragment_size,
            "compression": compression,
        }

        self.clients[sid] = client_details

        self.update_params()

        raw = compression == "cbor-raw"

        # Subscribe with the manager. This will propagate any exceptions
        manager.subscribe(
            self.client_id,
            self.topic,
            self.on_msg,
            self.node_handle,
            msg_type=msg_type,
            raw=raw,
        )

    def unsubscribe(self, sid=None):
        """
        Unsubscribe this particular client's subscription.

        :param sid: The individual subscription id. If None, all are unsubscribed
        """
        if sid is None:
            self.clients.clear()
        elif sid in self.clients:
            del self.clients[sid]

        if not self.is_empty():
            self.update_params()

    def is_empty(self):
        """Return True if there are no subscriptions currently."""
        return len(self.clients) == 0

    def _publish(self, message):
        """
        Publish a message to the subscribed clients.

        Internal method to propagate published messages to the registered
        publish callback.
        """
        self.publish(message, self.fragment_size, self.compression)

    def on_msg(self, msg):
        """
        Handle incoming messages.

        Raw callback called by subscription manager for all incoming
        messages.

        Incoming messages are passed to the message handler which may drop,
        buffer, or propagate the message.
        """
        with self.handler_lock:
            self.handler.handle_message(msg)

    def update_params(self):
        """
        Update the parameters of the message handler based on current subscriptions.

        Determine the 'lowest common denominator' params to satisfy all
        subscribed clients.
        """
        if len(self.clients) == 0:
            self.throttle_rate = 0
            self.queue_length = 0
            self.fragment_size = None
            self.compression = "none"
            return

        def f(fieldname):
            return [x[fieldname] for x in self.clients.values()]

        self.throttle_rate = min(f("throttle_rate"))
        self.queue_length = min(f("queue_length"))
        frags = [x for x in f("fragment_size") if x is not None]
        if frags == []:
            self.fragment_size = None
        else:
            self.fragment_size = min(frags)

        self.compression = "none"
        if "png" in f("compression"):
            self.compression = "png"
        if "cbor" in f("compression"):
            self.compression = "cbor"
        if "cbor-raw" in f("compression"):
            self.compression = "cbor-raw"

        with self.handler_lock:
            self.handler.set_throttle_rate(self.throttle_rate)
            self.handler = self.handler.set_queue_length(self.queue_length)


class Subscribe(Capability):
    subscribe_msg_fields = (
        (True, "topic", str),
        (False, "type", str),
        (False, "throttle_rate", int),
        (False, "fragment_size", int),
        (False, "queue_length", int),
        (False, "compression", str),
    )
    unsubscribe_msg_fields = (True, "topic", str)

    topics_glob = None

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("subscribe", self.subscribe)
        protocol.register_operation("unsubscribe", self.unsubscribe)

        self._subscriptions = {}

    def subscribe(self, msg):
        # Pull out the ID
        sid = msg.get("id", None)

        # Check the args
        self.basic_type_check(msg, self.subscribe_msg_fields)

        # Make the subscription
        topic = msg["topic"]

        if Subscribe.topics_glob is not None and Subscribe.topics_glob:
            self.protocol.log("debug", "Topic security glob enabled, checking topic: " + topic)
            match = False
            for glob in Subscribe.topics_glob:
                if fnmatch.fnmatch(topic, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing subscription...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for topic, cancelling subscription to: " + topic,
                )
                return
        else:
            self.protocol.log("debug", "No topic security glob, not checking subscription.")

        if topic not in self._subscriptions:
            client_id = self.protocol.client_id
            cb = partial(self.publish, topic)
            self._subscriptions[topic] = Subscription(
                client_id, topic, cb, self.protocol.node_handle
            )

        # Register the subscriber
        subscribe_args = {
            "sid": sid,
            "msg_type": msg.get("type", None),
            "throttle_rate": msg.get("throttle_rate", 0),
            "fragment_size": msg.get("fragment_size", None),
            "queue_length": msg.get("queue_length", 0),
            "compression": msg.get("compression", "none"),
        }
        self._subscriptions[topic].subscribe(**subscribe_args)

        self.protocol.log("info", f"Subscribed to {topic}")

    def unsubscribe(self, msg):
        # Pull out the ID
        sid = msg.get("id", None)

        self.basic_type_check(msg, self.unsubscribe_msg_fields)

        topic = msg["topic"]

        if topic not in self._subscriptions:
            return
        self._subscriptions[topic].unsubscribe(sid)

        if self._subscriptions[topic].is_empty():
            self._subscriptions[topic].unregister()
            del self._subscriptions[topic]

        self.protocol.log("info", f"Unsubscribed from {topic}")

    def publish(self, topic, message, fragment_size=None, compression="none"):  # noqa: ARG002
        """
        Publish a message to the client.

        :param topic: The topic to publish the message on
        :param message: A ROS message wrapped by OutgoingMessage
        :param fragment_size: (optional) If provided, fragment the serialized message into msgs
            with payloads not greater than this value
        :param compression: (optional) compress the message. valid values are
            'png' and 'none'
        """
        # TODO: fragmentation, proper ids

        outgoing_msg = {"op": "publish", "topic": topic}
        if compression == "png":
            outgoing_msg["msg"] = message.get_json_values()
            outgoing_msg_dumped = encode_json(outgoing_msg)
            outgoing_msg = {"op": "png", "data": encode_png(outgoing_msg_dumped)}
        elif compression == "cbor":
            outgoing_msg = message.get_cbor(outgoing_msg)
        elif compression == "cbor-raw":
            (secs, nsecs) = self.protocol.node_handle.get_clock().now().seconds_nanoseconds()
            outgoing_msg["msg"] = {
                "secs": secs,
                "nsecs": nsecs,
                "bytes": message.message,
            }
            outgoing_msg = message.get_cbor_raw(outgoing_msg)
        else:
            outgoing_msg["msg"] = message.get_json_values()

        self.protocol.send(outgoing_msg, compression=compression)

    def finish(self):
        for subscription in self._subscriptions.values():
            subscription.unregister()
        self._subscriptions.clear()
        self.protocol.unregister_operation("subscribe")
        self.protocol.unregister_operation("unsubscribe")



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/unadvertise_action.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import fnmatch

from rosbridge_library.capability import Capability
from rosbridge_library.protocol import Protocol


class UnadvertiseAction(Capability):
    actions_glob = None

    def __init__(self, protocol: Protocol) -> None:
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("unadvertise_action", self.unadvertise_action)

    def unadvertise_action(self, message: dict) -> None:
        # parse the message
        action_name = message["action"]

        if UnadvertiseAction.actions_glob is not None and UnadvertiseAction.actions_glob:
            self.protocol.log(
                "debug",
                f"Action security glob enabled, checking action: {action_name}",
            )
            match = False
            for glob in UnadvertiseAction.actions_glob:
                if fnmatch.fnmatch(action_name, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing action unadvertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    f"No match found for action, cancelling action unadvertisement for:{action_name}",
                )
                return
        else:
            self.protocol.log(
                "debug",
                "No action security glob, not checking action unadvertisement...",
            )

        # unregister action in ROS
        if action_name in self.protocol.external_action_list:
            self.protocol.external_action_list[action_name].graceful_shutdown()
            del self.protocol.external_action_list[action_name]
            self.protocol.log("info", f"Unadvertised action {action_name}")
        else:
            self.protocol.log(
                "error",
                f"Action {action_name} has not been advertised via rosbridge, can't unadvertise.",
            )



================================================
FILE: rosbridge_library/src/rosbridge_library/capabilities/unadvertise_service.py
================================================
import fnmatch

from rosbridge_library.capability import Capability


class UnadvertiseService(Capability):
    # unadvertise_service_msg_fields = [(True, "service", (str, unicode))]

    services_glob = None

    def __init__(self, protocol):
        # Call superclass constructor
        Capability.__init__(self, protocol)

        # Register the operations that this capability provides
        protocol.register_operation("unadvertise_service", self.unadvertise_service)

    def unadvertise_service(self, message):
        # parse the message
        service_name = message["service"]

        if UnadvertiseService.services_glob is not None and UnadvertiseService.services_glob:
            self.protocol.log(
                "debug",
                "Service security glob enabled, checking service: " + service_name,
            )
            match = False
            for glob in UnadvertiseService.services_glob:
                if fnmatch.fnmatch(service_name, glob):
                    self.protocol.log(
                        "debug",
                        "Found match with glob " + glob + ", continuing service unadvertisement...",
                    )
                    match = True
                    break
            if not match:
                self.protocol.log(
                    "warn",
                    "No match found for service, cancelling service unadvertisement for: "
                    + service_name,
                )
                return
        else:
            self.protocol.log(
                "debug",
                "No service security glob, not checking service unadvertisement...",
            )

        # unregister service in ROS
        if service_name in self.protocol.external_service_list:
            self.protocol.external_service_list[service_name].graceful_shutdown()
            self.protocol.external_service_list[service_name].service_handle.destroy()
            del self.protocol.external_service_list[service_name]
            self.protocol.log("info", f"Unadvertised service {service_name}")
        else:
            self.protocol.log(
                "error",
                f"Service {service_name} has not been advertised via rosbridge, can't unadvertise.",
            )



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/src/rosbridge_library/internal/actions.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, PickNik Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

import time
from threading import Thread
from typing import TYPE_CHECKING, Any, Callable

from rclpy.action import ActionClient
from rclpy.expand_topic_name import expand_topic_name

from rosbridge_library.internal.message_conversion import (
    extract_values,
    populate_instance,
)
from rosbridge_library.internal.ros_loader import (
    get_action_class,
    get_action_goal_instance,
)

if TYPE_CHECKING:
    from rclpy.node import Node
    from rclpy.task import Future


class InvalidActionException(Exception):
    def __init__(self, action_name) -> None:
        Exception.__init__(self, f"Action {action_name} does not exist")


class ActionClientHandler(Thread):
    def __init__(
        self,
        action: str,
        action_type: str,
        args: dict,
        success_callback: Callable[[dict], None],
        error_callback: Callable[[Exception], None],
        feedback_callback: Callable[[dict], None] | None,
        node_handle: Node,
    ) -> None:
        """
        Create a client handler for the specified action.

        Use start() to start in a separate thread or run() to run in this thread.

        :param action: The name of the action to execute.
        :param action_type: The type of the action to execute.
        :param args: Arguments to pass to the action. Can be an ordered list, or a dict of
            name-value pairs. Anything else will be treated as though no arguments were provided
            (which is still valid for some kinds of actions)
        :param success_callback: A callback to call with the JSON result of the service call
        :param error_callback: A callback to call if an error occurs. The callback will be passed
            the exception that caused the failure
        :param node_handle: A ROS 2 node handle to call services
        """
        Thread.__init__(self)
        self.daemon = True
        self.action = action
        self.action_type = action_type
        self.args = args
        self.success = success_callback
        self.error = error_callback
        self.feedback = feedback_callback
        self.node_handle = node_handle
        self.send_goal_helper = SendGoal()

    def run(self) -> None:
        try:
            # Call the service and pass the result to the success handler
            self.success(
                self.send_goal_helper.send_goal(
                    self.node_handle,
                    self.action,
                    self.action_type,
                    args=self.args,
                    feedback_cb=self.feedback,
                )
            )
        except Exception as e:
            # On error, just pass the exception to the error handler
            self.error(e)


def args_to_action_goal_instance(inst: Any, args: list | dict | None) -> Any:
    """
    Populate an action goal instance with the provided args.

    Propagates any exceptions that may be raised.

    :param args: Can be a dictionary of values, or a list, or None
    """
    msg = {}
    if isinstance(args, list):
        msg = dict(zip(inst.get_fields_and_field_types().keys(), args))
    elif isinstance(args, dict):
        msg = args

    # Populate the provided instance, propagating any exceptions
    populate_instance(msg, inst)


class SendGoal:
    """Helper class to send action goals."""

    def __init__(self, server_timeout_time: float = 1.0, sleep_time: float = 0.001) -> None:
        self.server_timeout_time = server_timeout_time
        self.sleep_time = sleep_time
        self.goal_handle = None
        self.goal_canceled = False

    def get_result_cb(self, future: Future) -> None:
        self.result = future.result()

    def goal_response_cb(self, future: Future) -> None:
        self.goal_handle = future.result()
        assert self.goal_handle is not None
        if not self.goal_handle.accepted:
            msg = "Action goal was rejected"
            raise Exception(msg)
        result_future = self.goal_handle.get_result_async()
        result_future.add_done_callback(self.get_result_cb)

    def goal_cancel_cb(self, _: Future) -> None:
        self.goal_canceled = True

    def send_goal(
        self,
        node_handle: Node,
        action: str,
        action_type: str,
        args: dict | None = None,
        feedback_cb: Callable[[dict], None] | None = None,
    ) -> dict:
        # Given the action name and type, fetch a request instance
        action_name = expand_topic_name(action, node_handle.get_name(), node_handle.get_namespace())
        action_class = get_action_class(action_type)
        inst = get_action_goal_instance(action_type)

        # Populate the instance with the provided args
        args_to_action_goal_instance(inst, args)

        self.result = None
        client: ActionClient = ActionClient(node_handle, action_class, action_name)
        client.wait_for_server(timeout_sec=self.server_timeout_time)
        send_goal_future = client.send_goal_async(inst, feedback_callback=feedback_cb)
        send_goal_future.add_done_callback(self.goal_response_cb)

        while self.result is None:
            time.sleep(self.sleep_time)

        client.destroy()
        if self.result is not None:
            # Turn the response into JSON and pass to the callback
            json_response = extract_values(self.result)
        else:
            raise Exception(self.result)

        return json_response

    def cancel_goal(self) -> None:
        while self.goal_handle is None and self.result is None:
            time.sleep(self.sleep_time)

        if self.result is not None:
            # The action has already completed
            return

        assert self.goal_handle is not None

        cancel_goal_future = self.goal_handle.cancel_goal_async()
        cancel_goal_future.add_done_callback(self.goal_cancel_cb)
        while not cancel_goal_future.done():
            time.sleep(self.sleep_time)



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/cbor_conversion.py
================================================
import struct

try:
    from cbor import Tag
except ImportError:
    from rosbridge_library.util.cbor import Tag


LIST_TYPES = [list, tuple]
INT_TYPES = [
    "byte",
    "char",
    "int8",
    "uint8",
    "int16",
    "uint16",
    "int32",
    "uint32",
    "int64",
    "uint64",
]
FLOAT_TYPES = ["float", "double"]
STRING_TYPES = ["string"]
BOOL_TYPES = ["boolean"]
TIME_TYPES = ["time", "duration"]
BOOL_ARRAY_TYPES = ["sequence<boolean>"]
STRING_ARRAY_TYPES = ["sequence<string>"]
BYTESTREAM_TYPES = ["sequence<uint8>", "sequence<char>"]

# Typed array tags according to <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>
# Always encode to little-endian variant, for now.
TAGGED_ARRAY_FORMATS = {
    "sequence<uint16>": (69, "<{}H"),
    "sequence<uint32>": (70, "<{}I"),
    "sequence<uint64>": (71, "<{}Q"),
    "sequence<byte>": (72, "{}b"),
    "sequence<int8>": (72, "{}b"),
    "sequence<int16>": (77, "<{}h"),
    "sequence<int32>": (78, "<{}i"),
    "sequence<int64>": (79, "<{}q"),
    "sequence<float>": (85, "<{}f"),
    "sequence<double>": (86, "<{}d"),
}


def extract_cbor_values(msg):
    """
    Extract a dictionary of CBOR-friendly values from a ROS message.

    Primitive values will be casted to specific Python primitives.

    Typed arrays will be tagged and packed into byte arrays.
    """
    out = {}
    for slot, slot_type in msg.get_fields_and_field_types().items():
        val = getattr(msg, slot)

        # string
        if slot_type in STRING_TYPES:
            out[slot] = str(val)

        # bool
        elif slot_type in BOOL_TYPES:
            out[slot] = bool(val)

        # integers
        elif slot_type in INT_TYPES:
            out[slot] = int(val)

        # floats
        elif slot_type in FLOAT_TYPES:
            out[slot] = float(val)

        # time/duration
        elif slot_type in TIME_TYPES:
            out[slot] = {
                "sec": int(val.sec),
                "nanosec": int(val.nanosec),
            }

        # byte array
        elif slot_type in BYTESTREAM_TYPES:
            out[slot] = bytes(val)

        # bool array
        elif slot_type in BOOL_ARRAY_TYPES:
            out[slot] = [bool(i) for i in val]

        elif slot_type in STRING_ARRAY_TYPES:
            out[slot] = [str(i) for i in val]

        # numeric arrays
        elif slot_type in TAGGED_ARRAY_FORMATS:
            tag, fmt = TAGGED_ARRAY_FORMATS[slot_type]
            fmt_to_length = fmt.format(len(val))
            packed = struct.pack(fmt_to_length, *val)
            out[slot] = Tag(tag=tag, value=packed)

        # array of messages
        elif type(val) in LIST_TYPES:
            out[slot] = [extract_cbor_values(i) for i in val]

        # message
        else:
            out[slot] = extract_cbor_values(val)

    return out



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/exceptions.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


class InvalidArgumentException(Exception):
    pass


class MissingArgumentException(Exception):
    pass



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/message_conversion.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import array
import math
import re
import sys
from base64 import standard_b64decode, standard_b64encode

import numpy as np
from rcl_interfaces.msg import Parameter
from rclpy.clock import ROSClock
from rclpy.time import Duration, Time

from rosbridge_library.internal import ros_loader
from rosbridge_library.util import bson

try:
    import rospy
except ImportError:
    rospy = None

type_map = {
    "bool": ["bool", "boolean"],
    "int": [
        "int8",
        "octet",
        "uint8",
        "char",
        "int16",
        "uint16",
        "int32",
        "uint32",
        "int64",
        "uint64",
    ],
    "float": ["float32", "float64", "double", "float"],
    "str": ["string"],
}
primitive_types = [bool, int, float]

list_types = [list, tuple, np.ndarray, array.array]
ros_time_types = ["builtin_interfaces/Time", "builtin_interfaces/Duration"]
ros_primitive_types = [
    "bool",
    "boolean",
    "octet",
    "char",
    "int8",
    "uint8",
    "int16",
    "uint16",
    "int32",
    "uint32",
    "int64",
    "uint64",
    "float32",
    "float64",
    "float",
    "double",
    "string",
]
ros_header_types = ["Header", "std_msgs/Header", "roslib/Header"]
ros_binary_types = ["uint8[]", "char[]", "sequence<uint8>", "sequence<char>"]
# Remove the list type wrapper, and length specifier, from rostypes i.e. sequence<double, 3>
list_tokens = re.compile(r"<(.+?)(, \d+)?>")
bounded_array_tokens = re.compile(r"(.+)\[.*\]")
ros_binary_types_list_braces = [
    ("uint8[]", re.compile(r"uint8\[[^\]]*\]")),
    ("char[]", re.compile(r"char\[[^\]]*\]")),
]

binary_encoder = None
binary_encoder_type = "default"
bson_only_mode = False


# TODO(@jubeira): configure module with a node handle.
# The original code doesn't seem to actually use these parameters.
def configure(node_handle=None):
    global binary_encoder, binary_encoder_type, bson_only_mode

    if node_handle is not None:
        binary_encoder_type = node_handle.get_parameter_or(
            "binary_encoder", Parameter("", value="default")
        ).value
        bson_only_mode = node_handle.get_parameter_or(
            "bson_only_mode", Parameter("", value=False)
        ).value

    if binary_encoder is None:
        if binary_encoder_type == "bson" or bson_only_mode:
            binary_encoder = bson.Binary
        elif binary_encoder_type in {"default", "b64"}:
            binary_encoder = standard_b64encode
        else:
            print(f"Unknown encoder type '{binary_encoder_type}'")
            sys.exit(0)


def get_encoder():
    configure()
    return binary_encoder


class InvalidMessageException(Exception):
    def __init__(self, inst):
        Exception.__init__(
            self,
            f"Unable to extract message values from {type(inst).__name__} instance",
        )


class NonexistentFieldException(Exception):
    def __init__(self, basetype, fields):
        Exception.__init__(
            self,
            "Message type {} does not have a field {}".format(basetype, ".".join(fields)),
        )


class FieldTypeMismatchException(Exception):
    def __init__(self, roottype, fields, expected_type, found_type):
        if roottype == expected_type:
            Exception.__init__(
                self,
                f"Expected a JSON object for type {roottype} but received a {found_type}",
            )
        else:
            Exception.__init__(
                self,
                "{} message requires a {} for field {}, but got a {}".format(
                    roottype, expected_type, ".".join(fields), found_type
                ),
            )


def extract_values(inst):
    rostype = msg_instance_type_repr(inst)
    if rostype is None:
        raise InvalidMessageException(inst=inst)
    return _from_inst(inst, rostype)


def populate_instance(msg, inst, clock=None):
    """
    Populate a ROS message instance with the provided values.

    Return an instance of the provided class, with its fields populated
    according to the values in msg.
    """
    if clock is None:
        clock = ROSClock()

    inst_type = msg_instance_type_repr(inst)

    return _to_inst(msg, inst_type, inst_type, clock, inst)


def msg_instance_type_repr(msg_inst):
    """Return a string representation of a ROS2 message type from a message instance."""
    # Message representation: '{package}.msg.{message_name}({fields})'.
    # A representation like '_type' member in ROS1 messages is needed: '{package}/{message_name}'.
    # E.g: 'std_msgs/Header'
    msg_type = type(msg_inst)
    if msg_type in primitive_types or msg_type in list_types:
        return str(type(msg_inst))
    inst_repr = str(msg_inst).split(".")
    return "{}/{}".format(inst_repr[0], inst_repr[2].split("(")[0])


def msg_class_type_repr(msg_class):
    """Return a string representation of a ROS2 message type from a class representation."""
    # The string representation of the class is <class '{package}.msg._{message}.{Message}'>
    # (e.g. <class 'std_msgs.msg._string.String'>).
    # This has to be converted to {package}/msg/{Message} (e.g. std_msgs/msg/String).
    class_repr = str(msg_class).split("'")[1].split(".")
    return f"{class_repr[0]}/{class_repr[1]}/{class_repr[3]}"


def _from_inst(inst, rostype):
    global bson_only_mode
    # Special case for uint8[], we encode the string
    for binary_type, expression in ros_binary_types_list_braces:
        if expression.sub(binary_type, rostype) in ros_binary_types:
            encoded = get_encoder()(inst)
            return encoded.decode("ascii")

    # Check for time or duration
    if rostype in ros_time_types:
        return {"sec": inst.sec, "nanosec": inst.nanosec}

    if bson_only_mode is None:
        bson_only_mode = rospy.get_param("~bson_only_mode", False)
    # Check for primitive types
    if rostype in ros_primitive_types:
        # JSON does not support Inf and NaN. They are mapped to None and encoded as null
        if (
            not bson_only_mode
            and rostype in type_map.get("float")
            and (math.isnan(inst) or math.isinf(inst))
        ):
            return None

        # JSON does not support byte array. They are converted to int
        if (not bson_only_mode) and (rostype == "octet"):
            return int.from_bytes(inst, "little")

        return inst

    # Check if it's a list or tuple
    if type(inst) in list_types:
        return _from_list_inst(inst, rostype)

    # Assume it's otherwise a full ros msg object
    return _from_object_inst(inst, rostype)


def _from_list_inst(inst, rostype):
    # Can duck out early if the list is empty
    if len(inst) == 0:
        return []

    # Remove the list indicators from the rostype
    try:
        rostype = re.search(list_tokens, rostype).group(1)
    except AttributeError:
        rostype = re.search(bounded_array_tokens, rostype).group(1)

    # Shortcut for primitives
    if rostype in ros_primitive_types:
        # Convert to Built-in integer types to dump as JSON
        if isinstance(inst, np.ndarray) and (
            rostype in type_map.get("int") or rostype in type_map.get("float")
        ):
            return inst.tolist()

        if rostype not in type_map.get("float"):
            return list(inst)

    # Call to _to_inst for every element of the list
    return [_from_inst(x, rostype) for x in inst]


def _from_object_inst(inst, _rostype):
    # Create an empty dict then populate with values from the inst
    msg = {}
    # Equivalent for zip(inst.__slots__, inst._slot_types) in ROS1:
    for field_name, field_rostype in inst.get_fields_and_field_types().items():
        field_inst = getattr(inst, field_name)
        msg[field_name] = _from_inst(field_inst, field_rostype)
    return msg


def _to_inst(msg, rostype, roottype, clock=None, inst=None, stack=None):
    if clock is None:
        clock = ROSClock()
    if stack is None:
        stack = []

    # Check if it's uint8[], and if it's a string, try to b64decode
    for binary_type, expression in ros_binary_types_list_braces:
        if expression.sub(binary_type, rostype) in ros_binary_types:
            return _to_binary_inst(msg)

    # Check the type for time or rostime
    if rostype in ros_time_types:
        return _to_time_inst(msg, rostype, clock, inst)

    # Check to see whether this is a primitive type
    if rostype in ros_primitive_types:
        return _to_primitive_inst(msg, rostype, roottype, stack)

    # Check whether we're dealing with a list type
    if inst is not None and type(inst) in list_types:
        return _to_list_inst(msg, rostype, roottype, clock, inst, stack)

    # Otherwise, the type has to be a full ros msg type, so msg must be a dict
    if inst is None:
        inst = ros_loader.get_message_instance(rostype)

    return _to_object_inst(msg, rostype, roottype, clock, inst, stack)


def _to_binary_inst(msg):
    if isinstance(msg, str):
        return list(standard_b64decode(msg))
    if isinstance(msg, list):
        return msg
    if isinstance(msg, bytes):
        # Using the frombytes() method with a memoryview of the data allows for zero copying of
        # data thanks to Python's buffer protocol (HUGE time-saver for large arrays)
        data = array.array("B")
        data.frombytes(memoryview(msg))
        return data
    return bytes(bytearray(msg))


def _to_time_inst(msg, rostype, clock, inst=None):
    # Create an instance if we haven't been provided with one

    if rostype == "builtin_interfaces/Time" and msg == "now":
        return clock.now().to_msg()

    if inst is None:
        if rostype == "builtin_interfaces/Time":
            inst = Time().to_msg()
        elif rostype == "builtin_interfaces/Duration":
            inst = Duration().to_msg()
        else:
            return None

    # Copy across the fields, try ROS1 and ROS2 fieldnames
    for field in ["sec", "secs"]:
        if field in msg:
            inst.sec = msg[field]
            break
    for field in ["nanosec", "nsecs"]:
        if field in msg:
            inst.nanosec = msg[field]
            break

    return inst


def _to_primitive_inst(msg, rostype, roottype, stack):
    # Typecheck the msg
    if isinstance(msg, int) and rostype in type_map["float"]:
        # probably wrong parsing,
        # fix that by casting the int to the expected float
        msg = float(msg)

    # Convert to byte
    if rostype == "octet" and isinstance(msg, int):
        return bytes([msg])

    msgtype = type(msg)
    if msgtype in primitive_types and rostype in type_map[msgtype.__name__]:
        return msg
    if isinstance(msg, str) and rostype in type_map[msgtype.__name__]:
        return msg
    raise FieldTypeMismatchException(roottype, stack, rostype, msgtype)


def _to_list_inst(msg, rostype, roottype, clock, inst, stack):
    # Typecheck the msg
    if type(msg) not in list_types:
        raise FieldTypeMismatchException(roottype, stack, rostype, type(msg))

    # Can duck out early if the list is empty
    if len(msg) == 0:
        return []

    # Special mappings for numeric types https://design.ros2.org/articles/idl_interface_definition.html
    if isinstance(inst, array.array):
        del inst[:]
        inst.extend(msg)  # accepts both ints and floats which may come from json
        return inst
    if isinstance(inst, np.ndarray):
        inst[:] = msg  # accepts both ints and floats which may come from json
        return inst

    # Remove the list indicators from the rostype
    try:
        rostype = re.search(list_tokens, rostype).group(1)
    except AttributeError:
        rostype = re.search(bounded_array_tokens, rostype).group(1)

    # Call to _to_inst for every element of the list
    return [_to_inst(x, rostype, roottype, clock, None, stack) for x in msg]


def _to_object_inst(msg, rostype, roottype, clock, inst, stack):
    # Typecheck the msg
    if not isinstance(msg, dict):
        raise FieldTypeMismatchException(roottype, stack, rostype, type(msg))

    # Substitute the correct time if we're an std_msgs/Header
    if rostype in ros_header_types:
        inst.stamp = clock.now().to_msg()

    inst_fields = inst.get_fields_and_field_types()
    for field_name in msg:
        # Add this field to the field stack
        field_stack = [*stack, field_name]

        # Raise an exception if the msg contains a bad field
        if field_name not in inst_fields:
            raise NonexistentFieldException(roottype, field_stack)

        field_rostype = inst_fields[field_name]
        field_inst = getattr(inst, field_name)

        field_value = _to_inst(
            msg[field_name], field_rostype, roottype, clock, field_inst, field_stack
        )

        setattr(inst, field_name, field_value)

    return inst



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/outgoing_message.py
================================================
from rosbridge_library.internal.cbor_conversion import extract_cbor_values
from rosbridge_library.internal.message_conversion import (
    extract_values as extract_json_values,
)

try:
    from cbor import dumps as encode_cbor
except ImportError:
    from rosbridge_library.util.cbor import dumps as encode_cbor


class OutgoingMessage:
    """A message wrapper for caching encoding operations."""

    def __init__(self, message):
        self._message = message
        self._json_values = None
        self._cbor_values = None
        self._cbor_msg = None
        self._cbor_raw_msg = None

    @property
    def message(self):
        return self._message

    def get_json_values(self):
        if self._json_values is None:
            self._json_values = extract_json_values(self._message)
        return self._json_values

    def get_cbor_values(self):
        if self._cbor_values is None:
            self._cbor_values = extract_cbor_values(self._message)
        return self._cbor_values

    def get_cbor(self, outgoing_msg):
        if self._cbor_msg is None:
            outgoing_msg["msg"] = self.get_cbor_values()
            self._cbor_msg = encode_cbor(outgoing_msg)

        return self._cbor_msg

    def get_cbor_raw(self, outgoing_msg):
        if self._cbor_raw_msg is None:
            self._cbor_raw_msg = encode_cbor(outgoing_msg)

        return self._cbor_raw_msg



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/pngcompression.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from base64 import standard_b64decode, standard_b64encode
from io import BytesIO
from math import ceil, floor, sqrt

from PIL import Image


def encode(string):
    r"""
    PNG-compress the string in a square RGB image padded with '\n'.

    :return: The b64 encoded bytes.
    """
    string_bytes = string.encode("utf-8")
    length = len(string_bytes)
    width = floor(sqrt(length / 3.0))
    height = ceil((length / 3.0) / width)
    bytes_needed = int(width * height * 3)
    string_padded = string_bytes + (b"\n" * (bytes_needed - length))
    i = Image.frombytes("RGB", (int(width), int(height)), string_padded)
    buff = BytesIO()
    i.save(buff, "png")
    encoded = standard_b64encode(buff.getvalue())
    return encoded.decode()


def decode(string):
    r"""b64 decode the string, then PNG-decompress and remove the '\n' padding."""
    decoded = standard_b64decode(string)
    buff = BytesIO(decoded)
    i = Image.open(buff, formats=("png",)).convert("RGB")
    dec_str = i.tobytes().decode("utf-8")
    return dec_str.replace("\n", "")  # Remove padding from encoding



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/publishers.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# Copyright (c) 2014, Creativa 77 SRL
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from threading import Timer

from rclpy.duration import Duration
from rclpy.qos import DurabilityPolicy, QoSProfile

from rosbridge_library.internal import message_conversion, ros_loader
from rosbridge_library.internal.message_conversion import msg_class_type_repr
from rosbridge_library.internal.topics import (
    TopicNotEstablishedException,
    TypeConflictException,
)


class MultiPublisher:
    """
    Keeps track of the clients that are using a particular publisher.

    Provides an API to publish messages and register clients that are using
    this publisher.
    """

    def __init__(self, topic, node_handle, msg_type=None, latched_client_id=None, queue_size=100):
        """
        Register a publisher on the specified topic.

        :param topic: The name of the topic to register the publisher to
        :param node_handle: Handle to a rclpy node to create the publisher.
        :param msg_type: (optional) The type to register the publisher as. If not provided, an
            attempt will be made to infer the topic type
        :param latch: (optional) If a client requested this publisher to be latched,
            provide the client_id of that client here

        :raises TopicNotEstablishedException: If no msg_type was specified by the caller and the
            topic is not yet established, so a topic type cannot be inferred
        :raises TypeConflictException: If the msg_type was specified by the caller and the topic
            is established, and the established type is different to the user-specified msg_type
        """
        # First check to see if the topic is already established
        topics_names_and_types = dict(node_handle.get_topic_names_and_types())
        topic_type = topics_names_and_types.get(topic)

        # If it's not established and no type was specified, exception
        if msg_type is None and topic_type is None:
            raise TopicNotEstablishedException(topic)

        # topic_type is a list of types or None at this point; only one type is supported.
        if topic_type is not None:
            if len(topic_type) > 1:
                node_handle.get_logger().warning(f"More than one topic type detected: {topic_type}")
            topic_type = topic_type[0]

        # Use the established topic type if none was specified
        if msg_type is None:
            msg_type = topic_type

        # Load the message class, propagating any exceptions from bad msg types
        msg_class = ros_loader.get_message_class(msg_type)

        # Make sure the specified msg type and established msg type are same
        msg_type_string = msg_class_type_repr(msg_class)
        if topic_type is not None and topic_type != msg_type_string:
            raise TypeConflictException(topic, topic_type, msg_type_string)

        # Create the publisher and associated member variables
        self.clients = {}
        self.latched_client_id = latched_client_id
        self.topic = topic
        self.node_handle = node_handle
        self.msg_class = msg_class
        # Adding a lifespan solves the problem of late-joining subscribers
        # without the need of a custom message publisher implementation.
        publisher_qos = QoSProfile(
            depth=queue_size,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )

        # For latched clients, no lifespan has to be specified (i.e. latch forever).
        # Otherwise we want to keep the messages for a second to prevent late-joining subscribers from
        # missing messages.
        if latched_client_id is None:
            publisher_qos.lifespan = Duration(seconds=1)
        else:
            publisher_qos.depth = 1

        self.publisher = node_handle.create_publisher(msg_class, topic, qos_profile=publisher_qos)

    def unregister(self):
        """Unregister the publisher and clear the clients."""
        self.node_handle.destroy_publisher(self.publisher)
        self.clients.clear()

    def verify_type(self, msg_type):
        """
        Verify that the publisher publishes messages of the specified type.

        :param msg_type: The type to check this publisher against

        :raises Exception: If ros_loader cannot load the specified msg type
        :raises TypeConflictException: If the msg_type is different than the type of this
            publisher
        """
        if ros_loader.get_message_class(msg_type) is not self.msg_class:
            raise TypeConflictException(self.topic, msg_class_type_repr(self.msg_class), msg_type)

    def publish(self, msg):
        """
        Publish a message using this publisher.

        :param msg: The dict (json) message to publish

        :raises Exception: Propagates exceptions from message conversion if the provided msg does
            not properly conform to the message type of this publisher
        """
        # Create a message instance
        inst = self.msg_class()

        # Populate the instance, propagating any exceptions that may be thrown
        message_conversion.populate_instance(msg, inst, self.node_handle.get_clock())

        # Publish the message
        self.publisher.publish(inst)

    def register_client(self, client_id):
        """
        Register the specified client as a client of this publisher.

        :param client_id: The ID of the client using the publisher
        """
        self.clients[client_id] = True

    def unregister_client(self, client_id):
        """
        Unregister the specified client from this publisher.

        If the specified client_id is not a client of this publisher, nothing
        happens.

        :param client_id: The ID of the client to remove
        """
        if client_id in self.clients:
            del self.clients[client_id]

    def has_clients(self):
        """Return true if there are clients to this publisher."""
        return len(self.clients) != 0


class PublisherManager:
    """
    The PublisherManager keeps track of ROS publishers.

    It maintains a MultiPublisher instance for each registered topic.

    When unregistering a client, if there are no more clients for a publisher,
    then that publisher is unregistered from the ROS Master.
    """

    def __init__(self):
        self._publishers = {}
        self.unregister_timers = {}
        self.unregister_timeout = 10.0

    def register(self, client_id, topic, node_handle, msg_type=None, latch=False, queue_size=100):
        """
        Register a publisher on the specified topic.

        Publishers are shared between clients, so a single MultiPublisher
        instance is created per topic, even if multiple clients register.

        :param client_id: The ID of the client making this request
        :param topic: The name of the topic to publish on
        :param node_handle: Handle to a rclpy node to create the publisher
        :param msg_type: (optional) The type to publish
        :param latch: (optional) Whether to make this publisher latched
        :param queue_size: (optional) Publisher queue_size to use

        :raises Exception: exceptions are propagated from the MultiPublisher if there is a problem
            loading the specified msg class or establishing the publisher
        """
        latched_client_id = client_id if latch else None
        if topic not in self._publishers:
            self._publishers[topic] = MultiPublisher(
                topic,
                node_handle,
                msg_type=msg_type,
                latched_client_id=latched_client_id,
                queue_size=queue_size,
            )
        elif latch and self._publishers[topic].latched_client_id != client_id:
            node_handle.get_logger().warning(
                f"Client ID {client_id} attempted to register topic [{topic}] as "
                "latched but this topic was previously registered."
            )
            node_handle.get_logger().warning(
                "Only a single registered latched publisher is supported at the time"
            )
        elif not latch and self._publishers[topic].latched_client_id:
            node_handle.get_logger().warning(
                f"New non-latched publisher registration for topic [{topic}] which is "
                "already registered as latched. but this topic was previously registered."
            )
            node_handle.get_logger().warning(
                "Only a single registered latched publisher is supported at the time"
            )

        if msg_type is not None:
            self._publishers[topic].verify_type(msg_type)

        self._publishers[topic].register_client(client_id)

    def unregister(self, client_id, topic):
        """
        Unregister a client from the publisher for the given topic.

        Will wait some time before actually unregistering, it is done in _unregister_impl/

        If there are no clients remaining for that publisher, then the publisher is unregistered
        from the ROS Master.

        :param client_id: The ID of the client making this request
        :param topic: The topic to unregister the publisher for
        """
        if topic not in self._publishers:
            return

        self._publishers[topic].unregister_client(client_id)
        if topic in self.unregister_timers:
            self.unregister_timers[topic].cancel()
            del self.unregister_timers[topic]
        self.unregister_timers[topic] = Timer(
            self.unregister_timeout, self._unregister_impl, [topic]
        )
        self.unregister_timers[topic].start()

    def _unregister_impl(self, topic):
        if not self._publishers[topic].has_clients():
            self._publishers[topic].unregister()
            del self._publishers[topic]
        del self.unregister_timers[topic]

    def unregister_all(self, client_id):
        """
        Unregister a client from all publishers that they are registered to.

        :param client_id: The ID of the client making this request
        """
        for topic in self._publishers:
            self.unregister(client_id, topic)

    def publish(self, client_id, topic, msg, node_handle, latch=False, queue_size=100):
        """
        Publish a message on the given topic.

        Tries to create a publisher on the topic if one does not already exist.

        :param client_id: The ID of the client making this request
        :param topic: The topic to publish the message on
        :param msg: A JSON-like dict of fields and values
        :param node_handle: Handle to a rclpy node to create the publisher
        :param latch: (optional) Whether to make this publisher latched
        :param queue_size: (optional) Publisher queue_size to use

        :raises Exception: A variety of exceptions are propagated. They can be thrown if there is
            a problem setting up or getting the publisher, or if the provided msg does not map to
            the msg class of the publisher.
        """
        self.register(client_id, topic, node_handle, latch=latch, queue_size=queue_size)

        self._publishers[topic].publish(msg)


manager = PublisherManager()



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/ros_loader.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import importlib
from threading import Lock
from typing import Any

""" ros_loader contains methods for dynamically loading ROS message classes at
runtime.  It's achieved by using roslib to load the manifest files for the
package that the respective class is contained in.

Methods typically return the requested class or instance, or None if not found
"""

# Variable containing the loaded classes
_loaded_msgs: dict[str, Any] = {}
_loaded_srvs: dict[str, Any] = {}
_loaded_actions: dict[str, Any] = {}
_msgs_lock = Lock()
_srvs_lock = Lock()
_actions_lock = Lock()


class InvalidTypeStringException(Exception):
    def __init__(self, typestring: str) -> None:
        Exception.__init__(self, f"{typestring} is not a valid type string")


class InvalidModuleException(Exception):
    def __init__(self, modname: str, subname: str, original_exception: Exception) -> None:
        Exception.__init__(
            self,
            f"Unable to import {modname}.{subname} from package {modname}. Caused by: {original_exception!s}",
        )


class InvalidClassException(Exception):
    def __init__(
        self, modname: str, subname: str, classname: str, original_exception: Exception
    ) -> None:
        Exception.__init__(
            self,
            f"Unable to import {subname} class {classname} from package {modname}. Caused by {original_exception!s}",
        )


def get_message_class(typestring: str) -> Any:
    """
    Load the message type specified.

    Throws exceptions on failure.

    :return: The loaded class
    """
    return _get_interface_class(typestring, "msg", _loaded_msgs, _msgs_lock)


def get_service_class(typestring: str) -> Any:
    """
    Load the service type specified.

    Throws exceptions on failure.

    :return: The loaded class
    """
    return _get_interface_class(typestring, "srv", _loaded_srvs, _srvs_lock)


def get_action_class(typestring: str) -> Any:
    """
    Load the action type specified.

    Throws exceptions on failure.

    :return: the loaded class
    """
    return _get_interface_class(typestring, "action", _loaded_actions, _actions_lock)


def get_message_instance(typestring: str) -> Any:
    """
    If not loaded, load the specified type and return an instance of it.

    Throws exceptions on failure.

    :return: The instance of the message class.
    """
    cls = get_message_class(typestring)
    return cls()


def get_service_request_instance(typestring: str) -> Any:
    cls = get_service_class(typestring)
    return cls.Request()


def get_service_response_instance(typestring: str) -> Any:
    cls = get_service_class(typestring)
    return cls.Response()


def get_action_goal_instance(typestring: str) -> Any:
    cls = get_action_class(typestring)
    return cls.Goal()


def get_action_feedback_instance(typestring: str) -> Any:
    cls = get_action_class(typestring)
    return cls.Feedback()


def get_action_result_instance(typestring: str) -> Any:
    cls = get_action_class(typestring)
    return cls.Result()


def _get_interface_class(
    typestring: str, intf_type: str, loaded_intfs: dict[str, Any], intf_lock: Lock
) -> Any:
    """
    If not loaded, load the specified ROS interface class then return an instance of it.

    Throws various exceptions if loading the interface class fails.
    """
    try:
        # The type string starts with the package and ends with the
        # class and contains module subnames in between. For
        # compatibility with ROS 1 style types, we fall back to use a
        # standard "msg" subname.
        splits = [x for x in typestring.split("/") if x]
        if len(splits) > 2:
            subname = ".".join(splits[1:-1])
        else:
            subname = intf_type

        return _get_class(typestring, subname, loaded_intfs, intf_lock)
    except (InvalidModuleException, InvalidClassException):
        return _get_class(typestring, intf_type, loaded_intfs, intf_lock)


def _get_class(typestring: str, subname: str, cache: dict[str, Any], lock: Lock) -> Any:
    """
    If not loaded, load the specified class then returns an instance of it.

    Loaded classes are cached in the provided cache dict

    Throws various exceptions if loading the msg class fails.
    """
    # First, see if we have this type string cached
    cls = _get_from_cache(cache, lock, typestring)
    if cls is not None:
        return cls

    # Now normalise the typestring
    modname, classname = _splittype(typestring)
    norm_typestring = modname + "/" + classname

    # Check to see if the normalised type string is cached
    cls = _get_from_cache(cache, lock, norm_typestring)
    if cls is not None:
        return cls

    # Load the class
    cls = _load_class(modname, subname, classname)

    # Cache the class for both the regular and normalised typestring
    _add_to_cache(cache, lock, typestring, cls)
    _add_to_cache(cache, lock, norm_typestring, cls)

    return cls


def _load_class(modname: str, subname: str, classname: str) -> Any:
    """
    Load the manifest and import the module that contains the specified type.

    :raises InvalidModuleException: if the module cannot be imported
    :raises InvalidClassException: if the class cannot be found in the module

    :return: the loaded module
    """
    # This assumes the module is already in the path.
    try:
        pypkg = importlib.import_module(f"{modname}.{subname}")
    except Exception as exc:
        raise InvalidModuleException(modname, subname, exc) from exc

    try:
        return getattr(pypkg, classname)
    except Exception as exc:
        raise InvalidClassException(modname, subname, classname, exc) from exc


def _splittype(typestring: str) -> tuple[str, str]:
    """
    Split the string using the / delimiter and strip out empty strings.

    :raises InvalidTypeStringException: if the typestring is not valid
    :return: A tuple of (modname, classname)
    """
    splits = [x for x in typestring.split("/") if x]
    if len(splits) == 3:
        return (splits[0], splits[2])
    if len(splits) == 2:
        return (splits[0], splits[1])
    raise InvalidTypeStringException(typestring)


def _add_to_cache(cache: dict[str, Any], lock: Lock, key: str, value: Any) -> None:
    lock.acquire()
    cache[key] = value
    lock.release()


def _get_from_cache(cache: dict[str, Any], lock: Lock, key: str) -> Any:
    """
    Return the value for the specified key from the cache.

    Locks the lock before doing anything. Returns None if key not in cache.
    """
    lock.acquire()
    ret = None
    if key in cache:
        ret = cache[key]
    lock.release()
    return ret



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/services.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
from __future__ import annotations

from threading import Event, Thread
from typing import TYPE_CHECKING, Any, Callable

from rclpy.callback_groups import ReentrantCallbackGroup

from rosbridge_library.internal.message_conversion import (
    extract_values,
    populate_instance,
)
from rosbridge_library.internal.ros_loader import (
    get_service_class,
    get_service_request_instance,
)

if TYPE_CHECKING:
    from rclpy.client import Client
    from rclpy.node import Node


class InvalidServiceException(Exception):
    def __init__(self, service_name) -> None:
        Exception.__init__(self, f"Service {service_name} does not exist")


class ServiceCaller(Thread):
    def __init__(
        self,
        service: str,
        args: dict,
        timeout: float,
        success_callback: Callable[[dict], None],
        error_callback: Callable[[Exception], None],
        node_handle: Node,
    ) -> None:
        """
        Create a service caller for the specified service.

        Use start() to start in a separate thread or run() to run in this thread.

        :param service: The name of the service to call
        :param args: Arguments to pass to the service.  Can be an ordered list, or a dict of
            name-value pairs. Anything else will be treated as though no arguments were provided
            (which is still valid for some kinds of service)
        :param timeout: The time, in seconds, to wait for a response from the server.
            A non-positive value means no timeout.
        :param success_callback: A callback to call with the JSON result of the service call
        :param error_callback: A callback to call if an error occurs. The callback will be passed
            the exception that caused the failure
        :param node_handle: A ROS 2 node handle to call services
        """
        Thread.__init__(self)
        self.daemon = True
        self.service = service
        self.args = args
        self.timeout = timeout
        self.success = success_callback
        self.error = error_callback
        self.node_handle = node_handle

    def run(self) -> None:
        try:
            # Call the service and pass the result to the success handler
            self.success(
                call_service(
                    self.node_handle,
                    self.service,
                    args=self.args,
                    server_response_timeout=self.timeout,
                )
            )
        except Exception as e:
            # On error, just pass the exception to the error handler
            self.error(e)


def args_to_service_request_instance(inst: Any, args: list | dict | None) -> Any:
    """
    Populate a service request instance with the provided args.

    Propagates any exceptions that may be raised.

    :param args: Can be a dictionary of values, or a list, or None
    """
    msg = {}
    if isinstance(args, list):
        msg = dict(zip(inst.get_fields_and_field_types().keys(), args))
    elif isinstance(args, dict):
        msg = args

    # Populate the provided instance, propagating any exceptions
    populate_instance(msg, inst)


def call_service(
    node_handle: Node,
    service: str,
    args: dict | None = None,
    server_ready_timeout: float = 1.0,
    server_response_timeout: float = 5.0,
) -> dict:
    # Get the fully qualified service name with remappings applied
    service = node_handle.resolve_service_name(service)

    # Given the service name, fetch the type and class of the service, and a request instance
    service_names_and_types = dict(node_handle.get_service_names_and_types())
    service_types = service_names_and_types.get(service)
    if service_types is None:
        raise InvalidServiceException(service)

    # service_type is a tuple of types at this point; only one type is supported.
    if len(service_types) > 1:
        node_handle.get_logger().warning(f"More than one service type detected: {service_types}")
    service_type = service_types[0]

    service_class = get_service_class(service_type)
    inst = get_service_request_instance(service_type)

    # Populate the instance with the provided args
    args_to_service_request_instance(inst, args)

    client: Client = node_handle.create_client(
        service_class, service, callback_group=ReentrantCallbackGroup()
    )

    if not client.wait_for_service(server_ready_timeout):
        node_handle.destroy_client(client)
        raise InvalidServiceException(service)

    future = client.call_async(inst)
    event = Event()

    def future_done_callback():
        event.set()

    future.add_done_callback(lambda _: future_done_callback())

    if not event.wait(timeout=(server_response_timeout if server_response_timeout > 0 else None)):
        future.cancel()
        node_handle.destroy_client(client)
        msg = "Timeout exceeded while waiting for service response"
        raise Exception(msg)

    node_handle.destroy_client(client)

    result = future.result()

    if result is not None:
        # Turn the response into JSON and pass to the callback
        json_response = extract_values(result)
    else:
        exception = future.exception()
        raise Exception("Service call exception: " + str(exception))

    return json_response



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/subscribers.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# Copyright (c) 2013, PAL Robotics SL
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

from threading import Lock, RLock

from rclpy.callback_groups import MutuallyExclusiveCallbackGroup
from rclpy.qos import DurabilityPolicy, QoSProfile, ReliabilityPolicy

from rosbridge_library.internal import ros_loader
from rosbridge_library.internal.message_conversion import msg_class_type_repr
from rosbridge_library.internal.outgoing_message import OutgoingMessage
from rosbridge_library.internal.topics import (
    TopicNotEstablishedException,
    TypeConflictException,
)

""" Manages and interfaces with ROS Subscriber objects.  A single subscriber
is shared between multiple clients
"""


class MultiSubscriber:
    """
    Handles multiple clients for a single subscriber.

    Converts msgs to JSON before handing them to callbacks. Due to subscriber
    callbacks being called in separate threads, must lock whenever modifying
    or accessing the subscribed clients.
    """

    def __init__(self, topic, client_id, callback, node_handle, msg_type=None, raw=False):
        """
        Register a subscriber on the specified topic.

        :param topic: The name of the topic to register the subscriber on
        :param client_id The ID of the client subscribing
        :param callback: This client's callback, that will be called for incoming messages
        :param node_handle: Handle to a rclpy node to create the publisher
        :param msg_type: (optional) The type to register the subscriber as.  If not provided, an
            attempt will be made to infer the topic type

        :raises TopicNotEstablishedException: If no msg_type was specified by the caller and the
            topic is not yet established, so a topic type cannot be inferred
        :raises TypeConflictException: If the msg_type was specified by the caller and the topic
            is established, and the established type is different to the user-specified msg_type
        """
        # First check to see if the topic is already established
        topics_names_and_types = dict(node_handle.get_topic_names_and_types())
        topic_type = topics_names_and_types.get(topic)

        # If it's not established and no type was specified, exception
        if msg_type is None and topic_type is None:
            raise TopicNotEstablishedException(topic)

        # topic_type is a list of types or None at this point; only one type is supported.
        if topic_type is not None:
            if len(topic_type) > 1:
                node_handle.get_logger().warning(f"More than one topic type detected: {topic_type}")
            topic_type = topic_type[0]

        # Use the established topic type if none was specified
        if msg_type is None:
            msg_type = topic_type

        # Load the message class, propagating any exceptions from bad msg types
        msg_class = ros_loader.get_message_class(msg_type)

        # Make sure the specified msg type and established msg type are same
        msg_type_string = msg_class_type_repr(msg_class)
        if topic_type is not None and topic_type != msg_type_string:
            raise TypeConflictException(topic, topic_type, msg_type_string)

        # Certain combinations of publisher and subscriber QoS parameters are
        # incompatible. Here we make a "best effort" attempt to match existing
        # publishers for the requested topic. This is not perfect because more
        # publishers may come online after our subscriber is set up, but we try
        # to provide sane defaults.
        # For this reason we use volatile durability and best effort reliability
        # to prioritize topic compatibility when the publisher policy is not known.
        # For more information, see:
        # - https://docs.ros.org/en/rolling/Concepts/About-Quality-of-Service-Settings.html
        # - https://github.com/RobotWebTools/rosbridge_suite/issues/551
        # - https://github.com/RobotWebTools/rosbridge_suite/issues/769
        qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.VOLATILE,
            reliability=ReliabilityPolicy.BEST_EFFORT,
        )

        infos = node_handle.get_publishers_info_by_topic(topic)

        if len(infos) > 0 and all(
            pub.qos_profile.durability == DurabilityPolicy.TRANSIENT_LOCAL for pub in infos
        ):
            qos.durability = DurabilityPolicy.TRANSIENT_LOCAL
            qos.reliability = ReliabilityPolicy.RELIABLE
        if any(pub.qos_profile.reliability == ReliabilityPolicy.BEST_EFFORT for pub in infos):
            qos.reliability = ReliabilityPolicy.BEST_EFFORT

        # Create the subscriber and associated member variables
        # Subscriptions is initialized with the current client to start with.
        self.subscriptions = {client_id: callback}
        self.rlock = RLock()
        self.msg_class = msg_class
        self.node_handle = node_handle
        self.topic = topic
        self.qos = qos
        self.raw = raw
        self.callback_group = MutuallyExclusiveCallbackGroup()

        self.subscriber = node_handle.create_subscription(
            msg_class, topic, self.callback, qos, raw=raw, callback_group=self.callback_group
        )
        self.new_subscriber = None
        self.new_subscriptions = {}

    def unregister(self):
        self.node_handle.destroy_subscription(self.subscriber)
        with self.rlock:
            self.subscriptions.clear()
            if self.new_subscriber:
                self.node_handle.destroy_subscription(self.new_subscriber)
                self.new_subscriber = None

    def verify_type(self, msg_type):
        """
        Verify that the subscriber subscribes to messages of this type.

        :param msg_type: The type to check this subscriber against

        :raises Exception: If ros_loader cannot load the specified msg type
        :raises TypeConflictException: If the msg_type is different than the type of this publisher
        """
        if ros_loader.get_message_class(msg_type) is not self.msg_class:
            raise TypeConflictException(self.topic, msg_class_type_repr(self.msg_class), msg_type)

    def subscribe(self, client_id, callback):
        """
        Subscribe the specified client to this subscriber.

        :param client_id: The ID of the client subscribing
        :param callback: This client's callback, that will be called for incoming messages
        """
        with self.rlock:
            # If the topic is latched, adding a new subscriber will immediately invoke
            # the given callback.
            # In any case, the first message is handled using new_sub_callback,
            # which adds the new callback to the subscriptions dictionary.
            self.new_subscriptions.update({client_id: callback})
            infos = self.node_handle.get_publishers_info_by_topic(self.topic)

            if len(infos) > 0 and all(
                pub.qos_profile.durability == DurabilityPolicy.TRANSIENT_LOCAL for pub in infos
            ):
                self.qos.durability = DurabilityPolicy.TRANSIENT_LOCAL
            if any(pub.qos_profile.reliability == ReliabilityPolicy.BEST_EFFORT for pub in infos):
                self.qos.reliability = ReliabilityPolicy.BEST_EFFORT

            if self.new_subscriber is None:
                self.new_subscriber = self.node_handle.create_subscription(
                    self.msg_class,
                    self.topic,
                    self._new_sub_callback,
                    self.qos,
                    raw=self.raw,
                    callback_group=self.callback_group,
                )

    def unsubscribe(self, client_id):
        """
        Unsubscribe the specified client from this subscriber.

        :param client_id: The ID of the client to unsubscribe
        """
        with self.rlock:
            if client_id in self.new_subscriptions:
                del self.new_subscriptions[client_id]
            if client_id in self.subscriptions:
                del self.subscriptions[client_id]

    def has_subscribers(self):
        """Return true if there are subscribers."""
        with self.rlock:
            return len(self.subscriptions) + len(self.new_subscriptions) != 0

    def callback(self, msg, callbacks=None):
        """
        Handle incoming messages on the rclpy subscription.

        Passes the message to registered subscriber callbacks.

        :param msg: The ROS message coming from the subscriber
        :param callbacks: Subscriber callbacks to invoke
        """
        outgoing = OutgoingMessage(msg)

        with self.rlock:
            callbacks = callbacks or self.subscriptions.values()

            # Pass the JSON to each of the callbacks
            for callback in callbacks:
                try:
                    callback(outgoing)
                except Exception as exc:  # noqa: PERF203
                    # Do nothing if one particular callback fails except log it
                    self.node_handle.get_logger().error(
                        f"Exception calling subscribe callback: {exc}"
                    )

    def _new_sub_callback(self, msg):
        """
        Callbacks for new subscribers.

        If the topic was latched, a new subscriber has to be added to receive
        a new message and route it to the new subscriptor.

        After the first message is routed, the new subscriber is deleted and
        the subscriptions dictionary is updated with the newly incorporated
        subscriptors.
        """
        with self.rlock:
            self.callback(msg, self.new_subscriptions.values())
            self.subscriptions.update(self.new_subscriptions)
            self.new_subscriptions = {}
            self.node_handle.destroy_subscription(self.new_subscriber)
            self.new_subscriber = None


class SubscriberManager:
    """Keeps track of client subscriptions."""

    def __init__(self):
        self._lock = Lock()
        self._subscribers = {}

    def subscribe(self, client_id, topic, callback, node_handle, msg_type=None, raw=False):
        """
        Subscribe to a topic.

        :param client_id: The ID of the client making this subscribe request
        :param topic: The name of the topic to subscribe to
        :param callback: The callback to call for incoming messages on the topic
        :param msg_type: (optional) The type of the topic
        """
        with self._lock:
            if topic not in self._subscribers:
                self._subscribers[topic] = MultiSubscriber(
                    topic, client_id, callback, node_handle, msg_type=msg_type, raw=raw
                )
            else:
                self._subscribers[topic].subscribe(client_id, callback)

            if msg_type is not None and not raw:
                self._subscribers[topic].verify_type(msg_type)

    def unsubscribe(self, client_id, topic):
        """
        Unsubscribe from a topic.

        :param client_id: The ID of the client to unsubscribe
        :param topic: The topic to unsubscribe from
        """
        with self._lock:
            if topic not in self._subscribers:
                return

            self._subscribers[topic].unsubscribe(client_id)

            if not self._subscribers[topic].has_subscribers():
                self._subscribers[topic].unregister()
                del self._subscribers[topic]


manager = SubscriberManager()



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/subscription_modifiers.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import sys
import time
import traceback
from collections import deque
from threading import Condition, Thread

""" Sits between incoming messages from a subscription, and the outgoing
publish method.  Provides throttling / buffering capabilities.

When the parameters change, the handler may transition to a different kind
of handler
"""


class MessageHandler:
    def __init__(self, previous_handler=None, publish=None):
        if previous_handler:
            self.last_publish = previous_handler.last_publish
            self.throttle_rate = previous_handler.throttle_rate
            self.queue_length = previous_handler.queue_length
            self.publish = previous_handler.publish
        else:
            self.last_publish = 0
            self.throttle_rate = 0
            self.queue_length = 0
            self.publish = publish

    def set_throttle_rate(self, throttle_rate):
        self.throttle_rate = throttle_rate / 1000.0
        return self.transition()

    def set_queue_length(self, queue_length):
        self.queue_length = queue_length
        return self.transition()

    def time_remaining(self):
        return max((self.last_publish + self.throttle_rate) - time.monotonic(), 0)

    def handle_message(self, msg):
        self.last_publish = time.monotonic()
        self.publish(msg)

    def transition(self):
        if self.queue_length > 0:
            return QueueMessageHandler(self)
        if self.throttle_rate > 0:
            return ThrottleMessageHandler(self)
        return self

    def finish(self, block=True):
        pass


class ThrottleMessageHandler(MessageHandler):
    def handle_message(self, msg):
        if self.time_remaining() == 0:
            MessageHandler.handle_message(self, msg)

    def transition(self):
        if self.queue_length > 0:
            return QueueMessageHandler(self)
        if self.throttle_rate > 0:
            return self
        return MessageHandler(self)

    def finish(self, block=True):
        pass


class QueueMessageHandler(MessageHandler, Thread):
    def __init__(self, previous_handler):
        Thread.__init__(self)
        MessageHandler.__init__(self, previous_handler)
        self.daemon = True
        self.queue = deque(maxlen=self.queue_length)
        self.c = Condition()
        self.alive = True
        self.start()

    def handle_message(self, msg):
        with self.c:
            if not self.alive:
                return
            should_notify = len(self.queue) == 0
            self.queue.append(msg)
            if should_notify:
                self.c.notify()

    def transition(self):
        if self.queue_length > 0:
            with self.c:
                old_queue = self.queue
                self.queue = deque(maxlen=self.queue_length)
                while len(old_queue) > 0:
                    self.queue.append(old_queue.popleft())
                self.c.notify()
                return self
        self.finish()
        if self.throttle_rate > 0:
            return ThrottleMessageHandler(self)
        return MessageHandler(self)

    def finish(self, block=True):
        """
        Notify the thread to finish, and optionally wait for it to finish.

        If throttle was set to 0, this pushes all buffered messages.

        :param block: If True, wait for the thread to finish before returning
        """
        # Notify the thread to finish
        with self.c:
            self.alive = False
            self.c.notify()

        if block:
            self.join()

    def run(self):
        while self.alive:
            msg = None
            with self.c:
                if len(self.queue) == 0:
                    self.c.wait()
                else:
                    self.c.wait(self.time_remaining())
                if self.alive and self.time_remaining() == 0 and len(self.queue) > 0:
                    msg = self.queue.popleft()
            if msg is not None:
                try:
                    MessageHandler.handle_message(self, msg)
                except Exception:
                    traceback.print_exc(file=sys.stderr)
        while self.time_remaining() == 0 and len(self.queue) > 0:
            try:
                msg = self.queue.popleft()
                MessageHandler.handle_message(self, msg)
            except Exception:  # noqa: PERF203
                traceback.print_exc(file=sys.stderr)



================================================
FILE: rosbridge_library/src/rosbridge_library/internal/topics.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""Exceptions and code common to both publishers and subscribers."""


class TopicNotEstablishedException(Exception):
    def __init__(self, topic):
        Exception.__init__(
            self,
            f"Cannot infer topic type for topic {topic} as it is not yet advertised",
        )


class TypeConflictException(Exception):
    def __init__(self, topic, orig_type, new_type):
        Exception.__init__(
            self,
            f"Tried to register topic {topic} with type {new_type} but it is already established with type {orig_type}",
        )



================================================
FILE: rosbridge_library/src/rosbridge_library/util/__init__.py
================================================
# try to import json-lib: 1st try ujson, 2nd try simplejson, else import standard Python json
try:
    import ujson as json  # type: ignore[import-untyped]
except ImportError:
    try:
        import simplejson as json  # type: ignore[import-untyped]
    except ImportError:
        import json  # noqa: F401

import bson

try:
    _ = bson.BSON
except AttributeError as exc:
    msg = (
        "BSON installation does not support all necessary features. "
        "Please use the MongoDB BSON implementation. "
        "See: https://github.com/RobotWebTools/rosbridge_suite/issues/198"
    )
    raise Exception(msg) from exc



================================================
FILE: rosbridge_library/src/rosbridge_library/util/cbor.py
================================================
# -*- Python -*-
# Copyright 2014-2015 Brian Olson
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import re
import struct
from io import BytesIO

CBOR_TYPE_MASK = 0xE0  # top 3 bits
CBOR_INFO_BITS = 0x1F  # low 5 bits


CBOR_UINT = 0x00
CBOR_NEGINT = 0x20
CBOR_BYTES = 0x40
CBOR_TEXT = 0x60
CBOR_ARRAY = 0x80
CBOR_MAP = 0xA0
CBOR_TAG = 0xC0
CBOR_7 = 0xE0  # float and other types

CBOR_UINT8_FOLLOWS = 24  # 0x18
CBOR_UINT16_FOLLOWS = 25  # 0x19
CBOR_UINT32_FOLLOWS = 26  # 0x1a
CBOR_UINT64_FOLLOWS = 27  # 0x1b
CBOR_VAR_FOLLOWS = 31  # 0x1f

CBOR_BREAK = 0xFF

CBOR_FALSE = CBOR_7 | 20
CBOR_TRUE = CBOR_7 | 21
CBOR_NULL = CBOR_7 | 22
CBOR_UNDEFINED = CBOR_7 | 23  # js 'undefined' value

CBOR_FLOAT16 = CBOR_7 | 25
CBOR_FLOAT32 = CBOR_7 | 26
CBOR_FLOAT64 = CBOR_7 | 27

CBOR_TAG_DATE_STRING = 0  # RFC3339
CBOR_TAG_DATE_ARRAY = 1  # any number type follows, seconds since 1970-01-01T00:00:00 UTC
CBOR_TAG_BIGNUM = 2  # big endian byte string follows
CBOR_TAG_NEGBIGNUM = 3  # big endian byte string follows
CBOR_TAG_DECIMAL = 4  # [ 10^x exponent, number ]
CBOR_TAG_BIGFLOAT = 5  # [ 2^x exponent, number ]
CBOR_TAG_BASE64URL = 21
CBOR_TAG_BASE64 = 22
CBOR_TAG_BASE16 = 23
CBOR_TAG_CBOR = 24  # following byte string is embedded CBOR data

CBOR_TAG_URI = 32
CBOR_TAG_BASE64URL = 33
CBOR_TAG_BASE64 = 34
CBOR_TAG_REGEX = 35
CBOR_TAG_MIME = 36  # following text is MIME message, headers, separators and all
CBOR_TAG_CBOR_FILEHEADER = 55799  # can open a file with 0xd9d9f7

_CBOR_TAG_BIGNUM_BYTES = struct.pack("B", CBOR_TAG | CBOR_TAG_BIGNUM)


def dumps_int(val):
    """Return bytes representing int val in CBOR."""
    if val >= 0:
        # CBOR_UINT is 0, so I'm lazy/efficient about not OR-ing it in.
        if val <= 23:
            return struct.pack("B", val)
        if val <= 0x0FF:
            return struct.pack("BB", CBOR_UINT8_FOLLOWS, val)
        if val <= 0x0FFFF:
            return struct.pack("!BH", CBOR_UINT16_FOLLOWS, val)
        if val <= 0x0FFFFFFFF:
            return struct.pack("!BI", CBOR_UINT32_FOLLOWS, val)
        if val <= 0x0FFFFFFFFFFFFFFFF:
            return struct.pack("!BQ", CBOR_UINT64_FOLLOWS, val)
        outb = _dumps_bignum_to_bytearray(val)
        return _CBOR_TAG_BIGNUM_BYTES + _encode_type_num(CBOR_BYTES, len(outb)) + outb
    val = -1 - val
    return _encode_type_num(CBOR_NEGINT, val)


def _dumps_bignum_to_bytearray(val):
    out = []
    while val > 0:
        out.insert(0, val & 0x0FF)
        val = val >> 8
    return bytes(out)


def dumps_float(val):
    return struct.pack("!Bd", CBOR_FLOAT64, val)


_CBOR_TAG_NEGBIGNUM_BYTES = struct.pack("B", CBOR_TAG | CBOR_TAG_NEGBIGNUM)


def _encode_type_num(cbor_type, val):
    """For some CBOR primary type [0..7] and an auxiliary unsigned number, return CBOR encoded bytes."""
    assert val >= 0
    if val <= 23:
        return struct.pack("B", cbor_type | val)
    if val <= 0x0FF:
        return struct.pack("BB", cbor_type | CBOR_UINT8_FOLLOWS, val)
    if val <= 0x0FFFF:
        return struct.pack("!BH", cbor_type | CBOR_UINT16_FOLLOWS, val)
    if val <= 0x0FFFFFFFF:
        return struct.pack("!BI", cbor_type | CBOR_UINT32_FOLLOWS, val)
    if ((cbor_type == CBOR_NEGINT) and (val <= 0x07FFFFFFFFFFFFFFF)) or (
        (cbor_type != CBOR_NEGINT) and (val <= 0x0FFFFFFFFFFFFFFFF)
    ):
        return struct.pack("!BQ", cbor_type | CBOR_UINT64_FOLLOWS, val)
    if cbor_type != CBOR_NEGINT:
        msg = f"value too big for CBOR unsigned number: {val!r}"
        raise Exception(msg)
    outb = _dumps_bignum_to_bytearray(val)
    return _CBOR_TAG_NEGBIGNUM_BYTES + _encode_type_num(CBOR_BYTES, len(outb)) + outb


def _is_unicode(val):
    return isinstance(val, str)


def dumps_string(val, is_text=None, is_bytes=None):
    if _is_unicode(val):
        val = val.encode("utf8")
        is_text = True
        is_bytes = False
    if is_bytes or is_text is not True:
        return _encode_type_num(CBOR_BYTES, len(val)) + val
    return _encode_type_num(CBOR_TEXT, len(val)) + val


def dumps_array(arr, sort_keys=False):
    head = _encode_type_num(CBOR_ARRAY, len(arr))
    parts = [dumps(x, sort_keys=sort_keys) for x in arr]
    return head + b"".join(parts)


def dumps_dict(d, sort_keys=False):
    head = _encode_type_num(CBOR_MAP, len(d))
    parts = [head]
    if sort_keys:
        for k in sorted(d.keys()):
            v = d[k]
            parts.append(dumps(k, sort_keys=sort_keys))
            parts.append(dumps(v, sort_keys=sort_keys))
    else:
        for k, v in d.items():
            parts.append(dumps(k, sort_keys=sort_keys))
            parts.append(dumps(v, sort_keys=sort_keys))
    return b"".join(parts)


def dumps_bool(b):
    if b:
        return struct.pack("B", CBOR_TRUE)
    return struct.pack("B", CBOR_FALSE)


def dumps_tag(t, sort_keys=False):
    return _encode_type_num(CBOR_TAG, t.tag) + dumps(t.value, sort_keys=sort_keys)


def _is_stringish(x):
    return isinstance(x, (str, bytes))


def _is_intish(x):
    return isinstance(x, int)


def dumps(ob, sort_keys=False):
    if ob is None:
        return struct.pack("B", CBOR_NULL)
    if isinstance(ob, bool):
        return dumps_bool(ob)
    if _is_stringish(ob):
        return dumps_string(ob)
    if isinstance(ob, (list, tuple)):
        return dumps_array(ob, sort_keys=sort_keys)
    # TODO: accept other enumerables and emit a variable length array
    if isinstance(ob, dict):
        return dumps_dict(ob, sort_keys=sort_keys)
    if isinstance(ob, float):
        return dumps_float(ob)
    if _is_intish(ob):
        return dumps_int(ob)
    if isinstance(ob, Tag):
        return dumps_tag(ob, sort_keys=sort_keys)
    msg = "don't know how to cbor serialize object of type %s"
    raise Exception(msg, type(ob))


# same basic signature as json.dump, but with no options (yet)
def dump(obj, fp, sort_keys=False):
    """
    Serialize obj to CBOR and write it to fp.

    :param obj: Python object to serialize
    :param fp: file-like object capable of .write(bytes)
    """
    # this is kinda lame, but probably not inefficient for non-huge objects
    # TODO: .write() to fp as we go as each inner object is serialized
    blob = dumps(obj, sort_keys=sort_keys)
    fp.write(blob)


class Tag:
    def __init__(self, tag=None, value=None):
        self.tag = tag
        self.value = value

    def __repr__(self):
        return f"Tag({self.tag!r}, {self.value!r})"

    def __eq__(self, other):
        if not isinstance(other, Tag):
            return False
        return (self.tag == other.tag) and (self.value == other.value)

    def __hash__(self):
        return hash((self.tag, self.value))


def loads(data):
    """Parse CBOR bytes and return Python objects."""
    if data is None:
        msg = "got None for buffer to decode in loads"
        raise ValueError(msg)
    fp = BytesIO(data)
    return _loads(fp)[0]


def load(fp):
    """Parse and return object from fp, a file-like object supporting .read(n)."""
    return _loads(fp)[0]


_MAX_DEPTH = 100


def _tag_aux(fp, tb):
    bytes_read = 1
    tag = tb & CBOR_TYPE_MASK
    tag_aux = tb & CBOR_INFO_BITS
    if tag_aux <= 23:
        aux = tag_aux
    elif tag_aux == CBOR_UINT8_FOLLOWS:
        data = fp.read(1)
        aux = struct.unpack_from("!B", data, 0)[0]
        bytes_read += 1
    elif tag_aux == CBOR_UINT16_FOLLOWS:
        data = fp.read(2)
        aux = struct.unpack_from("!H", data, 0)[0]
        bytes_read += 2
    elif tag_aux == CBOR_UINT32_FOLLOWS:
        data = fp.read(4)
        aux = struct.unpack_from("!I", data, 0)[0]
        bytes_read += 4
    elif tag_aux == CBOR_UINT64_FOLLOWS:
        data = fp.read(8)
        aux = struct.unpack_from("!Q", data, 0)[0]
        bytes_read += 8
    else:
        assert tag_aux == CBOR_VAR_FOLLOWS, f"bogus tag {tb:02x}"
        aux = None

    return tag, tag_aux, aux, bytes_read


def _read_byte(fp):
    tb = fp.read(1)
    if len(tb) == 0:
        # I guess not all file-like objects do this
        raise EOFError
    return ord(tb)


def _loads_var_array(fp, limit, depth, returntags, bytes_read):
    ob = []
    tb = _read_byte(fp)
    while tb != CBOR_BREAK:
        (subob, sub_len) = _loads_tb(fp, tb, limit, depth, returntags)
        bytes_read += 1 + sub_len
        ob.append(subob)
        tb = _read_byte(fp)
    return (ob, bytes_read + 1)


def _loads_var_map(fp, limit, depth, returntags, bytes_read):
    ob = {}
    tb = _read_byte(fp)
    while tb != CBOR_BREAK:
        (subk, sub_len) = _loads_tb(fp, tb, limit, depth, returntags)
        bytes_read += 1 + sub_len
        (subv, sub_len) = _loads(fp, limit, depth, returntags)
        bytes_read += sub_len
        ob[subk] = subv
        tb = _read_byte(fp)
    return (ob, bytes_read + 1)


def _loads_array(fp, _limit, _depth, _returntags, aux, bytes_read):
    ob = []
    for _ in range(aux):
        subob, subpos = _loads(fp)
        bytes_read += subpos
        ob.append(subob)
    return ob, bytes_read


def _loads_map(fp, _limit, _depth, _returntags, aux, bytes_read):
    ob = {}
    for _ in range(aux):
        subk, subpos = _loads(fp)
        bytes_read += subpos
        subv, subpos = _loads(fp)
        bytes_read += subpos
        ob[subk] = subv
    return ob, bytes_read


def _loads(fp, limit=None, depth=0, returntags=False):
    """Return (object, bytes read)."""
    if depth > _MAX_DEPTH:
        msg = "hit CBOR loads recursion depth limit"
        raise Exception(msg)

    tb = _read_byte(fp)

    return _loads_tb(fp, tb, limit, depth, returntags)


def _loads_tb(fp, tb, limit=None, depth=0, returntags=False):
    # Some special cases of CBOR_7 best handled by special struct.unpack logic here
    if tb == CBOR_FLOAT16:
        data = fp.read(2)
        hibyte, lowbyte = struct.unpack_from("BB", data, 0)
        exp = (hibyte >> 2) & 0x1F
        mant = ((hibyte & 0x03) << 8) | lowbyte
        if exp == 0:
            val = mant * (2.0**-24)
        elif exp == 31:
            if mant == 0:
                val = float("Inf")
            else:
                val = float("NaN")
        else:
            val = (mant + 1024.0) * (2 ** (exp - 25))
        if hibyte & 0x80:
            val = -1.0 * val
        return (val, 3)
    if tb == CBOR_FLOAT32:
        data = fp.read(4)
        pf = struct.unpack_from("!f", data, 0)
        return (pf[0], 5)
    if tb == CBOR_FLOAT64:
        data = fp.read(8)
        pf = struct.unpack_from("!d", data, 0)
        return (pf[0], 9)

    tag, tag_aux, aux, bytes_read = _tag_aux(fp, tb)

    if tag == CBOR_UINT:
        return (aux, bytes_read)
    if tag == CBOR_NEGINT:
        return (-1 - aux, bytes_read)
    if tag == CBOR_BYTES:
        ob, subpos = loads_bytes(fp, aux)
        return (ob, bytes_read + subpos)
    if tag == CBOR_TEXT:
        raw, subpos = loads_bytes(fp, aux, btag=CBOR_TEXT)
        ob = raw.decode("utf8")
        return (ob, bytes_read + subpos)
    if tag == CBOR_ARRAY:
        if aux is None:
            return _loads_var_array(fp, limit, depth, returntags, bytes_read)
        return _loads_array(fp, limit, depth, returntags, aux, bytes_read)
    if tag == CBOR_MAP:
        if aux is None:
            return _loads_var_map(fp, limit, depth, returntags, bytes_read)
        return _loads_map(fp, limit, depth, returntags, aux, bytes_read)
    if tag == CBOR_TAG:
        ob, subpos = _loads(fp)
        bytes_read += subpos
        if returntags:
            # Don't interpret the tag, return it and the tagged object.
            ob = Tag(aux, ob)
        else:
            # attempt to interpret the tag and the value into a Python object.
            ob = tagify(ob, aux)
        return ob, bytes_read
    if tag == CBOR_7:
        if tb == CBOR_TRUE:
            return (True, bytes_read)
        if tb == CBOR_FALSE:
            return (False, bytes_read)
        if tb == CBOR_NULL:
            return (None, bytes_read)
        if tb == CBOR_UNDEFINED:
            return (None, bytes_read)
        msg = f"unknown cbor tag 7 byte: {tb:02x}"
        raise ValueError(msg)
    return None


def loads_bytes(fp, aux, btag=CBOR_BYTES):
    # TODO: limit to some maximum number of chunks and some maximum total bytes
    if aux is not None:
        # simple case
        ob = fp.read(aux)
        return (ob, aux)
    # read chunks of bytes
    chunklist = []
    total_bytes_read = 0
    while True:
        tb = fp.read(1)[0]
        if tb == CBOR_BREAK:
            total_bytes_read += 1
            break
        tag, tag_aux, aux, bytes_read = _tag_aux(fp, tb)
        assert tag == btag, "variable length value contains unexpected component"
        ob = fp.read(aux)
        chunklist.append(ob)
        total_bytes_read += bytes_read + aux
    return (b"".join(chunklist), total_bytes_read)


def _bytes_to_biguint(bs):
    out = 0
    for ch in bs:
        out = out << 8
        out = out | ch
    return out


def tagify(ob, aux):
    # TODO: make this extensible?
    # cbor.register_tag_handler(tagnumber, tag_handler)
    # where tag_handler takes (tagnumber, tagged_object)
    if aux == CBOR_TAG_DATE_STRING:
        # TODO: parse RFC3339 date string
        pass
    if aux == CBOR_TAG_DATE_ARRAY:
        return datetime.datetime.fromtimestamp(ob, tz=datetime.timezone.utc)
    if aux == CBOR_TAG_BIGNUM:
        return _bytes_to_biguint(ob)
    if aux == CBOR_TAG_NEGBIGNUM:
        return -1 - _bytes_to_biguint(ob)
    if aux == CBOR_TAG_REGEX:
        # Is this actually a good idea? Should we just return the tag and the raw value to the user somehow?
        return re.compile(ob)
    return Tag(aux, ob)



================================================
FILE: rosbridge_library/src/rosbridge_library/util/ros.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2023, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


def is_topic_published(node, topic_name):
    """Check if a topic is published on a node."""
    published_topic_data = node.get_publisher_names_and_types_by_node(
        node.get_name(), node.get_namespace()
    )
    return any(topic[0] == topic_name for topic in published_topic_data)


def is_topic_subscribed(node, topic_name):
    """Check if a topic is subscribed to by a node."""
    subscribed_topic_data = node.get_subscriber_names_and_types_by_node(
        node.get_name(), node.get_namespace()
    )
    return any(topic[0] == topic_name for topic in subscribed_topic_data)



================================================
FILE: rosbridge_library/test/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/test/test_all.test
================================================
<launch>
  <include file="$(find rosbridge_library)/test/capabilities/test_capabilities.test" />
  <include file="$(find rosbridge_library)/test/internal/test_internal.test" />
</launch>



================================================
FILE: rosbridge_library/test/capabilities/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/test/capabilities/test_action_capabilities.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from action_msgs.msg import GoalStatus
from example_interfaces.action._fibonacci import Fibonacci_FeedbackMessage
from rclpy.executors import MultiThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile, ReliabilityPolicy

from rosbridge_library.capabilities.action_feedback import ActionFeedback
from rosbridge_library.capabilities.action_result import ActionResult
from rosbridge_library.capabilities.advertise_action import AdvertiseAction
from rosbridge_library.capabilities.send_action_goal import SendActionGoal
from rosbridge_library.capabilities.unadvertise_action import UnadvertiseAction
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.protocol import Protocol


class TestActionCapabilities(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = MultiThreadedExecutor()
        self.node = Node("test_action_capabilities")
        self.executor.add_node(self.node)

        self.node.declare_parameter("call_services_in_new_thread", False)
        self.node.declare_parameter("send_action_goals_in_new_thread", False)

        self.proto = Protocol(self._testMethodName, self.node)
        # change the log function so we can verify errors are logged
        self.proto.log = self.mock_log
        # change the send callback so we can access the rosbridge messages
        # being sent
        self.proto.send = self.local_send_cb
        self.advertise = AdvertiseAction(self.proto)
        self.unadvertise = UnadvertiseAction(self.proto)
        self.result = ActionResult(self.proto)
        self.send_goal = SendActionGoal(self.proto)
        self.feedback = ActionFeedback(self.proto)
        self.received_message = None
        self.log_entries = []

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.executor.shutdown()
        rclpy.shutdown()

    def local_send_cb(self, msg):
        self.received_message = msg

    def feedback_subscriber_cb(self, msg):
        self.latest_feedback = msg

    def mock_log(self, loglevel, message, _=None):
        self.log_entries.append((loglevel, message))

    def test_advertise_missing_arguments(self):
        advertise_msg = loads(dumps({"op": "advertise_action"}))
        self.assertRaises(MissingArgumentException, self.advertise.advertise_action, advertise_msg)

    def test_advertise_invalid_arguments(self):
        advertise_msg = loads(dumps({"op": "advertise_action", "type": 42, "action": None}))
        self.assertRaises(InvalidArgumentException, self.advertise.advertise_action, advertise_msg)

    def test_result_missing_arguments(self):
        result_msg = loads(dumps({"op": "action_result"}))
        self.assertRaises(MissingArgumentException, self.result.action_result, result_msg)

        # this message has the optional fields, with correct types, but not the
        # required ones
        result_msg = loads(dumps({"op": "action_result", "id": "dummy_action", "values": "none"}))
        self.assertRaises(MissingArgumentException, self.result.action_result, result_msg)

    def test_result_invalid_arguments(self):
        result_msg = loads(dumps({"op": "action_result", "action": 5, "result": "error"}))
        self.assertRaises(InvalidArgumentException, self.result.action_result, result_msg)

    def test_advertise_action(self):
        action_path = "/fibonacci_action_1"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_action",
                    "type": "example_interfaces/Fibonacci",
                    "action": action_path,
                }
            )
        )
        self.advertise.advertise_action(advertise_msg)

    def test_execute_advertised_action(self):
        # Advertise the action
        action_path = "/fibonacci_action_2"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_action",
                    "type": "example_interfaces/Fibonacci",
                    "action": action_path,
                }
            )
        )
        self.advertise.advertise_action(advertise_msg)
        time.sleep(0.1)

        # Send a goal to the advertised action using rosbridge
        self.received_message = None
        goal_msg = loads(
            dumps(
                {
                    "op": "send_action_goal",
                    "id": "foo2",
                    "action": action_path,
                    "action_type": "example_interfaces/Fibonacci",
                    "args": {"order": 5},
                }
            )
        )
        Thread(target=self.send_goal.send_action_goal, args=(goal_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action goal message.")

        self.assertIsNotNone(self.received_message)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "send_action_goal")
        self.assertTrue("id" in self.received_message)

        # Send feedback message
        self.latest_feedback = None
        sub_qos_profile = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.VOLATILE,
            reliability=ReliabilityPolicy.RELIABLE,
        )
        self.subscription = self.node.create_subscription(
            Fibonacci_FeedbackMessage,
            f"{action_path}/_action/feedback",
            self.feedback_subscriber_cb,
            sub_qos_profile,
        )
        time.sleep(0.1)
        feedback_msg = loads(
            dumps(
                {
                    "op": "action_feedback",
                    "action": action_path,
                    "id": self.received_message["id"],
                    "values": {"sequence": [0, 1, 1]},
                }
            )
        )
        self.feedback.action_feedback(feedback_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            # self.executor.spin_once(timeout_sec=0.1)
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action feedback message.")

        start_time = time.monotonic()
        while self.latest_feedback is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action feedback callback.")

        self.assertEqual(list(self.latest_feedback.feedback.sequence), [0, 1, 1])

        # Now send the result
        result_msg = loads(
            dumps(
                {
                    "op": "action_result",
                    "action": action_path,
                    "id": self.received_message["id"],
                    "values": {"sequence": [0, 1, 1, 2, 3, 5]},
                    "status": GoalStatus.STATUS_SUCCEEDED,
                    "result": True,
                }
            )
        )
        self.received_message = None
        self.result.action_result(result_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action result message.")

        self.assertIsNotNone(self.received_message)
        self.assertEqual(self.received_message["op"], "action_result")
        self.assertEqual(self.received_message["values"]["sequence"], [0, 1, 1, 2, 3, 5])
        self.assertEqual(self.received_message["status"], GoalStatus.STATUS_SUCCEEDED)

    def test_cancel_advertised_action(self):
        # Advertise the action
        action_path = "/fibonacci_action_3"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_action",
                    "type": "example_interfaces/Fibonacci",
                    "action": action_path,
                }
            )
        )
        self.advertise.advertise_action(advertise_msg)
        time.sleep(0.1)

        # Send a goal to the advertised action using rosbridge
        self.received_message = None
        goal_msg = loads(
            dumps(
                {
                    "op": "send_action_goal",
                    "id": "foo3",
                    "action": action_path,
                    "action_type": "example_interfaces/Fibonacci",
                    "args": {"order": 5},
                }
            )
        )
        Thread(target=self.send_goal.send_action_goal, args=(goal_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action goal message.")

        self.assertIsNotNone(self.received_message)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "send_action_goal")
        self.assertTrue("id" in self.received_message)

        # Now cancel the goal
        cancel_msg = loads(
            dumps(
                {
                    "op": "cancel_action_goal",
                    "action": action_path,
                    "id": "foo3",
                }
            )
        )
        self.received_message = None
        self.send_goal.cancel_action_goal(cancel_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for cancel action message.")

        self.assertIsNotNone(self.received_message)
        self.assertEqual(self.received_message["op"], "cancel_action_goal")

        # Now send the cancel result
        result_msg = loads(
            dumps(
                {
                    "op": "action_result",
                    "action": action_path,
                    "id": self.received_message["id"],
                    "values": {"sequence": []},
                    "status": GoalStatus.STATUS_CANCELED,
                    "result": True,
                }
            )
        )
        self.received_message = None
        self.result.action_result(result_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action result message.")

        self.assertIsNotNone(self.received_message)
        self.assertEqual(self.received_message["op"], "action_result")
        self.assertEqual(self.received_message["values"]["sequence"], [])
        self.assertEqual(self.received_message["status"], GoalStatus.STATUS_CANCELED)

    def test_unadvertise_action(self):
        # Advertise the action
        action_path = "/fibonacci_action_4"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_action",
                    "type": "example_interfaces/Fibonacci",
                    "action": action_path,
                }
            )
        )
        self.received_message = None
        self.advertise.advertise_action(advertise_msg)
        time.sleep(0.1)

        # Send a goal to the advertised action using rosbridge
        self.received_message = None
        goal_msg = loads(
            dumps(
                {
                    "op": "send_action_goal",
                    "id": "foo4",
                    "action": action_path,
                    "action_type": "example_interfaces/Fibonacci",
                    "args": {"order": 5},
                }
            )
        )
        Thread(target=self.send_goal.send_action_goal, args=(goal_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for action goal message.")

        self.assertIsNotNone(self.received_message)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "send_action_goal")
        self.assertTrue("id" in self.received_message)

        # Now unadvertise the action
        unadvertise_msg = loads(dumps({"op": "unadvertise_action", "action": action_path}))
        self.received_message = None
        self.unadvertise.unadvertise_action(unadvertise_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            time.sleep(0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for unadvertise action message.")


if __name__ == "__main__":
    unittest.main()



================================================
FILE: rosbridge_library/test/capabilities/test_advertise.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node

from rosbridge_library.capabilities.advertise import Advertise
from rosbridge_library.internal import ros_loader
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.internal.publishers import manager
from rosbridge_library.protocol import Protocol
from rosbridge_library.util.ros import is_topic_published


class TestAdvertise(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_advertise")
        self.executor.add_node(self.node)
        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

        manager.unregister_timeout = 1.0

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_missing_arguments(self):
        proto = Protocol("hello", self.node)
        adv = Advertise(proto)
        msg = {"op": "advertise"}
        self.assertRaises(MissingArgumentException, adv.advertise, loads(dumps(msg)))

        msg = {"op": "advertise", "topic": "/jon"}
        self.assertRaises(MissingArgumentException, adv.advertise, loads(dumps(msg)))

        msg = {"op": "advertise", "type": "std_msgs/String"}
        self.assertRaises(MissingArgumentException, adv.advertise, loads(dumps(msg)))

    def test_invalid_arguments(self):
        proto = Protocol("hello", self.node)
        adv = Advertise(proto)

        msg = {"op": "advertise", "topic": 3, "type": "std_msgs/String"}
        self.assertRaises(InvalidArgumentException, adv.advertise, loads(dumps(msg)))

        msg = {"op": "advertise", "topic": "/jon", "type": 3}
        self.assertRaises(InvalidArgumentException, adv.advertise, loads(dumps(msg)))

    def test_invalid_msg_typestrings(self):
        invalid = [
            "",
            "/",
            "//",
            "///",
            "////",
            "/////",
            "bad",
            "stillbad",
            "better/",
            "better//",
            "better///",
            "/better",
            "//better",
            "///better",
            r"this\isbad",
            "\\",
        ]

        proto = Protocol("hello", self.node)
        adv = Advertise(proto)

        for invalid_type in invalid:
            msg = {
                "op": "advertise",
                "topic": "/test_invalid_msg_typestrings",
                "type": invalid_type,
            }
            self.assertRaises(
                ros_loader.InvalidTypeStringException, adv.advertise, loads(dumps(msg))
            )

    def test_invalid_msg_package(self):
        nonexistent = [
            "roslib/Time",
            "roslib/Duration",
            "roslib/Header",
            "std_srvs/ConflictedMsg",
            "topic_tools/MessageMessage",
            "wangle_msgs/Jam",
            "whistleblower_msgs/Document",
            "coercion_msgs/Bribe",
            "airconditioning_msgs/Cold",
            "pr2thoughts_msgs/Escape",
        ]

        proto = Protocol("hello", self.node)
        adv = Advertise(proto)

        for invalid_type in nonexistent:
            msg = {
                "op": "advertise",
                "topic": "/test_invalid_msg_package",
                "type": invalid_type,
            }
            self.assertRaises(ros_loader.InvalidModuleException, adv.advertise, loads(dumps(msg)))

    def test_invalid_msg_classes(self):
        nonexistent = [
            "builtin_interfaces/SpaceTime",
            "std_msgs/Spool",
            "geometry_msgs/Tetrahedron",
            "sensor_msgs/TelepathyUnit",
        ]

        proto = Protocol("hello", self.node)
        adv = Advertise(proto)

        for invalid_type in nonexistent:
            msg = {
                "op": "advertise",
                "topic": "/test_invalid_msg_classes",
                "type": invalid_type,
            }
            self.assertRaises(ros_loader.InvalidClassException, adv.advertise, loads(dumps(msg)))

    def test_valid_msg_classes(self):
        assortedmsgs = [
            "geometry_msgs/Pose",
            "action_msgs/GoalStatus",
            "geometry_msgs/WrenchStamped",
            "stereo_msgs/DisparityImage",
            "nav_msgs/OccupancyGrid",
            "geometry_msgs/Point32",
            "std_msgs/String",
            "trajectory_msgs/JointTrajectoryPoint",
            "diagnostic_msgs/KeyValue",
            "visualization_msgs/InteractiveMarkerUpdate",
            "nav_msgs/GridCells",
            "sensor_msgs/PointCloud2",
        ]

        proto = Protocol("hello", self.node)
        adv = Advertise(proto)

        for valid_type in assortedmsgs:
            msg = {"op": "advertise", "topic": "/" + valid_type, "type": valid_type}
            adv.advertise(loads(dumps(msg)))
            adv.unadvertise(loads(dumps(msg)))

    def test_do_advertise(self):
        proto = Protocol("hello", self.node)
        adv = Advertise(proto)
        topic = "/test_do_advertise"
        type_name = "std_msgs/String"

        msg = {"op": "advertise", "topic": topic, "type": type_name}
        adv.advertise(loads(dumps(msg)))
        self.assertTrue(is_topic_published(self.node, topic))
        adv.unadvertise(loads(dumps(msg)))
        self.assertTrue(is_topic_published(self.node, topic))
        time.sleep(manager.unregister_timeout + 1.0)
        self.assertFalse(is_topic_published(self.node, topic))



================================================
FILE: rosbridge_library/test/capabilities/test_call_service.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from std_srvs.srv import SetBool, Trigger

from rosbridge_library.capabilities.call_service import CallService
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.protocol import Protocol


class TestCallService(unittest.TestCase):
    def trigger_cb(self, _request, response):
        """Handle request for a test service with no arguments."""
        response.success = True
        response.message = "called trigger service successfully"
        return response

    def trigger_long_cb(self, _request, response):
        """Handle request for a long running test service with no arguments."""
        time.sleep(0.5)
        response.success = True
        response.message = "called trigger service successfully"
        return response

    def set_bool_cb(self, request, response):
        """Handle request for a test service with arguments."""
        response.success = request.data
        if request.data:
            response.message = "set bool to true"
        else:
            response.message = "set bool to false"
        return response

    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_call_service")
        self.executor.add_node(self.node)

        self.node.declare_parameter("call_services_in_new_thread", False)
        self.node.declare_parameter("default_call_service_timeout", 5.0)
        self.node.declare_parameter("send_action_goals_in_new_thread", False)

        # Create service servers with a separate callback group
        self.cb_group = ReentrantCallbackGroup()
        self.trigger_srv = self.node.create_service(
            Trigger,
            self.node.get_name() + "/trigger",
            self.trigger_cb,
            callback_group=self.cb_group,
        )
        self.trigger_long_srv = self.node.create_service(
            Trigger,
            self.node.get_name() + "/trigger_long",
            self.trigger_long_cb,
            callback_group=self.cb_group,
        )
        self.set_bool_srv = self.node.create_service(
            SetBool,
            self.node.get_name() + "/set_bool",
            self.set_bool_cb,
            callback_group=self.cb_group,
        )

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.executor.shutdown()
        self.exec_thread.join()
        self.node.destroy_node()
        rclpy.shutdown()

    def test_missing_arguments(self):
        proto = Protocol("test_missing_arguments", self.node)
        s = CallService(proto)
        msg = loads(dumps({"op": "call_service"}))
        self.assertRaises(MissingArgumentException, s.call_service, msg)

    def test_invalid_arguments(self):
        proto = Protocol("test_invalid_arguments", self.node)
        s = CallService(proto)

        msg = loads(dumps({"op": "call_service", "service": 3}))
        self.assertRaises(InvalidArgumentException, s.call_service, msg)

    def test_call_service_works(self):
        client = self.node.create_client(Trigger, self.trigger_srv.srv_name)
        assert client.wait_for_service(1.0)

        proto = Protocol("test_call_service_works", self.node)
        s = CallService(proto)
        send_msg = loads(dumps({"op": "call_service", "service": self.trigger_srv.srv_name}))

        received = {"msg": None, "arrived": False}

        def cb(msg, cid=None, compression="none"):  # noqa: ARG001
            print(msg)
            received["msg"] = msg
            received["arrived"] = True

        proto.send = cb

        s.call_service(send_msg)

        self.assertTrue(received["arrived"])
        values = received["msg"]["values"]
        self.assertEqual(values["success"], True)
        self.assertEqual(values["message"], "called trigger service successfully")

    def test_call_service_args(self):
        client = self.node.create_client(SetBool, self.set_bool_srv.srv_name)
        assert client.wait_for_service(1.0)

        proto = Protocol("test_call_service_args", self.node)
        s = CallService(proto)
        send_msg = loads(
            dumps(
                {
                    "op": "call_service",
                    "service": self.set_bool_srv.srv_name,
                    "args": {"data": True},
                }
            )
        )

        received = {"msg": None, "arrived": False}

        def cb(msg, cid=None, compression="none"):  # noqa: ARG001
            received["msg"] = msg
            received["arrived"] = True

        proto.send = cb

        s.call_service(send_msg)

        self.assertTrue(received["arrived"])
        values = received["msg"]["values"]
        self.assertEqual(values["success"], True)
        self.assertEqual(values["message"], "set bool to true")

    def test_call_service_fails(self):
        client = self.node.create_client(Trigger, self.trigger_srv.srv_name)
        assert client.wait_for_service(1.0)

        proto = Protocol("test_call_service_works", self.node)
        s = CallService(proto)
        send_msg = loads(
            dumps(
                {
                    "op": "call_service",
                    "service": self.set_bool_srv.srv_name,
                    "args": {"data": 42.0},  # This data type is wrong so it will fail
                }
            )
        )

        received = {"msg": None, "arrived": False}

        def cb(msg, cid=None, compression="none"):  # noqa: ARG001
            print(msg)
            received["msg"] = msg
            received["arrived"] = True

        proto.send = cb

        s.call_service(send_msg)

        self.assertTrue(received["arrived"])
        self.assertFalse(received["msg"]["result"])

    def test_call_service_timeout(self):
        client = self.node.create_client(Trigger, self.trigger_long_srv.srv_name)
        assert client.wait_for_service(1.0)

        proto = Protocol("test_call_service_timeout", self.node)
        s = CallService(proto)
        send_msg = loads(
            dumps({"op": "call_service", "service": self.trigger_long_srv.srv_name, "timeout": 2.0})
        )

        received = {"msg": None, "arrived": False}

        def cb(msg, cid=None, compression="none"):  # noqa: ARG001
            print("Received message")
            received["msg"] = msg
            received["arrived"] = True

        proto.send = cb

        s.call_service(send_msg)

        self.assertTrue(received["arrived"])
        self.assertTrue(received["msg"]["result"])
        values = received["msg"]["values"]
        self.assertEqual(values["success"], True)
        self.assertEqual(values["message"], "called trigger service successfully")

        send_msg = loads(
            dumps({"op": "call_service", "service": self.trigger_long_srv.srv_name, "timeout": 0.1})
        )
        received = {"msg": None, "arrived": False}

        s.call_service(send_msg)

        self.assertTrue(received["arrived"])
        self.assertFalse(received["msg"]["result"])
        values = received["msg"]["values"]
        self.assertEqual(values, "Timeout exceeded while waiting for service response")



================================================
FILE: rosbridge_library/test/capabilities/test_publish.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import String

from rosbridge_library.capabilities.publish import Publish
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.protocol import Protocol


class TestAdvertise(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_publish")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_missing_arguments(self):
        proto = Protocol("hello", self.node)
        pub = Publish(proto)
        msg = {"op": "publish"}
        self.assertRaises(MissingArgumentException, pub.publish, msg)

        msg = {"op": "publish", "msg": {}}
        self.assertRaises(MissingArgumentException, pub.publish, msg)

    def test_invalid_arguments(self):
        proto = Protocol("hello", self.node)
        pub = Publish(proto)

        msg = {"op": "publish", "topic": 3}
        self.assertRaises(InvalidArgumentException, pub.publish, msg)

    def test_publish_works(self):
        proto = Protocol("hello", self.node)
        pub = Publish(proto)
        topic = "/test_publish_works"
        msg = {"data": "test publish works"}

        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        subscriber_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_subscription(String, topic, cb, subscriber_qos)

        pub_msg = loads(dumps({"op": "publish", "topic": topic, "msg": msg}))
        pub.publish(pub_msg)
        time.sleep(0.5)
        self.assertEqual(received["msg"].data, msg["data"])



================================================
FILE: rosbridge_library/test/capabilities/test_service_capabilities.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from rclpy.node import Node

from rosbridge_library.capabilities.advertise_service import AdvertiseService
from rosbridge_library.capabilities.call_service import CallService
from rosbridge_library.capabilities.service_response import ServiceResponse
from rosbridge_library.capabilities.unadvertise_service import UnadvertiseService
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.protocol import Protocol


class TestServiceCapabilities(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.node = Node("test_service_capabilities")

        self.node.declare_parameter("call_services_in_new_thread", False)
        self.node.declare_parameter("default_call_service_timeout", 5.0)
        self.node.declare_parameter("send_action_goals_in_new_thread", False)

        self.proto = Protocol(self._testMethodName, self.node)
        # change the log function so we can verify errors are logged
        self.proto.log = self.mock_log
        # change the send callback so we can access the rosbridge messages
        # being sent
        self.proto.send = self.local_send_cb
        self.advertise = AdvertiseService(self.proto)
        self.unadvertise = UnadvertiseService(self.proto)
        self.response = ServiceResponse(self.proto)
        self.call_service = CallService(self.proto)
        self.received_message = None
        self.log_entries = []

    def tearDown(self):
        self.node.destroy_node()
        rclpy.shutdown()

    def local_send_cb(self, msg):
        self.received_message = msg

    def mock_log(self, loglevel, message, _=None):
        self.log_entries.append((loglevel, message))

    def test_advertise_missing_arguments(self):
        advertise_msg = loads(dumps({"op": "advertise_service"}))
        self.assertRaises(MissingArgumentException, self.advertise.advertise_service, advertise_msg)

    def test_advertise_invalid_arguments(self):
        advertise_msg = loads(dumps({"op": "advertise_service", "type": 42, "service": None}))
        self.assertRaises(InvalidArgumentException, self.advertise.advertise_service, advertise_msg)

    def test_response_missing_arguments(self):
        response_msg = loads(dumps({"op": "service_response"}))
        self.assertRaises(MissingArgumentException, self.response.service_response, response_msg)

        # this message has the optional fields, with correct types, but not the
        # required ones
        response_msg = loads(
            dumps({"op": "service_response", "id": "dummy_service", "values": "none"})
        )
        self.assertRaises(MissingArgumentException, self.response.service_response, response_msg)

    def test_response_invalid_arguments(self):
        response_msg = loads(dumps({"op": "service_response", "service": 5, "result": "error"}))
        self.assertRaises(InvalidArgumentException, self.response.service_response, response_msg)

    def test_advertise_service(self):
        service_path = "/set_bool_1"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_service",
                    "type": "std_srvs/SetBool",
                    "service": service_path,
                }
            )
        )
        self.advertise.advertise_service(advertise_msg)

    def test_call_advertised_service(self):
        # Advertise the service
        service_path = "/set_bool_2"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_service",
                    "type": "std_srvs/SetBool",
                    "service": service_path,
                }
            )
        )
        self.received_message = None
        self.advertise.advertise_service(advertise_msg)

        # Call the advertised service using rosbridge
        self.received_message = None
        call_msg = loads(
            dumps(
                {
                    "op": "call_service",
                    "id": "foo",
                    "service": service_path,
                    "args": {"data": True},
                }
            )
        )
        Thread(target=self.call_service.call_service, args=(call_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            rclpy.spin_once(self.node, timeout_sec=0.1)
            if time.monotonic() - start_time > 0.3:
                self.fail("Timed out waiting for service call message.")

        self.assertFalse(self.received_message is None)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "call_service")
        self.assertTrue("id" in self.received_message)

        # Now send the response
        response_msg = loads(
            dumps(
                {
                    "op": "service_response",
                    "service": service_path,
                    "id": self.received_message["id"],
                    "values": {"success": True, "message": "set bool to true"},
                    "result": True,
                }
            )
        )
        self.received_message = None
        self.response.service_response(response_msg)

        start_time = time.monotonic()
        while self.received_message is None:
            rclpy.spin_once(self.node, timeout_sec=0.1)
            if time.monotonic() - start_time > 0.3:
                self.fail("Timed out waiting for service response message.")

        self.assertFalse(self.received_message is None)
        self.assertEqual(self.received_message["op"], "service_response")
        self.assertTrue(self.received_message["result"])

    def test_call_advertised_service_with_timeout(self):
        # Advertise the service
        service_path = "/set_bool_3"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_service",
                    "type": "std_srvs/SetBool",
                    "service": service_path,
                }
            )
        )
        self.received_message = None
        self.advertise.advertise_service(advertise_msg)

        # Call the advertised service using rosbridge
        self.received_message = None
        call_msg = loads(
            dumps(
                {
                    "op": "call_service",
                    "id": "foo",
                    "service": service_path,
                    "args": {"data": True},
                    "timeout": 0.5,
                }
            )
        )
        Thread(target=self.call_service.call_service, args=(call_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            rclpy.spin_once(self.node, timeout_sec=0.1)
            if time.monotonic() - start_time > 0.3:
                self.fail("Timed out waiting for service call message.")

        self.assertFalse(self.received_message is None)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "call_service")
        self.assertTrue("id" in self.received_message)

        self.received_message = None

        start_time = time.monotonic()
        while self.received_message is None:
            rclpy.spin_once(self.node, timeout_sec=0.1)
            if time.monotonic() - start_time > 1.0:
                self.fail("Timed out waiting for service response message.")

        self.assertFalse(self.received_message is None)
        self.assertEqual(self.received_message["op"], "service_response")
        self.assertFalse(self.received_message["result"])
        self.assertEqual(
            self.received_message["values"], "Timeout exceeded while waiting for service response"
        )

    def test_unadvertise_with_live_request(self):
        # Advertise the service
        service_path = "/set_bool_3"
        advertise_msg = loads(
            dumps(
                {
                    "op": "advertise_service",
                    "type": "std_srvs/SetBool",
                    "service": service_path,
                }
            )
        )
        self.received_message = None
        self.advertise.advertise_service(advertise_msg)

        # Now send the response
        call_msg = loads(
            dumps(
                {
                    "op": "call_service",
                    "id": "foo",
                    "service": service_path,
                    "args": {"data": True},
                }
            )
        )
        self.received_message = None
        Thread(target=self.call_service.call_service, args=(call_msg,)).start()

        start_time = time.monotonic()
        while self.received_message is None:
            rclpy.spin_once(self.node, timeout_sec=0.1)
            if time.monotonic() - start_time > 0.3:
                self.fail("Timed out waiting for service call message.")

        self.assertFalse(self.received_message is None)
        self.assertTrue("op" in self.received_message)
        self.assertEqual(self.received_message["op"], "call_service")
        self.assertTrue("id" in self.received_message)

        # Now unadvertise the service
        # TODO: This raises an exception, likely because of the following rclpy issue:
        # https://github.com/ros2/rclpy/issues/1098
        unadvertise_msg = loads(dumps({"op": "unadvertise_service", "service": service_path}))
        self.received_message = None
        self.unadvertise.unadvertise_service(unadvertise_msg)

        with self.assertRaises(RuntimeError) as context:
            start_time = time.monotonic()
            while self.received_message is None:
                rclpy.spin_once(self.node, timeout_sec=0.1)
                if time.monotonic() - start_time > 0.3:
                    self.fail("Timed out waiting for unadvertise service message.")

            self.assertTrue(f"Service {service_path} was unadvertised" in context.exception)


if __name__ == "__main__":
    unittest.main()



================================================
FILE: rosbridge_library/test/capabilities/test_subscribe.py
================================================
#!/usr/bin/env python
import time
import unittest
from json import dumps, loads
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import String

from rosbridge_library.capabilities import subscribe
from rosbridge_library.internal.exceptions import (
    InvalidArgumentException,
    MissingArgumentException,
)
from rosbridge_library.protocol import Protocol


class TestSubscribe(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_subscribe")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def dummy_cb(self, msg):
        pass

    def test_update_params(self):
        """
        Test the update_params method of the Subscription class.

        Adds a bunch of random clients to the subscription and sees whether
        the correct parameters are chosen as the min.
        """
        client_id = "client_test_update_params"
        topic = "/test_update_params"
        msg_type = "std_msgs/String"

        subscription = subscribe.Subscription(client_id, topic, None, self.node)

        min_throttle_rate = 5
        min_queue_length = 2
        min_frag_size = 20

        for throttle_rate in range(min_throttle_rate, min_throttle_rate + 10):
            for queue_length in range(min_queue_length, min_queue_length + 10):
                for frag_size in range(min_frag_size, min_frag_size + 10):
                    sid = throttle_rate * 100 + queue_length * 10 + frag_size
                    subscription.subscribe(sid, msg_type, throttle_rate, queue_length, frag_size)

        subscription.update_params()

        try:
            self.assertEqual(subscription.throttle_rate, min_throttle_rate)
            self.assertEqual(subscription.queue_length, min_queue_length)
            self.assertEqual(subscription.fragment_size, min_frag_size)
            self.assertEqual(subscription.compression, "none")

            next(iter(subscription.clients.values()))["compression"] = "png"

            subscription.update_params()

            self.assertEqual(subscription.throttle_rate, min_throttle_rate)
            self.assertEqual(subscription.queue_length, min_queue_length)
            self.assertEqual(subscription.fragment_size, min_frag_size)
            self.assertEqual(subscription.compression, "png")
        finally:
            subscription.unregister()

    def test_missing_arguments(self):
        proto = Protocol("test_missing_arguments", self.node)
        sub = subscribe.Subscribe(proto)
        msg = {"op": "subscribe"}
        self.assertRaises(MissingArgumentException, sub.subscribe, msg)

    def test_invalid_arguments(self):
        proto = Protocol("test_invalid_arguments", self.node)
        sub = subscribe.Subscribe(proto)

        msg = {"op": "subscribe", "topic": 3}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

        msg = {"op": "subscribe", "topic": "/jon", "type": 3}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

        msg = {"op": "subscribe", "topic": "/jon", "throttle_rate": "fast"}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

        msg = {"op": "subscribe", "topic": "/jon", "fragment_size": "five cubits"}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

        msg = {"op": "subscribe", "topic": "/jon", "queue_length": "long"}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

        msg = {"op": "subscribe", "topic": "/jon", "compression": 9000}
        self.assertRaises(InvalidArgumentException, sub.subscribe, msg)

    def test_subscribe_works(self):
        proto = Protocol("test_subscribe_works", self.node)
        sub = subscribe.Subscribe(proto)
        topic = "/test_subscribe_works"
        msg = String()
        msg.data = "test test_subscribe_works works"
        msg_type = "std_msgs/String"

        received = {"msg": None}

        def send(outgoing, cid=None, compression="none"):  # noqa: ARG001
            received["msg"] = outgoing

        proto.send = send

        sub.subscribe(loads(dumps({"op": "subscribe", "topic": topic, "type": msg_type})))

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(String, topic, publisher_qos)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(received["msg"]["msg"]["data"], msg.data)



================================================
FILE: rosbridge_library/test/experimental/complex_srv+tcp/test_non-ros_service_client_complex-srv.py
================================================
#!/usr/bin/python
import socket

from rosbridge_library.util import json

# ##################### variables begin ########################################
# these parameters should be changed to match the actual environment           #
# ##############################################################################

client_socket_timeout = 6  # seconds
max_msg_length = 2000000  # bytes

rosbridge_ip = "localhost"  # hostname or ip
rosbridge_port = 9090  # port as integer

service_name = "nested_srv"  # service name
# request_byte_count = 5000
receiving_fragment_size = 1000
receive_message_intervall = 0.0

# ##################### variables end ##########################################


# ##############################################################################


def request_service():
    service_request_object = {
        "op": "call_service",  # op-code for rosbridge
        "service": "/" + service_name,  # select service
        # optional: tells rosbridge to send fragments if message size is bigger than requested
        "fragment_size": receiving_fragment_size,
        "message_intervall": receive_message_intervall,
        "args": {
            "pose": {
                "position": {"y": 0.0, "x": 0.0, "z": 0.0},
                "orientation": {"y": 0.0, "x": 0.0, "z": 0.0, "w": 0.0},
            }
        },
        # count is the parameter for send_bytes as defined in srv-file (always put into args field!)
        # "count" : request_byte_count
    }
    service_request = json.dumps(service_request_object)
    print("sending JSON-message to rosbridge:", service_request)
    sock.send(service_request)


# ##############################################################################


# ##################### script begin ###########################################
# should not need to be changed (but could be improved ;) )                    #
# ##############################################################################
try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # connect to rosbridge
    sock.settimeout(client_socket_timeout)
    sock.connect((rosbridge_ip, rosbridge_port))

    request_service()  # send service_request

    incoming = None
    buffer = ""
    done = False
    result = None
    reconstructed = None
    # should not need a loop (maximum wait can be set by client_socket_timeout),
    # but since its for test/demonstration only .. leave it as it is for now
    while not done:
        try:
            incoming = sock.recv(max_msg_length)  # receive service_response from rosbridge
            if buffer == "":
                buffer = incoming.decode("utf-8")
                if incoming == "":
                    print("closing socket")
                    sock.close()
                    break
            else:
                buffer = buffer + incoming.decode("utf-8")
            # print "buffer-length:", len(buffer)
            try:  # try to access service_request directly (not fragmented)
                data_object = json.loads(buffer)
                if data_object["op"] == "service_response":
                    reconstructed = buffer
                    done = True
            except Exception:
                # print "direct access to JSON failed.."
                # print(e)
                pass
            try:
                # print "defragmenting incoming messages"
                result_string = buffer.split(
                    "}{"
                )  # split buffer into fragments and re-fill curly brackets
                result = []
                for fragment_str in result_string:
                    frag = fragment_str
                    if frag[0] != "{":
                        frag = "{" + frag
                    if frag[len(frag) - 1] != "}":
                        frag = frag + "}"
                    try:
                        result.append(
                            json.loads(frag)
                        )  # try to parse json from string, and append if successful
                    except Exception:
                        # print(e)
                        # print result_string
                        raise  # re-raise the last exception, allows to see and continue with processing of exception

                fragment_count = len(result)
                print("fragment_count:", fragment_count)
                announced = int(result[0]["total"])
                if fragment_count == announced:  # if all fragments received --> sort and defragment
                    # sort fragments
                    sorted_result = [None] * fragment_count
                    unsorted_result = []
                    for fragment in result:
                        unsorted_result.append(fragment)
                        sorted_result[int(fragment["num"])] = fragment
                    reconstructed = ""
                    for fragment in sorted_result:
                        reconstructed = reconstructed + fragment["data"]
                    done = True
            except Exception:
                # print(e)
                pass
        except Exception:
            # print(e)
            pass

    returned_data = json.loads(
        reconstructed
    )  # when service response is received --> access it (as defined in srv-file)
    if returned_data["values"] is None:
        print("response was None -> service was not available")
    else:
        print("received:")
        print(
            returned_data
        )  # ["values"]#["data"].decode('base64','strict')   # decode values-field

except Exception as e:
    print("ERROR - could not receive service_response")
    print(e)

sock.close()



================================================
FILE: rosbridge_library/test/experimental/complex_srv+tcp/test_non-ros_service_server_complex-srv.py
================================================
#!/usr/bin/python
import socket
import sys
import time
from random import randint

from rosbridge_library.util import json

# ##################### variables begin ########################################
# these parameters should be changed to match the actual environment           #
# ##############################################################################

tcp_socket_timeout = 10  # seconds
max_msg_length = 20000  # bytes

rosbridge_ip = "localhost"  # hostname or ip
rosbridge_port = 9090  # port as integer

# make sure this matches an existing service type on rosbridge-server (in specified srv_module)
service_type = "rosbridge_test_msgs/TestNestedService"
service_name = "nested_srv"  # service name

send_fragment_size = 1000
# delay between sends to rosbridge is not needed anymore, if using my version of protocol
# (uses buffer to collect data from stream)
send_fragment_delay = 0.000  # 1
receive_fragment_size = 10
receive_message_intervall = 0.0

# ##################### variables end ##########################################


# ##################### service_calculation begin ##############################
# change this function to match whatever service should be provided            #
# ##############################################################################


def calculate_service_response(request):
    request_object = json.loads(request)  # parse string for service request
    # args = request_object["args"]  # get parameter field (args)
    # count = int(args["count"])  # get parameter(s) as described in corresponding ROS srv-file
    #
    # message = ""  # calculate service response
    # for i in range(0,count):
    #     message += str(chr(randint(32,126)))
    #     if i% 100000 == 0:
    #         print count - i, "bytes left to generate"

    message = {"data": {"data": 42.0}}

    """
    IMPORTANT!
    use base64 encoding to avoid JSON-parsing problems!
    --> use .decode("base64","strict") at client side
    """
    # message = message.encode('base64','strict')
    service_response_data = message  # service response (as defined in srv-file)

    response_object = {
        "op": "service_response",
        "id": request_object["id"],
        # put service response in "data"-field of response object
        # (in this case it's twice "data", because response value is also named data, in srv-file)
        "data": service_response_data,
    }
    return json.dumps(response_object)


# ##################### service_calculation end ################################


# ##################### helper functions / and variables begin #################
# should not need to be changed (but could be improved )                       #
# ##############################################################################

buffer = ""


def connect_tcp_socket():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # connect to rosbridge
    tcp_sock.settimeout(tcp_socket_timeout)
    tcp_sock.connect((rosbridge_ip, rosbridge_port))
    return tcp_sock


def advertise_service():  # advertise service
    advertise_message_object = {
        "op": "advertise_service",
        "type": service_type,
        "service": service_name,
        "fragment_size": receive_fragment_size,
        "message_intervall": receive_message_intervall,
    }
    advertise_message = json.dumps(advertise_message_object)
    tcp_socket.send(str(advertise_message))


def unadvertise_service():  # unadvertise service
    unadvertise_message_object = {"op": "unadvertise_service", "service": service_name}
    unadvertise_message = json.dumps(unadvertise_message_object)
    tcp_socket.send(str(unadvertise_message))


def wait_for_service_request():  # receive data from rosbridge
    data = None
    global buffer

    try:
        done = False
        global buffer
        while not done:
            incoming = tcp_socket.recv(max_msg_length)  # get data from socket
            if incoming == "":
                print("connection closed by peer")
                sys.exit(1)
            buffer = buffer + incoming  # append data to buffer
            try:  # try to parse JSON from buffer
                data_object = json.loads(buffer)
                if data_object["op"] == "call_service":
                    data = buffer
                    done = True
                    return data  # if parsing was successful --> return data string
            except Exception:
                # print "direct_access error:"
                # print(e)
                pass

            # print "trying to defragment"
            try:  # opcode was not "call_service" -> try to defragment
                result_string = buffer.split(
                    "}{"
                )  # split buffer into fragments and re-fill with curly brackets
                result = []
                for fragment_str in result_string:
                    frag = fragment_str
                    if frag[0] != "{":
                        frag = "{" + frag
                    if frag[len(frag) - 1] != "}":
                        frag = frag + "}"
                    result.append(json.loads(frag))

                try:  # try to defragment when received all fragments
                    fragment_count = len(result)
                    announced = int(result[0]["total"])

                    if fragment_count == announced:
                        reconstructed = ""
                        sorted_result = [None] * fragment_count  # sort fragments..
                        unsorted_result = []
                        for fragment in result:
                            unsorted_result.append(fragment)
                            sorted_result[int(fragment["num"])] = fragment

                        for fragment in sorted_result:  # reconstruct from fragments
                            reconstructed = reconstructed + fragment["data"]

                        # print "reconstructed", reconstructed
                        buffer = ""  # empty buffer
                        done = True
                        print("reconstructed message from", len(result), "fragments")
                        # print reconstructed
                        return reconstructed
                except Exception as e:
                    print("not possible to defragment:", buffer)
                    print(e)
            except Exception as e:
                print("defrag_error:", buffer)
                print(e)
    except Exception:
        # print "network-error(?):", e
        pass
    return data


def send_service_response(response):  # send response to rosbridge
    tcp_socket.send(response)


def list_of_fragments(full_message, fragment_size):  # create fragment messages for a huge message
    message_id = randint(0, 64000)  # generate random message id
    fragments = []  # generate list of data fragments
    cursor = 0
    while cursor < len(full_message):
        fragment_begin = cursor
        if len(full_message) < cursor + fragment_size:
            fragment_end = len(full_message)
            cursor = len(full_message)
        else:
            fragment_end = cursor + fragment_size
            cursor += fragment_size
        fragment = full_message[fragment_begin:fragment_end]
        fragments.append(fragment)

    fragmented_messages_list = []  # generate list of fragmented messages (including headers)
    if len(fragments) > 1:
        for count, fragment in enumerate(fragments):  # iterate through list and have index counter
            fragmented_message_object = {
                "op": "fragment",  # create Python-object for each fragment message
                "id": str(message_id),
                "data": str(fragment),
                "num": count,
                "total": len(fragments),
            }
            fragmented_message = json.dumps(
                fragmented_message_object
            )  # create JSON-object from python-object for each fragment message
            fragmented_messages_list.append(
                fragmented_message
            )  # append JSON-object to list of fragmented messages
    else:  # if only 1 fragment --> do not send as fragment, but as service_response
        fragmented_messages_list.append(str(fragment))
    return fragmented_messages_list  # return list of 'ready-to-send' fragmented messages


# ##################### helper functions end ###################################


# ##################### script begin ###########################################
# should not need to be changed (but could be improved )                       #
# ##############################################################################

tcp_socket = connect_tcp_socket()  # open tcp_socket
advertise_service()  # advertise service in ROS (via rosbridge)
print("service provider started and waiting for requests")

try:  # allows to catch KeyboardInterrupt
    while True:  # loop forever (or until ctrl-c is pressed)
        data = None
        try:  # allows to catch any Exception (network, json, ..)
            data = wait_for_service_request()  # receive request from rosbridge
            if data == "":  # exit on empty string
                break
            elif data:  # received service_request (or at least some data..)
                response = calculate_service_response(data)  # generate service_response

                print("response calculated, now splitting into fragments..")
                fragment_list = list_of_fragments(
                    response, send_fragment_size
                )  # generate fragments to send to rosbridge

                print("sending", len(fragment_list), "messages as response")
                for fragment in fragment_list:
                    # print "sending:" ,fragment
                    send_service_response(
                        fragment
                    )  # send service_response to rosbridge (or fragments; just send any list entry)
                    time.sleep(
                        send_fragment_delay
                    )  # (not needed if using patched rosbridge protocol.py)
        except Exception as e:
            print(e)
except KeyboardInterrupt:
    try:
        unadvertise_service()  # unadvertise service
        tcp_socket.close()  # close tcp_socket
    except Exception as e:
        print(e)
    print('non-ros_service_server stopped because user pressed "Ctrl-C"')



================================================
FILE: rosbridge_library/test/experimental/fragmentation+srv+tcp/test_non-ros_service_client_fragmented.py
================================================
#!/usr/bin/python
import socket
from typing import Any

from rosbridge_library.util import json

# ##################### variables begin ########################################
# these parameters should be changed to match the actual environment           #
# ##############################################################################

client_socket_timeout = 6  # seconds
max_msg_length = 2000000  # bytes

rosbridge_ip = "localhost"  # hostname or ip
rosbridge_port = 9090  # port as integer

service_name = "send_bytes"  # service name
# NOTE: receiving more than ~100.000 bytes without setting a fragment_size was not possible during testing.
request_byte_count = 500000
receiving_fragment_size = 1000
receive_message_intervall = 0.0

# ##################### variables end ##########################################


# ##############################################################################


def request_service():
    service_request_object = {
        "op": "call_service",  # op-code for rosbridge
        "service": "/" + service_name,  # select service
        # optional: tells rosbridge to send fragments if message size is bigger than requested
        "fragment_size": receiving_fragment_size,
        "message_intervall": receive_message_intervall,
        "args": {
            # count is the parameter for send_bytes as defined in srv-file (always put into args field!)
            "count": request_byte_count
        },
    }
    service_request = json.dumps(service_request_object)
    print("sending JSON-message to rosbridge:", service_request)
    sock.send(service_request)


# ##############################################################################


# ##################### script begin ###########################################
# should not need to be changed (but could be improved ;) )                    #
# ##############################################################################
try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # connect to rosbridge
    sock.settimeout(client_socket_timeout)
    sock.connect((rosbridge_ip, rosbridge_port))

    request_service()  # send service_request

    incoming = None
    buffer = ""
    done = False
    result = None
    reconstructed = None
    # should not need a loop (maximum wait can be set by client_socket_timeout),
    # but since its for test/demonstration only .. leave it as it is for now
    while not done:
        try:
            incoming = sock.recv(max_msg_length)  # receive service_response from rosbridge
            if buffer == "":
                buffer = incoming.decode("utf-8")
                if incoming == "":
                    print("closing socket")
                    sock.close()
                    break
            else:
                buffer = buffer + incoming.decode("utf-8")
            # print "buffer-length:", len(buffer)
            try:  # try to access service_request directly (not fragmented)
                data_object = json.loads(buffer)
                if data_object["op"] == "service_response":
                    reconstructed = buffer
                    done = True
            except Exception:
                # print "direct access to JSON failed.."
                # print(e)
                pass
            try:
                # print "defragmenting incoming messages"
                result_string = buffer.split(
                    "}{"
                )  # split buffer into fragments and re-fill curly brackets
                result = []
                for fragment_str in result_string:
                    frag = fragment_str
                    if frag[0] != "{":
                        frag = "{" + frag
                    if frag[len(frag) - 1] != "}":
                        frag = frag + "}"
                    try:
                        result.append(
                            json.loads(frag)
                        )  # try to parse json from string, and append if successful
                    except Exception:
                        # print(e)
                        # print result_string
                        raise  # re-raise the last exception, allows to see and continue with processing of exception

                fragment_count = len(result)
                print("fragment_count:", fragment_count)
                announced = int(result[0]["total"])
                if fragment_count == announced:  # if all fragments received --> sort and defragment
                    # sort fragments
                    sorted_result: list[Any] = [None] * fragment_count
                    unsorted_result = []
                    for fragment in result:
                        unsorted_result.append(fragment)
                        sorted_result[int(fragment["num"])] = fragment
                    reconstructed = ""
                    for fragment in sorted_result:
                        reconstructed = reconstructed + fragment["data"]
                    done = True
            except Exception:
                # print(e)
                pass
        except Exception:
            #            print(e)
            pass

    returned_data = json.loads(
        reconstructed
    )  # when service response is received --> access it (as defined in srv-file)
    if returned_data["values"] is None:
        print("response was None -> service was not available")
    else:
        print("received:")
        print(returned_data["values"]["data"].decode("base64", "strict"))  # decode values-field

except Exception as e:
    print("ERROR - could not receive service_response")
    print(e)

sock.close()



================================================
FILE: rosbridge_library/test/experimental/fragmentation+srv+tcp/test_non-ros_service_server_fragmented.py
================================================
#!/usr/bin/python
import socket
import sys
import time
from random import randint

from rosbridge_library.util import json

# ##################### variables begin ########################################
# these parameters should be changed to match the actual environment           #
# ##############################################################################

tcp_socket_timeout = 10  # seconds
max_msg_length = 20000  # bytes

rosbridge_ip = "localhost"  # hostname or ip
rosbridge_port = 9090  # port as integer

# make sure this matches an existing service type on rosbridge-server (in specified srv_module)
service_type = "rosbridge_test_msgs/SendBytes"
service_name = "send_bytes"  # service name

send_fragment_size = 1000
# delay between sends to rosbridge is not needed anymore, if using my version of
# protocol (uses buffer to collect data from stream)
send_fragment_delay = 0.000  # 1
receive_fragment_size = 10
receive_message_intervall = 0.0

# ##################### variables end ##########################################


# ##################### service_calculation begin ##############################
# change this function to match whatever service should be provided            #
# ##############################################################################


def calculate_service_response(request):
    request_object = json.loads(request)  # parse string for service request
    args = request_object["args"]  # get parameter field (args)
    count = int(args["count"])  # get parameter(s) as described in corresponding ROS srv-file

    message = ""
    # calculate service response
    for i in range(count):
        # message += str(chr(randint(32,126)))
        message += str(chr(randint(32, 126)))
        if i % 100000 == 0:
            print(count - i, "bytes left to generate")

    """
    IMPORTANT!
    use base64 encoding to avoid JSON-parsing problems!
    --> use .decode("base64","strict") at client side
    """
    message = message.encode("base64", "strict")
    service_response_data = {"data": message}  # service response (as defined in srv-file)

    response_object = {
        "op": "service_response",
        "id": request_object["id"],
        "service": service_name,
        # put service response in "data"-field of response object
        # (in this case it's twice "data", because response value is also named data, in srv-file)
        "values": service_response_data,
    }
    return json.dumps(response_object)


# ##################### service_calculation end ################################


# ##################### helper functions / and variables begin #################
# should not need to be changed (but could be improved )                       #
# ##############################################################################

buffer = ""


def connect_tcp_socket():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # connect to rosbridge
    tcp_sock.settimeout(tcp_socket_timeout)
    tcp_sock.connect((rosbridge_ip, rosbridge_port))
    return tcp_sock


def advertise_service():  # advertise service
    advertise_message_object = {
        "op": "advertise_service",
        "type": service_type,
        "service": service_name,
        "fragment_size": receive_fragment_size,
        "message_intervall": receive_message_intervall,
    }
    advertise_message = json.dumps(advertise_message_object)
    tcp_socket.send(str(advertise_message))


def unadvertise_service():  # unadvertise service
    unadvertise_message_object = {"op": "unadvertise_service", "service": service_name}
    unadvertise_message = json.dumps(unadvertise_message_object)
    tcp_socket.send(str(unadvertise_message))


def wait_for_service_request():  # receive data from rosbridge
    data = None
    global buffer

    try:
        done = False
        global buffer
        while not done:
            incoming = tcp_socket.recv(max_msg_length)  # get data from socket
            if incoming == "":
                print("connection closed by peer")
                sys.exit(1)
            buffer = buffer + incoming  # append data to buffer
            try:  # try to parse JSON from buffer
                data_object = json.loads(buffer)
                if data_object["op"] == "call_service":
                    data = buffer
                    done = True
                    return data  # if parsing was successful --> return data string
            except Exception:
                # print "direct_access error:"
                # print(e)
                pass

            # print "trying to defragment"
            try:  # opcode was not "call_service" -> try to defragment
                result_string = buffer.split(
                    "}{"
                )  # split buffer into fragments and re-fill with curly brackets
                result = []
                for fragment_str in result_string:
                    frag = fragment_str
                    if frag[0] != "{":
                        frag = "{" + frag
                    if frag[len(frag) - 1] != "}":
                        frag = frag + "}"
                    result.append(json.loads(frag))

                try:  # try to defragment when received all fragments
                    fragment_count = len(result)
                    announced = int(result[0]["total"])

                    if fragment_count == announced:
                        reconstructed = ""
                        sorted_result = [None] * fragment_count  # sort fragments..
                        unsorted_result = []
                        for fragment in result:
                            unsorted_result.append(fragment)
                            sorted_result[int(fragment["num"])] = fragment

                        for fragment in sorted_result:  # reconstruct from fragments
                            reconstructed = reconstructed + fragment["data"]

                        # print "reconstructed", reconstructed
                        buffer = ""  # empty buffer
                        done = True
                        print("reconstructed message from", len(result), "fragments")
                        # print reconstructed
                        return reconstructed
                except Exception as e:
                    print("not possible to defragment:", buffer)
                    print(e)
            except Exception as e:
                print("defrag_error:", buffer)
                print(e)
    except Exception:
        # print "network-error(?):", e
        pass
    return data


def send_service_response(response):  # send response to rosbridge
    tcp_socket.send(response)


def list_of_fragments(full_message, fragment_size):  # create fragment messages for a huge message
    message_id = randint(0, 64000)  # generate random message id
    fragments = []  # generate list of data fragments
    cursor = 0
    while cursor < len(full_message):
        fragment_begin = cursor
        if len(full_message) < cursor + fragment_size:
            fragment_end = len(full_message)
            cursor = len(full_message)
        else:
            fragment_end = cursor + fragment_size
            cursor += fragment_size
        fragment = full_message[fragment_begin:fragment_end]
        fragments.append(fragment)

    fragmented_messages_list = []  # generate list of fragmented messages (including headers)
    if len(fragments) > 1:
        for count, fragment in enumerate(fragments):  # iterate through list and have index counter
            fragmented_message_object = {
                "op": "fragment",  # create Python-object for each fragment message
                "id": str(message_id),
                "data": str(fragment),
                "num": count,
                "total": len(fragments),
            }
            fragmented_message = json.dumps(
                fragmented_message_object
            )  # create JSON-object from python-object for each fragment message
            fragmented_messages_list.append(
                fragmented_message
            )  # append JSON-object to list of fragmented messages
    else:  # if only 1 fragment --> do not send as fragment, but as service_response
        fragmented_messages_list.append(str(fragment))
    return fragmented_messages_list  # return list of 'ready-to-send' fragmented messages


# ##################### helper functions end ###################################


# ##################### script begin ###########################################
# should not need to be changed (but could be improved )                       #
# ##############################################################################

tcp_socket = connect_tcp_socket()  # open tcp_socket
advertise_service()  # advertise service in ROS (via rosbridge)
print("service provider started and waiting for requests")

try:  # allows to catch KeyboardInterrupt
    while True:  # loop forever (or until ctrl-c is pressed)
        data = None
        try:  # allows to catch any Exception (network, json, ..)
            data = wait_for_service_request()  # receive request from rosbridge
            if data == "":  # exit on empty string
                break
            elif data:  # received service_request (or at least some data..)
                response = calculate_service_response(data)  # generate service_response

                print("response calculated, now splitting into fragments..")
                fragment_list = list_of_fragments(
                    response, send_fragment_size
                )  # generate fragments to send to rosbridge

                print("sending", len(fragment_list), "messages as response")
                for fragment in fragment_list:
                    # print "sending:" ,fragment
                    send_service_response(
                        fragment
                    )  # send service_response to rosbridge (or fragments; just send any list entry)
                    time.sleep(
                        send_fragment_delay
                    )  # (not needed if using patched rosbridge protocol.py)
        except Exception as e:
            print(e)
except KeyboardInterrupt:
    try:
        unadvertise_service()  # unadvertise service
        tcp_socket.close()  # close tcp_socket
    except Exception as e:
        print(e)
    print('non-ros_service_server stopped because user pressed "Ctrl-C"')



================================================
FILE: rosbridge_library/test/internal/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/test/internal/test_cbor_conversion.py
================================================
#!/usr/bin/env python3
import struct
import unittest
from array import array

from rosbridge_library.internal.cbor_conversion import (
    TAGGED_ARRAY_FORMATS,
    extract_cbor_values,
)

try:
    from cbor import Tag
except ImportError:
    from rosbridge_library.util.cbor import Tag

from builtin_interfaces.msg import Duration, Time
from std_msgs.msg import (
    Bool,
    Float32,
    Float32MultiArray,
    Float64,
    Float64MultiArray,
    Int8,
    Int8MultiArray,
    Int16,
    Int16MultiArray,
    Int32,
    Int32MultiArray,
    Int64,
    Int64MultiArray,
    MultiArrayDimension,
    MultiArrayLayout,
    String,
    UInt8,
    UInt8MultiArray,
    UInt16,
    UInt16MultiArray,
    UInt32,
    UInt32MultiArray,
    UInt64,
    UInt64MultiArray,
)


class TestCBORConversion(unittest.TestCase):
    def test_string(self):
        msg = String(data="foo")
        extracted = extract_cbor_values(msg)

        self.assertEqual(extracted["data"], msg.data)
        self.assertEqual(type(extracted["data"]), str)

    def test_bool(self):
        for val in [True, False]:
            msg = Bool(data=val)
            extracted = extract_cbor_values(msg)

            self.assertEqual(extracted["data"], msg.data, f"val={val}")
            self.assertEqual(type(extracted["data"]), bool, f"val={val}")

    def test_numbers(self):
        for msg_type in [Int8, Int16, Int32, Int64]:
            msg = msg_type(data=-5)
            extracted = extract_cbor_values(msg)

            self.assertEqual(extracted["data"], msg.data, f"type={msg_type}")
            self.assertEqual(type(extracted["data"]), int, f"type={msg_type}")

        for msg_type in [UInt8, UInt16, UInt32, UInt64]:
            msg = msg_type(data=5)
            extracted = extract_cbor_values(msg)

            self.assertEqual(extracted["data"], msg.data, f"type={msg_type}")
            self.assertEqual(type(extracted["data"]), int, f"type={msg_type}")

        for msg_type in [Float32, Float64]:
            msg = msg_type(data=2.3)
            extracted = extract_cbor_values(msg)

            self.assertEqual(extracted["data"], msg.data, f"type={msg_type}")
            self.assertEqual(type(extracted["data"]), float, f"type={msg_type}")

    def test_time(self):
        for msg_type in [Time, Duration]:
            msg = msg_type()
            extracted = extract_cbor_values(msg)

            self.assertEqual(extracted["sec"], msg.sec, f"type={msg_type}")
            self.assertEqual(extracted["nanosec"], msg.nanosec, f"type={msg_type}")
            self.assertEqual(type(extracted["sec"]), int, f"type={msg_type}")
            self.assertEqual(type(extracted["nanosec"]), int, f"type={msg_type}")

    def test_byte_array(self):
        msg = UInt8MultiArray(data=[0, 1, 2])
        extracted = extract_cbor_values(msg)

        data = extracted["data"]
        self.assertEqual(type(data), bytes)
        for i, val in enumerate(msg.data):
            self.assertEqual(data[i], val)

    def test_integer_array(self):
        for msg_type in [
            Int8MultiArray,
            Int16MultiArray,
            Int32MultiArray,
            Int64MultiArray,
            UInt16MultiArray,
            UInt32MultiArray,
            UInt64MultiArray,
        ]:
            msg = msg_type(data=[0, 1, 2])
            extracted = extract_cbor_values(msg)

            tag = extracted["data"]
            self.assertEqual(type(tag), Tag, f"type={msg_type}")
            self.assertEqual(type(tag.value), bytes, f"type={msg_type}")

            # This is as consistent as the message definitions.
            array_type = msg.get_fields_and_field_types()["data"]

            expected_tag = TAGGED_ARRAY_FORMATS[array_type][0]
            self.assertEqual(tag.tag, expected_tag, f"type={msg_type}")

            fmt = TAGGED_ARRAY_FORMATS[array_type][1]
            fmt_to_length = fmt.format(len(msg.data))
            unpacked = list(struct.unpack(fmt_to_length, tag.value))

            self.assertEqual(array("b", unpacked), msg.data, f"type={msg_type}")

    def test_float_array(self):
        for msg_type in [
            Float32MultiArray,
            Float64MultiArray,
        ]:
            msg = msg_type(data=[0, 1, 2])
            extracted = extract_cbor_values(msg)

            tag = extracted["data"]
            self.assertEqual(type(tag), Tag, f"type={msg_type}")
            self.assertEqual(type(tag.value), bytes, f"type={msg_type}")

            # This is as consistent as the message definitions.
            array_type = msg.get_fields_and_field_types()["data"]

            expected_tag = TAGGED_ARRAY_FORMATS[array_type][0]
            self.assertEqual(tag.tag, expected_tag, f"type={msg_type}")

            fmt = TAGGED_ARRAY_FORMATS[array_type][1]
            fmt_to_length = fmt.format(len(msg.data))
            unpacked = list(struct.unpack(fmt_to_length, tag.value))

            self.assertEqual(array("f", unpacked), msg.data, f"type={msg_type}")

    def test_nested_messages(self):
        msg = UInt8MultiArray(
            layout=MultiArrayLayout(
                data_offset=5,
                dim=[
                    MultiArrayDimension(
                        label="foo",
                        size=4,
                        stride=4,
                    ),
                    MultiArrayDimension(
                        label="bar",
                        size=8,
                        stride=8,
                    ),
                ],
            )
        )
        extracted = extract_cbor_values(msg)

        ex_layout = extracted["layout"]
        self.assertEqual(type(ex_layout), dict)
        self.assertEqual(ex_layout["data_offset"], msg.layout.data_offset)
        self.assertEqual(len(ex_layout["dim"]), len(msg.layout.dim))
        for i, val in enumerate(msg.layout.dim):
            self.assertEqual(ex_layout["dim"][i]["label"], val.label)
            self.assertEqual(ex_layout["dim"][i]["size"], val.size)
            self.assertEqual(ex_layout["dim"][i]["stride"], val.stride)

    def test_unicode_keys(self):
        msg = String(data="foo")
        extracted = extract_cbor_values(msg)

        keys = extracted.keys()
        for key in keys:
            self.assertEqual(type(key), str)



================================================
FILE: rosbridge_library/test/internal/test_compression.py
================================================
#!/usr/bin/env python
import unittest

from rosbridge_library.internal import pngcompression


class TestCompression(unittest.TestCase):
    def test_compress(self):
        bytes_data = list(range(128)) * 10000
        string = str(bytearray(bytes_data))
        encoded = pngcompression.encode(string)
        self.assertNotEqual(string, encoded)
        self.assertIsInstance(encoded, str)

    def test_compress_decompress(self):
        bytes_data = list(range(128)) * 10000
        string = str(bytearray(bytes_data))
        encoded = pngcompression.encode(string)
        self.assertNotEqual(string, encoded)
        decoded = pngcompression.decode(encoded)
        self.assertEqual(string, decoded)



================================================
FILE: rosbridge_library/test/internal/test_message_conversion.py
================================================
#!/usr/bin/env python3
import unittest
from base64 import standard_b64encode
from json import dumps, loads

import numpy as np
from rclpy.serialization import deserialize_message, serialize_message

from rosbridge_library.internal import message_conversion as c
from rosbridge_library.internal import ros_loader


class TestMessageConversion(unittest.TestCase):
    def validate_instance(self, inst1):
        """
        Validate that the instance is correct by serializing and deserializing it.

        Serializes and deserializes the inst to typecheck and ensure that instances are correct.
        """
        inst2 = deserialize_message(serialize_message(inst1), type(inst1))
        self.assertEqual(inst1, inst2)

    def msgs_equal(self, msg1, msg2):
        if isinstance(msg1, str) and isinstance(msg2, str):
            pass
        else:
            self.assertEqual(type(msg1), type(msg2))
        if type(msg1) in c.list_types:
            for x, y in zip(msg1, msg2):
                self.msgs_equal(x, y)
        elif type(msg1) in c.primitive_types or type(msg1) is str:
            self.assertEqual(msg1, msg2)
        else:
            for x in msg1:
                self.assertTrue(x in msg2)
            for x in msg2:
                self.assertTrue(x in msg1)
            for x in msg1:
                self.msgs_equal(msg1[x], msg2[x])

    def do_primitive_test(self, data_value, msgtype):
        for msg in [{"data": data_value}, loads(dumps({"data": data_value}))]:
            inst = ros_loader.get_message_instance(msgtype)
            c.populate_instance(msg, inst)
            self.assertEqual(inst.data, data_value)
            self.validate_instance(inst)
            extracted = c.extract_values(inst)
            for msg2 in [extracted, loads(dumps(extracted))]:
                self.msgs_equal(msg, msg2)
                self.assertEqual(msg["data"], msg2["data"])
                self.assertEqual(msg2["data"], inst.data)

    def do_byte_test(self, data_value, msgtype):
        for msg in [{"data": data_value}]:
            inst = ros_loader.get_message_instance(msgtype)
            c.populate_instance(msg, inst)
            self.assertEqual(inst.data, bytes([data_value]))
            self.validate_instance(inst)
            extracted = c.extract_values(inst)
            for msg2 in [extracted, loads(dumps(extracted))]:
                self.assertEqual(msg["data"], msg2["data"])
                self.assertEqual(bytes([msg2["data"]]), inst.data)

    def do_test(self, orig_msg, msgtype):
        for msg in [orig_msg, loads(dumps(orig_msg))]:
            inst = ros_loader.get_message_instance(msgtype)
            c.populate_instance(msg, inst)
            self.validate_instance(inst)
            extracted = c.extract_values(inst)
            for msg2 in [extracted, loads(dumps(extracted))]:
                self.msgs_equal(msg, msg2)

    def test_int_primitives(self):
        # Test raw primitives
        for msg in range(-100, 100):
            for rostype in ["int8", "int16", "int32", "int64"]:
                self.assertEqual(c._to_primitive_inst(msg, rostype, rostype, []), msg)
                self.assertEqual(c._to_inst(msg, rostype, rostype), msg)
        # Test raw primitives
        for msg in range(200):
            for rostype in ["uint8", "uint16", "uint32", "uint64"]:
                self.assertEqual(c._to_primitive_inst(msg, rostype, rostype, []), msg)
                self.assertEqual(c._to_inst(msg, rostype, rostype), msg)

    def test_byte_primitives(self):
        # Test raw primitives
        for msg in range(200):
            for rostype in ["octet"]:
                self.assertEqual(c._to_primitive_inst(msg, rostype, rostype, []), bytes([msg]))
                self.assertEqual(c._to_inst(msg, rostype, rostype), bytes([msg]))

    def test_bool_primitives(self):
        self.assertTrue(c._to_primitive_inst(True, "bool", "bool", []))
        self.assertTrue(c._to_inst(True, "bool", "bool"))
        self.assertFalse(c._to_primitive_inst(False, "bool", "bool", []))
        self.assertFalse(c._to_inst(False, "bool", "bool"))

    def test_float_primitives(self):
        for msg in [0.12341234 + i for i in range(-100, 100)]:
            for rostype in ["float32", "float64"]:
                self.assertEqual(c._to_primitive_inst(msg, rostype, rostype, []), msg)
                self.assertEqual(c._to_inst(msg, rostype, rostype), msg)
                c._to_inst(msg, rostype, rostype)

    def test_float_special_cases(self):
        for msg in [1e9999999, -1e9999999, float("nan")]:
            for rostype in ["float32", "float64"]:
                self.assertEqual(c._from_inst(msg, rostype), None)
                self.assertEqual(dumps({"data": c._from_inst(msg, rostype)}), '{"data": null}')

    def test_signed_int_base_msgs(self):
        int8s = range(-127, 128)
        for int8 in int8s:
            self.do_primitive_test(int8, "std_msgs/Int8")
            self.do_primitive_test(int8, "std_msgs/Int16")
            self.do_primitive_test(int8, "std_msgs/Int32")
            self.do_primitive_test(int8, "std_msgs/Int64")

        int16s = [-32767, 32767]
        for int16 in int16s:
            self.do_primitive_test(int16, "std_msgs/Int16")
            self.do_primitive_test(int16, "std_msgs/Int32")
            self.do_primitive_test(int16, "std_msgs/Int64")
            self.assertRaises(Exception, self.do_primitive_test, int16, "std_msgs/Int8")

        int32s = [-2147483647, 2147483647]
        for int32 in int32s:
            self.do_primitive_test(int32, "std_msgs/Int32")
            self.do_primitive_test(int32, "std_msgs/Int64")
            self.assertRaises(Exception, self.do_primitive_test, int32, "std_msgs/Int8")
            self.assertRaises(Exception, self.do_primitive_test, int32, "std_msgs/Int16")

        int64s = [-9223372036854775807, 9223372036854775807]
        for int64 in int64s:
            self.do_primitive_test(int64, "std_msgs/Int64")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/Int8")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/Int16")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/Int32")

    def test_unsigned_int_base_msgs(self):
        int8s = range(256)
        for int8 in int8s:
            self.do_primitive_test(int8, "std_msgs/Char")
            self.do_primitive_test(int8, "std_msgs/UInt8")
            self.do_primitive_test(int8, "std_msgs/UInt16")
            self.do_primitive_test(int8, "std_msgs/UInt32")
            self.do_primitive_test(int8, "std_msgs/UInt64")

        int16s = [32767, 32768, 65535]
        for int16 in int16s:
            self.do_primitive_test(int16, "std_msgs/UInt16")
            self.do_primitive_test(int16, "std_msgs/UInt32")
            self.do_primitive_test(int16, "std_msgs/UInt64")
            self.assertRaises(Exception, self.do_primitive_test, int16, "std_msgs/Char")
            self.assertRaises(Exception, self.do_primitive_test, int16, "std_msgs/UInt8")

        int32s = [2147483647, 2147483648, 4294967295]
        for int32 in int32s:
            self.do_primitive_test(int32, "std_msgs/UInt32")
            self.do_primitive_test(int32, "std_msgs/UInt64")
            self.assertRaises(Exception, self.do_primitive_test, int32, "std_msgs/Char")
            self.assertRaises(Exception, self.do_primitive_test, int32, "std_msgs/UInt8")
            self.assertRaises(Exception, self.do_primitive_test, int32, "std_msgs/UInt16")

        int64s = [
            4294967296,
            9223372036854775807,
            9223372036854775808,
            18446744073709551615,
        ]
        for int64 in int64s:
            self.do_primitive_test(int64, "std_msgs/UInt64")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/Char")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/UInt8")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/UInt16")
            self.assertRaises(Exception, self.do_primitive_test, int64, "std_msgs/UInt32")

    def test_byte_base_msg(self):
        int8s = range(256)
        for int8 in int8s:
            self.do_byte_test(int8, "std_msgs/Byte")

    def test_bool_base_msg(self):
        self.do_primitive_test(True, "std_msgs/Bool")
        self.do_primitive_test(False, "std_msgs/Bool")

    def test_string_base_msg(self):
        for x in c.ros_primitive_types:
            self.do_primitive_test(x, "std_msgs/String")

    def test_time_msg(self):
        now_inst = c._to_inst("now", "builtin_interfaces/Time", "builtin_interfaces/Time")
        self.assertTrue("sec" in now_inst.get_fields_and_field_types())
        self.assertTrue("nanosec" in now_inst.get_fields_and_field_types())

        msg = {"sec": 3, "nanosec": 5}
        self.do_test(msg, "builtin_interfaces/Time")

        msg = {"times": [{"sec": 3, "nanosec": 5}, {"sec": 2, "nanosec": 7}]}
        self.do_test(msg, "rosbridge_test_msgs/TestTimeArray")

        # For ROS1 compatibility
        inst1 = c._to_inst(
            {"sec": 3, "nanosec": 5}, "builtin_interfaces/Time", "builtin_interfaces/Time"
        )
        inst2 = c._to_inst(
            {"secs": 3, "nsecs": 5}, "builtin_interfaces/Time", "builtin_interfaces/Time"
        )
        self.assertEqual(inst1, inst2)

    def test_duration_msg(self):
        msg = {"sec": 3, "nanosec": 5}
        self.do_test(msg, "builtin_interfaces/Duration")

        msg = {"durations": [{"sec": 3, "nanosec": 5}, {"sec": 2, "nanosec": 7}]}
        self.do_test(msg, "rosbridge_test_msgs/TestDurationArray")

    def test_header_msg(self):
        msg = {
            "stamp": {"sec": 12347, "nanosec": 322304},
            "frame_id": "2394dnfnlcx;v[p234j]",
        }
        self.do_test(msg, "std_msgs/Header")

        msg = {"header": msg}
        self.do_test(msg, "rosbridge_test_msgs/TestHeader")
        self.do_test(msg, "rosbridge_test_msgs/TestHeaderTwo")

        msg = {"header": [msg["header"], msg["header"], msg["header"]]}
        self.do_test(msg, "rosbridge_test_msgs/TestHeaderArray")

    def test_assorted_msgs(self):
        assortedmsgs = [
            "geometry_msgs/Pose",
            "action_msgs/GoalStatus",
            "geometry_msgs/WrenchStamped",
            "stereo_msgs/DisparityImage",
            "nav_msgs/OccupancyGrid",
            "geometry_msgs/Point32",
            "std_msgs/String",
            "trajectory_msgs/JointTrajectoryPoint",
            "diagnostic_msgs/KeyValue",
            "visualization_msgs/InteractiveMarkerUpdate",
            "nav_msgs/GridCells",
            "sensor_msgs/PointCloud2",
        ]
        for rostype in assortedmsgs:
            inst = ros_loader.get_message_instance(rostype)
            msg = c.extract_values(inst)
            self.do_test(msg, rostype)
            _ = loads(dumps(msg))
            inst2 = ros_loader.get_message_instance(rostype)
            c.populate_instance(msg, inst2)
            self.assertEqual(inst, inst2)

    def test_int8array(self):
        def test_int8_msg(rostype, data):
            msg = {"data": data}
            inst = ros_loader.get_message_instance(rostype)
            c.populate_instance(msg, inst)
            self.validate_instance(inst)
            return inst.data

        for msgtype in ["TestChar", "TestUInt8"]:
            rostype = "rosbridge_test_msgs/" + msgtype

            # From List[int]
            int8s = list(range(256))
            ret = test_int8_msg(rostype, int8s)
            np.testing.assert_array_equal(ret, np.array(int8s))

            # From base64 string
            b64str_int8s = standard_b64encode(bytes(int8s)).decode("ascii")
            ret = test_int8_msg(rostype, b64str_int8s)
            np.testing.assert_array_equal(ret, np.array(int8s))

        for msgtype in ["TestUInt8FixedSizeArray16"]:
            rostype = "rosbridge_test_msgs/" + msgtype

            # From List[int]
            int8s = list(range(16))
            ret = test_int8_msg(rostype, int8s)
            np.testing.assert_array_equal(ret, np.array(int8s))

            # From base64 string
            b64str_int8s = standard_b64encode(bytes(int8s)).decode("ascii")
            ret = test_int8_msg(rostype, b64str_int8s)
            np.testing.assert_array_equal(ret, np.array(int8s))

    def test_float32array(self):
        def test_float32_msg(rostype, data):
            msg = {"data": data}
            inst = ros_loader.get_message_instance(rostype)
            c.populate_instance(msg, inst)
            self.validate_instance(inst)
            return inst.data

        for msgtype in ["TestFloat32Array"]:
            rostype = "rosbridge_test_msgs/" + msgtype

            # From List[float]
            floats = list(map(float, range(256)))
            ret = test_float32_msg(rostype, floats)
            np.testing.assert_array_equal(ret, np.array(floats))

            # From List[int]
            ints = list(map(int, range(256)))
            ret = test_float32_msg(rostype, ints)
            np.testing.assert_array_equal(ret, np.array(ints))

        for msgtype in ["TestFloat32BoundedArray"]:
            rostype = "rosbridge_test_msgs/" + msgtype

            # From List[float]
            floats = list(map(float, range(16)))
            ret = test_float32_msg(rostype, floats)
            np.testing.assert_array_equal(ret, np.array(floats))

            # From List[int]
            ints = list(map(int, range(16)))
            ret = test_float32_msg(rostype, ints)
            np.testing.assert_array_equal(ret, np.array(ints))

    # Test a float32 array with a length with non-numeric characters in it
    def test_float32_complexboundedarray(self):
        def test_nestedboundedarray_msg(rostype, data):
            msg = {"data": {"data": data}}
            inst = ros_loader.get_message_instance(rostype)
            c.populate_instance(msg, inst)
            self.validate_instance(inst)
            return inst.data

        for msgtype in ["TestNestedBoundedArray"]:
            rostype = "rosbridge_test_msgs/" + msgtype

            # From List[float]
            floats = list(map(float, range(16)))
            ret = test_nestedboundedarray_msg(rostype, floats)

            self.assertEqual(c._from_inst(ret, rostype), {"data": floats})



================================================
FILE: rosbridge_library/test/internal/test_outgoing_message.py
================================================
#!/usr/bin/env python
import unittest

from std_msgs.msg import String

from rosbridge_library.internal.outgoing_message import OutgoingMessage


class TestOutgoingMessage(unittest.TestCase):
    def test_json_values(self):
        msg = String(data="foo")
        outgoing = OutgoingMessage(msg)

        result = outgoing.get_json_values()
        self.assertEqual(result["data"], msg.data)

        again = outgoing.get_json_values()
        self.assertTrue(result is again)

    def test_cbor_values(self):
        msg = String(data="foo")
        outgoing = OutgoingMessage(msg)

        result = outgoing.get_cbor_values()
        self.assertEqual(result["data"], msg.data)

        again = outgoing.get_cbor_values()
        self.assertTrue(result is again)



================================================
FILE: rosbridge_library/test/internal/test_ros_loader.py
================================================
#!/usr/bin/env python
import unittest

from rosidl_runtime_py.utilities import get_message

from rosbridge_library.internal import ros_loader


class TestROSLoader(unittest.TestCase):
    #################
    # Message Tests #
    #################
    def test_bad_msg_names(self):
        bad = [
            "",
            "/",
            "//",
            "///",
            "////",
            "/////",
            "bad",
            "stillbad",
            "better/",
            "better//",
            "better///",
            "/better",
            "//better",
            "///better",
            r"this\isbad",
            "\\",
        ]
        for x in bad:
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_message_class, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_message_instance, x
            )

    def test_irregular_msg_names(self):
        irregular = [
            "std_msgs//String",
            "//std_msgs/String",
            "/std_msgs//String",
            "/std_msgs/String",
            "//std_msgs//String",
            "/std_msgs/String/",
            "//std_msgs//String//",
            "std_msgs/String/",
            "std_msgs//String//",
        ]
        for x in irregular:
            self.assertNotEqual(ros_loader.get_message_class(x), None)
            self.assertNotEqual(ros_loader.get_message_instance(x), None)

    def test_std_msg_names(self):
        stdmsgs = [
            "std_msgs/Bool",
            "std_msgs/Byte",
            "std_msgs/ByteMultiArray",
            "std_msgs/ColorRGBA",
            "std_msgs/Empty",
            "std_msgs/Float32",
            "std_msgs/Float32MultiArray",
            "std_msgs/Float64",
            "std_msgs/Header",
            "std_msgs/Int16",
            "std_msgs/Int16MultiArray",
            "std_msgs/Int32",
            "std_msgs/Int32MultiArray",
            "std_msgs/Int64",
            "std_msgs/Int64MultiArray",
            "std_msgs/Int8",
            "std_msgs/Int8MultiArray",
            "std_msgs/MultiArrayDimension",
            "std_msgs/MultiArrayLayout",
            "std_msgs/String",
            "std_msgs/UInt16",
            "std_msgs/UInt16MultiArray",
            "std_msgs/UInt32MultiArray",
            "std_msgs/UInt64MultiArray",
            "std_msgs/UInt32",
            "std_msgs/UInt64",
            "std_msgs/UInt8",
            "std_msgs/UInt8MultiArray",
        ]
        for x in stdmsgs:
            self.assertNotEqual(ros_loader.get_message_class(x), None)
            inst = ros_loader.get_message_instance(x)
            self.assertNotEqual(inst, None)
            self.assertEqual(get_message(x), type(inst))

    def test_msg_cache(self):
        stdmsgs = [
            "std_msgs/Bool",
            "std_msgs/Byte",
            "std_msgs/ByteMultiArray",
            "std_msgs/ColorRGBA",
            "std_msgs/Empty",
            "std_msgs/Float32",
            "std_msgs/Float32MultiArray",
            "std_msgs/Float64",
            "std_msgs/Header",
            "std_msgs/Int16",
            "std_msgs/Int16MultiArray",
            "std_msgs/Int32",
            "std_msgs/Int32MultiArray",
            "std_msgs/Int64",
            "std_msgs/Int64MultiArray",
            "std_msgs/Int8",
            "std_msgs/Int8MultiArray",
            "std_msgs/MultiArrayDimension",
            "std_msgs/MultiArrayLayout",
            "std_msgs/String",
            "std_msgs/UInt16",
            "std_msgs/UInt16MultiArray",
            "std_msgs/UInt32MultiArray",
            "std_msgs/UInt64MultiArray",
            "std_msgs/UInt32",
            "std_msgs/UInt64",
            "std_msgs/UInt8",
            "std_msgs/UInt8MultiArray",
        ]
        for x in stdmsgs:
            self.assertNotEqual(ros_loader.get_message_class(x), None)
            inst = ros_loader.get_message_instance(x)
            self.assertNotEqual(inst, None)
            self.assertEqual(get_message(x), type(inst))
            self.assertTrue(x in ros_loader._loaded_msgs)

    def test_assorted_msg_names(self):
        assortedmsgs = [
            "geometry_msgs/Pose",
            "action_msgs/GoalStatus",
            "geometry_msgs/WrenchStamped",
            "stereo_msgs/DisparityImage",
            "nav_msgs/OccupancyGrid",
            "geometry_msgs/Point32",
            "std_msgs/String",
            "trajectory_msgs/JointTrajectoryPoint",
            "diagnostic_msgs/KeyValue",
            "visualization_msgs/InteractiveMarkerUpdate",
            "nav_msgs/GridCells",
            "sensor_msgs/PointCloud2",
        ]
        for x in assortedmsgs:
            self.assertNotEqual(ros_loader.get_message_class(x), None)
            inst = ros_loader.get_message_instance(x)
            self.assertNotEqual(inst, None)
            self.assertEqual(get_message(x), type(inst))

    def test_invalid_msg_names_primitives(self):
        invalid = [
            "bool",
            "int8",
            "uint8",
            "int16",
            "uint16",
            "int32",
            "uint32",
            "int64",
            "uint64",
            "float32",
            "float64",
            "string",
            "time",
            "duration",
        ]
        for x in invalid:
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_message_class, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException,
                ros_loader.get_message_instance,
                x,
            )

    def test_nonexistent_package_names(self):
        nonexistent = [
            "wangle_msgs/Jam",
            "whistleblower_msgs/Document",
            "coercion_msgs/Bribe",
            "airconditioning_msgs/Cold",
            "pr2thoughts_msgs/Escape",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_message_class, x)
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_message_instance, x)

    def test_packages_without_msgs(self):
        no_msgs = [
            "roslib/Time",
            "roslib/Duration",
            "roslib/Header",
            "std_srvs/ConflictedMsg",
        ]
        for x in no_msgs:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_message_class, x)
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_message_instance, x)

    def test_nonexistent_msg_class_names(self):
        nonexistent = [
            "rcl_interfaces/Time",
            "rcl_interfaces/Duration",
            "rcl_interfaces/Header",
            "std_msgs/Spool",
            "geometry_msgs/Tetrahedron",
            "sensor_msgs/TelepathyUnit",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidClassException, ros_loader.get_message_class, x)
            self.assertRaises(ros_loader.InvalidClassException, ros_loader.get_message_instance, x)

    #################
    # Service Tests #
    #################
    def test_bad_service_names(self):
        bad = [
            "",
            "/",
            "//",
            "///",
            "////",
            "/////",
            "bad",
            "stillbad",
            "not/better/even/still",
            "not//better//even//still",
            "not///better///even///still",
            "better/",
            "better//",
            "better///",
            "/better",
            "//better",
            "///better",
            r"this\isbad",
            "\\",
        ]
        for x in bad:
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_service_class, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_service_request_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_service_response_instance, x
            )

    def test_irregular_service_names(self):
        irregular = [
            "rcl_interfaces//GetParameters",
            "/rcl_interfaces/GetParameters/",
            "/rcl_interfaces/GetParameters",
            "//rcl_interfaces/GetParameters",
            "/rcl_interfaces//GetParameters",
            "rcl_interfaces/GetParameters//",
            "/rcl_interfaces/GetParameters//",
            "rcl_interfaces/GetParameters/",
            "rcl_interfaces//GetParameters//",
        ]
        for x in irregular:
            self.assertNotEqual(ros_loader.get_service_class(x), None)
            self.assertNotEqual(ros_loader.get_service_request_instance(x), None)
            self.assertNotEqual(ros_loader.get_service_response_instance(x), None)

    def test_common_service_names(self):
        common = [
            "rcl_interfaces/GetParameters",
            "rcl_interfaces/SetParameters",
            "std_srvs/Empty",
            "nav_msgs/GetMap",
            "nav_msgs/GetPlan",
            "sensor_msgs/SetCameraInfo",
            "tf2_msgs/FrameGraph",
            "example_interfaces/AddTwoInts",
        ]
        for x in common:
            self.assertNotEqual(ros_loader.get_service_class(x), None)
            self.assertNotEqual(ros_loader.get_service_request_instance(x), None)
            self.assertNotEqual(ros_loader.get_service_response_instance(x), None)

    def test_srv_cache(self):
        common = [
            "rcl_interfaces/GetParameters",
            "rcl_interfaces/SetParameters",
            "std_srvs/Empty",
            "nav_msgs/GetMap",
            "nav_msgs/GetPlan",
            "sensor_msgs/SetCameraInfo",
            "tf2_msgs/FrameGraph",
            "example_interfaces/AddTwoInts",
        ]
        for x in common:
            self.assertNotEqual(ros_loader.get_service_class(x), None)
            self.assertNotEqual(ros_loader.get_service_request_instance(x), None)
            self.assertNotEqual(ros_loader.get_service_response_instance(x), None)
            self.assertTrue(x in ros_loader._loaded_srvs)

    def test_packages_without_srvs(self):
        no_msgs = ["roslib/A", "roslib/B", "roslib/C", "std_msgs/CuriousSrv"]
        for x in no_msgs:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_service_class, x)
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_service_request_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_service_response_instance, x
            )

    def test_nonexistent_service_package_names(self):
        nonexistent = [
            "butler_srvs/FetchDrink",
            "money_srvs/MoreMoney",
            "snoopdogg_srvs/SipOnGinAndJuice",
            "revenge_srvs/BackStab",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_service_class, x)
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_service_request_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_service_response_instance, x
            )

    def test_nonexistent_service_class_names(self):
        nonexistent = [
            "std_srvs/Reboot",
            "std_srvs/Full",
            "nav_msgs/LoseMap",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidClassException, ros_loader.get_service_class, x)
            self.assertRaises(
                ros_loader.InvalidClassException, ros_loader.get_service_request_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidClassException, ros_loader.get_service_response_instance, x
            )

    ################
    # Action Tests #
    ################
    def test_bad_action_names(self):
        bad = [
            "",
            "/",
            "//",
            "///",
            "////",
            "/////",
            "bad",
            "stillbad",
            "not/better/even/still",
            "not//better//even//still",
            "not///better///even///still",
            "better/",
            "better//",
            "better///",
            "/better",
            "//better",
            "///better",
            r"this\isbad",
            "\\",
        ]
        for x in bad:
            self.assertRaises(ros_loader.InvalidTypeStringException, ros_loader.get_action_class, x)
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_action_goal_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_action_feedback_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidTypeStringException, ros_loader.get_action_result_instance, x
            )

    def test_irregular_action_names(self):
        irregular = [
            "example_interfaces//Fibonacci",
            "/example_interfaces/Fibonacci/",
            "/example_interfaces/Fibonacci",
            "//example_interfaces/Fibonacci",
            "/example_interfaces//Fibonacci",
            "example_interfaces/Fibonacci//",
            "/example_interfaces/Fibonacci//",
            "example_interfaces/Fibonacci/",
            "example_interfaces//Fibonacci//",
        ]
        for x in irregular:
            self.assertNotEqual(ros_loader.get_action_class(x), None)
            self.assertNotEqual(ros_loader.get_action_goal_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_feedback_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_result_instance(x), None)

    def test_common_action_names(self):
        common = [
            "control_msgs/FollowJointTrajectory",
            "tf2_msgs/LookupTransform",
            "example_interfaces/Fibonacci",
        ]
        for x in common:
            self.assertNotEqual(ros_loader.get_action_class(x), None)
            self.assertNotEqual(ros_loader.get_action_goal_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_feedback_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_result_instance(x), None)

    def test_action_cache(self):
        common = [
            "control_msgs/FollowJointTrajectory",
            "tf2_msgs/LookupTransform",
            "example_interfaces/Fibonacci",
        ]
        for x in common:
            self.assertNotEqual(ros_loader.get_action_class(x), None)
            self.assertNotEqual(ros_loader.get_action_goal_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_feedback_instance(x), None)
            self.assertNotEqual(ros_loader.get_action_result_instance(x), None)
            self.assertTrue(x in ros_loader._loaded_actions)

    def test_packages_without_actions(self):
        no_msgs = ["roslib/A", "roslib/B", "roslib/C", "std_msgs/CuriousSrv"]
        for x in no_msgs:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_action_class, x)
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_goal_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_feedback_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_result_instance, x
            )

    def test_nonexistent_action_package_names(self):
        nonexistent = [
            "butler_srvs/SetTable",
            "money_srvs/WithdrawMoreMoney",
            "snoopdogg_actions/LayBackWithMyMindOnMyMoneyAndMyMoneyOnMyMind",
            "revenge_actions/PlotRevenge",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidModuleException, ros_loader.get_action_class, x)
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_goal_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_feedback_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidModuleException, ros_loader.get_action_result_instance, x
            )

    def test_nonexistent_action_class_names(self):
        nonexistent = [
            "control_msgs/ControlFusionReactor",
            "tf2_msgs/GetDualQuaternionRepresentation",
            "example_interfaces/DoNonexistentAction",
        ]
        for x in nonexistent:
            self.assertRaises(ros_loader.InvalidClassException, ros_loader.get_action_class, x)
            self.assertRaises(
                ros_loader.InvalidClassException, ros_loader.get_action_goal_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidClassException, ros_loader.get_action_feedback_instance, x
            )
            self.assertRaises(
                ros_loader.InvalidClassException, ros_loader.get_action_result_instance, x
            )


if __name__ == "__main__":
    unittest.main()



================================================
FILE: rosbridge_library/test/internal/actions/test_actions.py
================================================
#!/usr/bin/env python3
import time
import unittest
from threading import Thread

import numpy as np
import rclpy
from example_interfaces.action import Fibonacci
from rclpy.action import ActionClient, ActionServer
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node

from rosbridge_library.internal import actions, ros_loader
from rosbridge_library.internal import message_conversion as c
from rosbridge_library.internal.message_conversion import FieldTypeMismatchException


class ActionTester:
    def __init__(self, executor):
        self.executor = executor
        self.node = Node("action_tester")
        self.executor.add_node(self.node)
        self.action_server = ActionServer(
            self.node,
            Fibonacci,
            "get_fibonacci_sequence",
            self.execute_callback,
        )

    def __del__(self):
        self.executor.remove_node(self.node)

    def start(self):
        req = self.action_class.Goal()
        gen = c.extract_values(req)
        thread = actions.ActionClientHandler(
            self.name,
            self.name,
            gen,
            self.success,
            self.error,
            self.node,
        )
        thread.start()
        thread.join()

    def execute_callback(self, goal):
        self.goal = goal
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal.request.order):
            feedback_msg.sequence.append(feedback_msg.sequence[i] + feedback_msg.sequence[i - 1])
            goal.publish_feedback(feedback_msg)
            time.sleep(0.1)

        goal.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        return result

    def success(self, rsp):
        self.rsp = rsp

    def error(self, exc):
        self.exc = exc

    def validate(self, equality_function):
        if hasattr(self, "exc"):
            print(self.exc)
            raise self.exc
        equality_function(self.input, c.extract_values(self.req))
        equality_function(self.output, self.rsp)


class TestActions(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_node")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.executor.shutdown()
        rclpy.shutdown()

    def msgs_equal(self, msg1, msg2):
        if isinstance(msg1, str) and isinstance(msg2, str):
            pass
        else:
            self.assertEqual(type(msg1), type(msg2))
        if type(msg1) in c.list_types:
            for x, y in zip(msg1, msg2):
                self.msgs_equal(x, y)
        elif (
            type(msg1) in c.primitive_types
            or type(msg1) is str
            or np.issubdtype(type(msg1), np.number)
        ):
            self.assertEqual(msg1, msg2)
        else:
            for x in msg1:
                self.assertTrue(x in msg2)
            for x in msg2:
                self.assertTrue(x in msg1)
            for x in msg1:
                self.msgs_equal(msg1[x], msg2[x])

    def test_populate_goal_args(self):
        # Test empty messages
        for action_type in ["TestEmpty", "TestFeedbackAndResult", "TestResultOnly"]:
            cls = ros_loader.get_action_class("rosbridge_test_msgs/" + action_type)
            for args in [[], {}, None]:
                # Should throw no exceptions
                actions.args_to_action_goal_instance(cls.Goal(), args)

        # Test actions with data message
        for action_type in ["TestGoalOnly", "TestGoalAndResult", "TestGoalFeedbackAndResult"]:
            cls = ros_loader.get_action_class("rosbridge_test_msgs/" + action_type)
            for args in [[3], {"data": 3}]:
                # Should throw no exceptions
                actions.args_to_action_goal_instance(cls.Goal(), args)
            self.assertRaises(
                FieldTypeMismatchException,
                actions.args_to_action_goal_instance,
                cls.Goal(),
                ["hello"],
            )

        # Test actions with multiple fields
        cls = ros_loader.get_action_class("rosbridge_test_msgs/TestMultipleGoalFields")
        for args in [
            [3, 3.5, "hello", False],
            {"int_value": 3, "float_value": 3.5, "string": "hello", "bool_value": False},
        ]:
            # Should throw no exceptions
            actions.args_to_action_goal_instance(cls.Goal(), args)

    def test_send_action_goal(self):
        """Test a simple action call."""
        ActionTester(self.executor)
        self.result = None

        def get_response_callback(future):
            goal_handle = future.result()
            if not goal_handle.accepted:
                return
            result_future = future.result().get_result_async()
            result_future.add_done_callback(get_result_callback)

        def get_result_callback(future):
            self.result = future.result().result

        # First, call the action the 'proper' way
        client = ActionClient(self.node, Fibonacci, "get_fibonacci_sequence")
        client.wait_for_server()
        goal = Fibonacci.Goal()
        goal.order = 5
        future = client.send_goal_async(goal)
        future.add_done_callback(get_response_callback)
        while not future.done():
            time.sleep(0.1)
        client.destroy()

        self.assertIsNotNone(self.result)
        self.assertEqual(list(self.result.sequence), [0, 1, 1, 2, 3, 5])

        # Now, call using the services
        json_ret = actions.SendGoal().send_goal(
            self.node,
            "get_fibonacci_sequence",
            "example_interfaces/Fibonacci",
            {"order": 5},
        )
        self.assertEqual(list(json_ret["result"]["sequence"]), [0, 1, 1, 2, 3, 5])

    def test_action_client_handler(self):
        """Test service_call via the thread caller."""
        ActionTester(self.executor)

        received = {"json": None}

        def success(json):
            received["json"] = json

        def error():
            raise Exception

        # Now, call using the services
        order = 5
        actions.ActionClientHandler(
            "get_fibonacci_sequence",
            "example_interfaces/Fibonacci",
            {"order": order},
            success,
            error,
            None,  # No feedback
            self.node,
        ).start()

        time.sleep(1.0)

        self.assertIsNotNone(received["json"])
        self.assertEqual(list(received["json"]["result"]["sequence"]), [0, 1, 1, 2, 3, 5])


if __name__ == "__main__":
    unittest.main()



================================================
FILE: rosbridge_library/test/internal/publishers/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/test/internal/publishers/test_multi_publisher.py
================================================
#!/usr/bin/env python
import time
import unittest
from threading import Thread

import rclpy
from rclpy.executors import MultiThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile

from rosbridge_library.internal import ros_loader
from rosbridge_library.internal.message_conversion import FieldTypeMismatchException
from rosbridge_library.internal.publishers import MultiPublisher
from rosbridge_library.internal.topics import TypeConflictException
from rosbridge_library.util.ros import is_topic_published


class TestMultiPublisher(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = MultiThreadedExecutor(num_threads=2)
        self.node = Node("test_multi_publisher")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_register_multipublisher(self):
        """Register a publisher on a clean topic with a good msg type."""
        topic = "/test_register_multipublisher"
        msg_type = "std_msgs/String"

        self.assertFalse(is_topic_published(self.node, topic))
        MultiPublisher(topic, self.node, msg_type)
        self.assertTrue(is_topic_published(self.node, topic))

    def test_unregister_multipublisher(self):
        """Register and unregister a publisher on a clean topic with a good msg type."""
        topic = "/test_unregister_multipublisher"
        msg_type = "std_msgs/String"

        self.assertFalse(is_topic_published(self.node, topic))
        p = MultiPublisher(topic, self.node, msg_type)
        self.assertTrue(is_topic_published(self.node, topic))
        p.unregister()
        self.assertFalse(is_topic_published(self.node, topic))

    def test_register_client(self):
        """Adds a publisher then removes it."""
        topic = "/test_register_client"
        msg_type = "std_msgs/String"
        client_id = "client1"

        p = MultiPublisher(topic, self.node, msg_type)
        self.assertFalse(p.has_clients())

        p.register_client(client_id)
        self.assertTrue(p.has_clients())

        p.unregister_client(client_id)
        self.assertFalse(p.has_clients())

    def test_register_multiple_clients(self):
        """Adds multiple publishers then removes them."""
        topic = "/test_register_multiple_clients"
        msg_type = "std_msgs/String"

        p = MultiPublisher(topic, self.node, msg_type)
        self.assertFalse(p.has_clients())

        for i in range(1000):
            p.register_client(f"client{i}")
            self.assertTrue(p.has_clients())

        for i in range(1000):
            self.assertTrue(p.has_clients())
            p.unregister_client(f"client{i}")

        self.assertFalse(p.has_clients())

    def test_verify_type(self):
        topic = "/test_verify_type"
        msg_type = "std_msgs/String"
        othertypes = [
            "geometry_msgs/Pose",
            "action_msgs/GoalStatus",
            "geometry_msgs/WrenchStamped",
            "stereo_msgs/DisparityImage",
            "nav_msgs/OccupancyGrid",
            "geometry_msgs/Point32",
            "trajectory_msgs/JointTrajectoryPoint",
            "diagnostic_msgs/KeyValue",
            "visualization_msgs/InteractiveMarkerUpdate",
            "nav_msgs/GridCells",
            "sensor_msgs/PointCloud2",
        ]

        p = MultiPublisher(topic, self.node, msg_type)
        p.verify_type(msg_type)
        for othertype in othertypes:
            self.assertRaises(TypeConflictException, p.verify_type, othertype)

    def test_publish(self):
        """Make sure that publishing works."""
        topic = "/test_publish"
        msg_type = "std_msgs/String"
        msg = {"data": "why hello there"}

        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        subscriber_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_subscription(
            ros_loader.get_message_class(msg_type), topic, cb, subscriber_qos
        )

        p = MultiPublisher(topic, self.node, msg_type)
        p.publish(msg)
        time.sleep(0.1)
        self.assertEqual(received["msg"].data, msg["data"])

    def test_publish_twice(self):
        """Make sure that publishing works."""
        topic = "/test_publish_twice"
        msg_type = "std_msgs/String"
        msg = {"data": "why hello there"}

        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        subscriber_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_subscription(
            ros_loader.get_message_class(msg_type), topic, cb, subscriber_qos
        )

        p = MultiPublisher(topic, self.node, msg_type)
        p.publish(msg)
        time.sleep(0.1)
        self.assertEqual(received["msg"].data, msg["data"])

        p.unregister()
        # The publisher went away at time T. Here's the timeline of the events:
        # T+1 seconds - the subscriber will retry to reconnect
        # T+2 seconds - publish msg -> it's gone
        # T+3 seconds - publish msg -> OK
        time.sleep(1)

        received["msg"] = None
        self.assertIsNone(received["msg"])
        p = MultiPublisher(topic, self.node, msg_type)

        time.sleep(1)
        p.publish(msg)
        self.assertIsNone(received["msg"])

        time.sleep(1)
        p.publish(msg)
        self.assertEqual(received["msg"].data, msg["data"])

    def test_bad_publish(self):
        """Make sure that bad publishing fails."""
        topic = "/test_publish"
        msg_type = "std_msgs/String"
        msg = {"data": 3}

        p = MultiPublisher(topic, self.node, msg_type)
        self.assertRaises(FieldTypeMismatchException, p.publish, msg)



================================================
FILE: rosbridge_library/test/internal/publishers/test_publisher_manager.py
================================================
#!/usr/bin/env python
import time
import unittest
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import String

from rosbridge_library.internal.message_conversion import FieldTypeMismatchException
from rosbridge_library.internal.publishers import manager
from rosbridge_library.internal.topics import (
    TopicNotEstablishedException,
    TypeConflictException,
)
from rosbridge_library.util.ros import is_topic_published

# Reduce this from its default of 10 to speed up tests
manager.unregister_timeout = 1.0


class TestPublisherManager(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_publisher_manager")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_register_publisher(self):
        """Register a publisher on a clean topic with a good msg type."""
        topic = "/test_register_publisher"
        msg_type = "std_msgs/String"
        client = "client_test_register_publisher"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))
        manager.register(client, topic, self.node, msg_type)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client, topic)
        self.assertTrue(topic in manager.unregister_timers)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        time.sleep(manager.unregister_timeout + 1.0)
        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))
        self.assertFalse(topic in manager.unregister_timers)

    def test_register_publisher_multiclient(self):
        topic = "/test_register_publisher_multiclient"
        msg_type = "std_msgs/String"
        client1 = "client_test_register_publisher_1"
        client2 = "client_test_register_publisher_2"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))

        manager.register(client1, topic, self.node, msg_type)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.register(client2, topic, self.node, msg_type)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client1, topic)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client2, topic)
        self.assertTrue(topic in manager.unregister_timers)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        time.sleep(manager.unregister_timeout + 1.0)
        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))
        self.assertFalse(topic in manager.unregister_timers)

    def test_register_publisher_conflicting_types(self):
        topic = "/test_register_publisher_conflicting_types"
        msg_type = "std_msgs/String"
        msg_type_bad = "std_msgs/Int32"
        client = "client_test_register_publisher_conflicting_types"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))

        manager.register(client, topic, self.node, msg_type)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        self.assertRaises(
            TypeConflictException, manager.register, "client2", topic, self.node, msg_type_bad
        )

    def test_register_multiple_publishers(self):
        topic1 = "/test_register_multiple_publishers1"
        topic2 = "/test_register_multiple_publishers2"
        msg_type = "std_msgs/String"
        client = "client_test_register_multiple_publishers"

        self.assertFalse(topic1 in manager._publishers)
        self.assertFalse(topic2 in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic1))
        self.assertFalse(is_topic_published(self.node, topic2))

        manager.register(client, topic1, self.node, msg_type)
        self.assertTrue(topic1 in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic1))
        self.assertFalse(topic2 in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic2))

        manager.register(client, topic2, self.node, msg_type)
        self.assertTrue(topic1 in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic1))
        self.assertTrue(topic2 in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic2))

        manager.unregister(client, topic1)
        self.assertTrue(is_topic_published(self.node, topic1))
        self.assertTrue(topic1 in manager.unregister_timers)
        self.assertTrue(topic2 in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic2))

        manager.unregister(client, topic2)
        self.assertTrue(topic2 in manager.unregister_timers)
        self.assertTrue(is_topic_published(self.node, topic2))

        time.sleep(manager.unregister_timeout + 1.0)
        self.assertFalse(topic1 in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic1))
        self.assertFalse(topic2 in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic2))
        self.assertFalse(topic1 in manager.unregister_timers)
        self.assertFalse(topic2 in manager.unregister_timers)

    def test_register_no_msgtype(self):
        topic = "/test_register_no_msgtype"
        client = "client_test_register_no_msgtype"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))
        self.assertRaises(TopicNotEstablishedException, manager.register, client, topic, self.node)

    def test_register_infer_topictype(self):
        topic = "/test_register_infer_topictype"
        client = "client_test_register_infer_topictype"

        self.assertFalse(is_topic_published(self.node, topic))

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_publisher(String, topic, publisher_qos)
        time.sleep(0.1)

        self.assertTrue(is_topic_published(self.node, topic))
        self.assertFalse(topic in manager._publishers)

        manager.register(client, topic, self.node)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client, topic)
        self.assertTrue(topic in manager.unregister_timers)
        self.assertTrue(is_topic_published(self.node, topic))

    def test_register_multiple_notopictype(self):
        topic = "/test_register_multiple_notopictype"
        msg_type = "std_msgs/String"
        client1 = "client_test_register_multiple_notopictype_1"
        client2 = "client_test_register_multiple_notopictype_2"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(topic in manager.unregister_timers)
        self.assertFalse(is_topic_published(self.node, topic))

        manager.register(client1, topic, self.node, msg_type)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.register(client2, topic, self.node)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client1, topic)
        self.assertTrue(topic in manager._publishers)
        self.assertTrue(topic in manager.unregister_timers)
        self.assertTrue(is_topic_published(self.node, topic))

        manager.unregister(client2, topic)
        self.assertTrue(topic in manager.unregister_timers)
        self.assertTrue(topic in manager._publishers)

        time.sleep(manager.unregister_timeout + 1.0)
        self.assertFalse(topic in manager._publishers)
        self.assertFalse(topic in manager.unregister_timers)
        self.assertFalse(is_topic_published(self.node, topic))

    def test_publish_not_registered(self):
        topic = "/test_publish_not_registered"
        msg = {"data": "test publish not registered"}
        client = "client_test_publish_not_registered"

        self.assertFalse(topic in manager._publishers)
        self.assertFalse(is_topic_published(self.node, topic))
        self.assertRaises(
            TopicNotEstablishedException, manager.publish, client, topic, msg, self.node
        )

    def test_publisher_manager_publish(self):
        """Make sure that publishing works."""
        topic = "/test_publisher_manager_publish"
        msg = {"data": "test publisher manager publish"}
        client = "client_test_publisher_manager_publish"

        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        subscriber_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_subscription(String, topic, cb, subscriber_qos)

        manager.publish(client, topic, msg, self.node)
        time.sleep(0.5)
        self.assertEqual(received["msg"].data, msg["data"])

    def test_publisher_manager_bad_publish(self):
        """Make sure that bad publishing fails."""
        topic = "/test_publisher_manager_bad_publish"
        client = "client_test_publisher_manager_bad_publish"
        msg_type = "std_msgs/String"
        msg = {"data": 3}

        manager.register(client, topic, self.node, msg_type)
        self.assertRaises(
            FieldTypeMismatchException, manager.publish, client, topic, msg, self.node
        )



================================================
FILE: rosbridge_library/test/internal/services/test_services.py
================================================
#!/usr/bin/env python3
import random
import time
import unittest
from threading import Thread

import numpy as np
import rclpy
from rcl_interfaces.srv import ListParameters
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node

from rosbridge_library.internal import message_conversion as c
from rosbridge_library.internal import ros_loader, services
from rosbridge_library.internal.message_conversion import FieldTypeMismatchException


def populate_random_args(d):
    # Given a dictionary d, replaces primitives with random values
    if isinstance(d, dict):
        for x in d:
            d[x] = populate_random_args(d[x])
        return d
    if isinstance(d, str):
        return str(random.random())
    if isinstance(d, bool):
        return True
    if isinstance(d, int):
        return random.randint(100, 200)
    if isinstance(d, float):
        return 3.5
    return d


class ServiceTester:
    def __init__(self, executor, name, srv_type):
        self.name = name
        self.executor = executor
        self.node = Node("service_tester_" + srv_type.replace("/", "_"))
        self.executor.add_node(self.node)
        self.srvClass = ros_loader.get_service_class(srv_type)
        self.service = self.node.create_service(self.srvClass, name, self.callback)

    def __del__(self):
        self.executor.remove_node(self.node)

    def start(self):
        req = self.srvClass.Request()
        gen = c.extract_values(req)
        gen = populate_random_args(gen)
        self.input = gen
        thread = services.ServiceCaller(
            self.name,
            gen,
            5.0,
            self.success,
            self.error,
            self.node,
        )
        thread.start()
        thread.join()

    def callback(self, req, res):
        self.req = req
        time.sleep(0.1)
        gen = c.extract_values(res)
        gen = populate_random_args(gen)
        try:
            res = c.populate_instance(gen, res)
        except:  # Will print() and raise
            print("populating instance")
            print(res)
            print("populating with")
            print(gen)
            raise
        self.output = gen
        return res

    def success(self, rsp):
        self.rsp = rsp

    def error(self, exc):
        self.exc = exc

    def validate(self, equality_function):
        if hasattr(self, "exc"):
            print(self.exc)
            raise self.exc
        equality_function(self.input, c.extract_values(self.req))
        equality_function(self.output, self.rsp)


class TestServices(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_node")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.executor.shutdown()
        rclpy.shutdown()

    def msgs_equal(self, msg1, msg2):
        if isinstance(msg1, str) and isinstance(msg2, str):
            pass
        else:
            self.assertEqual(type(msg1), type(msg2))
        if type(msg1) in c.list_types:
            for x, y in zip(msg1, msg2):
                self.msgs_equal(x, y)
        elif (
            type(msg1) in c.primitive_types
            or type(msg1) is str
            or np.issubdtype(type(msg1), np.number)
        ):
            self.assertEqual(msg1, msg2)
        else:
            for x in msg1:
                self.assertTrue(x in msg2)
            for x in msg2:
                self.assertTrue(x in msg1)
            for x in msg1:
                self.msgs_equal(msg1[x], msg2[x])

    def test_populate_request_args(self):
        # Test empty messages
        for srv_type in ["TestEmpty", "TestResponseOnly"]:
            cls = ros_loader.get_service_class("rosbridge_test_msgs/" + srv_type)
            for args in [[], {}, None]:
                # Should throw no exceptions
                services.args_to_service_request_instance(cls.Request(), args)

        # Test msgs with data message
        for srv_type in ["TestRequestOnly", "TestRequestAndResponse"]:
            cls = ros_loader.get_service_class("rosbridge_test_msgs/" + srv_type)
            for args in [[3], {"data": 3}]:
                # Should throw no exceptions
                services.args_to_service_request_instance(cls.Request(), args)
            self.assertRaises(
                FieldTypeMismatchException,
                services.args_to_service_request_instance,
                cls.Request(),
                ["hello"],
            )

        # Test message with multiple fields
        cls = ros_loader.get_service_class("rosbridge_test_msgs/TestMultipleRequestFields")
        for args in [
            [3, 3.5, "hello", False],
            {"int_value": 3, "float_value": 3.5, "string": "hello", "bool_value": False},
        ]:
            # Should throw no exceptions
            services.args_to_service_request_instance(cls.Request(), args)

    def test_service_call(self):
        """Test a simple list_parameters service call."""
        # Prepare parameter
        self.node.declare_parameter("test_parameter", 1.0)

        # First, call the service the 'proper' way
        p = self.node.create_client(ListParameters, self.node.get_name() + "/list_parameters")
        p.wait_for_service(0.5)
        ret = p.call_async(ListParameters.Request())
        while not ret.done():
            time.sleep(0.1)
        self.node.destroy_client(p)

        # Now, call using the services
        json_ret = services.call_service(
            self.node,
            self.node.get_name() + "/list_parameters",
        )
        for x, y in zip(ret.result().result.names, json_ret["result"]["names"]):
            self.assertEqual(x, y)

    def test_service_caller(self):
        """Same as test_service_call but via the thread caller."""
        # Prepare parameter
        self.node.declare_parameter("test_parameter", 1.0)

        # First, call the service the 'proper' way
        p = self.node.create_client(ListParameters, self.node.get_name() + "/list_parameters")
        p.wait_for_service(0.5)
        ret = p.call_async(ListParameters.Request())
        while not ret.done():
            time.sleep(0.1)
        self.node.destroy_client(p)

        rcvd = {"json": None}

        def success(json):
            rcvd["json"] = json

        def error():
            raise Exception

        # Now, call using the services
        services.ServiceCaller(
            self.node.get_name() + "/list_parameters",
            None,
            5.0,
            success,
            error,
            self.node,
        ).start()

        time.sleep(0.2)

        for x, y in zip(ret.result().result.names, rcvd["json"]["result"]["names"]):
            self.assertEqual(x, y)

    def test_service_tester(self):
        t = ServiceTester(
            self.executor, "/test_service_tester", "rosbridge_test_msgs/TestRequestAndResponse"
        )
        t.start()
        time.sleep(0.2)
        t.validate(self.msgs_equal)

    def test_service_tester_alltypes(self):
        ts = []
        for srv in [
            "TestResponseOnly",
            "TestEmpty",
            "TestRequestAndResponse",
            "TestRequestOnly",
            "TestMultipleResponseFields",
            "TestMultipleRequestFields",
            "TestArrayRequest",
        ]:
            t = ServiceTester(
                self.executor, "/test_service_tester_alltypes_" + srv, "rosbridge_test_msgs/" + srv
            )
            t.start()
            ts.append(t)

        time.sleep(0.2)

        for t in ts:
            t.validate(self.msgs_equal)

    def test_random_service_types(self):
        common = [
            "rcl_interfaces/ListParameters",
            "rcl_interfaces/SetParameters",
            "std_srvs/Empty",
            "nav_msgs/GetMap",
            "nav_msgs/GetPlan",
            "sensor_msgs/SetCameraInfo",
            "tf2_msgs/FrameGraph",
            "example_interfaces/AddTwoInts",
        ]
        ts = []
        for srv in common:
            t = ServiceTester(self.executor, "/test_random_service_types/" + srv, srv)
            t.start()
            ts.append(t)

        time.sleep(0.2)

        for t in ts:
            t.validate(self.msgs_equal)



================================================
FILE: rosbridge_library/test/internal/subscribers/__init__.py
================================================
[Empty file]


================================================
FILE: rosbridge_library/test/internal/subscribers/test_multi_subscriber.py
================================================
#!/usr/bin/env python
import time
import unittest
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import Int32, String

from rosbridge_library.internal.subscribers import MultiSubscriber
from rosbridge_library.internal.topics import TypeConflictException
from rosbridge_library.util.ros import is_topic_subscribed


class TestMultiSubscriber(unittest.TestCase):
    def setUp(self):
        self.client_id = "test_client_id"

        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_multi_subscriber")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_register_multisubscriber(self):
        """Register a subscriber on a clean topic with a good msg type."""
        topic = "/test_register_multisubscriber"
        msg_type = "std_msgs/String"

        self.assertFalse(is_topic_subscribed(self.node, topic))
        MultiSubscriber(topic, self.client_id, lambda *_args: None, self.node, msg_type=msg_type)
        time.sleep(0.05)
        self.assertTrue(is_topic_subscribed(self.node, topic))

    def test_unregister_multisubscriber(self):
        """Register and unregister a subscriber on a clean topic with a good msg type."""
        topic = "/test_unregister_multisubscriber"
        msg_type = "std_msgs/String"

        self.assertFalse(is_topic_subscribed(self.node, topic))
        multi = MultiSubscriber(
            topic, self.client_id, lambda *_args: None, self.node, msg_type=msg_type
        )
        time.sleep(0.05)
        self.assertTrue(is_topic_subscribed(self.node, topic))
        multi.unregister()
        time.sleep(0.05)
        self.assertFalse(is_topic_subscribed(self.node, topic))

    def test_verify_type(self):
        topic = "/test_verify_type"
        msg_type = "std_msgs/String"
        othertypes = [
            "geometry_msgs/Pose",
            "action_msgs/GoalStatus",
            "geometry_msgs/WrenchStamped",
            "stereo_msgs/DisparityImage",
            "nav_msgs/OccupancyGrid",
            "geometry_msgs/Point32",
            "trajectory_msgs/JointTrajectoryPoint",
            "diagnostic_msgs/KeyValue",
            "visualization_msgs/InteractiveMarkerUpdate",
            "nav_msgs/GridCells",
            "sensor_msgs/PointCloud2",
        ]

        s = MultiSubscriber(
            topic, self.client_id, lambda *_args: None, self.node, msg_type=msg_type
        )
        s.verify_type(msg_type)
        for othertype in othertypes:
            self.assertRaises(TypeConflictException, s.verify_type, othertype)

    def test_subscribe_unsubscribe(self):
        topic = "/test_subscribe_unsubscribe"
        msg_type = "std_msgs/String"

        self.assertFalse(is_topic_subscribed(self.node, topic))
        multi = MultiSubscriber(
            topic, self.client_id, lambda *_args: None, self.node, msg_type=msg_type
        )
        time.sleep(0.05)
        self.assertTrue(is_topic_subscribed(self.node, topic))
        self.assertEqual(len(multi.new_subscriptions), 0)

        multi.subscribe(self.client_id, None)
        self.assertEqual(len(multi.new_subscriptions), 1)

        multi.unsubscribe(self.client_id)
        self.assertEqual(len(multi.new_subscriptions), 0)

        multi.unregister()
        time.sleep(0.1)
        self.assertFalse(is_topic_subscribed(self.node, topic))

    def test_subscribe_receive_json(self):
        topic = "/test_subscribe_receive_json"
        msg_type = "std_msgs/String"

        msg = String()
        msg.data = "dsajfadsufasdjf"

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(String, topic, publisher_qos)
        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg.get_json_values()

        MultiSubscriber(topic, self.client_id, cb, self.node, msg_type=msg_type)
        time.sleep(0.1)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(msg.data, received["msg"]["data"])

    def test_subscribe_receive_json_multiple(self):
        topic = "/test_subscribe_receive_json_multiple"
        msg_type = "std_msgs/Int32"

        numbers = list(range(100))

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(Int32, topic, publisher_qos)
        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg.get_json_values()["data"])

        MultiSubscriber(topic, self.client_id, cb, self.node, msg_type=msg_type)
        time.sleep(0.1)
        for x in numbers:
            msg = Int32()
            msg.data = x
            pub.publish(msg)
            time.sleep(0.01)
        time.sleep(0.1)
        self.assertEqual(numbers, received["msgs"])

    def test_unsubscribe_does_not_receive_further_msgs(self):
        topic = "/test_unsubscribe_does_not_receive_further_msgs"
        msg_type = "std_msgs/String"

        msg = String()
        msg.data = "dsajfadsufasdjf"

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(String, topic, publisher_qos)
        received = {"count": 0}

        def cb(_msg):
            received["count"] = received["count"] + 1

        multi = MultiSubscriber(topic, self.client_id, cb, self.node, msg_type=msg_type)
        time.sleep(0.1)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(received["count"], 1)
        multi.unsubscribe(self.client_id)
        time.sleep(0.1)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(received["count"], 1)

    def test_multiple_subscribers(self):
        topic = "/test_subscribe_receive_json"
        msg_type = "std_msgs/String"
        client1 = "client_test_subscribe_receive_json_1"
        client2 = "client_test_subscribe_receive_json_2"

        msg = String()
        msg.data = "dsajfadsufasdjf"

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(String, topic, publisher_qos)

        received = {"msg1": None, "msg2": None}

        def cb1(msg):
            received["msg1"] = msg.get_json_values()

        def cb2(msg):
            received["msg2"] = msg.get_json_values()

        multi = MultiSubscriber(topic, client1, cb1, self.node, msg_type=msg_type)
        multi.subscribe(client2, cb2)
        time.sleep(0.1)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(msg.data, received["msg1"]["data"])
        self.assertEqual(msg.data, received["msg2"]["data"])



================================================
FILE: rosbridge_library/test/internal/subscribers/test_subscriber_manager.py
================================================
#!/usr/bin/env python
import time
import unittest
from threading import Thread

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import String

from rosbridge_library.internal.subscribers import manager
from rosbridge_library.internal.topics import (
    TopicNotEstablishedException,
    TypeConflictException,
)
from rosbridge_library.util.ros import is_topic_subscribed


class TestSubscriberManager(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_subscriber_manager")
        self.executor.add_node(self.node)

        self.exec_thread = Thread(target=self.executor.spin)
        self.exec_thread.start()

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        self.executor.shutdown()
        rclpy.shutdown()

    def test_subscribe(self):
        """Register a publisher on a clean topic with a good msg type."""
        topic = "/test_subscribe"
        msg_type = "std_msgs/String"
        client = "client_test_subscribe"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))
        manager.subscribe(client, topic, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client, topic)
        time.sleep(0.05)
        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))

    def test_register_subscriber_multiclient(self):
        topic = "/test_register_subscriber_multiclient"
        msg_type = "std_msgs/String"
        client1 = "client_test_register_subscriber_multiclient_1"
        client2 = "client_test_register_subscriber_multiclient_2"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))
        manager.subscribe(client1, topic, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.subscribe(client2, topic, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client1, topic)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client2, topic)
        time.sleep(0.05)
        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))

    def test_register_publisher_conflicting_types(self):
        topic = "/test_register_publisher_conflicting_types"
        msg_type = "std_msgs/String"
        msg_type_bad = "std_msgs/Int32"
        client = "client_test_register_publisher_conflicting_types"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))
        manager.subscribe(client, topic, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        self.assertRaises(
            TypeConflictException,
            manager.subscribe,
            "client2",
            topic,
            None,
            self.node,
            msg_type_bad,
        )

    def test_register_multiple_publishers(self):
        topic1 = "/test_register_multiple_publishers1"
        topic2 = "/test_register_multiple_publishers2"
        msg_type = "std_msgs/String"
        client = "client_test_register_multiple_publishers"

        self.assertFalse(topic1 in manager._subscribers)
        self.assertFalse(topic2 in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic1))
        self.assertFalse(is_topic_subscribed(self.node, topic2))

        manager.subscribe(client, topic1, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic1 in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic1))
        self.assertFalse(topic2 in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic2))

        manager.subscribe(client, topic2, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic1 in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic1))
        self.assertTrue(topic2 in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic2))

        manager.unsubscribe(client, topic1)
        time.sleep(0.05)
        self.assertFalse(topic1 in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic1))
        self.assertTrue(topic2 in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic2))

        manager.unsubscribe(client, topic2)
        time.sleep(0.05)
        self.assertFalse(topic1 in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic1))
        self.assertFalse(topic2 in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic2))

    def test_register_no_msgtype(self):
        topic = "/test_register_no_msgtype"
        client = "client_test_register_no_msgtype"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))
        self.assertRaises(
            TopicNotEstablishedException, manager.subscribe, client, topic, None, self.node
        )

    def test_register_infer_topictype(self):
        topic = "/test_register_infer_topictype"
        client = "client_test_register_infer_topictype"

        self.assertFalse(is_topic_subscribed(self.node, topic))

        subscriber_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        self.node.create_subscription(String, topic, lambda *_args: None, subscriber_qos)

        self.assertTrue(is_topic_subscribed(self.node, topic))
        self.assertFalse(topic in manager._subscribers)

        manager.subscribe(client, topic, None, self.node)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client, topic)
        time.sleep(0.05)
        self.assertFalse(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

    def test_register_multiple_notopictype(self):
        topic = "/test_register_multiple_notopictype"
        msg_type = "std_msgs/String"
        client1 = "client_test_register_multiple_notopictype_1"
        client2 = "client_test_register_multiple_notopictype_2"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))

        manager.subscribe(client1, topic, None, self.node, msg_type)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.subscribe(client2, topic, None, self.node)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client1, topic)
        time.sleep(0.05)
        self.assertTrue(topic in manager._subscribers)
        self.assertTrue(is_topic_subscribed(self.node, topic))

        manager.unsubscribe(client2, topic)
        time.sleep(0.05)
        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))

    def test_subscribe_not_registered(self):
        topic = "/test_subscribe_not_registered"
        client = "client_test_subscribe_not_registered"

        self.assertFalse(topic in manager._subscribers)
        self.assertFalse(is_topic_subscribed(self.node, topic))
        self.assertRaises(
            TopicNotEstablishedException, manager.subscribe, client, topic, None, self.node
        )

    def test_publisher_manager_publish(self):
        topic = "/test_publisher_manager_publish"
        msg_type = "std_msgs/String"
        client = "client_test_publisher_manager_publish"

        msg = String()
        msg.data = "dsajfadsufasdjf"

        publisher_qos = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )
        pub = self.node.create_publisher(String, topic, publisher_qos)
        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg.get_json_values()

        manager.subscribe(client, topic, cb, self.node, msg_type)
        time.sleep(0.1)
        pub.publish(msg)
        time.sleep(0.1)
        self.assertEqual(msg.data, received["msg"]["data"])



================================================
FILE: rosbridge_library/test/internal/subscribers/test_subscription_modifiers.py
================================================
#!/usr/bin/env python
import time
import unittest

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node

from rosbridge_library.internal import subscription_modifiers


class TestMessageHandlers(unittest.TestCase):
    def setUp(self):
        rclpy.init()
        self.executor = SingleThreadedExecutor()
        self.node = Node("test_subscription_modifiers")
        self.executor.add_node(self.node)

    def tearDown(self):
        self.executor.remove_node(self.node)
        self.node.destroy_node()
        rclpy.shutdown()

    def dummy_cb(self, msg):
        pass

    def test_default_message_handler(self):
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        self.help_test_default(handler)

    def test_throttle_message_handler(self):
        handler = subscription_modifiers.ThrottleMessageHandler(
            subscription_modifiers.MessageHandler(None, self.dummy_cb)
        )
        self.help_test_throttle(handler, 50)

    def test_queue_message_handler_passes_msgs(self):
        handler = subscription_modifiers.QueueMessageHandler(
            subscription_modifiers.MessageHandler(None, self.dummy_cb)
        )
        self.help_test_queue(handler, 1000)
        handler.finish()

    def test_queue_message_handler_stops(self):
        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)

        handler = subscription_modifiers.QueueMessageHandler(
            subscription_modifiers.MessageHandler(None, cb)
        )

        self.assertTrue(handler.is_alive())

        handler.finish()

        self.assertFalse(handler.is_alive())

    def test_queue_message_handler_queue(self):
        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)

        msgs = range(1000)

        handler = subscription_modifiers.MessageHandler(None, cb)

        handler = handler.set_throttle_rate(10000)
        handler = handler.set_queue_length(10)
        self.assertIsInstance(handler, subscription_modifiers.QueueMessageHandler)

        # 'hello' is handled immediately
        handler.handle_message("hello")
        time.sleep(0.02)
        # queue is now empty, but throttling is in effect
        # no messages will be handled in the next 10 seconds

        # these will fill up the queue, with newer values displacing old ones
        # nothing gets sent because the throttle rate
        for x in msgs:
            handler.handle_message(x)

        handler = handler.set_throttle_rate(0)

        time.sleep(0.1)

        try:
            self.assertEqual(["hello", *list(range(990, 1000))], received["msgs"])
        finally:
            handler.finish()

    def test_queue_message_handler_dropping(self):
        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)
            time.sleep(1)

        queue_length = 5
        msgs = range(queue_length * 5)

        handler = subscription_modifiers.MessageHandler(None, cb)

        handler = handler.set_queue_length(queue_length)
        self.assertIsInstance(handler, subscription_modifiers.QueueMessageHandler)

        # send all messages at once.
        # only the first and the last queue_length should get through,
        # because the callbacks are blocked.
        for x in msgs:
            handler.handle_message(x)
            # yield the thread so the first callback can append,
            # otherwise the first handled value is non-deterministic.
            time.sleep(0.01)

        # wait long enough for all the callbacks, and then some.
        time.sleep(queue_length + 3)

        try:
            self.assertEqual([msgs[0], *list(msgs[-queue_length:])], received["msgs"])
        except:  # Will finish and raise
            handler.finish()
            raise

        handler.finish()

    def test_queue_message_handler_rate(self):
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        self.help_test_queue_rate(handler, 50, 10)
        handler.finish()

    # Helper methods for each of the three Handler types, plus one for Queue+Rate.
    # Used in standalone testing as well as the test_transition_functionality test
    def help_test_default(self, handler):
        handler = handler.set_queue_length(0)
        handler = handler.set_throttle_rate(0)
        self.assertIsInstance(handler, subscription_modifiers.MessageHandler)

        msg = "test_default_message_handler"
        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        handler.publish = cb

        self.assertTrue(handler.time_remaining() == 0)
        t1 = time.monotonic()
        handler.handle_message(msg)
        t2 = time.monotonic()

        self.assertEqual(received["msg"], msg)
        self.assertLessEqual(t1, handler.last_publish)
        self.assertLessEqual(handler.last_publish, t2)
        self.assertEqual(handler.time_remaining(), 0)

        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)

        handler.publish = cb
        xs = list(range(10000))
        for x in xs:
            handler.handle_message(x)

        self.assertEqual(received["msgs"], xs)
        return handler

    def help_test_throttle(self, handler, throttle_rate):
        handler = handler.set_queue_length(0)
        handler = handler.set_throttle_rate(throttle_rate)
        self.assertIsInstance(handler, subscription_modifiers.ThrottleMessageHandler)

        msg = "test_throttle_message_handler"

        # First, try with a single message
        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        handler.publish = cb

        # ensure the handler doesn't swallow this message
        time.sleep(2.0 * handler.throttle_rate)
        handler.handle_message(msg)
        self.assertEqual(received["msg"], msg)

        # sleep to make sure the handler sends right away for the second part
        time.sleep(2.0 * handler.throttle_rate)

        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)

        handler.publish = cb
        x = 0
        time_padding = handler.throttle_rate / 4.0
        for i in range(1, 10):
            # We guarantee that in the while loop below only the first message is handled
            # All subsequent messages (within throttling window - time_padding ) are dropped
            # Time padding is a test-only hack around race condition when time.time() - fin is within
            # the throttling window, but handler.handle_message(x) gets a later timestamp that is outside.
            time.sleep(2.0 * time_padding)
            fin = time.time() + throttle_rate / 1000.0 - time_padding
            while time.time() < fin:
                handler.handle_message(x)
                x = x + 1
            self.assertEqual(len(received["msgs"]), i)
        return handler

    def help_test_queue(self, handler, queue_length):
        handler = handler.set_queue_length(queue_length)
        self.assertIsInstance(handler, subscription_modifiers.QueueMessageHandler)

        received = {"msgs": []}

        def cb(msg):
            received["msgs"].append(msg)

        handler.publish = cb

        msgs = list(range(queue_length))
        for x in msgs:
            handler.handle_message(x)

        time.sleep(0.1)

        self.assertEqual(msgs, received["msgs"])
        return handler

    def help_test_queue_rate(self, handler, throttle_rate, queue_length):
        handler = handler.set_throttle_rate(throttle_rate)
        handler = handler.set_queue_length(queue_length)
        self.assertIsInstance(handler, subscription_modifiers.QueueMessageHandler)

        received = {"msg": None}

        def cb(msg):
            received["msg"] = msg

        handler.publish = cb

        throttle_rate_sec = throttle_rate / 1000.0

        # ensure previous tests' last sent time is long enough ago
        time.sleep(throttle_rate_sec)
        for x in range(queue_length):
            handler.handle_message(x)

        time.sleep(throttle_rate_sec / 2.0)

        try:
            for x in range(10):
                self.assertEqual(x, received["msg"])
                time.sleep(throttle_rate_sec)
        except:  # Will finish and raise
            handler.finish()
            raise

        return handler

    # Test that each transition works and is stable
    def test_transitions(self):
        # MessageHandler.transition is stable
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        next_handler = handler.transition()
        self.assertEqual(handler, next_handler)

        # Going from MessageHandler to ThrottleMessageHandler...
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        next_handler = handler.set_throttle_rate(100)
        self.assertIsInstance(next_handler, subscription_modifiers.ThrottleMessageHandler)
        handler = next_handler
        # Testing transition returns another ThrottleMessageHandler
        next_handler = handler.transition()
        self.assertEqual(handler, next_handler)
        # And finally going back to MessageHandler
        next_handler = handler.set_throttle_rate(0)
        self.assertIsInstance(next_handler, subscription_modifiers.MessageHandler)

        # Same for QueueMessageHandler
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        next_handler = handler.set_queue_length(100)
        self.assertIsInstance(next_handler, subscription_modifiers.QueueMessageHandler)
        handler = next_handler
        next_handler = handler.transition()
        self.assertEqual(handler, next_handler)
        next_handler = handler.set_queue_length(0)
        self.assertIsInstance(next_handler, subscription_modifiers.MessageHandler)

        # Checking a QueueMessageHandler with rate limit can be generated both ways
        handler = subscription_modifiers.MessageHandler(None, self.dummy_cb)
        next_handler = handler.set_queue_length(100).set_throttle_rate(100)
        self.assertIsInstance(next_handler, subscription_modifiers.QueueMessageHandler)
        next_handler.finish()
        next_handler = handler.set_throttle_rate(100).set_queue_length(100)
        self.assertIsInstance(next_handler, subscription_modifiers.QueueMessageHandler)
        next_handler.finish()
        handler = next_handler
        next_handler = handler.transition()
        self.assertEqual(handler, next_handler)
        # Check both steps on the way back to plain MessageHandler
        next_handler = handler.set_throttle_rate(0)
        self.assertIsInstance(next_handler, subscription_modifiers.QueueMessageHandler)
        next_handler = handler.set_queue_length(0)
        self.assertIsInstance(next_handler, subscription_modifiers.MessageHandler)

    def test_transition_functionality(self):
        # Test individually
        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_queue(handler, 10)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_throttle(handler, 50)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_default(handler)
        handler.finish()

        # Test combinations
        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_queue(handler, 10)
        handler = self.help_test_throttle(handler, 50)
        handler = self.help_test_default(handler)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_queue(handler, 10)
        handler = self.help_test_default(handler)
        handler = self.help_test_throttle(handler, 50)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_throttle(handler, 50)
        handler = self.help_test_queue_rate(handler, 50, 10)
        handler = self.help_test_default(handler)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_throttle(handler, 50)
        handler = self.help_test_default(handler)
        handler = self.help_test_queue_rate(handler, 50, 10)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_default(handler)
        handler = self.help_test_throttle(handler, 50)
        handler = self.help_test_queue_rate(handler, 50, 10)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_default(handler)
        handler = self.help_test_queue(handler, 10)
        handler = self.help_test_throttle(handler, 50)
        handler.finish()

        # Test duplicates
        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_queue_rate(handler, 50, 10)
        handler = self.help_test_queue_rate(handler, 100, 10)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_throttle(handler, 50)
        handler = self.help_test_throttle(handler, 100)
        handler.finish()

        handler = subscription_modifiers.MessageHandler(None, None)
        handler = self.help_test_default(handler)
        handler = self.help_test_default(handler)
        handler.finish()



================================================
FILE: rosbridge_msgs/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosbridge_msgs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------

2.2.0 (2025-02-26)
------------------
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Contributors: Błażej Sowa

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------

1.3.2 (2023-09-27)
------------------

1.3.1 (2022-10-21)
------------------

1.3.0 (2022-08-16)
------------------

1.2.0 (2022-05-20)
------------------

1.1.2 (2022-01-03)
------------------

1.1.1 (2021-12-09)
------------------

1.1.0 (2021-10-22)
------------------

1.0.8 (2021-08-26)
------------------

1.0.7 (2021-08-18)
------------------

1.0.6 (2021-08-17)
------------------

1.0.5 (2021-08-12)
------------------

1.0.4 (2021-08-11)
------------------

1.0.3 (2021-08-03)
------------------

1.0.2 (2019-09-24)
------------------

1.0.1 (2019-09-20)
------------------

1.0.0 (2019-09-19)
------------------
* Port to ROS 2

0.11.3 (2019-08-07)
-------------------

0.11.2 (2019-07-08)
-------------------

0.11.1 (2019-05-08)
-------------------

0.11.0 (2019-03-29)
-------------------
* Additional client information websocket (`#393 <https://github.com/RobotWebTools/rosbridge_suite/issues/393>`_)
  * Add package rosbridge_msgs.
  * rosbridge_server: Publish additional information about connected clients.
  * rosbridge_server: Make ClientManager's add_client/remove_client methods thread safe.
  * rosbridge_server: Rm unnecessary publishing.
  * rosbridge_msgs: Cleanup/fix dependencies.
* Contributors: Hans-Joachim Krauch



================================================
FILE: rosbridge_msgs/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosbridge_msgs)

find_package(ament_cmake REQUIRED)
find_package(builtin_interfaces REQUIRED)
find_package(rosidl_default_generators REQUIRED)

if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 14)
endif()

rosidl_generate_interfaces(${PROJECT_NAME}
  msg/ConnectedClient.msg
  msg/ConnectedClients.msg
  DEPENDENCIES builtin_interfaces
)

ament_export_dependencies(rosidl_default_runtime)

ament_package()



================================================
FILE: rosbridge_msgs/package.xml
================================================
<?xml version="1.0"?>
<package format="3">
  <name>rosbridge_msgs</name>
  <version>2.3.0</version>
  <description>Interface definitions for the rosbridge library.</description>

  <author email="achim@intermodalics.eu">Hans-Joachim Krauch</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <license>BSD</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>builtin_interfaces</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosbridge_msgs/msg/ConnectedClient.msg
================================================
string ip_address
builtin_interfaces/Time connection_time



================================================
FILE: rosbridge_msgs/msg/ConnectedClients.msg
================================================
ConnectedClient[] clients



================================================
FILE: rosbridge_server/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosbridge_server
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------
* Add missing service timeout parameter to conditional launch (`#1028 <https://github.com/RobotWebTools/rosbridge_suite/issues/1028>`_)
* Contributors: Ana

2.2.0 (2025-02-26)
------------------
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Prevent parameter retrieval crashes (`#978 <https://github.com/RobotWebTools/rosbridge_suite/issues/978>`_)
* Call services and send action goals in new threads by default (`#996 <https://github.com/RobotWebTools/rosbridge_suite/issues/996>`_)
* Add timeout option to call_service messages (`#984 <https://github.com/RobotWebTools/rosbridge_suite/issues/984>`_)
* Add ament_mypy test and fix all mypy errors (`#980 <https://github.com/RobotWebTools/rosbridge_suite/issues/980>`_)
* Add namespace and respawn parameters to the nodes in the launch file (`#977 <https://github.com/RobotWebTools/rosbridge_suite/issues/977>`_)
* fix: add url_path parameter in rosbridge_websocket_launch.xml (`#963 <https://github.com/RobotWebTools/rosbridge_suite/issues/963>`_)
* Contributors: Błażej Sowa, Lebecque Florian, Mehsias, Matthias Rathauscher, SeanPai

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------
* Fix action cancellation by passing status from JSON (`#953 <https://github.com/RobotWebTools/rosbridge_suite/issues/953>`_)
* Update pre-commit and fix issues (`#954 <https://github.com/RobotWebTools/rosbridge_suite/issues/954>`_)
* rosbridge_websocket: Stop websocket server if ROS shuts down (`#946 <https://github.com/RobotWebTools/rosbridge_suite/issues/946>`_)
* Support actions in rosbridge protocol (`#886 <https://github.com/RobotWebTools/rosbridge_suite/issues/886>`_)
* Port unit tests to ROS 2 + Fix CBOR conversion and PNG compression (`#882 <https://github.com/RobotWebTools/rosbridge_suite/issues/882>`_)
* Contributors: Brad Martin, Sebastian Castro

1.3.2 (2023-09-27)
------------------
* Add option to call services in a separate thread (`#847 <https://github.com/RobotWebTools/rosbridge_suite/issues/847>`_)
* Contributors: Sebastian Castro

1.3.1 (2022-10-21)
------------------
* Fix exceptions not being handled correctly. (`#817 <https://github.com/RobotWebTools/rosbridge_suite/issues/817>`_)
* Skip unnecessary conversion for cbor/cbor-raw compression (`#792 <https://github.com/RobotWebTools/rosbridge_suite/issues/792>`_) (`#800 <https://github.com/RobotWebTools/rosbridge_suite/issues/800>`_)
* Improve robustness for multiple client connections (`#803 <https://github.com/RobotWebTools/rosbridge_suite/issues/803>`_)
* Minor performance improvements (`#809 <https://github.com/RobotWebTools/rosbridge_suite/issues/809>`_)
* Fix hostname parameter is no longer converted as an int value (`#780 <https://github.com/RobotWebTools/rosbridge_suite/issues/780>`_)
* Fix duplicate subscription created with wrong 'raw' attribute. (`#798 <https://github.com/RobotWebTools/rosbridge_suite/issues/798>`_)
* Add graceful shutdown (`#794 <https://github.com/RobotWebTools/rosbridge_suite/issues/794>`_)
* Contributors: Hans-Joachim Krauch, Hugo Perier, Steffen Nattke

1.3.0 (2022-08-16)
------------------
* Add url_path config option (`#709 <https://github.com/RobotWebTools/rosbridge_suite/issues/709>`_)
* Contributors: Matthijs van der Burgh, Sirawat S

1.2.0 (2022-05-20)
------------------
* Fixed multiple subscriber on transient_local topic (`#723 <https://github.com/RobotWebTools/rosbridge_suite/issues/723>`_)
* use uuid to ensure client id uniqueness (`#713 <https://github.com/RobotWebTools/rosbridge_suite/issues/713>`_)
* Contributors: Jacob Bandes-Storch, Will, p0rys

1.1.2 (2022-01-03)
------------------
* [694] update DurabilityPolicy api that are being deprecated (`#695 <https://github.com/RobotWebTools/rosbridge_suite/issues/695>`_)
* Contributors: Evan Flynn

1.1.1 (2021-12-09)
------------------
* Allow subscribing to any qos profile when creating a subscriber (`#690 <https://github.com/RobotWebTools/rosbridge_suite/issues/690>`_)
* Fix and add test for multiple subscribers to same topic (`#687 <https://github.com/RobotWebTools/rosbridge_suite/issues/687>`_)
* Delete unsupported TCP and UDP server implementations in ROS 2 branch (`#685 <https://github.com/RobotWebTools/rosbridge_suite/issues/685>`_)
* Fix error when advertising duplicate service (`#683 <https://github.com/RobotWebTools/rosbridge_suite/issues/683>`_)
* Fix incoming service calls (`#669 <https://github.com/RobotWebTools/rosbridge_suite/issues/669>`_)
* Replace busy wait in AdvertiseService with async handler (`#666 <https://github.com/RobotWebTools/rosbridge_suite/issues/666>`_)
* Refactor smoke test to make WebSocket test harness reusable (`#675 <https://github.com/RobotWebTools/rosbridge_suite/issues/675>`_)
* Contributors: Domenic Rodriguez, Jacob Bandes-Storch, Roman Shtylman

1.1.0 (2021-10-22)
------------------
* Exit cleanly on SIGINT; remove sleep in test (`#667 <https://github.com/RobotWebTools/rosbridge_suite/issues/667>`_)
* Fix unused variables: flake8 --select=F841 (`#623 <https://github.com/RobotWebTools/rosbridge_suite/issues/623>`_)
* Fix undefined name in rosbridge_websocket (`#659 <https://github.com/RobotWebTools/rosbridge_suite/issues/659>`_)
* Port `#464 <https://github.com/RobotWebTools/rosbridge_suite/issues/464>`_, `#478 <https://github.com/RobotWebTools/rosbridge_suite/issues/478>`_, `#496 <https://github.com/RobotWebTools/rosbridge_suite/issues/496>`_, and `#502 <https://github.com/RobotWebTools/rosbridge_suite/issues/502>`_ from ROS1 branch (`#663 <https://github.com/RobotWebTools/rosbridge_suite/issues/663>`_)
* Add pre-commit, format with black and isort (`#648 <https://github.com/RobotWebTools/rosbridge_suite/issues/648>`_)
* Contributors: Adrian Macneil, Christian Clauss, Domenic Rodriguez, Jacob Bandes-Storch, Kenji Miyake

1.0.8 (2021-08-26)
------------------
* Add missing test_depends and buildtool_depends
* Fix various Python code style and lint issues
* Contributors: Christian Clauss, Jacob Bandes-Storch

1.0.7 (2021-08-18)
------------------
* Fix typos discovered by codespell (`#600 <https://github.com/RobotWebTools/rosbridge_suite/issues/600>`_)
* Contributors: Christian Clauss

1.0.6 (2021-08-17)
------------------
* Fix broken links in changelogs
* Contributors: Jacob Bandes-Storch

1.0.5 (2021-08-12)
------------------
* Fix globs in launch xml for ROS 2 pre-Galactic (`#589 <https://github.com/RobotWebTools/rosbridge_suite/issues/589>`_)
* Remove authentication features and rosauth dependency (`#586 <https://github.com/RobotWebTools/rosbridge_suite/issues/586>`_)
  [rosauth](http://wiki.ros.org/rosauth) is not maintained for ROS 2, and has not been released for Galactic (https://github.com/GT-RAIL/rosauth/issues/35). Since the authentication feature is old and not commonly used, and since rosbridge_suite has not yet been released in Eloquent, Foxy, or Galactic, we decided to just remove the authentication features to unblock us from pushing releases.
  To avoid breaking backwards compatibility, we will not publish the new version of rosbridge_suite for Dashing.
* The server now allows choosing `port:=0` to select an ephemeral port, and sets the port number in the `actual_port` ROS param. (`#585 <https://github.com/RobotWebTools/rosbridge_suite/issues/585>`_)
* Contributors: Jacob Bandes-Storch

1.0.4 (2021-08-11)
------------------

1.0.3 (2021-08-03)
------------------
* Add cbor-raw compression support (`#574 <https://github.com/RobotWebTools/rosbridge_suite/issues/574>`_, adapted from ROS 1 implementation `#452 <https://github.com/RobotWebTools/rosbridge_suite/issues/452>`_)
* Adaptations to Eloquent [Again] (`#533 <https://github.com/RobotWebTools/rosbridge_suite/issues/533>`_)
  * increase spin period to 1000Hz to allow 1000 messages per second into the websocket
  * allow interpreting int as float when needed
  * better handling array.array and numpy arrays
  * allow bytes and str websocket messages
  * add boolean type
  * handle type extraction of static array rostypes
  * missing cls variable
  Co-authored-by: Maximilian Matthe <maxi.matthe@googlemail.com>
  Co-authored-by: CoRoLa generic <corola@bi>
  Co-authored-by: joshwapohlmann <joshwa.pohlmann@barkhauseninstitut.org>
* Contributors: Jacob Bandes-Storch, travipross

1.0.2 (2019-09-24)
------------------
* use Python 3 dependency keys (`#436 <https://github.com/RobotWebTools/rosbridge_suite/issues/436>`_)

1.0.1 (2019-09-20)
------------------

1.0.0 (2019-09-19)
------------------
* Port to ROS 2

0.11.3 (2019-08-07)
-------------------
* Fixes `#418 <https://github.com/RobotWebTools/rosbridge_suite/issues/418>`_: WebSocketClosedError Spam (`#423 <https://github.com/RobotWebTools/rosbridge_suite/issues/423>`_)
  * not raising WebSocketClosedError for old tornado versions
* Contributors: lennartdopatka

0.11.2 (2019-07-08)
-------------------
* yield infinite lock (`#413 <https://github.com/RobotWebTools/rosbridge_suite/issues/413>`_)
* Add settings for websocket timeout (`#410 <https://github.com/RobotWebTools/rosbridge_suite/issues/410>`_)
  * Add settings for websocket timeout
  * Error handling of StreamClosedError
* Contributors: Aurélien Labate

0.11.1 (2019-05-08)
-------------------

0.11.0 (2019-03-29)
-------------------
* Additional client information websocket (`#393 <https://github.com/RobotWebTools/rosbridge_suite/issues/393>`_)
  * Add package rosbridge_msgs.
  * rosbridge_server: Publish additional information about connected clients.
  * rosbridge_server: Make ClientManager's add_client/remove_client methods thread safe.
  * rosbridge_server: Rm unnecessary publishing.
  * rosbridge_msgs: Cleanup/fix dependencies.
* Handle BadYieldError in Tornado <4.5.0 (`#395 <https://github.com/RobotWebTools/rosbridge_suite/issues/395>`_)
* Contributors: Hans-Joachim Krauch, Matt Vollrath

0.10.2 (2019-03-04)
-------------------
* Log Tornado handler exceptions (`#386 <https://github.com/RobotWebTools/rosbridge_suite/issues/386>`_)
  * Decorate most handlers which were previously failing silently.
  * Use a try block in the @coroutine, it refused double decoration.
  * Always raise after logging, so Tornado sees the Exception too.
  * Only warn when racing to write to a closed WebSocket.
* Synchronous websocket write (`#385 <https://github.com/RobotWebTools/rosbridge_suite/issues/385>`_)
  Fixes `#212 <https://github.com/RobotWebTools/rosbridge_suite/issues/212>`_
* Contributors: Matt Vollrath

0.10.1 (2018-12-16)
-------------------

0.10.0 (2018-12-14)
-------------------
* CBOR encoding (`#364 <https://github.com/RobotWebTools/rosbridge_suite/issues/364>`_)
  * Add CBOR encoding
  * Fix value extraction performance regression
  Extract message values once per message.
  * Fix typed array tags
  Was using big-endian tags and encoding little-endian.
  Always use little-endian for now since Intel is prevalent for desktop.
  Add some comments to this effect.
  * Update CBOR protocol documentation
  More information about draft typed arrays and when to use CBOR.
  * Fix 64-bit integer CBOR packing
  Use an actual 64-bit format.
* Add param to enable ws per-message deflate (`#365 <https://github.com/RobotWebTools/rosbridge_suite/issues/365>`_)
  * Add param to enable ws per-message deflate
  Tornado has its own per-message deflate compression option, which
  compresses each WebSocket message.  The compression level should be
  roughly equivalent to PNG compression, depending on whether the message is
  JSON or binary (CBOR).  The encoding/decoding time will be much faster
  than protocol PNG compression.
  This param should be enabled when wire size is important, e.g. not
  connecting to localhost.
* rosbridge_server: Publish number of connected clients on latched topic. (`#359 <https://github.com/RobotWebTools/rosbridge_suite/issues/359>`_)
* Fix a few problems (`#350 <https://github.com/RobotWebTools/rosbridge_suite/issues/350>`_)
  * xrange is not available in Python3, range works for both Python versions
  * the variable v is undefined in search_param, comparing the implementation with the sibling functions I expect name to be the intended variable
  * The module udp_handler is using the Authentication service but wasn't importing the module
* use package format 2, remove unnecessary dependencies (`#348 <https://github.com/RobotWebTools/rosbridge_suite/issues/348>`_)
* Adding bson support for websockets (`#327 <https://github.com/RobotWebTools/rosbridge_suite/issues/327>`_)
  * removed message that bson isn't supported. setting the bson only mode class attribute
  * added auth package inspection for bson only mode
* Contributors: Dirk Thomas, Hans-Joachim Krauch, Matt Vollrath, Sanic

0.9.0 (2018-04-09)
------------------
* Make unregister_timeout configurable (`#322 <https://github.com/RobotWebTools/rosbridge_suite/issues/322>`_)
  Pull request `#247 <https://github.com/RobotWebTools/rosbridge_suite/issues/247>`_ introduces a 10 second delay to mitigate issue `#138 <https://github.com/RobotWebTools/rosbridge_suite/issues/138>`_.
  This change makes this delay configurable by passing an argument either
  on the command line or when including a launch file.
  Usage example:
  ```xml
  <launch>
  <include file="$(find rosbridge_server)/launch/rosbridge_websocket.launch">
  <arg name="unregister_timeout" value="5.0"/>
  </include>
  </launch>
  ```
  Closes `#320 <https://github.com/RobotWebTools/rosbridge_suite/issues/320>`_
* Remove tornado fork from source code and add python-tornado as run dependency (`#317 <https://github.com/RobotWebTools/rosbridge_suite/issues/317>`_)
  Release only for kinetic+
* Fix bug that lost data while sending large packets (`#310 <https://github.com/RobotWebTools/rosbridge_suite/issues/310>`_)
  * fix bug that lost data while sending large packets
* Contributors: Jørgen Borgesen, MBlistein, WH-0501

0.8.6 (2017-12-08)
------------------

0.8.5 (2017-11-23)
------------------
* Raise if inappropriate bson module is installed (Appease `#198 <https://github.com/RobotWebTools/rosbridge_suite/issues/198>`_) (`#270 <https://github.com/RobotWebTools/rosbridge_suite/issues/270>`_)
  * Raise Exception if inappropriate bson module is installed (Related to `#198 <https://github.com/RobotWebTools/rosbridge_suite/issues/198>`_)
* Add Python3 compatibility (`#300 <https://github.com/RobotWebTools/rosbridge_suite/issues/300>`_)
  * First pass at Python 3 compatibility
  * message_conversion: Only call encode on a Python2 str or bytes type
  * protocol.py: Changes for dict in Python3. Compatible with Python 2 too.
  * More Python 3 fixes, all tests pass
  * Move definition of string_types to rosbridge_library.util
* Contributors: Junya Hayashi, Kartik Mohta

0.8.4 (2017-10-16)
------------------

0.8.3 (2017-09-11)
------------------

0.8.2 (2017-09-11)
------------------

0.8.1 (2017-08-30)
------------------

0.8.0 (2017-08-30)
------------------
* Merge pull request `#281 <https://github.com/RobotWebTools/rosbridge_suite/issues/281>`_ from RobotWebTools/expose_b64
  expose binary_encoder rosparam that was hidden in deep depth
* address review comment. more explicitly describe valid args
* correct the possible argument
* expose binary_encoder rosparam that was hidden in deep depth
* Merge pull request `#277 <https://github.com/RobotWebTools/rosbridge_suite/issues/277>`_ from T045T/remove_nodelay_for_udp
  don't try to set TCP nodelay option for UDP
* don't try to set TCP nodelay option for UDP
* Merge pull request `#273 <https://github.com/RobotWebTools/rosbridge_suite/issues/273>`_ from Sanic/set_bson_only_flags
  Set default for bson_only_mode in websocket handler and launch file.
* Set default for bson_only_mode in websocket handler and launch file.
* Merge pull request `#257 <https://github.com/RobotWebTools/rosbridge_suite/issues/257>`_ from Sanic/bson-only-mode
  Implemented a bson_only_mode flag for the TCP version of rosbridge
* Implemented a bson_only_mode flag for the TCP version of rosbridge; This allows you to switch to a full-duplex transmission of BSON messages and therefore eliminates the need for a base64 encoding of binary data; Use the new mode by starting:'roslaunch rosbridge_server rosbridge_tcp.launch bson_only_mode:=True' or passing '--bson_only_mode' to the rosbridge_tcp.py script
* Contributors: Adolfo Rodriguez Tsouroukdissian, Jihoon Lee, Nils Berg, Patrick Mania, pmania

0.7.17 (2017-01-25)
-------------------
* Fixed the launch files for the tcp and udp service. Without these modifications, the rosapi node fails because some rosparams are not defined properly before. Now the launchfiles comply to the websocket version.
* Added default topics to all launch files, and fixed bug where it would crash if nothing was put into the lists as values
* Fix: Set default to publish all topics
  Without better doc, one does not understand why no topics are published. I thought, something is broken.
  With this defaults, everything is working out of the box. And for a more secure setup, one can change it.
* correct default values for security globs
  also accept empty list as the default "do not check globs" value in addition to None.
  Finally, append rosapi service glob after processing command line input so it's not overwritten
* add missing imports and correct default values for glob parameters
* Added services_glob to CallServices, added globs to rosbridge_tcp and rosbridge_udp, and other miscellaneous fixes.
* Two minor fixes.
* Added new parameters for topic and service security.
  Added 3 new parameters to rosapi and rosbridge_server which filter the
  topics, services, and parameters broadcast by the server to match an
  array of glob strings.
* Contributors: Devon Ash, Eric, Nils Berg, Patrick Mania, plieningerweb

0.7.16 (2016-08-15)
-------------------

0.7.15 (2016-04-25)
-------------------
* Track Twisted run_depend
  Fixes `#218 <https://github.com/RobotWebTools/rosbridge_suite/issues/218>`_
* Add rosbridge_udp cmake install rule `#225 <https://github.com/RobotWebTools/rosbridge_suite/issues/225>`_
* Stop UDP server on ROS shutdown
* changelog updated
* Track Twisted run_depend
  Fixes `#218 <https://github.com/RobotWebTools/rosbridge_suite/issues/218>`_
* Contributors: Jihoon Lee, Matt Vollrath, Russell Toris

0.7.14 (2016-02-11)
-------------------
* Abort websocket server listen() retry on shutdown
  This allows the server to shut down via SIGINT or SIGTERM during its listen() retry loop.
* rospy.get_param instead of get_param
* actually use those parameters
* remove reference to retry_startup_delay from rosbridge_udp.launch
* clean up parameters and handling
  * make parameters accessible via parameter server for all three versions
  * remove old advertise_service parameters
  * UDP and TCP can't do SSL
  * TCP can't authenticate yet (because the RosbridgeTcpSocket class is instantiated for each request and hence does not hold state)
  * UDP does not take a hostname or address, but rather an interface
* Allow TCP Server to reuse address after restart
  After killing (Ctrl-C) a rosbridge_tcp server instance which has
  connected clients, starting a new instance (on the same port) can
  fail with the error: '[Errno 98] Address already in use'. Although the
  node retries until the server starts, this can take up to a few minutes.
  Instruct the ThreadingTCPServer to allow the reuse of the same address.
* Adding UDP
* Contributors: Matt Vollrath, Nils Berg, Victor Savu, XuHao, xuhao1

0.7.13 (2015-08-14)
-------------------
* Add bson encoding to the server side
* Add default strings for certfile and keyfile
  This allows downstream packages with roslaunch_add_file_check tests to pass.
* Fix whitespace in RosbridgeTcpHandler
* Modularize RosbridgeTcpSocket
* Modularize RosbridgeWebSocket
* add shutdown handling to rosbridge_tcp and make rosbridge_websocket more robust
* Removed space from empty line.
  Thanks @T045T
* Stop IOLoop on shutdown.
* Contributors: Benny, David Lu, Matt Vollrath, Nils Berg, Paul Bovbel

0.7.12 (2015-04-07)
-------------------

0.7.11 (2015-03-23)
-------------------
* rename rosapi script to rosapi_node to address `#170 <https://github.com/RobotWebTools/rosbridge_suite/issues/170>`_
* Enabled TCP nodelay in Websocket handler
* Contributors: Jihoon Lee, Sebastien Mamessier

0.7.10 (2015-02-25)
-------------------

0.7.9 (2015-02-24)
------------------

0.7.8 (2015-01-16)
------------------
* Fix path to Tornado speedup extension source
* Build Tornado speedups
  Fixes `#135 <https://github.com/RobotWebTools/rosbridge_suite/issues/135>`_
* Contributors: Matt Vollrath

0.7.7 (2015-01-06)
------------------
* remove rosbridge_tools from dependency `#163 <https://github.com/RobotWebTools/rosbridge_suite/issues/163>`_
* reverting back the changes
* Contributors: Jihoon Lee

0.7.6 (2014-12-26)
------------------
* 0.7.5
* update changelog
* Function in robridge_tools for importing tornado
* Revert "reverts back to internal tornado until fix is ready"
  This reverts commit 49eeb1d97da154213d3170c95169b5677b329d07.
* 0.7.4
* changelog updated
* reverts back to internal tornado until fix is ready
* 0.7.3
* changelog updated
* 0.7.2
* changelog updated
* use alias to import rosbridge_tool tornado
* move modules under rosbridge_tools
* 0.7.1
* update changelog
* Merge pull request #147 from RobotWebTools/migrate_third_parties
  separate tornado and backports from rosbridge_server
* separate out third party library and ros related script
* remove setup.py
* add rosbridge_tools as rosbridge_server dependency
* remove python-imaging dependency. it is used in rosbridge_library
* 0.7.0
* changelog updated
* Contributors: Jihoon Lee, Jon Binney, Russell Toris

0.7.5 (2014-12-26)
------------------
* Function in robridge_tools for importing tornado
* Revert "reverts back to internal tornado until fix is ready"
  This reverts commit 49eeb1d97da154213d3170c95169b5677b329d07.
* Contributors: Jon Binney

0.7.4 (2014-12-16)
------------------
* reverts back to internal tornado until fix is ready
* Contributors: Russell Toris

0.7.3 (2014-12-15)
------------------

0.7.2 (2014-12-15)
------------------
* use alias to import rosbridge_tool tornado
* move modules under rosbridge_tools
* 0.7.1
* update changelog
* Merge pull request #147 from RobotWebTools/migrate_third_parties
  separate tornado and backports from rosbridge_server
* separate out third party library and ros related script
* remove setup.py
* add rosbridge_tools as rosbridge_server dependency
* remove python-imaging dependency. it is used in rosbridge_library
* Contributors: Jihoon Lee, Russell Toris

0.7.1 (2014-12-09)
------------------
* Merge pull request `#147 <https://github.com/RobotWebTools/rosbridge_suite/issues/147>`_ from RobotWebTools/migrate_third_parties
  separate tornado and backports from rosbridge_server
* separate out third party library and ros related script
* remove setup.py
* add rosbridge_tools as rosbridge_server dependency
* remove python-imaging dependency. it is used in rosbridge_library
* Contributors: Jihoon Lee, Russell Toris

0.7.0 (2014-12-02)
------------------

0.6.8 (2014-11-05)
------------------

0.6.7 (2014-10-22)
------------------
* updated package manifests
* Merge pull request #137 from RobotWebTools/revert
  Revert "Install Tornado via rosdep"
* Revert "Install Tornado via rosdep"
  This reverts commit 2d8a2fa5d23550427d6957acffc7dfa6f55e9c34.
* Contributors: Russell Toris

0.6.6 (2014-10-21)
------------------
* Install Tornado via rosdep
  Use python-tornado-pip to make sure we get the speedups introduced in Tornado 3.2.
* Contributors: Matt Vollrath

0.6.5 (2014-10-14)
------------------
* 0.6.4
* update changelog
* add backports to setup.py, so backports.ssl_match_hostname can be properly resolved
* 0.6.3
* update change log
* Contributors: Jihoon Lee, Nils Berg

0.6.4 (2014-10-08)
------------------
* add backports to setup.py, so backports.ssl_match_hostname can be properly resolved
* Contributors: Nils Berg

0.6.3 (2014-10-07)
------------------

0.6.2 (2014-10-06)
------------------
* Merge pull request #125 from megawac/json
  Remove unused imports; move json imports to utility
* override to enable support for allowing alternate origins
  To accept all cross-origin traffic (which was the default prior to Tornado 4.0), simply override this method to always return true.
* import backports.ssl_match_hostname 3.4.0.2
* upgrade tornado to 4.0.2
* Remove unused json imports; move json imports to utility
  Fixes #7
* Contributors: Graeme Yeates, Ramon Wijnands, Russell Toris

0.6.1 (2014-09-01)
------------------

0.6.0 (2014-05-23)
------------------

0.5.4 (2014-04-17)
------------------

0.5.3 (2014-03-28)
------------------
* rosbridge_server: add install tag for python files, not just symlinks, to make them executable
* Contributors: ipa-mig

0.5.2 (2014-03-14)
------------------
* move global param into local param to address issue `#25 <https://github.com/RobotWebTools/rosbridge_suite/issues/25>`_
* moving global parameter into local parameter to address issue `#25 <https://github.com/RobotWebTools/rosbridge_suite/issues/25>`_
* merging changes of groovy-devel into hydro-devel
* Specific IP address binding using roslauch
* added parameter lookup to rosbridge_tcp.py, modules where those are used, and default parameters to launch file; internal default-values still get used when launch-file does not provide them; internal defaults can be changed within rosbridge_tcp.py
* increasing max_msg_length - still hardcoded
* preparing pull request for upstream..
* cleanup: files, notes, some code
* cleanup tcp-server
* added message_field <message_intervall> to allow client to control delay between messages from rosbridge
* tested rosbridge_websocket with new capabilities; websocket test scripts not working yet..; but new caps are working when using rosbridge_websocket and tcp2ws wrapper --> so only testscripts need to be fixed for websockets.
* feierabend.. morgen weiter mit server & client JSON-decoder, see notes
* only current changes; not yet done..
* code cleanup, not yet finished..; rosbridge logging much cleaner now
* file extension for websocket server .py
* ...
* ...
* fixed test_server_defragment - recodegit status
* linuxonandroid
* added extension to server script; + symlink
* fixed some parts; ..still better do some redesign for queueing of messages..
* forced tcp_send to use queue and use delay between sends
* blocking behavior for service requests to non-ros; test-scripts use get-ip4 helper function; ..needs a lot cleanup before next steps..
* message_size debugging; TODO: sort list of received fragments! ; make sure receive_buffers are big enough for fragment_size + header..
* some code cleanup
* some minor changes: comments, debug-output, ..
* first working classes: service_server
* added socket_timeout and exception-handling for clients that do not send any data at all but are listening only.
* Catkin fixes for rosbridge TCP.
* Catkinizes rosbridge_tcp.
  Adds launch file too.
* Clean up of Rosbridge TCP.
* add rosbridge_server with tcp socket support
* adapt rosbridge_tcp to groovy-devel structure
* add rosbridge_server with tcp socket support
* Param bug fixed
* SSL options added
* Contributors: Brandon Alexander, Jihoon Lee, Russell Toris, Steffel Fenix, dave, fxm-db, ipa-fxm, root

0.5.1 (2013-10-31)
------------------

0.5.0 (2013-07-17)
------------------
* 0.5.0 preparation for hydro release
* Removes trailing commas.
* removing global bin installation in setup.py
* Contributors: Brandon Alexander, Jihoon Lee

0.4.4 (2013-04-08)
------------------

0.4.3 (2013-04-03 08:24)
------------------------

0.4.2 (2013-04-03 08:12)
------------------------
* launch file location fixed in install
* response from rosauth fixed
* authentication added
* launch file updated with args for port and SSL options
* SSL options added
* eclipse projects removed
* Contributors: Russell Toris

0.4.1 (2013-03-07)
------------------

0.4.0 (2013-03-05)
------------------
* Resolves submodule issues.
* Adds rosbridge_websocket launch file.
* Uses only 1 .gitignore to avoid confusion.
* Fixing rosapi's "Cannot include proxy..." errors.
* Renames server script to rosbridge_websocket.
* Adds BSD license header to code files.
  See Issue `#13 <https://github.com/RobotWebTools/rosbridge_suite/issues/13>`_.
* rosbridge_server requires rosapi.
* Moves rosbridge_server code to scripts.
  Was getting an odd bug with tornado:
  [ERROR] [WallTime: 1356115083.100585] Uncaught exception, closing connection.
  [ERROR] [WallTime: 1356115083.100900] Exception in callback <tornado.stack_context._StackContextWrapper object at 0x1dd6e10>
* Removing ultrajson from rosbridge.
  If JSON parsing becomes a performance bottle neck, we can re-add it.
* Refactors rosbridge_server. Adds scripts dir.
* Catkinizing rosbridge_library and server.
* Added command line --port argument.
* Collapse directory structure.
* Moved the packages inside a folder called rosbridge
* Initial commit of rosbridge_server
* Contributors: Austin Hendrix, Brandon Alexander, Jonathan Mace



================================================
FILE: rosbridge_server/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosbridge_server)

find_package(ament_cmake REQUIRED)
find_package(ament_cmake_python REQUIRED)

ament_python_install_package(
  ${PROJECT_NAME} PACKAGE_DIR "src/${PROJECT_NAME}")

ament_package()

install(PROGRAMS
  scripts/rosbridge_websocket.py
  scripts/rosbridge_websocket
  DESTINATION lib/${PROJECT_NAME}
)

install(FILES
  launch/rosbridge_websocket_launch.xml
  DESTINATION share/${PROJECT_NAME}/launch
)

if(BUILD_TESTING)
  find_package(launch_testing_ament_cmake REQUIRED)
  add_launch_test(test/websocket/advertise_action.test.py)
  add_launch_test(test/websocket/advertise_action_feedback.test.py)
  add_launch_test(test/websocket/advertise_service.test.py)
  add_launch_test(test/websocket/call_service.test.py)
  add_launch_test(test/websocket/send_action_goal.test.py)
  add_launch_test(test/websocket/smoke.test.py)
  add_launch_test(test/websocket/transient_local_publisher.test.py)
  add_launch_test(test/websocket/best_effort_publisher.test.py)
  add_launch_test(test/websocket/multiple_subscribers_raw.test.py)

  find_package(ament_cmake_mypy REQUIRED)
  ament_mypy()
endif()



================================================
FILE: rosbridge_server/package.xml
================================================
<?xml version="1.0"?>
<package format="2">
  <name>rosbridge_server</name>
  <version>2.3.0</version>
  <description>A WebSocket interface to rosbridge.</description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosbridge_server</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>ament_cmake_python</buildtool_depend>

  <exec_depend>python3-tornado</exec_depend>
  <exec_depend>rclpy</exec_depend>
  <exec_depend>rosapi</exec_depend>
  <exec_depend>rosbridge_library</exec_depend>
  <exec_depend>rosbridge_msgs</exec_depend>
  <exec_depend>std_msgs</exec_depend>

  <test_depend>action_msgs</test_depend>
  <test_depend>ament_cmake_mypy</test_depend>
  <test_depend>example_interfaces</test_depend>
  <test_depend>launch</test_depend>
  <test_depend>launch_ros</test_depend>
  <test_depend>launch_testing_ament_cmake</test_depend>
  <test_depend>python3-autobahn</test_depend>
  <test_depend>python3-twisted</test_depend>
  <test_depend>rcl_interfaces</test_depend>
  <test_depend>std_srvs</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosbridge_server/launch/rosbridge_websocket_launch.xml
================================================
<launch>
  <arg name="port" default="9090" />
  <arg name="address" default="" />
  <arg name="url_path" default="/" />
  <arg name="ssl" default="false" />
  <arg name="certfile" default=""/>
  <arg name="keyfile" default="" />

  <arg name="namespace" default="" />

  <arg name="retry_startup_delay" default="5.0" />

  <arg name="fragment_timeout" default="600" />
  <arg name="delay_between_messages" default="0" />
  <arg name="max_message_size" default="10000000" />
  <arg name="unregister_timeout" default="10.0" />

  <arg name="use_compression" default="false" />
  <arg name="call_services_in_new_thread" default="true" />
  <arg name="default_call_service_timeout" default="5.0" />
  <arg name="send_action_goals_in_new_thread" default="true" />

  <arg name="topics_glob" default="" />
  <arg name="services_glob" default="" />
  <arg name="params_glob" default="" />
  <arg name="params_timeout" default="5.0" />
  <arg name="bson_only_mode" default="false" />

  <arg name="respawn" default="false"/>

  <arg unless="$(var bson_only_mode)" name="binary_encoder" default="default"/>

  <group if="$(var ssl)">
    <node name="rosbridge_websocket" namespace="$(var namespace)" pkg="rosbridge_server" exec="rosbridge_websocket" output="screen" respawn="$(var respawn)" >
      <param name="certfile" value="$(var certfile)" />
      <param name="keyfile" value="$(var keyfile)" />
      <param name="port" value="$(var port)"/>
      <param name="address" value="$(var address)"/>
      <param name="url_path" value="$(var url_path)"/>
      <param name="retry_startup_delay" value="$(var retry_startup_delay)"/>
      <param name="fragment_timeout" value="$(var fragment_timeout)"/>
      <param name="delay_between_messages" value="$(var delay_between_messages)"/>
      <param name="max_message_size" value="$(var max_message_size)"/>
      <param name="unregister_timeout" value="$(var unregister_timeout)"/>
      <param name="use_compression" value="$(var use_compression)"/>
      <param name="call_services_in_new_thread" value="$(var call_services_in_new_thread)"/>
      <param name="default_call_service_timeout" value="$(var default_call_service_timeout)"/>
      <param name="send_action_goals_in_new_thread" value="$(var send_action_goals_in_new_thread)"/>

      <param name="topics_glob" value="$(var topics_glob)"/>
      <param name="services_glob" value="$(var services_glob)"/>
      <param name="params_glob" value="$(var params_glob)"/>
    </node>
  </group>

  <group unless="$(var ssl)">
    <node name="rosbridge_websocket" namespace="$(var namespace)" pkg="rosbridge_server" exec="rosbridge_websocket" output="screen" respawn="$(var respawn)">
      <param name="port" value="$(var port)"/>
      <param name="address" value="$(var address)"/>
      <param name="url_path" value="$(var url_path)"/>
      <param name="retry_startup_delay" value="$(var retry_startup_delay)"/>
      <param name="fragment_timeout" value="$(var fragment_timeout)"/>
      <param name="delay_between_messages" value="$(var delay_between_messages)"/>
      <param name="max_message_size" value="$(var max_message_size)"/>
      <param name="unregister_timeout" value="$(var unregister_timeout)"/>
      <param name="use_compression" value="$(var use_compression)"/>
      <param name="call_services_in_new_thread" value="$(var call_services_in_new_thread)"/>
      <param name="default_call_service_timeout" value="$(var default_call_service_timeout)"/>
      <param name="send_action_goals_in_new_thread" value="$(var send_action_goals_in_new_thread)"/>

      <param name="topics_glob" value="$(var topics_glob)"/>
      <param name="services_glob" value="$(var services_glob)"/>
      <param name="params_glob" value="$(var params_glob)"/>

      <param name="bson_only_mode" value="$(var bson_only_mode)"/>
    </node>
  </group>

  <node name="rosapi" namespace="$(var namespace)" pkg="rosapi" exec="rosapi_node" respawn="$(var respawn)">
    <param name="topics_glob" value="$(var topics_glob)"/>
    <param name="services_glob" value="$(var services_glob)"/>
    <param name="params_glob" value="$(var params_glob)"/>
    <param name="params_timeout" value="$(var params_timeout)"/>
  </node>
</launch>



================================================
FILE: rosbridge_server/scripts/rosbridge_websocket.py
================================================
#!/usr/bin/env python3
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


import sys
import time

import rclpy
from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import Int32
from tornado.httpserver import HTTPServer
from tornado.ioloop import IOLoop, PeriodicCallback
from tornado.netutil import bind_sockets
from tornado.web import Application

from rosbridge_library.capabilities.advertise import Advertise
from rosbridge_library.capabilities.advertise_service import AdvertiseService
from rosbridge_library.capabilities.call_service import CallService
from rosbridge_library.capabilities.publish import Publish
from rosbridge_library.capabilities.subscribe import Subscribe
from rosbridge_library.capabilities.unadvertise_service import UnadvertiseService
from rosbridge_server import ClientManager, RosbridgeWebSocket


def start_hook():
    IOLoop.instance().start()


def shutdown_hook():
    IOLoop.instance().stop()


class RosbridgeWebsocketNode(Node):
    def __init__(self):
        super().__init__("rosbridge_websocket")

        RosbridgeWebSocket.node_handle = self

        ##################################################
        # Parameter handling                             #
        ##################################################

        self.protocol_parameter_handling()

        # get tornado application parameters
        tornado_settings = {}
        tornado_settings["websocket_ping_interval"] = float(
            self.declare_parameter("websocket_ping_interval", 0).value
        )
        tornado_settings["websocket_ping_timeout"] = float(
            self.declare_parameter("websocket_ping_timeout", 30).value
        )
        if "--websocket_ping_interval" in sys.argv:
            idx = sys.argv.index("--websocket_ping_interval") + 1
            if idx < len(sys.argv):
                tornado_settings["websocket_ping_interval"] = float(sys.argv[idx])
            else:
                print("--websocket_ping_interval argument provided without a value.")
                sys.exit(-1)

        if "--websocket_ping_timeout" in sys.argv:
            idx = sys.argv.index("--websocket_ping_timeout") + 1
            if idx < len(sys.argv):
                tornado_settings["websocket_ping_timeout"] = float(sys.argv[idx])
            else:
                print("--websocket_ping_timeout argument provided without a value.")
                sys.exit(-1)

        # Server and SSL options
        # SSL options, cannot set default to None - rclpy throws warning
        certfile = self.declare_parameter("certfile", "").value
        keyfile = self.declare_parameter("keyfile", "").value
        # if not set, set to None
        if certfile == "":
            certfile = None
        if keyfile == "":
            keyfile = None

        port = self.declare_parameter("port", 9090).value
        if "--port" in sys.argv:
            idx = sys.argv.index("--port") + 1
            if idx < len(sys.argv):
                port = int(sys.argv[idx])
            else:
                print("--port argument provided without a value.")
                sys.exit(-1)
        address = self.declare_parameter("address", "").value
        if "--address" in sys.argv:
            idx = sys.argv.index("--address") + 1
            if idx < len(sys.argv):
                address = sys.argv[idx]
            else:
                print("--address argument provided without a value.")
                sys.exit(-1)

        url_path = self.declare_parameter("url_path", "/").value
        if "--url_path" in sys.argv:
            idx = sys.argv.index("--url_path") + 1
            if idx < len(sys.argv):
                url_path = str(sys.argv[idx])
            else:
                print("--url_path argument provided without a value.")
                sys.exit(-1)

        retry_startup_delay = self.declare_parameter("retry_startup_delay", 2.0).value  # seconds.
        if "--retry_startup_delay" in sys.argv:
            idx = sys.argv.index("--retry_startup_delay") + 1
            if idx < len(sys.argv):
                retry_startup_delay = int(sys.argv[idx])
            else:
                print("--retry_startup_delay argument provided without a value.")
                sys.exit(-1)

        ##################################################
        # Done with parameter handling                   #
        ##################################################

        handlers = [(r"/", RosbridgeWebSocket), (r"", RosbridgeWebSocket)]
        if url_path != "/":
            handlers = [(rf"{url_path}", RosbridgeWebSocket)]

        application = Application(handlers, **tornado_settings)

        connected = False
        while not connected and self.context.ok():
            try:
                ssl_options = None
                if certfile is not None and keyfile is not None:
                    ssl_options = {"certfile": certfile, "keyfile": keyfile}
                sockets = bind_sockets(port, address)
                actual_port = sockets[0].getsockname()[1]
                server = HTTPServer(application, ssl_options=ssl_options)
                server.add_sockets(sockets)
                self.declare_parameter("actual_port", actual_port)
                self.get_logger().info(f"Rosbridge WebSocket server started on port {actual_port}")
                connected = True
            except OSError as e:  # noqa: PERF203
                self.get_logger().warning(
                    f"Unable to start server: {e} Retrying in {retry_startup_delay}s."
                )
                time.sleep(retry_startup_delay)

    def protocol_parameter_handling(self):
        RosbridgeWebSocket.use_compression = self.declare_parameter("use_compression", False).value

        RosbridgeWebSocket.call_services_in_new_thread = self.declare_parameter(
            "call_services_in_new_thread", True
        ).value

        RosbridgeWebSocket.default_call_service_timeout = self.declare_parameter(
            "default_call_service_timeout", 5.0
        ).value

        RosbridgeWebSocket.send_action_goals_in_new_thread = self.declare_parameter(
            "send_action_goals_in_new_thread", True
        ).value

        # get RosbridgeProtocol parameters
        RosbridgeWebSocket.fragment_timeout = self.declare_parameter(
            "fragment_timeout", RosbridgeWebSocket.fragment_timeout
        ).value

        RosbridgeWebSocket.delay_between_messages = self.declare_parameter(
            "delay_between_messages", RosbridgeWebSocket.delay_between_messages
        ).value

        RosbridgeWebSocket.max_message_size = self.declare_parameter(
            "max_message_size", RosbridgeWebSocket.max_message_size
        ).value

        RosbridgeWebSocket.unregister_timeout = self.declare_parameter(
            "unregister_timeout", RosbridgeWebSocket.unregister_timeout
        ).value

        bson_only_mode = self.declare_parameter("bson_only_mode", False).value

        RosbridgeWebSocket.client_manager = ClientManager(self)

        # Publisher for number of connected clients
        # QoS profile with transient local durability (latched topic in ROS 1).
        client_count_qos_profile = QoSProfile(
            depth=10,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )

        RosbridgeWebSocket.client_count_pub = self.create_publisher(
            Int32, "client_count", qos_profile=client_count_qos_profile
        )
        RosbridgeWebSocket.client_count_pub.publish(Int32(data=0))

        # Get the glob strings and parse them as arrays.
        topics_glob = self.declare_parameter("topics_glob", "").value

        services_glob = self.declare_parameter("services_glob", "").value

        params_glob = self.declare_parameter("params_glob", "").value

        RosbridgeWebSocket.topics_glob = [
            element.strip().strip("'")
            for element in topics_glob[1:-1].split(",")
            if len(element.strip().strip("'")) > 0
        ]
        RosbridgeWebSocket.services_glob = [
            element.strip().strip("'")
            for element in services_glob[1:-1].split(",")
            if len(element.strip().strip("'")) > 0
        ]
        RosbridgeWebSocket.params_glob = [
            element.strip().strip("'")
            for element in params_glob[1:-1].split(",")
            if len(element.strip().strip("'")) > 0
        ]

        if "--fragment_timeout" in sys.argv:
            idx = sys.argv.index("--fragment_timeout") + 1
            if idx < len(sys.argv):
                RosbridgeWebSocket.fragment_timeout = int(sys.argv[idx])
            else:
                print("--fragment_timeout argument provided without a value.")
                sys.exit(-1)

        if "--delay_between_messages" in sys.argv:
            idx = sys.argv.index("--delay_between_messages") + 1
            if idx < len(sys.argv):
                RosbridgeWebSocket.delay_between_messages = float(sys.argv[idx])
            else:
                print("--delay_between_messages argument provided without a value.")
                sys.exit(-1)

        if "--max_message_size" in sys.argv:
            idx = sys.argv.index("--max_message_size") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                RosbridgeWebSocket.max_message_size = int(value)
            else:
                print("--max_message_size argument provided without a value. (can be <Integer>)")
                sys.exit(-1)

        if "--unregister_timeout" in sys.argv:
            idx = sys.argv.index("--unregister_timeout") + 1
            if idx < len(sys.argv):
                RosbridgeWebSocket.unregister_timeout = float(sys.argv[idx])
            else:
                print("--unregister_timeout argument provided without a value.")
                sys.exit(-1)

        if "--topics_glob" in sys.argv:
            idx = sys.argv.index("--topics_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocket.topics_glob = []
                else:
                    RosbridgeWebSocket.topics_glob = [
                        element.strip().strip("'") for element in value[1:-1].split(",")
                    ]
            else:
                print("--topics_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if "--services_glob" in sys.argv:
            idx = sys.argv.index("--services_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocket.services_glob = []
                else:
                    RosbridgeWebSocket.services_glob = [
                        element.strip().strip("'") for element in value[1:-1].split(",")
                    ]
            else:
                print("--services_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if "--params_glob" in sys.argv:
            idx = sys.argv.index("--params_glob") + 1
            if idx < len(sys.argv):
                value = sys.argv[idx]
                if value == "None":
                    RosbridgeWebSocket.params_glob = []
                else:
                    RosbridgeWebSocket.params_glob = [
                        element.strip().strip("'") for element in value[1:-1].split(",")
                    ]
            else:
                print("--params_glob argument provided without a value. (can be None or a list)")
                sys.exit(-1)

        if ("--bson_only_mode" in sys.argv) or bson_only_mode:
            RosbridgeWebSocket.bson_only_mode = bson_only_mode

        # To be able to access the list of topics and services, you must be able to access the rosapi services.
        if RosbridgeWebSocket.services_glob:
            RosbridgeWebSocket.services_glob.append("/rosapi/*")

        Subscribe.topics_glob = RosbridgeWebSocket.topics_glob
        Advertise.topics_glob = RosbridgeWebSocket.topics_glob
        Publish.topics_glob = RosbridgeWebSocket.topics_glob
        AdvertiseService.services_glob = RosbridgeWebSocket.services_glob
        UnadvertiseService.services_glob = RosbridgeWebSocket.services_glob
        CallService.services_glob = RosbridgeWebSocket.services_glob


def main(args=None):
    if args is None:
        args = sys.argv

    rclpy.init(args=args)
    node = RosbridgeWebsocketNode()

    executor = rclpy.executors.SingleThreadedExecutor()
    executor.add_node(node)

    def spin_ros():
        if not rclpy.ok():
            shutdown_hook()
            return
        executor.spin_once(timeout_sec=0.01)

    spin_callback = PeriodicCallback(spin_ros, 1)
    spin_callback.start()
    try:
        start_hook()
        node.destroy_node()
        rclpy.shutdown()
    except KeyboardInterrupt:
        print("Exiting due to SIGINT")
    finally:
        spin_callback.stop()
        shutdown_hook()  # shutdown hook to stop the server


if __name__ == "__main__":
    main()



================================================
SYMLINK: rosbridge_server/scripts/rosbridge_websocket -> rosbridge_websocket.py
================================================



================================================
FILE: rosbridge_server/src/rosbridge_server/__init__.py
================================================
from .client_manager import ClientManager  # noqa: F401
from .websocket_handler import RosbridgeWebSocket  # noqa: F401



================================================
FILE: rosbridge_server/src/rosbridge_server/client_manager.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2018, Intermodalics
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Intermodalics nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
import threading

from rclpy.clock import ROSClock
from rclpy.qos import DurabilityPolicy, QoSProfile
from std_msgs.msg import Int32

from rosbridge_msgs.msg import ConnectedClient, ConnectedClients


class ClientManager:
    def __init__(self, node_handle):
        qos = QoSProfile(
            depth=1,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
        )

        # Publisher for number of connected clients
        self._client_count_pub = node_handle.create_publisher(
            Int32, "client_count", qos_profile=qos
        )
        # Publisher for connected clients
        self._conn_clients_pub = node_handle.create_publisher(
            ConnectedClients, "connected_clients", qos_profile=qos
        )

        self._lock = threading.Lock()
        self._client_count = 0
        self._clients = {}
        self.__publish()

    def __publish(self):
        msg = ConnectedClients()
        msg.clients = list(self._clients.values())
        self._conn_clients_pub.publish(msg)
        self._client_count_pub.publish(Int32(data=len(msg.clients)))

    def add_client(self, client_id, ip_address):
        with self._lock:
            client = ConnectedClient()
            client.ip_address = ip_address
            client.connection_time = ROSClock().now().to_msg()
            self._clients[client_id] = client
            self.__publish()

    def remove_client(self, client_id, ip_address):  # noqa: ARG002
        with self._lock:
            self._clients.pop(client_id, None)
            self.__publish()



================================================
FILE: rosbridge_server/src/rosbridge_server/websocket_handler.py
================================================
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of Willow Garage, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import sys
import threading
import traceback
import uuid
from collections import deque
from functools import partial, wraps

from tornado.ioloop import IOLoop
from tornado.iostream import StreamClosedError
from tornado.websocket import WebSocketClosedError, WebSocketHandler

from rosbridge_library.rosbridge_protocol import RosbridgeProtocol
from rosbridge_library.util import bson

_io_loop = IOLoop.instance()


def _log_exception():
    """Log the most recent exception to ROS."""
    exc = traceback.format_exception(*sys.exc_info())
    RosbridgeWebSocket.node_handle.get_logger().error("".join(exc))


def log_exceptions(f):
    """Log exceptions to ROS."""

    @wraps(f)
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except Exception:
            _log_exception()
            raise

    return wrapper


class IncomingQueue(threading.Thread):
    """
    Decouples incoming messages from the Tornado thread.

    This mitigates cases where outgoing messages are blocked by incoming,
    and vice versa.
    """

    def __init__(self, protocol):
        threading.Thread.__init__(self)
        self.daemon = True
        self.queue = deque()
        self.protocol = protocol

        self.cond = threading.Condition()
        self._finished = False

    def finish(self):
        """Clear the queue and do not accept further messages."""
        with self.cond:
            self._finished = True
            while len(self.queue) > 0:
                self.queue.popleft()
            self.cond.notify()

    def push(self, msg):
        with self.cond:
            self.queue.append(msg)
            self.cond.notify()

    def run(self):
        while True:
            with self.cond:
                if len(self.queue) == 0 and not self._finished:
                    self.cond.wait()

                if self._finished:
                    break

                msg = self.queue.popleft()

            self.protocol.incoming(msg)

        self.protocol.finish()


class RosbridgeWebSocket(WebSocketHandler):
    clients_connected = 0
    use_compression = False

    # The following are passed on to RosbridgeProtocol
    # defragmentation.py:
    fragment_timeout = 600  # seconds
    # protocol.py:
    delay_between_messages = 0  # seconds
    max_message_size = 10000000  # bytes
    unregister_timeout = 10.0  # seconds
    bson_only_mode = False
    node_handle = None

    @log_exceptions
    def open(self):
        cls = self.__class__
        parameters = {
            "fragment_timeout": cls.fragment_timeout,
            "delay_between_messages": cls.delay_between_messages,
            "max_message_size": cls.max_message_size,
            "unregister_timeout": cls.unregister_timeout,
            "bson_only_mode": cls.bson_only_mode,
        }
        try:
            self.client_id = uuid.uuid4()
            self.protocol = RosbridgeProtocol(
                self.client_id, cls.node_handle, parameters=parameters
            )
            self.incoming_queue = IncomingQueue(self.protocol)
            self.incoming_queue.start()
            self.protocol.outgoing = self.send_message
            self.set_nodelay(True)
            cls.clients_connected += 1
            if cls.client_manager:
                cls.client_manager.add_client(self.client_id, self.request.remote_ip)
        except Exception as exc:
            cls.node_handle.get_logger().error(
                f"Unable to accept incoming connection.  Reason: {exc}"
            )

        cls.node_handle.get_logger().info(
            f"Client connected. {cls.clients_connected} clients total."
        )

    @log_exceptions
    def on_message(self, message):
        if isinstance(message, bytes):
            message = message.decode("utf-8")
        self.incoming_queue.push(message)

    @log_exceptions
    def on_close(self):
        cls = self.__class__
        cls.clients_connected -= 1
        if cls.client_manager:
            cls.client_manager.remove_client(self.client_id, self.request.remote_ip)
        cls.node_handle.get_logger().info(
            f"Client disconnected. {cls.clients_connected} clients total."
        )
        self.incoming_queue.finish()

    def send_message(self, message, compression="none"):
        if isinstance(message, bson.BSON) or compression in ["cbor", "cbor-raw"]:
            binary = True
        else:
            binary = False

        _io_loop.add_callback(partial(self.prewrite_message, message, binary))

    async def prewrite_message(self, message, binary):
        cls = self.__class__
        try:
            await self.write_message(message, binary)
        except WebSocketClosedError:
            cls.node_handle.get_logger().warning(
                "WebSocketClosedError: Tried to write to a closed websocket",
                throttle_duration_sec=1.0,
            )
            # If we end up here, a client has disconnected before its message callback(s) could be removed.
        except StreamClosedError:
            cls.node_handle.get_logger().warning(
                "StreamClosedError: Tried to write to a closed stream",
                throttle_duration_sec=1.0,
            )
        except:  # noqa: E722  # Will log and raise
            _log_exception()

    @log_exceptions
    def check_origin(self, origin):  # noqa: ARG002
        return True

    @log_exceptions
    def get_compression_options(self):
        # If this method returns None (the default), compression will be disabled.
        # If it returns a dict (even an empty one), it will be enabled.
        cls = self.__class__

        if not cls.use_compression:
            return None

        return {}



================================================
FILE: rosbridge_server/test/websocket/advertise_action.test.py
================================================
from __future__ import annotations

import sys
import unittest
from pathlib import Path

from action_msgs.msg import GoalStatus
from example_interfaces.action import Fibonacci
from rclpy.action import ActionClient
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

from typing import TYPE_CHECKING

import common
from common import expect_messages, websocket_test

if TYPE_CHECKING:
    from rclpy.node import Node
    from rclpy.task import Future

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestAdvertiseAction(unittest.TestCase):
    goal1_result_future: Future | None
    goal2_result_future: Future | None

    def goal1_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            return
        self.goal1_result_future = goal_handle.get_result_async()

    def goal2_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            return
        self.goal2_result_future = goal_handle.get_result_async()

    @websocket_test
    async def test_two_concurrent_calls(self, node: Node, make_client):
        ws_client = await make_client()
        ws_client.sendJson(
            {
                "op": "advertise_action",
                "action": "/test_fibonacci_action",
                "type": "example_interfaces/Fibonacci",
            }
        )
        client: ActionClient = ActionClient(node, Fibonacci, "/test_fibonacci_action")
        client.wait_for_server()

        requests_future, ws_client.message_handler = expect_messages(
            2, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        requests_future.add_done_callback(lambda _: node.executor.wake())

        self.goal1_result_future = None
        goal1_future = client.send_goal_async(Fibonacci.Goal(order=3))
        goal1_future.add_done_callback(self.goal1_response_callback)

        self.goal2_result_future = None
        goal2_future = client.send_goal_async(Fibonacci.Goal(order=5))
        goal2_future.add_done_callback(self.goal2_response_callback)

        requests = await requests_future

        self.assertEqual(requests[0]["op"], "send_action_goal")
        self.assertEqual(requests[0]["action"], "/test_fibonacci_action")
        self.assertEqual(requests[0]["action_type"], "example_interfaces/Fibonacci")
        self.assertEqual(requests[0]["args"], {"order": 3})
        ws_client.sendJson(
            {
                "op": "action_result",
                "action": "/test_fibonacci_action",
                "values": {"sequence": [0, 1, 1, 2]},
                "status": GoalStatus.STATUS_SUCCEEDED,
                "id": requests[0]["id"],
                "result": True,
            }
        )

        self.assertEqual(requests[1]["op"], "send_action_goal")
        self.assertEqual(requests[1]["action"], "/test_fibonacci_action")
        self.assertEqual(requests[1]["action_type"], "example_interfaces/Fibonacci")
        self.assertEqual(requests[1]["args"], {"order": 5})
        ws_client.sendJson(
            {
                "op": "action_result",
                "action": "/test_fibonacci_action",
                "values": {"sequence": [0, 1, 1, 2, 3, 5]},
                "status": GoalStatus.STATUS_SUCCEEDED,
                "id": requests[1]["id"],
                "result": True,
            }
        )

        assert self.goal1_result_future is not None
        result1 = await self.goal1_result_future
        self.assertEqual(result1.result, Fibonacci.Result(sequence=[0, 1, 1, 2]))
        assert self.goal2_result_future is not None
        result2 = await self.goal2_result_future
        self.assertEqual(result2.result, Fibonacci.Result(sequence=[0, 1, 1, 2, 3, 5]))

        node.destroy_client(client)



================================================
FILE: rosbridge_server/test/websocket/advertise_action_feedback.test.py
================================================
from __future__ import annotations

import sys
import unittest
from pathlib import Path

from action_msgs.msg import GoalStatus
from example_interfaces.action import Fibonacci
from rclpy.action import ActionClient
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

from typing import TYPE_CHECKING

import common
from common import expect_messages, websocket_test

if TYPE_CHECKING:
    from rclpy.node import Node
    from rclpy.task import Future

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestActionFeedback(unittest.TestCase):
    goal_result_future: Future | None

    def goal_response_callback(self, future: Future):
        goal_handle = future.result()
        assert goal_handle is not None
        if not goal_handle.accepted:
            return
        self.goal_result_future = goal_handle.get_result_async()

    def feedback_callback(self, msg):
        self.latest_feedback = msg

    @websocket_test
    async def test_feedback(self, node: Node, make_client):
        ws_client = await make_client()
        ws_client.sendJson(
            {
                "op": "advertise_action",
                "action": "/test_fibonacci_action",
                "type": "example_interfaces/Fibonacci",
            }
        )
        client: ActionClient = ActionClient(node, Fibonacci, "/test_fibonacci_action")
        client.wait_for_server()

        requests_future, ws_client.message_handler = expect_messages(
            1, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        requests_future.add_done_callback(lambda _: node.executor.wake())

        self.goal_result_future = None
        goal_future = client.send_goal_async(
            Fibonacci.Goal(order=5),
            feedback_callback=self.feedback_callback,
        )
        goal_future.add_done_callback(self.goal_response_callback)

        requests = await requests_future

        self.assertEqual(requests[0]["op"], "send_action_goal")
        self.assertEqual(requests[0]["action"], "/test_fibonacci_action")
        self.assertEqual(requests[0]["action_type"], "example_interfaces/Fibonacci")
        self.assertEqual(requests[0]["args"], {"order": 5})

        self.latest_feedback = None
        ws_client.sendJson(
            {
                "op": "action_feedback",
                "action": "/test_fibonacci_action",
                "values": {"sequence": [0, 1, 1, 2]},
                "id": requests[0]["id"],
            }
        )
        ws_client.sendJson(
            {
                "op": "action_result",
                "action": "/test_fibonacci_action",
                "values": {"sequence": [0, 1, 1, 2, 3, 5]},
                "status": GoalStatus.STATUS_SUCCEEDED,
                "id": requests[0]["id"],
                "result": True,
            }
        )

        assert self.goal_result_future is not None
        result = await self.goal_result_future
        self.assertIsNotNone(self.latest_feedback)
        self.assertEqual(self.latest_feedback.feedback, Fibonacci.Feedback(sequence=[0, 1, 1, 2]))
        self.assertEqual(result.result, Fibonacci.Result(sequence=[0, 1, 1, 2, 3, 5]))

        node.destroy_client(client)



================================================
FILE: rosbridge_server/test/websocket/advertise_service.test.py
================================================
import sys
import unittest
from pathlib import Path
from typing import TYPE_CHECKING

from rclpy.node import Node
from std_srvs.srv import SetBool
from twisted.python import log

if TYPE_CHECKING:
    from rclpy.client import Client

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestAdvertiseService(unittest.TestCase):
    @websocket_test
    async def test_two_concurrent_calls(self, node: Node, make_client):
        ws_client = await make_client()
        ws_client.sendJson(
            {
                "op": "advertise_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service",
            }
        )
        client: Client = node.create_client(SetBool, "/test_service")
        client.wait_for_service()

        requests_future, ws_client.message_handler = expect_messages(
            2, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        requests_future.add_done_callback(lambda _: node.executor.wake())

        response1_future = client.call_async(SetBool.Request(data=True))
        response2_future = client.call_async(SetBool.Request(data=False))

        requests = await requests_future
        self.assertEqual(len(requests), 2)

        self.assertEqual(requests[0]["op"], "call_service")
        self.assertEqual(requests[0]["service"], "/test_service")
        self.assertEqual(requests[0]["args"], {"data": True})
        ws_client.sendJson(
            {
                "op": "service_response",
                "service": "/test_service",
                "values": {"success": True, "message": "Hello world 1"},
                "id": requests[0]["id"],
                "result": True,
            }
        )

        self.assertEqual(requests[1]["op"], "call_service")
        self.assertEqual(requests[1]["service"], "/test_service")
        self.assertEqual(requests[1]["args"], {"data": False})
        ws_client.sendJson(
            {
                "op": "service_response",
                "service": "/test_service",
                "values": {"success": True, "message": "Hello world 2"},
                "id": requests[1]["id"],
                "result": True,
            }
        )

        self.assertEqual(
            await response1_future, SetBool.Response(success=True, message="Hello world 1")
        )
        self.assertEqual(
            await response2_future, SetBool.Response(success=True, message="Hello world 2")
        )

        node.destroy_client(client)



================================================
FILE: rosbridge_server/test/websocket/advertise_service_duplicate.test.py
================================================
import sys
import unittest
from pathlib import Path
from typing import TYPE_CHECKING

from rclpy.node import Node
from std_srvs.srv import SetBool
from twisted.python import log

if TYPE_CHECKING:
    from rclpy.client import Client

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestAdvertiseService(unittest.TestCase):
    @websocket_test
    async def test_double_advertise(self, node: Node, make_client):
        ws_client1 = await make_client()
        ws_client1.sendJson(
            {
                "op": "advertise_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service",
            }
        )
        client: Client = node.create_client(SetBool, "/test_service")
        client.wait_for_service()

        requests1_future, ws_client1.message_handler = expect_messages(
            1, "WebSocket 1", node.get_logger()
        )
        assert node.executor is not None
        requests1_future.add_done_callback(lambda _: node.executor.wake())

        client.call_async(SetBool.Request(data=True))

        requests1 = await requests1_future
        self.assertEqual(
            requests1,
            [
                {
                    "op": "call_service",
                    "service": "/test_service",
                    "id": "service_request:/test_service:1",
                    "args": {"data": True},
                }
            ],
        )

        ws_client1.sendClose()

        ws_client2 = await make_client()
        ws_client2.sendJson(
            {
                "op": "advertise_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service",
            }
        )

        # wait for the server to handle the new advertisement
        await sleep(node, 1)

        requests2_future, ws_client2.message_handler = expect_messages(
            1, "WebSocket 2", node.get_logger()
        )
        requests2_future.add_done_callback(lambda _: node.executor.wake())

        response2_future = client.call_async(SetBool.Request(data=False))

        requests2 = await requests2_future
        self.assertEqual(
            requests2,
            [
                {
                    "op": "call_service",
                    "id": "service_request:/test_service:1",
                    "service": "/test_service",
                    "args": {"data": False},
                }
            ],
        )

        ws_client2.sendJson(
            {
                "op": "service_response",
                "service": "/test_service",
                "values": {"success": True, "message": "Hello world 2"},
                "id": "service_request:/test_service:1",
                "result": True,
            }
        )

        self.assertEqual(
            await response2_future, SetBool.Response(success=True, message="Hello world 2")
        )



================================================
FILE: rosbridge_server/test/websocket/best_effort_publisher.test.py
================================================
import sys
import unittest
from pathlib import Path

from rclpy.node import Node
from rclpy.qos import HistoryPolicy, QoSProfile, ReliabilityPolicy
from std_msgs.msg import String
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestBestEffortPublisher(unittest.TestCase):
    @websocket_test
    async def test_best_effort_publisher(self, node: Node, make_client):
        qos = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.SYSTEM_DEFAULT,
        )
        pub_a = node.create_publisher(String, "/a_topic", qos_profile=qos)

        await sleep(node, 1)  # wait for publisher to be set up

        ws_client1 = await make_client()
        ws_client1.sendJson(
            {
                "op": "subscribe",
                "topic": "/a_topic",
                "type": "std_msgs/String",
            }
        )

        await sleep(node, 1)  # wait for subscriber to be set up

        pub_a.publish(String(data="hello"))

        ws1_completed_future, ws_client1.message_handler = expect_messages(
            1, "WebSocket 1", node.get_logger()
        )
        assert node.executor is not None
        ws1_completed_future.add_done_callback(lambda _: node.executor.wake())

        self.assertEqual(
            await ws1_completed_future,
            [{"op": "publish", "topic": "/a_topic", "msg": {"data": "hello"}}],
        )

        node.destroy_publisher(pub_a)



================================================
FILE: rosbridge_server/test/websocket/call_service.test.py
================================================
import sys
import time
import unittest
from pathlib import Path

from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.node import Node
from std_srvs.srv import SetBool
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestCallService(unittest.TestCase):
    @websocket_test
    async def test_one_call(self, node: Node, make_client):
        def service_cb(req, res):
            self.assertTrue(req.data)
            res.success = True
            res.message = "Hello, world!"
            return res

        service = node.create_service(
            SetBool, "/test_service", service_cb, callback_group=ReentrantCallbackGroup()
        )

        ws_client = await make_client()
        responses_future, ws_client.message_handler = expect_messages(
            1, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        responses_future.add_done_callback(lambda _: node.executor.wake())

        ws_client.sendJson(
            {
                "op": "call_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service",
                "args": {"data": True},
            }
        )

        responses = await responses_future
        self.assertEqual(len(responses), 1)
        self.assertEqual(responses[0]["op"], "service_response")
        self.assertEqual(responses[0]["service"], "/test_service")
        self.assertEqual(responses[0]["values"], {"success": True, "message": "Hello, world!"})
        self.assertEqual(responses[0]["result"], True)

        node.destroy_service(service)

        def service_long_cb(req, res):
            time.sleep(0.2)
            self.assertTrue(req.data)
            res.success = True
            res.message = "Hello, world!"
            return res

        service = node.create_service(
            SetBool, "/test_service_long", service_long_cb, callback_group=ReentrantCallbackGroup()
        )

        responses_future, ws_client.message_handler = expect_messages(
            2, "WebSocket", node.get_logger()
        )
        responses_future.add_done_callback(lambda _: node.executor.wake())

        ws_client.sendJson(
            {
                "op": "call_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service_long",
                "args": {"data": True},
                "timeout": 0.1,
            }
        )

        ws_client.sendJson(
            {
                "op": "call_service",
                "type": "std_srvs/SetBool",
                "service": "/test_service_long",
                "args": {"data": True},
                "timeout": 0.5,
            }
        )

        responses = await responses_future
        self.assertEqual(len(responses), 2)
        self.assertEqual(responses[0]["op"], "service_response")
        self.assertEqual(responses[0]["service"], "/test_service_long")
        self.assertEqual(
            responses[0]["values"], "Timeout exceeded while waiting for service response"
        )
        self.assertEqual(responses[0]["result"], False)

        self.assertEqual(responses[1]["op"], "service_response")
        self.assertEqual(responses[1]["service"], "/test_service_long")
        self.assertEqual(responses[1]["values"], {"success": True, "message": "Hello, world!"})
        self.assertEqual(responses[1]["result"], True)

        node.destroy_service(service)



================================================
FILE: rosbridge_server/test/websocket/common.py
================================================
import functools
import json
from collections.abc import Awaitable
from typing import TYPE_CHECKING, Any, Callable

import launch
import launch_ros
import rclpy
import rclpy.task
from autobahn.twisted.websocket import WebSocketClientFactory, WebSocketClientProtocol
from launch.launch_description import LaunchDescription
from rcl_interfaces.srv import GetParameters
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from rclpy.task import Future
from twisted.internet import reactor
from twisted.internet.endpoints import TCP4ClientEndpoint

if TYPE_CHECKING:
    from rclpy.client import Client


class TestClientProtocol(WebSocketClientProtocol):
    """Set message_handler to handle messages received from the server."""

    message_handler: Callable[[Any], None]

    def __init__(self, *args, **kwargs):
        self.received = []
        self.connected_future = Future()
        self.message_handler = lambda _: None
        super().__init__(*args, **kwargs)

    def onOpen(self):
        self.connected_future.set_result(None)

    def sendJson(self, msg_dict, *, times=1):
        msg = json.dumps(msg_dict).encode("utf-8")
        for _ in range(times):
            print(f"WebSocket client sent message: {msg}")
            self.sendMessage(msg)

    def onMessage(self, payload, binary):
        print(f"WebSocket client received message: {payload}")
        self.message_handler(payload if binary else json.loads(payload))


def _generate_node():
    try:
        return launch_ros.actions.Node(
            executable="rosbridge_websocket",
            package="rosbridge_server",
            parameters=[{"port": 0}],
        )
    except TypeError:
        # Deprecated keyword arg node_executable: https://github.com/ros2/launch_ros/pull/140
        return launch_ros.actions.Node(
            node_executable="rosbridge_websocket",
            package="rosbridge_server",
            parameters=[{"port": 0}],
        )


try:
    from launch_testing.actions import ReadyToTest

    def generate_test_description() -> LaunchDescription:
        """
        Generate a launch description that runs the websocket server.

        Re-export this from a test file and use add_launch_test() to run the test.
        """
        return LaunchDescription([_generate_node(), ReadyToTest()])

except ImportError:

    def generate_test_description(ready_fn) -> LaunchDescription:  # type: ignore[misc]
        """
        Generate a launch description that runs the websocket server.

        Re-export this from a test file and use add_launch_test() to run the test.
        """
        return LaunchDescription(
            [_generate_node(), launch.actions.OpaqueFunction(function=lambda _context: ready_fn())]
        )


async def get_server_port(node: Node) -> int:
    """Return the port which the WebSocket server is running on."""
    client: Client = node.create_client(GetParameters, "/rosbridge_websocket/get_parameters")
    try:
        if not client.wait_for_service(5):
            msg = "GetParameters service not available"
            raise RuntimeError(msg)
        port_param = await client.call_async(GetParameters.Request(names=["actual_port"]))
        assert port_param is not None
        return port_param.values[0].integer_value
    finally:
        node.destroy_client(client)


async def connect_to_server(node: Node) -> TestClientProtocol:
    port = await get_server_port(node)
    factory = WebSocketClientFactory("ws://127.0.0.1:" + str(port))
    factory.protocol = TestClientProtocol

    future: Future = Future()
    executor = node.executor
    assert executor is not None
    future.add_done_callback(lambda _: executor.wake())

    def connect():
        TCP4ClientEndpoint(reactor, "127.0.0.1", port).connect(factory).addCallback(
            future.set_result
        )

    reactor.callFromThread(connect)  # type: ignore[attr-defined]

    protocol: TestClientProtocol | None = await future
    assert protocol is not None
    protocol.connected_future.add_done_callback(lambda _: executor.wake())
    await protocol.connected_future  # wait for onOpen before proceeding
    return protocol


def run_websocket_test(
    node_name: str,
    test_fn: Callable[[Node, Callable[[], Awaitable[TestClientProtocol]]], Awaitable[None]],
):
    context = rclpy.Context()
    rclpy.init(context=context)
    executor = SingleThreadedExecutor(context=context)
    node = Node(node_name, context=context)
    executor.add_node(node)

    async def task():
        await test_fn(node, lambda: connect_to_server(node))
        reactor.callFromThread(reactor.stop)

    future = executor.create_task(task)

    reactor.callInThread(executor.spin_until_future_complete, future)  # type: ignore[attr-defined]
    reactor.run(installSignalHandlers=False)  # type: ignore[attr-defined]

    executor.remove_node(node)
    node.destroy_node()
    rclpy.shutdown(context=context)


def sleep(node: Node, duration: float) -> Awaitable[None]:
    """
    Sleep for a given duration in seconds.

    Async-compatible delay function based on a ROS timer.
    """
    future: Future = Future()

    def callback():
        future.set_result(None)
        timer.cancel()
        node.destroy_timer(timer)

    timer = node.create_timer(duration, callback)
    return future


def websocket_test(test_fn):
    """
    Decorate tests which use a ROS node and WebSocket server and client.

    Multiple tests per file are not supported because the Twisted reactor cannot be run multiple times.
    """

    @functools.wraps(test_fn)
    def run_test(self):
        run_websocket_test(test_fn.__name__, lambda *args: test_fn(self, *args))

    return run_test


def expect_messages(count: int, description: str, logger):
    """
    Expect a specific number of messages.

    Convenience function to create a Future and a message handler function which gathers results
    into a list and waits for the list to have the expected number of items.
    """
    future: Future = Future()
    results = []

    def handler(msg):
        logger.info(f"Received message on {description}: {msg}")  # noqa: G004
        results.append(msg)
        if len(results) == count:
            logger.info(f"Received all messages on {description}")  # noqa: G004
            future.set_result(results)
        elif len(results) > count:
            msg = f"Received {len(results)} messages on {description} but expected {count}"
            raise AssertionError(msg)

    return future, handler



================================================
FILE: rosbridge_server/test/websocket/multiple_subscribers.test.py
================================================
import sys
import unittest
from pathlib import Path

from rclpy.node import Node
from std_msgs.msg import String
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestMultipleSubscribers(unittest.TestCase):
    @websocket_test
    async def test_multiple_subscribers(self, node: Node, make_client):
        ws_client1 = await make_client()
        ws_client1.sendJson(
            {
                "op": "subscribe",
                "topic": "/a_topic",
                "type": "std_msgs/String",
            }
        )

        ws_client2 = await make_client()
        ws_client2.sendJson(
            {
                "op": "subscribe",
                "topic": "/a_topic",
                "type": "std_msgs/String",
            }
        )

        ws1_completed_future, ws_client1.message_handler = expect_messages(
            1, "WebSocket 1", node.get_logger()
        )
        assert node.executor is not None
        ws1_completed_future.add_done_callback(lambda _: node.executor.wake())
        ws2_completed_future, ws_client2.message_handler = expect_messages(
            1, "WebSocket 2", node.get_logger()
        )
        ws2_completed_future.add_done_callback(lambda _: node.executor.wake())

        pub_a = node.create_publisher(String, "/a_topic", 1)

        await sleep(node, 1)

        pub_a.publish(String(data="hello"))

        self.assertEqual(
            await ws1_completed_future,
            [{"op": "publish", "topic": "/a_topic", "msg": {"data": "hello"}}],
        )
        self.assertEqual(
            await ws2_completed_future,
            [{"op": "publish", "topic": "/a_topic", "msg": {"data": "hello"}}],
        )
        node.destroy_publisher(pub_a)



================================================
FILE: rosbridge_server/test/websocket/multiple_subscribers_raw.test.py
================================================
import sys
import unittest
from pathlib import Path

from rclpy.node import Node
from std_msgs.msg import String
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestMultipleSubscribers(unittest.TestCase):
    @websocket_test
    async def test_multiple_subscribers(self, node: Node, make_client):
        sub_operation_json = {
            "op": "subscribe",
            "topic": "/a_topic",
            "type": "std_msgs/String",
            "compression": "cbor-raw",
        }
        ws_client1 = await make_client()
        ws_client1.sendJson(sub_operation_json)
        ws_client2 = await make_client()
        ws_client2.sendJson(sub_operation_json)

        ws1_completed_future, ws_client1.message_handler = expect_messages(
            1, "WebSocket 1", node.get_logger()
        )
        assert node.executor is not None
        ws1_completed_future.add_done_callback(lambda _: node.executor.wake())
        ws2_completed_future, ws_client2.message_handler = expect_messages(
            1, "WebSocket 2", node.get_logger()
        )
        ws2_completed_future.add_done_callback(lambda _: node.executor.wake())

        pub_a = node.create_publisher(String, "/a_topic", 1)

        await sleep(node, 1)
        pub_a.publish(String(data="hello"))
        await sleep(node, 1)

        self.assertTrue(await ws1_completed_future)
        self.assertTrue(await ws2_completed_future)
        node.destroy_publisher(pub_a)



================================================
FILE: rosbridge_server/test/websocket/send_action_goal.test.py
================================================
import sys
import time
import unittest
from pathlib import Path

from action_msgs.msg import GoalStatus
from example_interfaces.action import Fibonacci
from rclpy.action import ActionServer, CancelResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.node import Node
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestSendActionGoal(unittest.TestCase):
    def cancel_callback(self, _):
        return CancelResponse.ACCEPT

    def execute_callback(self, goal):
        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal.request.order):
            if goal.is_cancel_requested:
                goal.canceled()
                return Fibonacci.Result()

            feedback_msg.sequence.append(feedback_msg.sequence[i] + feedback_msg.sequence[i - 1])
            goal.publish_feedback(feedback_msg)
            time.sleep(0.5)

        goal.succeed()
        return Fibonacci.Result(sequence=feedback_msg.sequence)

    @websocket_test
    async def test_one_call(self, node: Node, make_client):
        action_server = ActionServer(
            node,
            Fibonacci,
            "/test_fibonacci_action",
            execute_callback=self.execute_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup(),
        )

        ws_client = await make_client()
        responses_future, ws_client.message_handler = expect_messages(
            5, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        responses_future.add_done_callback(lambda _: node.executor.wake())

        ws_client.sendJson(
            {
                "op": "send_action_goal",
                "action": "/test_fibonacci_action",
                "action_type": "example_interfaces/Fibonacci",
                "args": {"order": 5},
                "feedback": True,
            }
        )

        responses = await responses_future
        expected_result = [0, 1, 1, 2, 3, 5]
        self.assertEqual(len(responses), 5)

        for idx in range(4):
            self.assertEqual(responses[idx]["op"], "action_feedback")
            self.assertEqual(responses[idx]["values"]["sequence"], expected_result[: idx + 3])

        self.assertEqual(responses[-1]["op"], "action_result")
        self.assertEqual(responses[-1]["action"], "/test_fibonacci_action")
        self.assertEqual(responses[-1]["values"]["sequence"], expected_result)
        self.assertEqual(responses[-1]["status"], GoalStatus.STATUS_SUCCEEDED)
        self.assertEqual(responses[-1]["result"], True)

        action_server.destroy()



================================================
FILE: rosbridge_server/test/websocket/smoke.test.py
================================================
import sys
import unittest
from pathlib import Path

from rclpy.node import Node
from std_msgs.msg import String
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestWebsocketSmoke(unittest.TestCase):
    @websocket_test
    async def test_smoke(self, node: Node, make_client):
        ws_client = await make_client()
        # For consistency, the number of messages must not exceed the the protocol
        # Subscriber queue_size.
        NUM_MSGS = 10
        MSG_SIZE = 10
        A_TOPIC = "/a_topic"
        B_TOPIC = "/b_topic"
        A_STRING = "A" * MSG_SIZE
        B_STRING = "B" * MSG_SIZE
        WARMUP_DELAY = 1.0  # seconds

        sub_completed_future, sub_handler = expect_messages(
            NUM_MSGS, "ROS subscriber", node.get_logger()
        )
        ws_completed_future, ws_client.message_handler = expect_messages(
            NUM_MSGS, "WebSocket", node.get_logger()
        )
        assert node.executor is not None
        ws_completed_future.add_done_callback(lambda _: node.executor.wake())

        sub_a = node.create_subscription(String, A_TOPIC, sub_handler, NUM_MSGS)
        pub_b = node.create_publisher(String, B_TOPIC, NUM_MSGS)

        ws_client.sendJson(
            {
                "op": "subscribe",
                "topic": B_TOPIC,
                "type": "std_msgs/String",
                "queue_length": 0,  # Test the roslib default.
            }
        )
        ws_client.sendJson(
            {
                "op": "advertise",
                "topic": A_TOPIC,
                "type": "std_msgs/String",
            }
        )

        await sleep(node, WARMUP_DELAY)

        ws_client.sendJson(
            {
                "op": "publish",
                "topic": A_TOPIC,
                "msg": {
                    "data": A_STRING,
                },
            },
            times=NUM_MSGS,
        )

        for _ in range(NUM_MSGS):
            pub_b.publish(String(data=B_STRING))

        ros_received = await sub_completed_future
        ws_received = await ws_completed_future

        for msg in ws_received:
            self.assertEqual("publish", msg["op"])
            self.assertEqual(B_TOPIC, msg["topic"])
            self.assertEqual(B_STRING, msg["msg"]["data"])
        self.assertEqual(NUM_MSGS, len(ws_received))

        for msg in ros_received:
            self.assertEqual(A_STRING, msg.data)
        self.assertEqual(NUM_MSGS, len(ros_received))

        node.destroy_subscription(sub_a)
        node.destroy_publisher(pub_b)



================================================
FILE: rosbridge_server/test/websocket/transient_local_publisher.test.py
================================================
import sys
import unittest
from pathlib import Path

from rclpy.node import Node
from rclpy.qos import DurabilityPolicy, HistoryPolicy, QoSProfile
from std_msgs.msg import String
from twisted.python import log

sys.path.append(str(Path(__file__).parent))  # enable importing from common.py in this directory

import common
from common import expect_messages, sleep, websocket_test

log.startLogging(sys.stderr)

generate_test_description = common.generate_test_description


class TestTransientLocalPublisher(unittest.TestCase):
    @websocket_test
    async def test_transient_local_publisher(self, node: Node, make_client):
        qos = QoSProfile(
            depth=1,
            durability=DurabilityPolicy.TRANSIENT_LOCAL,
            history=HistoryPolicy.KEEP_LAST,
        )
        pub_a = node.create_publisher(String, "/a_topic", qos_profile=qos)

        await sleep(node, 1)

        pub_a.publish(String(data="hello"))

        await sleep(node, 1)

        for num in range(3):
            ws_client = await make_client()
            ws_client.sendJson(
                {
                    "op": "subscribe",
                    "topic": "/a_topic",
                    "type": "std_msgs/String",
                }
            )

            ws_completed_future, ws_client.message_handler = expect_messages(
                1, "WebSocket " + str(num), node.get_logger()
            )
            assert node.executor is not None
            ws_completed_future.add_done_callback(lambda _: node.executor.wake())

            self.assertEqual(
                await ws_completed_future,
                [{"op": "publish", "topic": "/a_topic", "msg": {"data": "hello"}}],
            )

        node.destroy_publisher(pub_a)



================================================
FILE: rosbridge_suite/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosbridge_suite
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------

2.2.0 (2025-02-26)
------------------
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Contributors: Błażej Sowa

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------

1.3.2 (2023-09-27)
------------------
* rosbridge_suite: depend on ament_cmake (`#848 <https://github.com/RobotWebTools/rosbridge_suite/issues/848>`_)
* Contributors: Jochen Sprickerhof

1.3.1 (2022-10-21)
------------------

1.3.0 (2022-08-16)
------------------

1.2.0 (2022-05-20)
------------------

1.1.2 (2022-01-03)
------------------

1.1.1 (2021-12-09)
------------------

1.1.0 (2021-10-22)
------------------

1.0.8 (2021-08-26)
------------------

1.0.7 (2021-08-18)
------------------
* Fix typos discovered by codespell (`#600 <https://github.com/RobotWebTools/rosbridge_suite/issues/600>`_)
* Contributors: Christian Clauss

1.0.6 (2021-08-17)
------------------

1.0.5 (2021-08-12)
------------------

1.0.4 (2021-08-11)
------------------

1.0.3 (2021-08-03)
------------------

1.0.2 (2019-09-24)
------------------

1.0.1 (2019-09-20)
------------------

1.0.0 (2019-09-19)
------------------
* Port to ROS 2

0.11.3 (2019-08-07)
-------------------

0.11.2 (2019-07-08)
-------------------

0.11.1 (2019-05-08)
-------------------

0.11.0 (2019-03-29)
-------------------

0.10.2 (2019-03-04)
-------------------

0.10.1 (2018-12-16)
-------------------

0.10.0 (2018-12-14)
-------------------
* use package format 2, remove unnecessary dependencies (`#348 <https://github.com/RobotWebTools/rosbridge_suite/issues/348>`_)
* Contributors: Dirk Thomas

0.9.0 (2018-04-09)
------------------

0.8.6 (2017-12-08)
------------------

0.8.5 (2017-11-23)
------------------

0.8.4 (2017-10-16)
------------------

0.8.3 (2017-09-11)
------------------

0.8.2 (2017-09-11)
------------------

0.8.1 (2017-08-30)
------------------

0.8.0 (2017-08-30)
------------------

0.7.17 (2017-01-25)
-------------------

0.7.16 (2016-08-15)
-------------------

0.7.15 (2016-04-25)
-------------------
* changelog updated
* Contributors: Russell Toris

0.7.14 (2016-02-11)
-------------------

0.7.13 (2015-08-14)
-------------------

0.7.12 (2015-04-07)
-------------------

0.7.11 (2015-03-23)
-------------------

0.7.10 (2015-02-25)
-------------------

0.7.9 (2015-02-24)
------------------

0.7.8 (2015-01-16)
------------------

0.7.7 (2015-01-06)
------------------

0.7.6 (2014-12-26)
------------------
* 0.7.5
* update changelog
* 0.7.4
* changelog updated
* 0.7.3
* changelog updated
* 0.7.2
* changelog updated
* 0.7.1
* update changelog
* 0.7.0
* changelog updated
* Contributors: Jihoon Lee, Russell Toris

0.7.5 (2014-12-26)
------------------

0.7.4 (2014-12-16)
------------------

0.7.3 (2014-12-15)
------------------

0.7.2 (2014-12-15)
------------------
* 0.7.1
* update changelog
* Contributors: Jihoon Lee

0.7.1 (2014-12-09)
------------------

0.7.0 (2014-12-02)
------------------

0.6.8 (2014-11-05)
------------------

0.6.7 (2014-10-22)
------------------
* updated package manifests
* Contributors: Russell Toris

0.6.6 (2014-10-21)
------------------

0.6.5 (2014-10-14)
------------------
* 0.6.4
* update changelog
* 0.6.3
* update change log
* Contributors: Jihoon Lee

0.6.4 (2014-10-08)
------------------

0.6.3 (2014-10-07)
------------------

0.6.2 (2014-10-06)
------------------

0.6.1 (2014-09-01)
------------------

0.6.0 (2014-05-23)
------------------

0.5.4 (2014-04-17)
------------------

0.5.3 (2014-03-28)
------------------

0.5.2 (2014-03-14)
------------------

0.5.1 (2013-10-31)
------------------

0.5.0 (2013-07-17)
------------------
* 0.5.0 preparation for hydro release
* Contributors: Jihoon Lee

0.4.4 (2013-04-08)
------------------
* adding russl and myself as maintainer. adding build_tool depend
* Contributors: Jihoon Lee

0.4.3 (2013-04-03 08:24)
------------------------
* adding CMake list for meta pkg
* Contributors: Jihoon Lee

0.4.2 (2013-04-03 08:12)
------------------------

0.4.1 (2013-03-07)
------------------

0.4.0 (2013-03-05)
------------------
* cleaning up meta package
* Catkinizing rosbridge_library and server.
* Collapse directory structure.
* Removed print statements and also made sure to cast any tuples to lists.
* Removed the pypng dependency and finalised PIL dependency
* Use python imaging library to encode PNG instead of pypng
* Added the ujson library, modified cmakelists to install ujson to the
  user python directory.
* Fixed an inconsequential elif bug.
* Refactored to use simplejson if the package is installed.
* Added simplejson library and moved the location of the libraries.
* Temporary commit adding profiling messages. something is going awry.
* Renamed rosbridge stack to rosbridge_suite
* Contributors: Austin Hendrix, Brandon Alexander, Jihoon Lee, jon



================================================
FILE: rosbridge_suite/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosbridge_suite NONE)
find_package(ament_cmake_core REQUIRED)
ament_package()



================================================
FILE: rosbridge_suite/package.xml
================================================
<?xml version="1.0"?>
<package format="2">
  <name>rosbridge_suite</name>
  <version>2.3.0</version>
  <description>
Rosbridge provides a JSON API to ROS functionality for non-ROS programs.
There are a variety of front ends that interface with rosbridge, including
a WebSocket server for web browsers to interact with.

Rosbridge_suite is a meta-package containing rosbridge, various front end
packages for rosbridge like a WebSocket package, and helper packages.
  </description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosbridge_suite</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <exec_depend>rosbridge_library</exec_depend>
  <exec_depend>rosbridge_server</exec_depend>
  <exec_depend>rosapi</exec_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosbridge_test_msgs/CHANGELOG.rst
================================================
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Changelog for package rosbridge_test_msgs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

2.3.0 (2025-05-19)
------------------

2.2.0 (2025-02-26)
------------------
* Update maintainers (`#1000 <https://github.com/RobotWebTools/rosbridge_suite/issues/1000>`_)
* Contributors: Błażej Sowa

2.1.0 (2024-10-08)
------------------

2.0.0 (2024-10-08)
------------------
* Fix action cancellation by passing status from JSON (`#953 <https://github.com/RobotWebTools/rosbridge_suite/issues/953>`_)
* Fix length-limited list types (`#840 <https://github.com/RobotWebTools/rosbridge_suite/issues/840>`_)
* Support actions in rosbridge protocol (`#886 <https://github.com/RobotWebTools/rosbridge_suite/issues/886>`_)
* Contributors: Ezra Brooks, Sebastian Castro

1.3.2 (2023-09-27)
------------------

1.3.1 (2022-10-21)
------------------

1.3.0 (2022-08-16)
------------------

1.2.0 (2022-05-20)
------------------

1.1.2 (2022-01-03)
------------------

1.1.1 (2021-12-09)
------------------

1.1.0 (2021-10-22)
------------------
* Move msg/srv from rosapi and rosbridge_library into separate packages; enable Rolling in CI (`#665 <https://github.com/RobotWebTools/rosbridge_suite/issues/665>`_)
* Contributors: Jacob Bandes-Storch



================================================
FILE: rosbridge_test_msgs/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.5)
project(rosbridge_test_msgs)

find_package(ament_cmake REQUIRED)
find_package(builtin_interfaces REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(std_msgs REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  msg/Num.msg
  msg/TestChar.msg
  msg/TestDurationArray.msg
  msg/TestHeaderArray.msg
  msg/TestHeader.msg
  msg/TestHeaderTwo.msg
  msg/TestTimeArray.msg
  msg/TestUInt8.msg
  msg/TestUInt8FixedSizeArray16.msg
  msg/TestFloat32Array.msg
  msg/TestFloat32BoundedArray.msg
  msg/TestNestedBoundedArray.msg
  srv/AddTwoInts.srv
  srv/SendBytes.srv
  srv/TestArrayRequest.srv
  srv/TestEmpty.srv
  srv/TestMultipleRequestFields.srv
  srv/TestMultipleResponseFields.srv
  srv/TestNestedService.srv
  srv/TestRequestAndResponse.srv
  srv/TestRequestOnly.srv
  srv/TestResponseOnly.srv
  action/TestEmpty.action
  action/TestFeedbackAndResult.action
  action/TestGoalAndResult.action
  action/TestGoalFeedbackAndResult.action
  action/TestGoalOnly.action
  action/TestMultipleGoalFields.action
  action/TestResultOnly.action
  DEPENDENCIES builtin_interfaces geometry_msgs std_msgs
)

ament_export_dependencies(rosidl_default_runtime)

ament_package()



================================================
FILE: rosbridge_test_msgs/package.xml
================================================
<?xml version="1.0"?>
<package format="3">
  <name>rosbridge_test_msgs</name>
  <version>2.3.0</version>
  <description>
    Message and service definitions used in internal tests for rosbridge packages.
  </description>

  <license>BSD</license>

  <url type="website">http://ros.org/wiki/rosbridge_library</url>
  <url type="bugtracker">https://github.com/RobotWebTools/rosbridge_suite/issues</url>
  <url type="repository">https://github.com/RobotWebTools/rosbridge_suite</url>

  <author email="jonathan.c.mace@gmail.com">Jonathan Mace</author>
  <maintainer email="blazej@fictionlab.pl">Błażej Sowa</maintainer>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>action_msgs</depend>
  <depend>builtin_interfaces</depend>
  <depend>geometry_msgs</depend>
  <depend>std_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: rosbridge_test_msgs/action/TestEmpty.action
================================================
# Empty goal
---
# Empty feedback
---
# Empty result



================================================
FILE: rosbridge_test_msgs/action/TestFeedbackAndResult.action
================================================
# Empty goal
---
# Empty feedback
---
# Result
int32 data



================================================
FILE: rosbridge_test_msgs/action/TestGoalAndResult.action
================================================
# Goal
int32 data
---
# Empty feedback
---
# result
int32 data



================================================
FILE: rosbridge_test_msgs/action/TestGoalFeedbackAndResult.action
================================================
# Goal
int32 data
---
# Feedback
int32 data
---
# result
int32 data



================================================
FILE: rosbridge_test_msgs/action/TestGoalOnly.action
================================================
# Goal
int32 data
---
# Empty feedback
---
# Empty result



================================================
FILE: rosbridge_test_msgs/action/TestMultipleGoalFields.action
================================================
# Goal
int32 int_value
float32 float_value
string string
bool bool_value
---
# Empty feedback
---
# Empty result



================================================
FILE: rosbridge_test_msgs/action/TestResultOnly.action
================================================
# Empty goal
---
# Empty feedback
---
# Result
int32 data



================================================
FILE: rosbridge_test_msgs/msg/Num.msg
================================================
int64 num



================================================
FILE: rosbridge_test_msgs/msg/TestChar.msg
================================================
char[] data



================================================
FILE: rosbridge_test_msgs/msg/TestDurationArray.msg
================================================
builtin_interfaces/Duration[] durations



================================================
FILE: rosbridge_test_msgs/msg/TestFloat32Array.msg
================================================
float32[] data



================================================
FILE: rosbridge_test_msgs/msg/TestFloat32BoundedArray.msg
================================================
float32[16] data



================================================
FILE: rosbridge_test_msgs/msg/TestHeader.msg
================================================
std_msgs/Header header



================================================
FILE: rosbridge_test_msgs/msg/TestHeaderArray.msg
================================================
std_msgs/Header[] header



================================================
FILE: rosbridge_test_msgs/msg/TestHeaderTwo.msg
================================================
std_msgs/Header header



================================================
FILE: rosbridge_test_msgs/msg/TestNestedBoundedArray.msg
================================================
TestFloat32BoundedArray data



================================================
FILE: rosbridge_test_msgs/msg/TestTimeArray.msg
================================================
builtin_interfaces/Time[] times



================================================
FILE: rosbridge_test_msgs/msg/TestUInt8.msg
================================================
uint8[] data



================================================
FILE: rosbridge_test_msgs/msg/TestUInt8FixedSizeArray16.msg
================================================
uint8[16] data



================================================
FILE: rosbridge_test_msgs/srv/AddTwoInts.srv
================================================
int64 a
int64 b
---
int64 sum



================================================
FILE: rosbridge_test_msgs/srv/SendBytes.srv
================================================
int64 count
---
string data



================================================
FILE: rosbridge_test_msgs/srv/TestArrayRequest.srv
================================================
int32[] int_values
---



================================================
FILE: rosbridge_test_msgs/srv/TestEmpty.srv
================================================
---



================================================
FILE: rosbridge_test_msgs/srv/TestMultipleRequestFields.srv
================================================
int32 int_value
float32 float_value
string string
bool bool_value
---



================================================
FILE: rosbridge_test_msgs/srv/TestMultipleResponseFields.srv
================================================
---
int32 int_value
float32 float_value
string string
bool bool_value



================================================
FILE: rosbridge_test_msgs/srv/TestNestedService.srv
================================================
#request definition
geometry_msgs/Pose pose
---
#response definition
std_msgs/Float64 data



================================================
FILE: rosbridge_test_msgs/srv/TestRequestAndResponse.srv
================================================
int32 data
---
int32 data



================================================
FILE: rosbridge_test_msgs/srv/TestRequestOnly.srv
================================================
int32 data
---



================================================
FILE: rosbridge_test_msgs/srv/TestResponseOnly.srv
================================================
---
int32 data



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "daily"



================================================
FILE: .github/ISSUE_TEMPLATE.md
================================================
<!-- If you have a question about how to use rosbridge, please ask at https://answers.ros.org/ -->
<!-- For solutions to common problems, see TROUBLESHOOTING.md -->


## Expected Behavior


## Actual Behavior


## Steps to Reproduce the Problem

  1.
  1.
  1.

## Specifications

  - ROS Version (`echo $ROS_DISTRO`):
  - OS Version (`grep DISTRIB_CODENAME /etc/lsb-release`):
  - Rosbridge Version (`roscat rosbridge_server package.xml | grep '<version>'`):
  - Tornado Version (`python -c 'import tornado; print tornado.version'`):



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on: [push, pull_request, workflow_dispatch]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-python@v6
        with:
          python-version: '3.10'

      - uses: pre-commit/action@v3.0.1

  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          # Test supported ROS 2 distributions
          # https://docs.ros.org/en/rolling/Releases.html
          # NOTE: Humble and Jazzy do not work on the `ros2` branch, so they are tested in their own branches.
          - ros: kilted
            os: ubuntu-24.04
          - ros: rolling
            os: ubuntu-24.04

    name: ROS 2 ${{ matrix.ros }} (${{ matrix.os }})
    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v5
        with:
          path: ros_ws/src

      - uses: ros-tooling/setup-ros@v0.7

      - uses: ros-tooling/action-ros-ci@v0.4
        with:
          target-ros2-distro: ${{ matrix.ros }}



================================================
FILE: .github/workflows/stale.yml
================================================
name: Stale

on:
  schedule:
    - cron: "0 0 * * *"

jobs:
  stale:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - uses: actions/stale@v10.0.0
        with:
          stale-issue-message: "This issue has been marked as stale because there has been no activity in the past 12 months. Please add a comment to keep it open."
          stale-issue-label: stale
          days-before-issue-stale: 365
          days-before-issue-close: 30

          stale-pr-message: "This PR has been marked as stale because there has been no activity in the past 6 months. Please add a comment to keep it open."
          stale-pr-label: stale
          days-before-pr-stale: 180
          days-before-pr-close: 30
          delete-branch: true


