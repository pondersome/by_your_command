Directory structure:
└── moffkalast-vizanti/
    ├── ReadMe.md
    ├── Contributing.md
    ├── LICENSE
    ├── docker/
    │   └── Dockerfile
    ├── vizanti/
    │   ├── CMakeLists.txt
    │   └── package.xml
    ├── vizanti_cpp/
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   └── src/
    │       └── tf_consolidator.cpp
    ├── vizanti_demos/
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── launch/
    │   │   └── test.launch.py
    │   ├── resource/
    │   │   └── vizanti_demos
    │   └── scripts/
    │       ├── __init__.py
    │       ├── particle_cloud_to_pose_array.py
    │       ├── path_to_nav2poses.py
    │       ├── test_button.py
    │       ├── test_grid_cells.py
    │       ├── test_marker_array.py
    │       ├── test_occupancy_grid.py
    │       ├── test_tf.py
    │       └── waypoints_to_simple_goals.py
    ├── vizanti_msgs/
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── resource/
    │   │   └── vizanti_msgs
    │   └── srv/
    │       ├── GetNodeParameters.srv
    │       ├── ListExecutables.srv
    │       ├── ListLifecycles.srv
    │       ├── ListPackages.srv
    │       ├── LoadMap.srv
    │       ├── ManageNode.srv
    │       ├── RecordRosbag.srv
    │       ├── SaveMap.srv
    │       └── SetNodeParameter.srv
    ├── vizanti_server/
    │   ├── CMakeLists.txt
    │   ├── package.xml
    │   ├── launch/
    │   │   ├── vizanti_rws.launch.py
    │   │   └── vizanti_server.launch.py
    │   ├── public/
    │   │   ├── head.html
    │   │   ├── iconbar.html
    │   │   ├── index.html
    │   │   ├── assets/
    │   │   │   ├── default_layout.json
    │   │   │   └── icon/
    │   │   │       └── manifest.json
    │   │   ├── css/
    │   │   │   ├── style.css
    │   │   │   └── font/
    │   │   │       ├── LICENCE.txt
    │   │   │       └── TRADEMARKS.txt
    │   │   ├── js/
    │   │   │   ├── main.js
    │   │   │   ├── setup.js
    │   │   │   ├── lib/
    │   │   │   │   ├── nipplejs.js
    │   │   │   │   ├── nipplejs_LICENSE.txt
    │   │   │   │   ├── numericjs_LICENSE.txt
    │   │   │   │   ├── quaternionjs_LICENSE.txt
    │   │   │   │   └── roslibjs_LICENSE.txt
    │   │   │   └── modules/
    │   │   │       ├── database.js
    │   │   │       ├── elements.js
    │   │   │       ├── joystick.js
    │   │   │       ├── navsat.js
    │   │   │       ├── persistent.js
    │   │   │       ├── rosbridge.js
    │   │   │       ├── status.js
    │   │   │       ├── tf.js
    │   │   │       ├── util.js
    │   │   │       └── view.js
    │   │   └── templates/
    │   │       ├── add/
    │   │       │   ├── add_icon.html
    │   │       │   ├── add_modal.html
    │   │       │   └── add_script.js
    │   │       ├── altimeter/
    │   │       │   ├── altimeter_icon.html
    │   │       │   ├── altimeter_modal.html
    │   │       │   ├── altimeter_script.js
    │   │       │   └── altimeter_view.html
    │   │       ├── area/
    │   │       │   ├── area_icon.html
    │   │       │   ├── area_modal.html
    │   │       │   ├── area_script.js
    │   │       │   └── area_view.html
    │   │       ├── battery/
    │   │       │   ├── battery_icon.html
    │   │       │   ├── battery_modal.html
    │   │       │   └── battery_script.js
    │   │       ├── button/
    │   │       │   ├── button_icon.html
    │   │       │   ├── button_modal.html
    │   │       │   └── button_script.js
    │   │       ├── compressedimage/
    │   │       │   ├── compressedimage_icon.html
    │   │       │   ├── compressedimage_modal.html
    │   │       │   ├── compressedimage_script.js
    │   │       │   └── compressedimage_view.html
    │   │       ├── folder/
    │   │       │   ├── folder_icon.html
    │   │       │   ├── folder_modal.html
    │   │       │   └── folder_script.js
    │   │       ├── grid/
    │   │       │   ├── grid_icon.html
    │   │       │   ├── grid_modal.html
    │   │       │   ├── grid_script.js
    │   │       │   └── grid_view.html
    │   │       ├── gridcells/
    │   │       │   ├── gridcells_icon.html
    │   │       │   ├── gridcells_modal.html
    │   │       │   ├── gridcells_script.js
    │   │       │   └── gridcells_view.html
    │   │       ├── initialpose/
    │   │       │   ├── initialpose_icon.html
    │   │       │   ├── initialpose_modal.html
    │   │       │   ├── initialpose_script.js
    │   │       │   └── initialpose_view.html
    │   │       ├── inspector/
    │   │       │   ├── inspector_icon.html
    │   │       │   ├── inspector_modal.html
    │   │       │   └── inspector_script.js
    │   │       ├── map/
    │   │       │   ├── map_icon.html
    │   │       │   ├── map_modal.html
    │   │       │   ├── map_script.js
    │   │       │   ├── map_view.html
    │   │       │   └── map_worker.js
    │   │       ├── markerarray/
    │   │       │   ├── markerarray_icon.html
    │   │       │   ├── markerarray_modal.html
    │   │       │   ├── markerarray_script.js
    │   │       │   └── markerarray_view.html
    │   │       ├── nodemgr/
    │   │       │   ├── nodemgr_icon.html
    │   │       │   ├── nodemgr_modal.html
    │   │       │   └── nodemgr_script.js
    │   │       ├── odom/
    │   │       │   ├── odom_icon.html
    │   │       │   ├── odom_modal.html
    │   │       │   ├── odom_script.js
    │   │       │   └── odom_view.html
    │   │       ├── path/
    │   │       │   ├── path_icon.html
    │   │       │   ├── path_modal.html
    │   │       │   ├── path_script.js
    │   │       │   └── path_view.html
    │   │       ├── pointcloud/
    │   │       │   ├── pointcloud_icon.html
    │   │       │   ├── pointcloud_modal.html
    │   │       │   ├── pointcloud_script.js
    │   │       │   └── pointcloud_view.html
    │   │       ├── posearray/
    │   │       │   ├── posearray_icon.html
    │   │       │   ├── posearray_modal.html
    │   │       │   ├── posearray_script.js
    │   │       │   └── posearray_view.html
    │   │       ├── posewithcovariancestamped/
    │   │       │   ├── posewithcovariancestamped_icon.html
    │   │       │   ├── posewithcovariancestamped_modal.html
    │   │       │   ├── posewithcovariancestamped_script.js
    │   │       │   └── posewithcovariancestamped_view.html
    │   │       ├── range/
    │   │       │   ├── range_icon.html
    │   │       │   ├── range_modal.html
    │   │       │   ├── range_script.js
    │   │       │   └── range_view.html
    │   │       ├── reconfigure/
    │   │       │   ├── reconfigure_icon.html
    │   │       │   ├── reconfigure_modal.html
    │   │       │   └── reconfigure_script.js
    │   │       ├── robotmodel/
    │   │       │   ├── robotmodel_icon.html
    │   │       │   ├── robotmodel_modal.html
    │   │       │   ├── robotmodel_script.js
    │   │       │   └── robotmodel_view.html
    │   │       ├── rosbag/
    │   │       │   ├── rosbag_icon.html
    │   │       │   ├── rosbag_modal.html
    │   │       │   └── rosbag_script.js
    │   │       ├── rosbridge/
    │   │       │   ├── rosbridge_icon.html
    │   │       │   ├── rosbridge_modal.html
    │   │       │   └── rosbridge_script.js
    │   │       ├── satelite/
    │   │       │   ├── satelite_icon.html
    │   │       │   ├── satelite_modal.html
    │   │       │   ├── satelite_script.js
    │   │       │   └── satelite_view.html
    │   │       ├── scan/
    │   │       │   ├── scan_icon.html
    │   │       │   ├── scan_modal.html
    │   │       │   ├── scan_script.js
    │   │       │   └── scan_view.html
    │   │       ├── settings/
    │   │       │   ├── settings_icon.html
    │   │       │   ├── settings_modal.html
    │   │       │   └── settings_script.js
    │   │       ├── simplegoal/
    │   │       │   ├── simplegoal_icon.html
    │   │       │   ├── simplegoal_modal.html
    │   │       │   ├── simplegoal_script.js
    │   │       │   └── simplegoal_view.html
    │   │       ├── speedometer/
    │   │       │   ├── speedometer_icon.html
    │   │       │   ├── speedometer_modal.html
    │   │       │   └── speedometer_script.js
    │   │       ├── teleop/
    │   │       │   ├── teleop_icon.html
    │   │       │   ├── teleop_modal.html
    │   │       │   ├── teleop_script.js
    │   │       │   └── teleop_view.html
    │   │       ├── temperature/
    │   │       │   ├── temperature_icon.html
    │   │       │   ├── temperature_modal.html
    │   │       │   └── temperature_script.js
    │   │       ├── tf/
    │   │       │   ├── tf_icon.html
    │   │       │   ├── tf_modal.html
    │   │       │   ├── tf_script.js
    │   │       │   └── tf_view.html
    │   │       └── waypoints/
    │   │           ├── waypoints_icon.html
    │   │           ├── waypoints_modal.html
    │   │           ├── waypoints_script.js
    │   │           └── waypoints_view.html
    │   ├── resource/
    │   │   └── vizanti_server
    │   └── scripts/
    │       ├── __init__.py
    │       ├── rqt_reconfigure_param_api.py
    │       ├── server.py
    │       └── service_handler.py
    └── .github/
        └── ISSUE_TEMPLATE/
            ├── bug-issue.md
            ├── discussion.md
            └── feature_request.md

================================================
FILE: ReadMe.md
================================================
# <img src="vizanti_server/public/assets/icon/512.png" alt="Icon" title="Grid" width="50" height="50"/> Vizanti - Web Visualizer & Mission Planner for ROS

[![License](https://img.shields.io/badge/License-BSD_3--Clause-blue.png)](https://opensource.org/licenses/BSD-3-Clause) [![Build Status](https://build.ros2.org/buildStatus/icon?job=Hdev__vizanti__ubuntu_jammy_amd64)](https://build.ros2.org/job/Hdev__vizanti__ubuntu_jammy_amd64/)

Vizanti is a web-based visualization and control tool developed for more convenient operation of outdoor robots running the Robot Operating System (ROS). The application attempts to replicate RViz's orthographic 2D view as closely as possible with a smartphone friendly interface. The second goal is to allow planning and executing movement and mission commands, i.e. goals and waypoints, with custom buttons and parameter reconfigure.

<img src="vizanti_server/public/assets/icon/preview.jpg" alt=""/> 

## Installation

As a field tool, Vizanti is designed to operate just as well without internet access, and as such the intended way is to host it on a robot, with rosbridge autoconnecting to the host IP.

```bash
cd ~/colcon_ws/src
git clone -b ros2 https://github.com/MoffKalast/vizanti.git

cd ..
rosdep install -i --from-path src/vizanti -y
colcon build
```

### Docker

Alternatively, you can also containerize Vizanti. For that you need to [install Docker](https://docs.docker.com/engine/install/ubuntu/) and build the container:

In case you're building on a system with a different version of ROS or it's not installed, replace $ROS_DISTRO with either humble or jazzy.

```bash
git clone -b ros2 https://github.com/MoffKalast/vizanti.git
cd vizanti
docker build -f docker/Dockerfile -t vizanti:2.0 . --build-arg ROS_VERSION=$ROS_DISTRO
```

## Run
```bash
ros2 launch vizanti_server vizanti_server.launch.py
```  
Or with Docker (set env vars directly if they need to be different):
```bash
docker run --rm -it --net=host --name vizanti-ros2 -e ROS_DOMAIN_ID=$ROS_DOMAIN_ID -e RMW_IMPLEMENTATION=$RMW_IMPLEMENTATION -e USE_RWS=false -v /dev/shm:/dev/shm vizanti:2.0
```  

The web app can be accessed at `http://<host_ip>:5000`. Client settings are automatically saved in localStorage. The satelite imagery renderer also uses the indexedDB to store tiles for offline use (note that this is IP specific). By default the rosbridge instance also occupies port 5001.

If you're using a mobile device connected to a robot's hotspot that doesn't have internet access and can't load the page, turn off mobile data. This will prevent the browser from sending packets to the wrong gateway.

####  Check [the wiki](https://github.com/MoffKalast/vizanti/wiki) for usage and configuration instructions, as well as feature and compatibility info.

## Recommended - RWS Backend

With rosbridge being a Tornado python based package and rclpy being overly CPU heavy, this cpp drop-in replacement server should result in a ~5x lower overhead and faster response times. It works with CycloneDDS out of the box, and for FastDDS it requires the `rmw_fastrtps_dynamic_cpp` version which includes interface introspection.

```bash
cd ~/colcon_ws/src
git clone -b $ROS_DISTRO https://github.com/v-kiniv/rws.git

cd ..
rosdep install -i --from-path src/rws -y 
colcon build
```

If using FastDDS:

```bash
sudo apt install ros-$ROS_DISTRO-rmw-fastrtps-dynamic-cpp
export RMW_IMPLEMENTATION=rmw_fastrtps_dynamic_cpp
```

Then run the RWS launch instead:

```bash
ros2 launch vizanti_server vizanti_rws.launch.py
```

Or with Docker (set env vars directly if they need to be different):
```bash
docker run --rm -it --net=host --name vizanti-ros2 -e ROS_DOMAIN_ID=$ROS_DOMAIN_ID -e RMW_IMPLEMENTATION=$RMW_IMPLEMENTATION -e USE_RWS=true -v /dev/shm:/dev/shm vizanti:2.0
```

----

## Contributing

Please see [Contributing.md](Contributing.md) for more information.



================================================
FILE: Contributing.md
================================================
# Contributing to Vizanti

Got an idea on how to improve Vizanti?

Contrbutions are of course welcome, feel free to fork and submit PRs for any fixes or extra widgets you find useful.

## Overview

Vizanti is split into the python based ROS-side server and the web browser client.

### Server

The static content is served using Flask, with Jinja2 as the template engine. ROS related communications go through Rosbridge and Rosapi.

[server.py](vizanti_server/vizanti_server/server.py)

There are also two ROS nodes that provide additional functionality not covered by Rosbridge.

[service_handler.py](vizanti_server/vizanti_server/service_handler.py)

[tf_consolidator.cpp](vizanti_cpp/src/tf_consolidator.cpp)

### Client

The front end is written in vanilla JS with ES6 modules, while making use of Jinja templating and minimal fixed dependencies in [vizanti_server/public/js/lib](vizanti_server/public/js/lib).

---

## Adding a new widget

Upon client load, the server collects all widget templates in [vizanti_server/public/templates](vizanti_server/public/templates) and sends them to the client where they are processed by [main.js](vizanti_server/public/js/main.js). As per the existing examples, the suported files are:

- `name_icon.html` The mandatory icon element that will be added to the taskbar.

- `name_modal.html` A popup window element that is used to select the topic and change any settings.

- `name_view.html` A canvas layer for drawing visualizers. Define the Z-order value so that your element is rendered in the right order. Canvases of the same type of widget will be rendered in the order they were added.

- `name_script.js` A JS module that can import helper singletons from [vizanti_server/public/js/modules](vizanti_server/public/js/modules).

To add the widget to the taskbar, it has to be defined in the `add_types_container` list in the [add_modal.html](vizanti_server/public/templates/add/add_modal.html). The `data-topic` value is used for creating widgets from a specific topic.

Any required assets should be put into [vizanti_server/public/assets](vizanti_server/public/assets). Any SVG icons that need to display a colour change using utilModule.setIconColor need to have specific elements tagged as id="fillColor" or id="strokeColor" depending on which part needs coloring.

### {uniqueID}

Every widget should have the string "{uniqueID}" embedded in its code, which will be replaced with a unique sequential identifier (e.g. "auto53") at widget instantiation, so all of those scattered elements above can have direct references to each other and a unique tag for saving settings.

As an example:
```javascript
//battery_icon.html
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/battery_unknown.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 
```
Which can then be obtained from the script as follows:

```javascript
//battery_script.html
const icon = document.getElementById("{uniqueID}_icon");
icon.src = "something.png"
```


-----

## Helper Singletons

Quaternion.js and Roslib.js are loaded globally. There are also two global functions to streamline opening and closing models, the aptly named `openModal(widget_id+"_modal")` and `closeModal(widget_id+"_modal")` found in [setup.js](vizanti_server/public/js/setup.js). Typically called when an icon is clicked.

### View

```javascript
let viewModule = await import(`${base_url}/js/modules/view.js`);
let view = viewModule.view;
```
Handles how the screen is moved and zoomed by the user for final rendering from ROS tf space into screen space. The TF and screen frames are currently not rotated, which simplifies rendering.

Example:

```javascript
const img_width = view.getMapUnitsInPixels(width_meters);
const img_height = view.getMapUnitsInPixels(length_meters);

let pos = view.fixedToScreen({
    x: object.translation.x,
    y: object.translation.y,
});

ctx.translate(pos.x, pos.y);
ctx.drawImage(img, -img_width/2, -img_height/2, img_width, img_height);
```

It fires off events when the screen is updated as a rendering callback.

```javascript
window.addEventListener("view_changed", drawWidget);
```   
-----


### TF Transforms

```javascript
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let tf = tfModule.tf;
```
An implementation of the TF graph that gets grouped TF data at 30 fps from the`/vizanti/tf_consolidated` topic.

Example:

```javascript
//global rendering frame, as selected in global options
tf.fixed_frame

//absoluteTransforms provides all known frames transformed to the global fixed frame for quick rendering
const absolute_frame = tf.absoluteTransforms["base_link"];
absolute_frame.translation // Vector3
absolute_frame.rotation // Quaternion

//getting the radians yaw for top down rendering
let yaw = absolute_frame.rotation.toEuler().h;

//transforms provides the relative parent-child transforms as given by TF
const relative_frame = tf.transforms["base_link"];
relative_frame.parent //"odom", most likely
```

Like the view, it fires off events when the screen is updated as a rendering callback.
```javascript
window.addEventListener("tf_changed", drawWidget);
```

-----

### Rosbridge

```javascript
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let rosbridge = rosbridgeModule.rosbridge;
```
Wrapper for roslib.js, used for communicating with ROS.

Example:

```javascript
//all running nodes
let nodes = await rosbridge.get_all_nodes();

//all topics
let topics = await rosbridge.get_all_topics();

//all topics of specified type
let specific_topics = await rosbridge.get_topics("sensor_msgs/NavSatFix");

//built in function to get the topic name passed by the widget creator
let topic = getTopic("{uniqueID}");

roslib_topic = new ROSLIB.Topic({
    ros : rosbridge.ros,
    name : topic,
    messageType : 'sensor_msgs/LaserScan',
    throttle_rate: 30, //minium ms between messages, alleviates congestion but does not guarantee that all messages will be received
    compression: "cbor" //compression for higher throughput topics
});

listener = roslib_topic.subscribe((msg) => {	
    console.log(msg.data)
});
```

-----
### Settings

```javascript
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let settings = persistentModule.settings;
```

Provides a localStorage object for saving widget settings.


Example:
```javascript
//if there's saved data, we fetch it upon module load
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	something = loaded_data.something;
	checkbox.checked = loaded_data.checkbox;
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		something: input.value,
		checkbox: checkbox.checked
	}
	settings.save();
}

//on input change
saveSettings();
```

-----
### Util

```javascript
let utilModule = await import(`${base_url}/js/modules/util.js`);
let imageToDataURL = utilModule.imageToDataURL;
```   
The util class provides utility functions, the only one right now being imageToDataURL for persistent image loading that doesn't trigger new server requests upon changing an Image .src param.

```javascript
const persistent_image = await imageToDataURL("assets/image.svg");
```   
-----
### Status

```javascript
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let Status = StatusModule.Status;
```   
A helper class that emulates the status indicator from rviz for each widget.

First, add this element to the widget's modal, the current convention is directly below the title text.
```html
<p id="{uniqueID}_status" class="status">Status: Ok.</p>

```

Then instantiate the class and pass it the icon and status elements:

```javascript
//by default the status is "Ok" as defined in the html
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

//show an errpr
status.setError("Empty topic.");

//show a warning
status.setWarn("No data received.");

//everything should be working fine
status.setOK();
```   

-----
### Joysticks

```javascript
let joystickModule = await import(`${base_url}/js/modules/joystick.js`);
let nipplejs = joystickModule.nipplejs;
```   

Joystick.js is a module wrapper for nipple.js. Example usage in [teleop:script.js](vizanti_server/public/templates/teleop/teleop_script.js)

-----
### Satelite Tiles

```javascript
let navsatModule = await import(`${base_url}/js/modules/navsat.js`);
let navsat = navsatModule.navsat;
```   
A module for downloading, storing, and loading slippy map tiles, mainly for use in [satelite_script.js](vizanti_server/public/templates/satelite/satelite_script.js).

Example:
```javascript
const tileURL = "https://tile.openstreetmap.org/19/123/254.png"

let tileImage = navsat.live_cache[tileURL];

//could be a placeholder if we're still loading, or not downloaded yet, in which case fetch it
if(!tileImage || !tileImage.complete){
    tileImage = placeholder;
    navsat.enqueue(tileURL);
}

//lattitude and longitude to coordinate tile indices
let tile_coords = navsat.coordToTile(longitude, latitude, zoomLevel)

//and the reverse, gets the bottom left corner of the tile
let tile_fix = navsat.tileToCoord(x, y, zoomLevel);

//distance between two points on a sphere
let distance_meters = navsat.haversine(latitude_a, longitude_a, latitude_b, longitude_b);
```   

More general info:

https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames

https://github.com/nobleo/rviz_satellite

-----

    


================================================
FILE: LICENSE
================================================
BSD 3-Clause License

Copyright (c) 2023, Vid Rijavec

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: docker/Dockerfile
================================================
ARG ROS_VERSION=jazzy

FROM osrf/ros:${ROS_VERSION}-desktop

SHELL ["/bin/bash", "-c"]

# Username
ENV user=vizanti

# Update and build the vizanti package
RUN apt-get update

# Need openssh-client for git to work properly, can be removed when rosbridge has binaries properly updated.
RUN apt-get install openssh-client -y
RUN apt-get install ros-$ROS_DISTRO-rmw-fastrtps-dynamic-cpp -y
RUN apt-get install ros-$ROS_DISTRO-rmw-cyclonedds-cpp -y

# Only add our user if does not exist.
RUN id -u $user &>/dev/null || useradd -ms /bin/bash $user
RUN chown $user: /home
RUN usermod -o -u 1000 -g 1000 $user

USER $user
RUN mkdir -p /home/$user/colcon_ws/src
COPY . /home/$user/colcon_ws/src/vizanti/.

# Note: There are breaking changes in the rosbridge suite for ROS versions. We need to switch based on version.
RUN if [ "${ROS_DISTRO}" == "humble" ] ; then \
      cd /home/$user/colcon_ws/src/ \
      && git clone -b humble https://github.com/RobotWebTools/rosbridge_suite.git ; \
    else \
      cd /home/$user/colcon_ws/src/ \
      && git clone -b ros2 https://github.com/RobotWebTools/rosbridge_suite.git ; \
    fi

# Install the RWS implementation alternative to ROSbridge.
RUN cd /home/$user/colcon_ws/src/ \
    && git clone -b $ROS_DISTRO https://github.com/v-kiniv/rws.git ;

RUN rosdep update

USER root
RUN apt-get update
RUN cd /home/$user/colcon_ws && rosdep install -i --from-path src -y ;
USER $user

RUN source /opt/ros/${ROS_DISTRO}/setup.bash && cd /home/$user/colcon_ws && colcon build

# Launch the Vizanti with RWS or ROSBridge
CMD source /home/$user/colcon_ws/install/setup.bash \
    && \
    if [ "${USE_RWS}" == "true" ] ; then \
      ros2 launch vizanti_server vizanti_rws.launch.py ; \
    else \
      ros2 launch vizanti_server vizanti_server.launch.py ; \
    fi


================================================
FILE: vizanti/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.20)
project(vizanti NONE)
find_package(ament_cmake_core REQUIRED)
ament_package()


================================================
FILE: vizanti/package.xml
================================================
<package format="3">
    <name>vizanti</name>
    <version>0.1.0</version>
    <description>Web mission planner and visualizer for controlling outdoor ROS robots.</description>
    <maintainer email="vid.rijavec@gmail.com">MoffKalast</maintainer>
    <maintainer email="albradford2468@gmail.com">Alastair Bradford</maintainer>
    <license>BSD</license>
    <author email="vid.rijavec@gmail.com">MoffKalast</author>
    <url type="bugtracker">https://github.com/MoffKalast/vizanti/issues</url>
    <url type="repository">https://github.com/MoffKalast/vizanti/tree/ros2</url>

    <buildtool_depend>ament_cmake_core</buildtool_depend>

    <exec_depend>vizanti_msgs</exec_depend>
    <exec_depend>vizanti_server</exec_depend>

    <export>
        <build_type>ament_cmake</build_type>
    </export>

</package>


================================================
FILE: vizanti_cpp/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.10)
project(vizanti_cpp)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(tf2_msgs REQUIRED)

add_executable(tf_consolidator src/tf_consolidator.cpp)
ament_target_dependencies(tf_consolidator rclcpp std_msgs tf2_msgs)

install(TARGETS
  tf_consolidator
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()



================================================
FILE: vizanti_cpp/package.xml
================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>vizanti_cpp</name>
  <version>0.0.1</version>
  <description>An ament built package for any cpp nodes.</description>
  <maintainer email="vid.rijavec@gmail.com">MoffKalast</maintainer>
  <license>BSD</license>
  <url type="bugtracker">https://github.com/MoffKalast/vizanti/issues</url>
  <url type="repository">https://github.com/MoffKalast/vizanti/tree/ros2</url>

  <depend>rclcpp</depend>
  <depend>std_msgs</depend>
  <depend>tf2_msgs</depend>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: vizanti_cpp/src/tf_consolidator.cpp
================================================
#include <chrono>
#include <functional>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"
#include "tf2_msgs/msg/tf_message.hpp"

class TfConsolidator:public rclcpp::Node{
	public:

		bool updated;
		std::map<std::string, geometry_msgs::msg::TransformStamped> transforms;
		std::map<std::string, rclcpp::Time> transform_timeout;

		rclcpp::Subscription<tf2_msgs::msg::TFMessage>::SharedPtr tf_sub;
		rclcpp::Publisher<tf2_msgs::msg::TFMessage>::SharedPtr tf_pub;
		rclcpp::TimerBase::SharedPtr clear_timer;
		rclcpp::TimerBase::SharedPtr publish_timer;

		//subscribes to all /tf frames published separately by different nodes and consolidates them into one throttled message
		TfConsolidator():Node("vizanti_tf_consolidator"),  updated(false){
			tf_sub = create_subscription<tf2_msgs::msg::TFMessage>("/tf", rclcpp::QoS(20), std::bind(&TfConsolidator::tf_callback, this, std::placeholders::_1));
			tf_pub = create_publisher<tf2_msgs::msg::TFMessage>(
				"/vizanti/tf_consolidated",
				rclcpp::QoS(10)
					.durability(RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL) //latched in case there's no tf activity so that the web client can set itself up
					.lifespan(rclcpp::Duration(0, 66000000))  // 66ms
			);
			clear_timer = create_wall_timer(std::chrono::seconds(5), std::bind(&TfConsolidator::clear_old_tfs, this));
			publish_timer = create_wall_timer(std::chrono::milliseconds(33), std::bind(&TfConsolidator::publish, this));

			RCLCPP_INFO(get_logger(), "TF handler ready.");
		}

		//removes any non-static frames that haven't been published for 10-15 seconds
		void clear_old_tfs(){
			auto current_time = rclcpp::Clock().now();
			for (auto it = transforms.begin(); it != transforms.end(); /* no increment */) {
				const auto key = it->first;
				if (current_time.seconds() - transform_timeout[key].seconds() > 10.0){
					const auto parent = it->second.header.frame_id;

					std::string parent_str(parent.begin(), parent.end());
            		std::string key_str(key.begin(), key.end());

					it = transforms.erase(it);
					transform_timeout.erase(key);
					updated = true;
					RCLCPP_WARN(get_logger(), "Removed old TF link: %s -> %s", parent_str.c_str(), key_str.c_str());
        	} else {
					++it;
				}
			}
		}

		//send all frames at ~30 hz, so websocket throttling can skip packets if congested
		void publish(){
			if (!updated){
				return;
			}

			auto msg = tf2_msgs::msg::TFMessage();
			for (const auto &entry : transforms){
				msg.transforms.push_back(entry.second);
			}
			updated = false;
			tf_pub->publish(msg);
		}

		//adds extra timestamps for tracking staleness regardless of ros time skips, since old bags might shift time and presist otherwise
		void tf_callback(const tf2_msgs::msg::TFMessage::SharedPtr msg){
			for (const auto &transform : msg->transforms){
				transforms[transform.child_frame_id] = transform;
				transform_timeout[transform.child_frame_id] = rclcpp::Clock().now();
			}
			updated = true;
		}
};

int main(int argc, char *argv[])
{
	rclcpp::init(argc, argv);
	rclcpp::spin(std::make_shared<TfConsolidator>());
	rclcpp::shutdown();
	return 0;
}



================================================
FILE: vizanti_demos/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.20)
project(vizanti_demos)

if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 17)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(ament_cmake_python REQUIRED)

find_package(rclcpp REQUIRED)
find_package(rclpy REQUIRED)

find_package(std_msgs REQUIRED)
find_package(std_srvs REQUIRED)
find_package(tf2_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(vizanti_msgs REQUIRED)
find_package(nav_msgs REQUIRED)
find_package(visualization_msgs REQUIRED)

install(DIRECTORY
  launch
  assets
  DESTINATION share/${PROJECT_NAME}/
)

install(PROGRAMS
  scripts/particle_cloud_to_pose_array.py
  scripts/path_to_nav2poses.py
  scripts/test_occupancy_grid.py
  scripts/test_grid_cells.py
  scripts/test_marker_array.py
  scripts/test_tf.py
  scripts/test_button.py
  scripts/waypoints_to_simple_goals.py
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()



================================================
FILE: vizanti_demos/package.xml
================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>vizanti_demos</name>
  <version>0.0.2</version>
  <description>Demonstration package for Vizanti</description>
  <maintainer email="vid.rijavec@gmail.com">MoffKalast</maintainer>
  <maintainer email="albradford2468@gmail.com">Alastair Bradford</maintainer>
  <license>BSD</license>
  <author email="vid.rijavec@gmail.com">MoffKalast</author>
  <url type="bugtracker">https://github.com/MoffKalast/vizanti/issues</url>
  <url type="repository">https://github.com/MoffKalast/vizanti/tree/ros2</url>

  <depend>rclpy</depend>
  <depend>rclcpp</depend>
  <depend>std_msgs</depend>
  <depend>std_srvs</depend>
  <depend>tf2_msgs</depend>
  <depend>python3-scipy</depend>
  <depend>geometry_msgs</depend>
  <depend>vizanti_msgs</depend>
  <depend>nav_msgs</depend>
  <depend>visualization_msgs</depend>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>ament_cmake_python</buildtool_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>



================================================
FILE: vizanti_demos/launch/test.launch.py
================================================
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    test_grid_cells = Node(
        package='vizanti_demos',
        executable='test_grid_cells.py',
        name='test_grid_cells',
        output='screen',
        emulate_tty=True
    )

    test_marker_array = Node(
        package='vizanti_demos',
        executable='test_marker_array.py',
        name='test_marker_array',
        output='screen',
        emulate_tty=True
    )

    #Test transforms
    static_tf_publisher_node_1 = Node(
        package='tf2_ros',
        executable='static_transform_publisher',
        name='test_tf_publisher_1',
        arguments=['10', '0', '0', '0', '0', '0', 'map', 'test_link'],
        output='screen'
    )

    static_tf_publisher_node_2 = Node(
        package='tf2_ros',
        executable='static_transform_publisher',
        name='test_tf_publisher_2',
        arguments=['0', '10', '0', '0', '0', '0', 'test_link', 'test_child_link'],
        output='screen'
    )

    ld = LaunchDescription()
    ld.add_action(test_grid_cells)
    ld.add_action(test_marker_array)
    ld.add_action(static_tf_publisher_node_1)
    ld.add_action(static_tf_publisher_node_2)
    return ld


================================================
FILE: vizanti_demos/resource/vizanti_demos
================================================
[Empty file]


================================================
FILE: vizanti_demos/scripts/__init__.py
================================================
[Empty file]


================================================
FILE: vizanti_demos/scripts/particle_cloud_to_pose_array.py
================================================
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav2_msgs.msg import ParticleCloud
from geometry_msgs.msg import PoseArray, Pose
from rclpy.qos import QoSProfile, QoSDurabilityPolicy

import random

class ParticleCloudToPoseArrayNode(Node):

    def __init__(self):
        super().__init__('particle_cloud_to_pose_array')
        
        qos_profile = QoSProfile(
            depth=1,
            reliability=0
        )
        
        self.subscription = self.create_subscription(
            ParticleCloud,
            '/particle_cloud',
            self.particle_cloud_callback,
            qos_profile
        )
        
        self.publisher = self.create_publisher(
            PoseArray,
            '/poses',
            qos_profile
        )

    def particle_cloud_callback(self, msg):
        selected_indices = random.sample(msg.particles, 20)
        
        pose_array = PoseArray()
        pose_array.header = msg.header
        
        for particle in selected_indices:
            pose = Pose()
            pose = particle.pose
            pose_array.poses.append(pose)
        
        self.publisher.publish(pose_array)

def main(args=None):
    rclpy.init(args=args)
    node = ParticleCloudToPoseArrayNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass

    node.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()


================================================
FILE: vizanti_demos/scripts/path_to_nav2poses.py
================================================
#!/usr/bin/env python3

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node

from nav_msgs.msg import Path
from nav2_msgs.action import NavigateThroughPoses

class PathToNavigateThroughPosesNode(Node):

    def __init__(self):
        super().__init__('path_to_navigate_through_poses')
        self.subscription = self.create_subscription(
            Path,
            '/navigate_through_path',
            self.path_callback,
            10
        )
        
        self.action_client = ActionClient(self, NavigateThroughPoses, '/navigate_through_poses')
        while not self.action_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().info('Waiting for /navigate_through_poses action server...')
            
    def path_callback(self, msg):
        self.get_logger().info('Received a path with %d poses' % len(msg.poses))

        goal_msg = NavigateThroughPoses.Goal()
        goal_msg.poses = msg.poses
        
        self.send_goal(goal_msg)

    def send_goal(self, goal):
        if not self.action_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().warn('/navigate_through_poses action server not available!')
            return
        
        future = self.action_client.send_goal_async(goal)
        future.add_done_callback(self.goal_response_callback)
        
    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('NavigateThroughPoses goal rejected :(')
            return

        self.get_logger().info('NavigateThroughPoses goal accepted :)')
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.goal_result_callback)
        
    def goal_result_callback(self, future):
        result = future.result().result
        self.get_logger().info('Finished NavigateThroughPoses with result: %s' % result)


def main(args=None):
    rclpy.init(args=args)

    node = PathToNavigateThroughPosesNode()

    rclpy.spin(node)

    node.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()


================================================
FILE: vizanti_demos/scripts/test_button.py
================================================
#!/usr/bin/env python

import rclpy
from rclpy.node import Node
from std_srvs.srv import Empty as EmptySrv, Trigger, SetBool
from std_msgs.msg import Bool, Empty as EmptyMsg
from rclpy.qos import QoSProfile, QoSDurabilityPolicy


class TestServiceNode(Node):
    def __init__(self):
        super().__init__('test_button_service_node')

        # For visualization
        self.empty_state = False
        self.trigger_state = False
        self.setbool_state = False
        self.empty_topic_state = False

        qos_profile = QoSProfile(depth=1)
        qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL  # Ensures latched-like behavior

        self.emptysrv_pub = self.create_publisher(Bool, '/empty_srv_triggered', qos_profile)
        self.emptymsg_pub = self.create_publisher(Bool, '/empty_msg_triggered', qos_profile)
        self.trigger_pub = self.create_publisher(Bool, '/trigger_triggered', qos_profile)
        self.setbool_pub = self.create_publisher(Bool, '/setbool_triggered', qos_profile)

        self.emptysrv_pub.publish(Bool(data=self.empty_state))
        self.emptymsg_pub.publish(Bool(data=self.empty_state))
        self.trigger_pub.publish(Bool(data=self.trigger_state))
        self.setbool_pub.publish(Bool(data=self.setbool_state))

        self.create_service(EmptySrv, '/test_emptysrv', self.handle_empty)
        self.create_service(Trigger, '/test_trigger', self.handle_trigger)
        self.create_service(SetBool, '/test_setbool', self.handle_setbool)

        self.create_subscription(EmptyMsg, '/test_emptymsg', self.handle_empty_topic, 10)

        self.get_logger().info('Test service node ready.')

    def handle_empty(self, request, response):
        self.empty_state = not self.empty_state
        self.emptysrv_pub.publish(Bool(data=self.empty_state))
        self.get_logger().info(f'Empty service triggered, state: {self.empty_state}')
        return response

    def handle_trigger(self, request, response):
        self.trigger_state = not self.trigger_state
        self.trigger_pub.publish(Bool(data=self.trigger_state))
        self.get_logger().info(f'Trigger service triggered, state: {self.trigger_state}')
        response.success = True
        response.message = 'Trigger service called'
        return response

    def handle_setbool(self, request, response):
        self.setbool_state = request.data
        self.setbool_pub.publish(Bool(data=self.setbool_state))
        self.get_logger().info(f'SetBool service triggered, state: {self.setbool_state}')
        response.success = True
        response.message = 'SetBool service called'
        return response

    def handle_empty_topic(self, msg):
        self.empty_topic_state = not self.empty_topic_state
        self.emptymsg_pub.publish(Bool(data=self.empty_topic_state))
        self.get_logger().info(f'Empty topic message received, state: {self.empty_topic_state}')



def main(args=None):
    rclpy.init(args=args)
    node = TestServiceNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()



================================================
FILE: vizanti_demos/scripts/test_grid_cells.py
================================================
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from nav_msgs.msg import GridCells
from geometry_msgs.msg import Point
import random
import time

class RandomGridCellsPublisher(Node):
    def __init__(self):
        super().__init__('test_grid_cells')
        self.publisher_ = self.create_publisher(GridCells, 'test_grid_cells', 10)
        self.timer = self.create_timer(1.0, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        if self.i % 10 == 0:
            # Generate a random resolution between 0.1 and 1.0
            resolution_x = random.uniform(0.1, 3)+0.01
            resolution_y = random.uniform(0.1, 3)+0.01

            # Generate a random number of cells
            num_cells = random.randint(1, 500)

            # Generate random cells
            cells = GridCells()
            cells.header.stamp = self.get_clock().now().to_msg()
            cells.header.frame_id = 'world'
            cells.cell_width = resolution_x
            cells.cell_height = resolution_y

            for _ in range(num_cells):
                point = Point()
                point.x = resolution_x * random.randint(-80, 80)
                point.y = resolution_y * random.randint(-80, 80)
                point.z = 0.0
                cells.cells.append(point)
            
            self.publisher_.publish(cells)
        elif self.i % 10 == 9:
            # Publish an empty GridCells message
            empty_cells = GridCells()
            empty_cells.header.stamp = self.get_clock().now().to_msg()
            empty_cells.header.frame_id = 'world'
            empty_cells.cell_width = 1.0
            empty_cells.cell_height = 1.0
            self.publisher_.publish(empty_cells)

        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    random_grid_cells_publisher = RandomGridCellsPublisher()
    rclpy.spin(random_grid_cells_publisher)
    random_grid_cells_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()


================================================
FILE: vizanti_demos/scripts/test_marker_array.py
================================================
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSDurabilityPolicy
from visualization_msgs.msg import Marker, MarkerArray
import random

class MarkerArrayPublisher(Node):
    def __init__(self):
        super().__init__('test_marker_array')

        latch = QoSProfile(depth=1, durability=QoSDurabilityPolicy.TRANSIENT_LOCAL)

        self.marker_array_publisher = self.create_publisher(MarkerArray, 'test_marker_array', latch)

        marker_array = MarkerArray()

        # Define particle types and their variations
        particle_types = [Marker.ARROW, Marker.CUBE, Marker.CYLINDER, Marker.SPHERE, Marker.TEXT_VIEW_FACING]
        rotations = [(0.0, 0.0, 0.0, 1.0), (0.0, 0.0, 0.707, 0.707), (0.0, 0.0, 0.383, 0.924)]
        num_variations = 5

        for i, particle_type in enumerate(particle_types):
            for j in range(num_variations):
                marker = Marker()
                marker.header.frame_id = 'world'
                marker.id = i * num_variations + j
                marker.type = particle_type
                marker.action = Marker.ADD
                marker.pose.position.x = i * 2.0  # Separation on the X axis
                marker.pose.position.y = j * 2.0  # Separation on the Y axis
                marker.pose.position.z = 0.0
                marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w = rotations[random.randint(0,len(rotations)-1)]
                marker.scale.x, marker.scale.y, marker.scale.z = self.randomScale()
                marker.color.r, marker.color.g, marker.color.b, marker.color.a = self.randomColour()
                marker.lifetime.sec = 6000
                marker.text = "TEST"
                marker_array.markers.append(marker)

        self.marker_array_publisher.publish(marker_array)

    def randomScale(self):
        return (random.uniform(0.2,1.5), random.uniform(0.2,1.5), random.uniform(0.2,1.5))

    def randomColour(self):
        return (random.random(), random.random(), random.random(), random.uniform(0.3,1.0))


def main(args=None):
    rclpy.init(args=args)
    marker_array_publisher = MarkerArrayPublisher()
    rclpy.spin(marker_array_publisher)

if __name__ == "__main__":
    main()


================================================
FILE: vizanti_demos/scripts/test_occupancy_grid.py
================================================
#!/usr/bin/env python3

import os
import rclpy
import cv2
import numpy as np

from rclpy.node import Node
from nav_msgs.msg import OccupancyGrid
from std_msgs.msg import Header
from geometry_msgs.msg import Pose
from rclpy.qos import QoSProfile, QoSDurabilityPolicy

from ament_index_python.packages import get_package_share_directory

class ImageToOccupancyGrid(Node):
    def __init__(self):
        super().__init__('test_occupancy_grid')

        # Declare and get parameters
        self.declare_parameter('image_path', 'assets/test_heightmap.png')
        self.declare_parameter('frame_id', 'world')
        self.declare_parameter('topic_name', '/heightmap')
        self.declare_parameter('scale', 0.1)

        image_path = self.get_parameter('image_path').get_parameter_value().string_value
        frame_id = self.get_parameter('frame_id').get_parameter_value().string_value
        topic_name = self.get_parameter('topic_name').get_parameter_value().string_value
        scale = self.get_parameter('scale').get_parameter_value().double_value

        self.get_logger().info("Loading image...")

        absolute_path = os.path.join(get_package_share_directory('vizanti_demos'), image_path)

        print(absolute_path)
        image = cv2.imread(absolute_path, cv2.IMREAD_GRAYSCALE)

        # Flatten the image and convert to occupancy grid data
        data = []
        for pixel in image.flatten():
            data.append(pixel)

        # Create OccupancyGrid message
        grid = OccupancyGrid()
        grid.header = Header()
        grid.header.stamp = self.get_clock().now().to_msg()
        grid.header.frame_id = frame_id
        grid.info.resolution = float(scale)
        grid.info.width = image.shape[1]
        grid.info.height = image.shape[0]
        grid.info.origin = Pose()
        grid.info.origin.position.x = 0.0
        grid.info.origin.position.y = 0.0
        grid.info.origin.position.z = 0.0
        grid.info.origin.orientation.w = 1.0
        grid.data = np.array(data, dtype=np.int8).tolist()

        qos_profile = QoSProfile(depth=1)
        qos_profile.durability = QoSDurabilityPolicy.TRANSIENT_LOCAL

        # Publish the grid
        self.publisher = self.create_publisher(OccupancyGrid, topic_name, qos_profile)
        self.publisher.publish(grid)

        self.get_logger().info("Published image!")


def main(args=None):
    rclpy.init(args=args)
    node = ImageToOccupancyGrid()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("Shutting down node.")
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()


================================================
FILE: vizanti_demos/scripts/test_tf.py
================================================
#!/usr/bin/env python3
import rclpy
import tf2_ros
import geometry_msgs.msg
import nav_msgs.msg
import math
import numpy as np

from rclpy.duration import Duration
from rclpy.node import Node
from scipy.spatial.transform import Rotation as R

class Particle:
    def __init__(self, i, position, velocity, node):
        self.position = np.array(position)
        self.velocity = np.array(velocity)

        self.path_publisher = node.create_publisher(nav_msgs.msg.Path, "spaceship_path_"+str(i), 10)
        self.path = nav_msgs.msg.Path()
        self.path.header.frame_id = "world"
        self.path_max_length = 200
        self.path_timer = node.get_clock().now()

class OrbitingFramesNode(Node):

    def __init__(self):
        super().__init__('test_tf')

        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)
        
        self.timer_period = 1/30  # seconds
        self.G = 1.0  # Gravitational constant for simplicity
        self.mass = 1.0  # Mass of the central attractor at the origin
        self.num_frames = 10  # Number of orbiting frames

        # Initialize particles with starting positions and velocities
        self.particles = []
        for i in range(self.num_frames):
            radius = 2.0 + i * 0.5
            speed = np.sqrt(self.G * self.mass / radius)
            
            # Randomize the initial angle and plane of orbit
            theta = np.random.uniform(0, 2 * np.pi)
            phi = np.random.uniform(0, np.pi)

            position = radius * np.array([math.sin(phi) * math.cos(theta), math.sin(phi) * math.sin(theta), math.cos(phi)])
            
            # Randomize orbit direction
            orbit_direction = np.random.choice([-1, 1])
            velocity = orbit_direction * speed * np.cross(position, np.array([0, 0, 1]))
            velocity = velocity / np.linalg.norm(velocity) * speed

            self.particles.append(Particle(i, position, velocity, self))

        self.timer = self.create_timer(self.timer_period, self.publish_transforms)

    def publish_transforms(self):
        dt = self.timer_period

        for i, particle in enumerate(self.particles):
            # Calculate gravitational force towards origin
            r = np.linalg.norm(particle.position)
            force_magnitude = self.G * self.mass / (r ** 2)
            force_direction = -particle.position / r
            force = force_magnitude * force_direction

            # Update velocity and position
            particle.velocity += force * dt
            particle.position += particle.velocity * dt

            # Calculate orientation: X axis should point towards velocity vector
            x_axis = particle.velocity / np.linalg.norm(particle.velocity)
            z_axis = np.cross(x_axis, [0, 1, 0])
            if np.linalg.norm(z_axis) < 1e-6:  # Handle the special case where velocity is aligned with Y axis
                z_axis = np.cross(x_axis, [0, 0, 1])
            z_axis /= np.linalg.norm(z_axis)
            y_axis = np.cross(z_axis, x_axis)
            
            rotation_matrix = np.vstack([x_axis, y_axis, z_axis]).T
            rotation_quat = R.from_matrix(rotation_matrix).as_quat()

            # Create transform message
            transform = geometry_msgs.msg.TransformStamped()
            transform.header.stamp = self.get_clock().now().to_msg()
            transform.header.frame_id = "world"
            transform.child_frame_id = f"spaceship_{i}"
            transform.transform.translation.x = particle.position[0]
            transform.transform.translation.y = particle.position[1]
            transform.transform.translation.z = particle.position[2]
            transform.transform.rotation.x = rotation_quat[0]
            transform.transform.rotation.y = rotation_quat[1]
            transform.transform.rotation.z = rotation_quat[2]
            transform.transform.rotation.w = rotation_quat[3]

            # Broadcast the transform
            self.tf_broadcaster.sendTransform(transform)

            # Track the path of the first particle
            if self.get_clock().now() - particle.path_timer > Duration(seconds=0.1):
                particle.path_timer = self.get_clock().now()
                pose = geometry_msgs.msg.PoseStamped()
                pose.header = transform.header
                pose.pose.position.x = particle.position[0]
                pose.pose.position.y = particle.position[1]
                pose.pose.position.z = particle.position[2]
                pose.pose.orientation.x = rotation_quat[0]
                pose.pose.orientation.y = rotation_quat[1]
                pose.pose.orientation.z = rotation_quat[2]
                pose.pose.orientation.w = rotation_quat[3]
                
                particle.path.poses.append(pose)
                
                if len(particle.path.poses) > particle.path_max_length:
                    particle.path.poses.pop(0)
                
                particle.path.header.stamp = self.get_clock().now().to_msg()
                particle.path_publisher.publish(particle.path)

def main(args=None):
    rclpy.init(args=args)
    node = OrbitingFramesNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()


================================================
FILE: vizanti_demos/scripts/waypoints_to_simple_goals.py
================================================
#!/usr/bin/env python3

import math
import rclpy
import tf2_ros

from rclpy.node import Node
from rclpy.qos import QoSProfile
from rcl_interfaces.msg import SetParametersResult

from geometry_msgs.msg import PoseArray, PoseStamped, Pose
from std_msgs.msg import Bool, Empty
from tf2_ros import TransformListener, Buffer

"""
Since navigate_through_poses is still a bit unreliable,
this node serves is a demo example of sending simple goals sequentially,
checking for range completion in between.
Goal timeouts and handling other edge cases is left as an excercise to the reader.
"""

class WaypointsToSimpleGoals(Node):
    def __init__(self):
        super().__init__('waypoints_to_simple_goals')

        self.declare_parameter('rate', 10)
        self.declare_parameter('robot_link', 'base_link')
        self.declare_parameter('goal_reached_range', 0.3)

        self.rate = self.get_parameter('rate').get_parameter_value().integer_value
        self.robot_link = self.get_parameter('robot_link').get_parameter_value().string_value
        self.goal_reached_range = self.get_parameter('goal_reached_range').get_parameter_value().double_value

        self.waypoints = []
        self.current_goal = None
        self.waypoints_header = None
        self.last_robot_pose = None

        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)

        self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)
        self.state_pub = self.create_publisher(Bool, '/waypoints/state', 10)
        
        self.create_subscription(PoseArray, '/waypoints', self.waypoints_callback, 10)
        self.create_subscription(Empty, '/waypoints/estop', self.estop_callback, 10)

        self.add_on_set_parameters_callback(self.parameters_callback)

        self.publish_navigation_state(False)
        self.get_logger().info("Waypoints node started.")

        self.timer = self.create_timer(1.0 / self.rate, self.update)

    def parameters_callback(self, params):

        for param in params:
            if param.name == "robot_link":
                self.robot_link = param.value
            elif param.name == "goal_reached_range":
                self.goal_reached_range = param.value

        return SetParametersResult(successful=True)

    def waypoints_callback(self, msg):
        poses = list(msg.poses)
        
        if not poses:
            self.estop_callback(None)
            return

        self.waypoints = poses
        self.waypoints_header = msg.header
        self.current_goal = None
        self.get_logger().info("New path received!")

    def estop_callback(self, _):
        if self.current_goal and self.last_robot_pose and self.waypoints_header:
            goal = PoseStamped()
            goal.header = self.waypoints_header
            goal.pose = self.last_robot_pose
            self.goal_pub.publish(goal)

        self.waypoints = []
        self.current_goal = None
        self.publish_navigation_state(False)

        self.get_logger().info("Emergency stop triggered!")

    def update(self):
        if not self.waypoints:
            if self.current_goal is not None:
                self.current_goal = None
                self.publish_navigation_state(False)
            return

        if self.current_goal is None and self.waypoints:
            next_pose = self.waypoints[0]

            goal = PoseStamped()
            goal.header = self.waypoints_header
            goal.pose = next_pose
            self.goal_pub.publish(goal)

            self.current_goal = goal
            self.publish_navigation_state(True)
            self.get_logger().info(f"Published: ({next_pose.position.x},{next_pose.position.y},{next_pose.position.z}), {len(self.waypoints)} goals left.")

        if self.current_goal and self.check_goal_reached(self.current_goal):
            self.waypoints.pop(0)
            self.current_goal = None

            if not self.waypoints:
                self.get_logger().info("Path finished!")

    def check_goal_reached(self, goal):
        try:
            transform = self.tf_buffer.lookup_transform(
                goal.header.frame_id,
                self.robot_link,
                rclpy.time.Time()
            )

            pos = transform.transform.translation

            self.last_robot_pose = Pose()
            self.last_robot_pose.position.x = pos.x
            self.last_robot_pose.position.y = pos.y
            self.last_robot_pose.position.z = pos.y
            self.last_robot_pose.orientation = transform.transform.rotation

            dx = pos.x - goal.pose.position.x
            dy = pos.y - goal.pose.position.y
            distance = math.sqrt(dx * dx + dy * dy)

            return distance <= self.goal_reached_range
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            return False

    def publish_navigation_state(self, state):
        self.state_pub.publish(Bool(data=state))

    def cleanup(self):
        self.waypoints = []
        self.current_goal = None
        self.publish_navigation_state(False)


def main(args=None):
    rclpy.init(args=args)
    node = WaypointsToSimpleGoals()
    rclpy.spin(node)
    node.cleanup()
    node.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()


================================================
FILE: vizanti_msgs/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.20)
project(vizanti_msgs)
set(CMAKE_CXX_STANDARD 17)

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(std_msgs REQUIRED)
find_package(nav_msgs REQUIRED)

# List of service files
set(srv_files
    "srv/GetNodeParameters.srv"
    "srv/SetNodeParameter.srv"
    "srv/SaveMap.srv"
    "srv/LoadMap.srv"
    "srv/RecordRosbag.srv"
    "srv/ManageNode.srv"
    "srv/ListPackages.srv"
    "srv/ListExecutables.srv"
    "srv/ListLifecycles.srv"
)

# Generate messages / actions /  services
rosidl_generate_interfaces(${PROJECT_NAME}
  ${srv_files}
  DEPENDENCIES std_msgs nav_msgs geometry_msgs
)

ament_export_dependencies(rosidl_default_runtime)

ament_package()



================================================
FILE: vizanti_msgs/package.xml
================================================
<package format="3">
    <name>vizanti_msgs</name>
    <version>0.1.0</version>
    <description>Interfaces for Vizanti.</description>
    <maintainer email="vid.rijavec@gmail.com">MoffKalast</maintainer>
    <maintainer email="albradford2468@gmail.com">Alastair Bradford</maintainer>
    <license>BSD</license>
    <author email="vid.rijavec@gmail.com">MoffKalast</author>
    <url type="bugtracker">https://github.com/MoffKalast/vizanti/issues</url>
    <url type="repository">https://github.com/MoffKalast/vizanti/tree/ros2</url>

    <depend>std_srvs</depend>
    <depend>std_msgs</depend>
    <depend>nav_msgs</depend>
    <depend>geometry_msgs</depend>

    <buildtool_depend>ament_cmake</buildtool_depend>
    <buildtool_depend>rosidl_default_generators</buildtool_depend>

    <exec_depend>rosidl_default_runtime</exec_depend>
    <member_of_group>rosidl_interface_packages</member_of_group>

    <export>
        <build_type>ament_cmake</build_type>
    </export>
</package>



================================================
FILE: vizanti_msgs/resource/vizanti_msgs
================================================
[Empty file]


================================================
FILE: vizanti_msgs/srv/GetNodeParameters.srv
================================================
string node
---
string parameters


================================================
FILE: vizanti_msgs/srv/ListExecutables.srv
================================================
string package
---
string[] executables 



================================================
FILE: vizanti_msgs/srv/ListLifecycles.srv
================================================
---
string[] nodes
int8[] states


================================================
FILE: vizanti_msgs/srv/ListPackages.srv
================================================
---
string[] packages 



================================================
FILE: vizanti_msgs/srv/LoadMap.srv
================================================
string file_path
string topic
---
bool success
string message


================================================
FILE: vizanti_msgs/srv/ManageNode.srv
================================================
string node
---
bool success
string message


================================================
FILE: vizanti_msgs/srv/RecordRosbag.srv
================================================
string[] topics
bool start
string path
---
bool success
string message 



================================================
FILE: vizanti_msgs/srv/SaveMap.srv
================================================
string file_path
string topic
---
bool success
string message


================================================
FILE: vizanti_msgs/srv/SetNodeParameter.srv
================================================
string node
string param
string value
---
string status


================================================
FILE: vizanti_server/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.20)
project(vizanti_server)

if(NOT CMAKE_CXX_STANDARD)
  set(CMAKE_CXX_STANDARD 17)
endif()

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(ament_cmake_python REQUIRED)

find_package(rclcpp REQUIRED)
find_package(rclpy REQUIRED)

find_package(std_msgs REQUIRED)
find_package(std_srvs REQUIRED)
find_package(tf2_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(vizanti_msgs REQUIRED)
find_package(rosbridge_suite REQUIRED)

install(DIRECTORY
  launch
  public
  DESTINATION share/${PROJECT_NAME}/
)

install(PROGRAMS
  scripts/__init__.py
  scripts/server.py
  scripts/service_handler.py
  scripts/rqt_reconfigure_param_api.py
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()



================================================
FILE: vizanti_server/package.xml
================================================
<package format="3">
    <name>vizanti_server</name>
    <version>0.1.1</version>
    <description>A mission planner and visualizer for controlling outdoor ROS robots.</description>
    <maintainer email="vid.rijavec@gmail.com">MoffKalast</maintainer>
    <maintainer email="albradford2468@gmail.com">Alastair Bradford</maintainer>
    <license>BSD</license>
    <author email="vid.rijavec@gmail.com">MoffKalast</author>
    <url type="bugtracker">https://github.com/MoffKalast/vizanti/issues</url>
    <url type="repository">https://github.com/MoffKalast/vizanti/tree/ros2</url>

    <depend>rclpy</depend>
    <depend>rclcpp</depend>
    <depend>ros2pkg</depend>
    <depend>std_srvs</depend>
    <depend>tf2_msgs</depend>
    <depend>rcl_interfaces</depend>
    <depend>geometry_msgs</depend>
    <depend>std_msgs</depend>
    <depend>vizanti_msgs</depend>
    <depend>python3-flask</depend>
    <depend>python3-waitress</depend>
    <depend>rosbridge_suite</depend>

    <buildtool_depend>ament_cmake</buildtool_depend>
    <buildtool_depend>ament_cmake_python</buildtool_depend>

    <exec_depend>ros2launch</exec_depend>

    <export>
    <build_type>ament_cmake</build_type>
    </export>
</package>



================================================
FILE: vizanti_server/launch/vizanti_rws.launch.py
================================================
import launch
import launch_ros.actions

def generate_launch_description():
    base_url = launch.substitutions.LaunchConfiguration('base_url', default='') #e.g. /vizanti
    port = launch.substitutions.LaunchConfiguration('port', default=5000)
    port_rosbridge = launch.substitutions.LaunchConfiguration('port_rosbridge', default=5001)
    flask_debug = launch.substitutions.LaunchConfiguration('flask_debug', default=True)
    default_widget_config = launch.substitutions.LaunchConfiguration('default_widget_config', default='') #e.g. ~/your_custom_config.json

    #https://github.com/v-kiniv/rws
    rws_server_node = launch_ros.actions.Node(
        package='rws',
        executable='rws_server',
        name='vizanti_rws_server',
        output='screen',
        parameters=[
            {'rosbridge_compatible ': True},
            {'port': port_rosbridge},
            {'watchdog': True}
        ]
    )

    flask_node = launch_ros.actions.Node(
        name='vizanti_flask_node',
        package='vizanti_server',
        executable='server.py',
        output='screen',
        parameters=[
            {'host': '0.0.0.0'},
            {'port': port},
            {'port_rosbridge': port_rosbridge},
            {'flask_debug': flask_debug},
            {'base_url': base_url},
            {'compression': "cbor"},
            {'default_widget_config': default_widget_config}
        ]
    )

    tf_handler_node = launch_ros.actions.Node(
        name='vizanti_tf_handler_node',
        package='vizanti_cpp',
        executable='tf_consolidator',
        output='screen'
    )

    service_handler_node = launch_ros.actions.Node(
        name='vizanti_service_handler_node',
        package='vizanti_server',
        executable='service_handler.py',
        output='screen'
    )

    return launch.LaunchDescription([
        rws_server_node,
        flask_node,
        tf_handler_node,
        service_handler_node
    ])

if __name__ == '__main__':
    launch.main()



================================================
FILE: vizanti_server/launch/vizanti_server.launch.py
================================================
import launch
import launch_ros.actions

def generate_launch_description():

    #general params
    base_url = launch.substitutions.LaunchConfiguration('base_url', default='') #e.g. /vizanti
    port = launch.substitutions.LaunchConfiguration('port', default=5000)
    port_rosbridge = launch.substitutions.LaunchConfiguration('port_rosbridge', default=5001)
    flask_debug = launch.substitutions.LaunchConfiguration('flask_debug', default=True)
    default_widget_config = launch.substitutions.LaunchConfiguration('default_widget_config', default='') #e.g. ~/your_custom_config.json

    #rosbridge internal params
    unregister_timeout = launch.substitutions.LaunchConfiguration('unregister_timeout', default='9999999.9')
    retry_startup_delay = launch.substitutions.LaunchConfiguration('retry_startup_delay', default='10.0')
    fragment_timeout = launch.substitutions.LaunchConfiguration('fragment_timeout', default='30')
    delay_between_messages = launch.substitutions.LaunchConfiguration('delay_between_messages', default='0')
    max_message_size = launch.substitutions.LaunchConfiguration('max_message_size', default='999999999')

    rosbridge_node = launch_ros.actions.Node(
        name='vizanti_rosbridge',
        package='rosbridge_server',
        executable='rosbridge_websocket',
        output='screen',
        parameters=[
            {'authenticate': False},
            {'port': port_rosbridge},
            {'address': ''},
            {'retry_startup_delay': retry_startup_delay},
            {'fragment_timeout': fragment_timeout},
            {'delay_between_messages': delay_between_messages},
            {'max_message_size': max_message_size},
            {'unregister_timeout': unregister_timeout},
            {'use_compression': True}
        ]
    )

    rosapi_node = launch_ros.actions.Node(
        name='rosapi',
        package='rosapi',
        executable='rosapi_node'
    )

    flask_node = launch_ros.actions.Node(
        name='vizanti_flask_node',
        package='vizanti_server',
        executable='server.py',
        output='screen',
        parameters=[
            {'host': '0.0.0.0'},
            {'port': port},
            {'port_rosbridge': port_rosbridge},
            {'flask_debug': flask_debug},
            {'base_url': base_url},
            {'compression': "none"},
            {'default_widget_config': default_widget_config}
        ]
    )

    tf_handler_node = launch_ros.actions.Node(
        name='vizanti_tf_handler_node',
        package='vizanti_cpp',
        executable='tf_consolidator',
        output='screen'
    )

    service_handler_node = launch_ros.actions.Node(
        name='vizanti_service_handler_node',
        package='vizanti_server',
        executable='service_handler.py',
        output='screen'
    )

    return launch.LaunchDescription([
        rosbridge_node,
        rosapi_node,
        flask_node,
        tf_handler_node,
        service_handler_node
    ])

if __name__ == '__main__':
    launch.main()



================================================
FILE: vizanti_server/public/head.html
================================================
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, viewport-fit=cover, user-scalable=no, shrink-to-fit=no">
	<meta name="HandheldFriendly" content="true">

	<meta name="theme-color" content="#666666">
	<meta name="msapplication-TileColor" content="#666666">
	<meta name="msapplication-navbutton-color" content="#666666">
	<meta name="apple-mobile-web-app-status-bar-style" content="#666666">

	<title>Vizanti</title>

	<link rel="apple-touch-icon-precomposed" type="image/png" href="assets/icon/152.png" sizes="152x152">
	<link rel="icon" type="image/png" href="assets/icon/96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="assets/icon/32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="assets/icon/16.png" sizes="16x16">

	<link rel="stylesheet" type="text/css" href="css/style.css" />
	<link rel="manifest" href="assets/icon/manifest.json">
</head>


================================================
FILE: vizanti_server/public/iconbar.html
================================================
<div id="icon_bar">

	<div id="icon_container" onmousedown="iconContainerScrollHandler(event)">
		<!-- Icon templates get rendered in here  -->
	</div>

	<div id="icon_bar_handle" ontouchstart="iconBarHandler(event)" onmousedown="iconBarHandler(event)"></div>
	
</div>

<script>

	//drag scrolling with a mouse
	function iconContainerScrollHandler(event) {
		event.preventDefault();

		const container = document.getElementById('icon_container');
		container.setAttribute("mouse_start", event.clientX)
		container.setAttribute("scroll_start", document.getElementById('icon_bar').scrollLeft)

		document.addEventListener('mousemove', iconContainerMouseMove);
		document.addEventListener('mouseup', iconContainerMouseUp);
	}

	function iconContainerMouseMove(event) {
		const container = document.getElementById('icon_container');
		const scroll_start = parseFloat(container.getAttribute("scroll_start"));
		const mouse_start = parseFloat(container.getAttribute("mouse_start"));
		document.getElementById('icon_bar').scrollLeft = scroll_start + (mouse_start - event.clientX);
	}

	function iconContainerMouseUp() {
		document.removeEventListener('mousemove', iconContainerMouseMove);
		document.removeEventListener('mouseup', iconContainerMouseUp);
	}

	//dra expanding the icon bar downwards
	function iconBarHandler(event) {
		event.preventDefault();

		document.addEventListener('mousemove', iconBarMouseMove);
		document.addEventListener('touchmove', iconBarMouseMove);

		document.addEventListener('mouseup', iconBarMouseUp);
		document.addEventListener('touchend', iconBarMouseUp);
	}

	function calculateWidth() {
		const iconBar = document.getElementById('icon_bar');
		const iconContainer = document.getElementById('icon_container');
		const iconBarHandle = document.getElementById('icon_bar_handle');

		if(iconBar.style.height == ""){
			iconBar.style.height = "75px";
			iconContainer.style.height = "75px";
		}

		const numRows = Math.ceil(parseInt(iconBar.style.height) / 60)-1;
		const totalIcons = iconContainer.children.length;
		let requiredWidth = Math.ceil(totalIcons / numRows) * 60 + 10; // icon width;

		if (requiredWidth < window.innerWidth)
			requiredWidth = window.innerWidth;

		iconContainer.style.width = requiredWidth + 'px';
		iconBarHandle.style.width = requiredWidth + 'px';

		window.dispatchEvent(new Event("iconbar_height_change"));		
	}

	function iconBarMouseMove(event) {
		const iconBar = document.getElementById('icon_bar');
		const iconContainer = document.getElementById('icon_container');
		let newpos = event.touches && event.touches[0] ? event.touches[0].clientY : event.clientY;
		newpos = parseInt(newpos / 60) * 60;

		if (newpos < 60) newpos = 60;
		else if (newpos > 360) newpos = 360;

		iconBar.style.height = (newpos + 15) + 'px';
		iconContainer.style.height = iconBar.style.height;

		calculateWidth();
	}

	function iconBarMouseUp() {
		document.removeEventListener('mousemove', iconBarMouseMove);
		document.removeEventListener('touchmove', iconBarMouseMove);

		document.removeEventListener('mouseup', iconBarMouseUp);
		document.removeEventListener('touchend', iconBarMouseUp);
	}

	window.addEventListener('icons_changed', calculateWidth);
	window.addEventListener('resize', calculateWidth);

	//allow scrolling without holding down shift
	document.getElementById('icon_bar').addEventListener("wheel", function (e) {
		document.getElementById('icon_bar').scrollLeft += e.deltaY*0.5;
	});

</script>



================================================
FILE: vizanti_server/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">

{% include "head.html" %}

<body class="noselect">

	{% include "iconbar.html" %}

	<div id="view_container" class="noselect">
		<!-- View templates get rendered in here -->
	</div>

	<div id="modal_container" class="noselect">
		<!-- Modals templates get rendered in here -->
	</div>

	<script>
		const base_url = "{{ base_url }}";
	</script>

	<div id="script_container">

	</div>

	<!-- global libraries -->
	<script src="{{ url_for('serve_static', path='js/lib/quaternion.min.js') }}"></script>
	
	<!-- modules -->
	<script type="module" src="{{ url_for('serve_static', path='js/modules/rosbridge.js') }}"></script>
	<script type="module" src="{{ url_for('serve_static', path='js/modules/persistent.js') }}"></script>
	<script type="module" src="{{ url_for('serve_static', path='js/modules/elements.js') }}"></script>
	<script type="module" src="{{ url_for('serve_static', path='js/modules/view.js') }}"></script>
	<script type="module" src="{{ url_for('serve_static', path='js/modules/tf.js') }}"></script>

	<!-- app -->
	<script src="{{ url_for('serve_static', path='js/setup.js') }}"></script>
	<script type="module" src="{{ url_for('serve_static', path='js/main.js') }}"></script>


</body>
</html>


================================================
FILE: vizanti_server/public/assets/default_layout.json
================================================
{
  "navbar": [
    {
      "type": "settings",
      "id": "settings_default"
    },
    {
      "type": "rosbridge",
      "id": "rosbridge_default"
    },
    {
      "type": "grid",
      "id": "grid_default"
    },
    {
      "type": "tf",
      "id": "tf_default"
    }
  ],
  "view": {
    "center": {
      "x": 0,
      "y": 0
    },
    "scale": 50
  }
}



================================================
FILE: vizanti_server/public/assets/icon/manifest.json
================================================
{
    "name": "Vizanti",
    "short_name": "Vizanti",
    "description": "A web-based visualization and control tool for outdoor robots running ROS.",
    "start_url": "/",
    "display": "fullscreen",
    "background_color": "#111111",
    "theme_color": "#111111",
    "orientation": "any",
    "icons": [
      {
        "src": "192.png",
        "sizes": "192x192",
        "type": "image/png"
      },
      {
        "src": "512.png",
        "sizes": "512x512",
        "type": "image/png"
      }
    ]
  }


================================================
FILE: vizanti_server/public/css/style.css
================================================
@font-face {
    font-family: 'Ubuntu Mono';
    src: url('./font/ubuntu.mono.woff2') format('woff2'),
         url('./font/ubuntu.mono.woff') format('woff'),
         url('./font/ubuntu.mono.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}

html, body {
	min-height: 100%;
	margin: 0;
	height: 100%;

	color: white;
	background-color: #273444;

	font-family: 'Ubuntu Mono', Monospace;

	font-size: 1.0rem;
	text-rendering: optimizeLegibility;

	overflow: hidden;
	overscroll-behavior:none;
	touch-action: none; /* Safari zooming chaos prevention */
}

i {
	color: rgb(174, 174, 174);
}

h1, h2, h3, b, p {
	overflow-x: auto;
	scrollbar-color: #4242426a #99999978;
	scrollbar-width: thin;
}

.comment {
	font-size: 15px;
	margin-top: 0.5em;
	margin-bottom: 1.5em;
	color:#b4b4b4;
}

.dark_hr{
	border: 1px solid rgba(160, 160, 160, 0.6);
}

a {
	color:rgb(0, 186, 243)
}

h3 {
	margin-bottom: 5px;
}

h4 {
	margin-top: 1.5em;
}

/* Icon bar */

object {
	pointer-events: none;
}

.icon-text {
    position: absolute;
    top: 45%;
    left: 50%;
    margin: 0;
    transform: translate(-50%, -50%);
	font-weight: bold;
    font-size: 0.8em;
	pointer-events: none;
}

.icon-text-dial {
    position: absolute;
    top: 45%;
    left: 50%;
    margin: 0;
	width: 100%;
    transform: translate(-68%, 35%);
	font-weight: bold;
    font-size: 0.7em;
	color: black; 
	text-align: right;
}

.icon-text-dial-unit {
    position: absolute;
    top: 45%;
    left: 50%;
    margin: 0;
	width: 100%;
    transform: translate(-50%, -100%);
	font-weight: bold;
    font-size: 0.5em;
	color: black; 
	text-align: center;
}

.icon-img {
    position: absolute;
    top: 65%;
    left: 50%;
    margin: 0;
    transform: translate(-50%, -50%);
	font-weight: bold;
    font-size: 0.8em;
	pointer-events: none;
	display: none;
}

.icon-stack-img {
    position: absolute;
    top: 50%;
    left: 50%;
    margin: 0;
    transform: translate(-50%, -50%);
	font-weight: bold;
    font-size: 0.8em;
	pointer-events: none;
	z-index: -1;
}

.icon {
	display: inline-block;
	position: relative;
	width: 50px;
	height: 50px;
	margin: 5px;
	border-radius: 15px;

	background-color: rgba(124, 124, 124, 0.3);

	border: none;
	box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;

	transition: linear  0.2s;
}

.icon-warn {
	background-color: rgba(185, 167, 0, 0.37); 
}

.icon-error {
	background-color: rgba(175, 0, 0, 0.397);
}

.icon:hover {
	background-color: rgba(185, 185, 185, 0.3);
	transform: scale(1.05);
}

.status {
	padding: 0;
	margin: 0;
	color: lime; 
	font-size: 11px;
}

.status-warn {
	color: rgb(255, 205, 42); 
	font-weight: bold;
}

.status-error {
	color: rgb(255, 60, 60);  
	font-weight: bold;
}

#icon_container {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
	grid-auto-flow: rows;
	height: 100%;
	justify-content: start;
	align-content: start;
	width: 200vw;
}
  
#icon_bar {
	background-color: rgba(0, 0, 0, 0.7);
	height: 70px;
	width: 100%;
	overflow: hidden;
	overflow-x: scroll;
	overflow-y: hidden;
	scrollbar-width: none;
	display: block;
	position: relative;
	transition: height 0.1s;
	z-index: 10;
	-ms-overflow-style: none;
}

#icon_bar::-webkit-scrollbar {
	display: none;
}

#icon_bar::-webkit-scrollbar-thumb {
	display: none;
}

#icon_bar::-webkit-scrollbar-track {
	display: none;
}

#icon_bar_handle {
	position: absolute;
	bottom: 0;
	left: 0;
	width: 100vw;
	height: 12px;
	cursor: grab;
}

#icon_bar_handle::before {
	content: '';
	display: block;
	position: absolute;
	background-color:#444444;
	height: 7px;
	width: 100%;
	bottom: 0;
	left: 0;
}

#icon_bar_handle:hover::before {
	background-color: #333333;
}

/* Modal windows */

#modal_container{
	height: 100%;
	width: 100%;
	position: fixed;
	left: 0;
	top: 0;
	pointer-events: none;
	z-index: 20;
}

.modal_outer{
	position: absolute;
	display: none; /*flex;*/

	align-items: flex-start;
	justify-content: center;

	left: 0;
	top: 0;

	width: 100%;
	height: 100%;
	min-height: 100%;
	
	overflow: auto;
	scrollbar-color: #424242 #999999;
	scrollbar-width: thin;

	background-color: rgba(0, 0, 0, 0.4);
	pointer-events: auto;
}

.modal_outer::-webkit-scrollbar {
	width: 6px;
}

.modal_outer::-webkit-scrollbar-thumb {
	background-color: #999999;
	border-radius: 3px;
}

.modal_outer::-webkit-scrollbar-track {
	background-color: #424242;
}

.modal_inner {
	position: relative;

	background-color: #273444;
	height: auto;

	border-style: outset;
	border-radius: 15px;
	padding: 15px;

	max-width: 95%;
	min-width: 50%;
	margin: 50px;
	pointer-events: auto;
}

.folder_modal {
	background-color: rgba(0, 0, 0, 0.6);
	border-style: solid;
	border-color:#444444;
	border-width: 6px;
	border-radius: 5px;
	min-width: 70%;
	margin-top: 70px;
}

.folder_icon_container {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
	grid-auto-flow: rows;
	height: 100%;
	justify-content: start;
	align-content: start;
}


/* Media query for non-touch devices (usually desktop) */
@media (pointer: fine) {
	.modal_inner {
		max-width: 50%;
	}
}

.altimeter_canvas {
	pointer-events: auto;
	z-index: 11; 
	border-left: 5px solid #4070bfff;
	width: 110px;
	bottom: 0;
	top: auto;
	background-image: linear-gradient(to right, rgba(0, 0, 0, 0.589) , transparent);
}

.altimeter_arrow {
	pointer-events: none;
	position: absolute;
	bottom: 50%;
	transform: translateY(-50%);
	width: 60px;
	height: 60px;
	z-index: 12; 
}
  

/*Add widget cards*/

.widget_entry {
	display: flex;
	align-items: center;
	padding-top: 5px;
	padding-bottom: 5px;
	border-radius: 10px;
	width: 100%;
}

.widget_entry:hover {
	background-color: rgba(185, 185, 185, 0.3);
}

.card_icon {
	flex: 0 0 40px;
	width: 40px;
	height: 40px;
	margin-right: 1rem; /* Add margin to the right of the icon */
}

.card {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	flex: 1; /* This will make the card take the remaining space in the container */
	min-width: 0; /* This is necessary for text-overflow to work properly in flex container */
}

.card_title {
	margin-bottom: 0.5rem;
}

.card_desc {
	width: 100%;
	margin: 0;
	font-size: 0.8rem;
	color: lightgray;
	overflow-x: auto;
	scrollbar-color: #99999978 #4242426a;
	scrollbar-width: thin;
}

.card_desc::-webkit-scrollbar {
	height: 3px;
}

.card_desc::-webkit-scrollbar-thumb {
	background-color: #99999978;
	border-radius: 2px;
}

.card_desc::-webkit-scrollbar-track {
	background-color: #4242426a;
	height: 3px;
}

.live_data_display {
    background: #12181f;
    color: #ffffff; 
    padding: 15px;
    margin: 10px 0;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    font-size: 15px;
    line-height: 1.6; 
	border-left: 3px solid gray;
	margin-bottom: 1rem;
}

.live_data_display p {
    margin-left: 5px;
    margin-top: 5px;
    margin-bottom: 5px;
}

/* Input box */

input[type=color] {
	max-width: 100%;
	min-width: 100px;
	font-size: 1.0rem;
	border-radius: 4px;
	outline: 0;
	height: 24px;
	color: white;
	background-color: #424242;
	font-family: 'Ubuntu Mono', Monospace;
}

input[type=number] {
	max-width: 100%;
	min-width: 100px;
	font-size: 1.0rem;
	border-radius: 4px;
	height: 22px;
	outline: 0;
	color: white;
	background-color: #424242;
	font-family: 'Ubuntu Mono', Monospace;
}

input[type=text] {
	width: 80%;
	font-size: 1.0rem;
	height: 22px;
	outline: 0;
	color: white;
	background-color: #424242;
	font-family: 'Ubuntu Mono', Monospace;
}

.spacer {
	display: block;
	height: 0.8rem;      /* Adjust for desired spacing */
	line-height: 1;    /* Prevent line-height inflation */
	margin: 0;         /* Remove default div margin */
	padding: 0;
}

input[type="checkbox"] {
	appearance: none;
	width: 50px;
	height: 20px;
	background-color: #3f3f3f;
	border-radius: 10px;
	position: relative;
	cursor: pointer;
	outline: none;
	vertical-align: middle;
}
  
input[type="checkbox"]:checked {
	background-color: #52b7ff;
}
  
input[type="checkbox"]:before {
	content: "";
	width: 20px;
	height: 20px;
	background-color: rgb(255, 255, 255);
	border-radius: 50%;
	position: absolute;
	left: 0;
	top: 0;
	transition: all 0.2s;
}
  
input[type="checkbox"]:checked:before {
	left: calc(100% - 20px);
}

.tf_label {
	white-space: nowrap;
	width: 100%;
	margin: 0;
	overflow-x: auto;
	scrollbar-color: #99999978 #4242426a;
	scrollbar-width: thin;
}

.tf_label::-webkit-scrollbar {
	height: 3px;
}

.tf_label::-webkit-scrollbar-thumb {
	background-color: #99999978;
	border-radius: 2px;
}

.tf_label::-webkit-scrollbar-track {
	background-color: #4242426a;
	height: 3px;
}

.tf_details {
	background: linear-gradient(to right, #1D2835, transparent);
	padding: 5px;
	border-radius: 5px;
}

.tf_summary {
	color: lightgray;
	font-style: italic;
}

input[type="range"] {
	-webkit-appearance: none;
	appearance: none;
	width: 100%;
	height: 5px;
	background-color: #bcbcbc;
	border-radius: 5px;
	outline: none;
	cursor: pointer;
	margin-bottom: 15px;
	margin-top: 15px;
}
  
input[type="range"]::-webkit-slider-thumb {
	-webkit-appearance: none;
	appearance: none;
	width: 20px;
	height: 20px;
	background-color: #ffffff;
	border-radius: 50%;
	cursor: pointer;
}
  
input[type="range"]::-moz-range-thumb {
	width: 20px;
	height: 20px;
	background-color: #ffffff;
	border-radius: 50%;
	cursor: pointer;
}

select, .datalist_input {
	max-width: 100%;
	min-width: 100px;
	font-size: 1.0rem;
	border-radius: 4px;
	outline: 0;
	height: 24px;
	color: white;
	background-color: #424242;
	font-family: 'Ubuntu Mono', Monospace;
	margin-top: 5px;
	margin-bottom: 5px;
}

/* Canvas */

canvas {
	width: 100%;
	height: 100%;
	position: absolute;
	top: 0;
	left: 0;
}

#view_container {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	overflow: hidden;
	z-index: 0;
}

.compressedimage {
	width: 25%;
	height: 25%;

	position: absolute;
	top: 0;
	left: 0;
	border: 3px solid #424242;

	transition: transform 0.2s;  
}

.compressedimage_preview {
	position: fixed;
	bottom: 15vh; 
	left: 50vw; 
	transform: translate(-50px, -50px);
}

/* Details */

details {
	background-color: rgba(0.153, 0.2, 0.26, 0.15); /* Translucent black background */
	padding: 5px; /* Add padding for better visual */
	border-radius: 7px;
	margin-bottom: 7px;
}

/* Style for summary elements */
summary {
	font-weight: bold;
	cursor: pointer; /* Change cursor to pointer on hover */
}

/* Style for content within the details element */
details > *:not(summary) {
	margin-left: 5px; /* Add a slight indent */
	margin-top: 5px; /* Add margin to separate summary from content */
}

/* Buttons */

button {
	max-width: 100%;
	font-size: 1.0rem;

	border: 3px solid #757575; 
	border-radius: 2px;
	font-family: 'Ubuntu Mono', Monospace;

	color: white;
	background-color: #484848;
	margin-bottom: 5px;
}

.export_button {
	margin-right: 10px;
}

.tablinks{
	margin-bottom: 0px;
}

.delete_button {
	border: 3px solid #784b4b; 
	background-color: #4d2626;
	float: right;
}

button:hover{
	transform: scale(1.02);
	text-decoration: none;
	cursor: pointer;
}

@keyframes buttonPressFlash {
	0% {
		border-color: #3a9cff;
		transform: scale(1.15);
		font-size: 1.17em;
		color: #4d9aff;
	}
	100% {
		border-color: transparent;
		transform: scale(1);
		font-size: 1em;
		color: white;
	}
}

.button-press-effect {
	animation: buttonPressFlash 0.25s ease-out;
}


/* Dropdown */

.dropdown-menu {
	position: fixed;
	background: rgba(0, 0, 0, 0.7);
	border-radius: 15px;
	width: 90px;
	z-index: 25;
}

.dropdown-inner {
	background: rgba(100, 100, 100, 0.5);
	border-radius: 15px;
}

.dropdown-item {
	border-radius: 15px;
	display: flex;
	align-items: center;
	padding: 8px;
	padding-top: 15px;
	padding-bottom: 15px;
	cursor: pointer;
	font-size: 14px;
	color: rgb(255, 255, 255);
	transition: background-color 0.2s;
}

.dropdown-item:hover {
	background: #706300;
}

.dropdown-icon {
	width: 16px;
	height: 16px;
	margin-right: 8px;
}

/* Misc */

.logo {
	position: fixed;
	right: 5px;
	bottom: 5px;
	width: max(min(150px, 15%), 70px);
	height: auto;
	pointer-events: none;
	z-index: 1000;
}

.noselect {
	-webkit-touch-callout:none;
	-webkit-user-select:none;
	-khtml-user-select:none;
	-moz-user-select:none;
	-ms-user-select:none;
	user-select:none;
	-webkit-tap-highlight-color:rgba(0,0,0,0);
}

.canvas {
	-webkit-touch-callout:none;
	-webkit-user-select:none;
	-khtml-user-select:none;
	-moz-user-select:none;
	-ms-user-select:none;
	user-select:none;
	-webkit-tap-highlight-color:rgba(0,0,0,0);
}

li {
	padding-bottom: 7px;
}

/* Loader */

.loader {
	display: inline-block;
	border: 7px solid #273444;
	border-radius: 50%;
	border-top: 7px solid #aeaeae;
	width: 15px;
	height: 15px;
	-webkit-animation: spin 0.6s linear infinite; /* Safari */
	animation: spin 0.6s linear infinite;
	margin: 7px;
	position: flex;
}

@-webkit-keyframes spin {
	0% { -webkit-transform: rotate(0deg); }
	100% { -webkit-transform: rotate(360deg); }
}

@keyframes spin {
	0% { transform: rotate(0deg); }
	100% { transform: rotate(360deg); }
}

/*Collapsible buttons*/

.collapsible {
	cursor: pointer;
	border: none;
	text-align: left;
	outline: none;
	font-size: 15px;
	background-color: #282828;
	padding: 10px;
	border: none;
	text-align: left;
	outline: none;
	overflow-x: auto;
	scrollbar-color: #4242426a #99999978;
	scrollbar-width: thin;
	white-space: nowrap;
	width: 100%;
}

.collapsible:hover{
	transform: scale(1.0);
}

.collapsible:after {
	content: '-';
	white-space: nowrap;
	color: #ffffff;
	font-weight: bold;
	float: right;
	margin-left: 5px;
}

.active:after {
	content: "+";
}

.content {
	padding: 0 18px;
	display: none;
	overflow: hidden;
	background-color: #2f2f2f;
	overflow-x: auto;
	scrollbar-color: #4242426a #99999978;
	scrollbar-width: thin;
	padding-top: 15px;
    margin-top: -5px;
}

/* Node manager*/

.node-box {
	background-color: #282828;
	border-left: 6px solid gray;
	border-top-right-radius: 15px;
	border-bottom-right-radius: 15px;
	border-top-left-radius: 6px;
	border-bottom-left-radius: 6px;
	white-space: nowrap;
	margin-bottom: 10px;
	padding-left: 15px;
	height: 40px;
	width:auto;
	min-width: auto;
	display: flex;
	justify-content: space-between;
	align-items: center;
	overflow-x: auto;
	overflow-y: hidden;
	scrollbar-color: #4242426a #99999978;
	scrollbar-width: thin;
}

.action-button {
	border: none;
	background: none;
	cursor: pointer;
	padding-top: 5px;
	display: inline-block
}

.action-button:hover{
	transform: scale(1.00);
	text-decoration: none;
	cursor: pointer;
}

.action-container {
	flex-wrap: nowrap;
	width: 110px; 
	min-width: 110px;
	height: 50px; 
	display: inline-block; 
}

/*Dynamic reconfigure arrow animations*/

@keyframes arrowMove {
	0% {
		transform: translateX(0);
		opacity: 1;
	}
	100% {
		transform: translateX(200px);
		opacity: 0;
	}
}

.arrow {
	position: relative;
	animation: arrowMove 0.5s linear;
	/* Adjust the following based on your design */
	display: inline-block;
	color: rgb(255, 255, 255);
	font-size: 30px;
}

/* Add Menu tabs */
.tab {
	border-style: outset;
	border-radius: 5px;
	display: flex;
    justify-content: space-around;
	overflow: hidden;
	background-color: #273B54;
	margin-bottom: 15px;
}

.tab button {
	background-color: inherit;
	flex-grow: 1;
	float: left;
	border: none;
	outline: none;
	cursor: pointer;
	padding: 7px 7px;
	transition: 0.3s;
	color: lightgray;
}

.tab button:hover {
	background-color: #39567A;
	transform: scale(1);
}

.tab button.active-tab {
	background-color: #496D99;
	font-weight: bold;
	color: white;
}

.tabcontent {
	display: none;
	padding: 6px 12px;
	border: none;
	border-top: none;
}

/* Sprite selector tabs */

.sprite-selector {
    margin: 10px 0;
}

.sprite-tab-buttons {
    border-style: outset;
    border-radius: 5px;
    display: flex;
    justify-content: space-around;
    overflow: hidden;
    background-color: #273B54;
    margin-bottom: 15px;
}

.sprite-tab-btn {
    background-color: inherit;
    flex-grow: 1;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 7px 7px;
    transition: 0.3s;
    color: lightgray;
    font-family: 'Ubuntu Mono', Monospace;
    font-size: 1.0rem;
}

.sprite-tab-btn:hover {
    background-color: #39567A;
    transform: scale(1);
}

.thumbnail-gallery {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 10px;
    max-height: 200px;
    overflow-y: auto;
    border: 3px solid #424242;
    padding: 10px;
    background-color: #2f2f2f;
    border-radius: 5px;
    scrollbar-color: #4242426a #99999978;
    scrollbar-width: thin;
}

.thumbnail-gallery::-webkit-scrollbar {
    width: 6px;
}

.thumbnail-gallery::-webkit-scrollbar-thumb {
    background-color: #99999978;
    border-radius: 3px;
}

.thumbnail-gallery::-webkit-scrollbar-track {
    background-color: #4242426a;
}

.thumbnail-item {
    text-align: center;
    cursor: pointer;
    padding: 5px;
    border: 2px solid transparent;
    border-radius: 4px;
    background-color: rgba(124, 124, 124, 0.3);
    transition: transform 0.2s, background-color 0.2s;
}

.thumbnail-item:hover {
    background-color: rgba(185, 185, 185, 0.3);
    transform: scale(1.05);
}

.thumbnail-item.selected {
    border-color: #ffffff;
    background-color: rgba(82, 183, 255, 0.2);
}

.thumbnail-item img {
    width: 64px;
    height: 64px;
    object-fit: contain;
}

.thumb-label {
    display: block;
    font-size: 10px;
    margin-top: 2px;
    color: white;
    font-family: 'Ubuntu Mono', Monospace;
}


================================================
FILE: vizanti_server/public/css/font/LICENCE.txt
================================================
-------------------------------
UBUNTU FONT LICENCE Version 1.0
-------------------------------

PREAMBLE
This licence allows the licensed fonts to be used, studied, modified and
redistributed freely. The fonts, including any derivative works, can be
bundled, embedded, and redistributed provided the terms of this licence
are met. The fonts and derivatives, however, cannot be released under
any other licence. The requirement for fonts to remain under this
licence does not require any document created using the fonts or their
derivatives to be published under this licence, as long as the primary
purpose of the document is not to be a vehicle for the distribution of
the fonts.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this licence and clearly marked as such. This may
include source files, build scripts and documentation.

"Original Version" refers to the collection of Font Software components
as received under this licence.

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to
a new environment.

"Copyright Holder(s)" refers to all individuals and companies who have a
copyright ownership of the Font Software.

"Substantially Changed" refers to Modified Versions which can be easily
identified as dissimilar to the Font Software by users of the Font
Software comparing the Original Version with the Modified Version.

To "Propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy. Propagation includes copying,
distribution (with or without modification and with or without charging
a redistribution fee), making available to the public, and in some
countries other activities as well.

PERMISSION & CONDITIONS
This licence does not grant any rights under trademark law and all such
rights are reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of the Font Software, to propagate the Font Software, subject to
the below conditions:

1) Each copy of the Font Software must contain the above copyright
notice and this licence. These can be included either as stand-alone
text files, human-readable headers or in the appropriate machine-
readable metadata fields within text or binary files as long as those
fields can be easily viewed by the user.

2) The font name complies with the following:
(a) The Original Version must retain its name, unmodified.
(b) Modified Versions which are Substantially Changed must be renamed to
avoid use of the name of the Original Version or similar names entirely.
(c) Modified Versions which are not Substantially Changed must be
renamed to both (i) retain the name of the Original Version and (ii) add
additional naming elements to distinguish the Modified Version from the
Original Version. The name of such Modified Versions must be the name of
the Original Version, with "derivative X" where X represents the name of
the new work, appended to that name.

3) The name(s) of the Copyright Holder(s) and any contributor to the
Font Software shall not be used to promote, endorse or advertise any
Modified Version, except (i) as required by this licence, (ii) to
acknowledge the contribution(s) of the Copyright Holder(s) or (iii) with
their explicit written permission.

4) The Font Software, modified or unmodified, in part or in whole, must
be distributed entirely under this licence, and must not be distributed
under any other licence. The requirement for fonts to remain under this
licence does not affect any document created using the Font Software,
except any version of the Font Software extracted from a document
created using the Font Software may only be distributed under this
licence.

TERMINATION
This licence becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF
COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER
DEALINGS IN THE FONT SOFTWARE.



================================================
FILE: vizanti_server/public/css/font/TRADEMARKS.txt
================================================
Ubuntu and Canonical are registered trademarks of Canonical Ltd.

The licence accompanying these works does not grant any rights
under trademark law and all such rights are reserved.



================================================
FILE: vizanti_server/public/js/main.js
================================================
import { settings } from './modules/persistent.js';
import { elementTemplatesPromise } from './modules/elements.js';

var uid = NaN;
var element_templates = {};

function set_unique(string, uniqueid) {
	return string.replaceAll('{uniqueID}', uniqueid);
}

function createElement(template, eid){
	let div = document.createElement("div");
	div.dataset.uniqueid = eid;
	div.innerHTML = set_unique(template, eid);
	return div;
}

function createScript(template, eid){
	let script = document.createElement("script");
	script.dataset.uniqueid = eid;
	script.type = "module";
	script.textContent = set_unique(template, eid);
	return script;
}

function initializeNav() {
	const icon_container = document.getElementById("icon_container");
	const modal_container = document.getElementById("modal_container");
	const view_container = document.getElementById("view_container");
	const script_container = document.getElementById("script_container");

	let scripts = [];
	for(let i = 0; i < settings.navbar.length; i++){
		const type = settings.navbar[i].type;
		const eid = settings.navbar[i].id;
		const container = settings.navbar[i].container_id;
		const template = element_templates[type];

		if(typeof container === 'undefined' || container == "icon_container")
			icon_container.appendChild(createElement(template.icon, eid));
		else if(typeof container !== 'undefined' && container !== "icon_container"){
			const container_element = document.getElementById(container);
			container_element.insertBefore(createElement(template.icon, eid), container_element.querySelector("[data-uniqueid='addbutton']"));
		}

		if (template.hasOwnProperty("modal"))
			modal_container.appendChild(createElement(template.modal, eid));

		if (template.hasOwnProperty("view"))
			view_container.appendChild(createElement(template.view, eid));

		if(template.hasOwnProperty("script"))
			scripts.push(createScript(template.script, eid));
	};

	const add = element_templates["add"];
	modal_container.appendChild(createElement(add.modal, "addbutton"));
	icon_container.appendChild(createElement(add.icon, "addbutton"));
	scripts.push(createScript(add.script, "addbutton"));

	scripts.forEach(element => {
		script_container.appendChild(element);
	});

	window.dispatchEvent(new Event("icons_changed"));
}

function loadAll(){
	Promise.all([elementTemplatesPromise]).then((values) => {
		element_templates = values[0];

		const modal_container = document.getElementById("modal_container");
		const view_container = document.getElementById("view_container");
		const script_container = document.getElementById("script_container");
	
		window.addEventListener("add_widget", (event) => {
			if(isNaN(uid)){
				if(isNaN(settings.uid))
					uid = 0;
				else
					uid = settings.uid;
			}

			const template = element_templates[event.widget_type];
			const eid = event.widget_type+"_autoID_" + uid++;
			settings.navbar.push({ type: event.widget_type, id: eid, container_id: event.container_target });
			settings.uid = uid;
			settings.save();
	
			const icon_element = createElement(template.icon, eid);
			icon_element.dataset.topic = event.widget_topic;

			const icon_container = document.getElementById(event.container_target);
			icon_container.insertBefore(icon_element, icon_container.querySelector("[data-uniqueid='addbutton']"));

			if (template.hasOwnProperty("modal"))
				modal_container.appendChild(createElement(template.modal, eid));

			if (template.hasOwnProperty("view"))
				view_container.appendChild(createElement(template.view, eid));
	
			if(template.hasOwnProperty("script"))
				script_container.appendChild(createScript(template.script, eid));

			window.dispatchEvent(new Event("icons_changed"));
		});
	
		window.addEventListener("remove_widget", (event) => {
			const uniqueID = event.uniqueID;
			const elementIndex = settings.navbar.findIndex((item) => item.id === uniqueID);
	
			if (elementIndex !== -1) {
				const elements = document.querySelectorAll(`[data-uniqueid="${uniqueID}"]`);
				elements.forEach((element) => {
					element.remove();
				});

				settings.navbar.splice(elementIndex, 1);
				delete settings[uniqueID];

				settings.save();
				window.dispatchEvent(new Event("icons_changed"));
			}
		});

		initializeNav();
	});	
}

if (document.readyState !== 'loading') {
    loadAll();
} else {
    document.addEventListener('DOMContentLoaded', function () {
        loadAll();
    });
}




================================================
FILE: vizanti_server/public/js/setup.js
================================================
var isMobile = false;
var isTouchscreen = false;

console.log(`\n%cHaving issues? Please log them here:https://github.com/MoffKalast/vizanti/issues`, 'color:#273444; background:lightgrey; font-size:1.0rem; padding:0.3rem 0.3rem; ont-family: Monospace; font-weight: bold;');

// mobile device detection
if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) {
    isMobile = true;
}

// touchscreen detection
document.documentElement.addEventListener('touchstart', function(e){
	isTouchscreen = true;
}, {passive: false});

// antisafari dragging?
document.documentElement.ondragstart = function () {
	return false;
};

// sizing correction
window.addEventListener("load", function(){
	setTimeout(() => {
		window.dispatchEvent(new Event('resize'));
	}, 200);
	window.dispatchEvent(new Event('resize'));
}, false); 

var widgetTarget = "icon_container";

//modal opening
function openModal(id, widgetTargetID = "icon_container"){
	document.getElementById(id).style.display = "flex";
	widgetTarget = widgetTargetID;
}

function closeModal(id){
	document.getElementById(id).style.display = "none";
}

function yieldToMainThread () {
	return new Promise(resolve => {
	  setTimeout(resolve, 0);
	});
  }

//modal closing
document.addEventListener("click", function(event){
	if(event.target.classList.contains("modal_outer")) {
		event.target.style.display = "none";
	}
}, false); 

//widget event
function addWidget(type, topic){
	let event = new Event("add_widget");
	event.widget_type = type;
	event.widget_topic = topic;
	event.container_target = widgetTarget;
	window.dispatchEvent(event);
	document.getElementById("modal_add_element").style.display = "none";
}

function removeWidget(uniqueID){
	let e = new Event("remove_widget");
	e.uniqueID = uniqueID;
	window.dispatchEvent(e);
}

function getTopic(uniqueID){
	const icon = document.getElementById(uniqueID+"_icon");
	const topic = icon.parentElement.dataset.topic;
	return topic ? topic : "";
}

// preventing the context menu popups on main views
document.getElementById("view_container").addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

document.getElementById("modal_container").addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

document.getElementById("icon_bar").addEventListener("contextmenu", (event) => {
	event.preventDefault();
});


================================================
FILE: vizanti_server/public/js/lib/nipplejs.js
================================================
!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define("nipplejs",[],i):"object"==typeof exports?exports.nipplejs=i():t.nipplejs=i()}(window,(function(){return function(t){var i={};function e(o){if(i[o])return i[o].exports;var n=i[o]={i:o,l:!1,exports:{}};return t[o].call(n.exports,n,n.exports,e),n.l=!0,n.exports}return e.m=t,e.c=i,e.d=function(t,i,o){e.o(t,i)||Object.defineProperty(t,i,{enumerable:!0,get:o})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,i){if(1&i&&(t=e(t)),8&i)return t;if(4&i&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(e.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&i&&"string"!=typeof t)for(var n in t)e.d(o,n,function(i){return t[i]}.bind(null,n));return o},e.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(i,"a",i),i},e.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},e.p="",e(e.s=0)}([function(t,i,e){"use strict";e.r(i);var o,n=function(t,i){var e=i.x-t.x,o=i.y-t.y;return Math.sqrt(e*e+o*o)},s=function(t){return t*(Math.PI/180)},r=function(t){return t*(180/Math.PI)},d=new Map,a=function(t){d.has(t)&&clearTimeout(d.get(t)),d.set(t,setTimeout(t,100))},p=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.addEventListener?t.addEventListener(o,e,!1):t.attachEvent&&t.attachEvent(o,e)},c=function(t,i,e){for(var o,n=i.split(/[ ,]+/g),s=0;s<n.length;s+=1)o=n[s],t.removeEventListener?t.removeEventListener(o,e):t.detachEvent&&t.detachEvent(o,e)},l=function(t){return t.preventDefault(),t.type.match(/^touch/)?t.changedTouches:t},h=function(){return{x:void 0!==window.pageXOffset?window.pageXOffset:(document.documentElement||document.body.parentNode||document.body).scrollLeft,y:void 0!==window.pageYOffset?window.pageYOffset:(document.documentElement||document.body.parentNode||document.body).scrollTop}},u=function(t,i){i.top||i.right||i.bottom||i.left?(t.style.top=i.top,t.style.right=i.right,t.style.bottom=i.bottom,t.style.left=i.left):(t.style.left=i.x+"px",t.style.top=i.y+"px")},f=function(t,i,e){var o=y(t);for(var n in o)if(o.hasOwnProperty(n))if("string"==typeof i)o[n]=i+" "+e;else{for(var s="",r=0,d=i.length;r<d;r+=1)s+=i[r]+" "+e+", ";o[n]=s.slice(0,-2)}return o},y=function(t){var i={};i[t]="";return["webkit","Moz","o"].forEach((function(e){i[e+t.charAt(0).toUpperCase()+t.slice(1)]=""})),i},m=function(t,i){for(var e in i)i.hasOwnProperty(e)&&(t[e]=i[e]);return t},v=function(t,i){if(t.length)for(var e=0,o=t.length;e<o;e+=1)i(t[e]);else i(t)},g=!!("ontouchstart"in window),b=!!window.PointerEvent,x=!!window.MSPointerEvent,O={start:"mousedown",move:"mousemove",end:"mouseup"},w={};function _(){}b?o={start:"pointerdown",move:"pointermove",end:"pointerup, pointercancel"}:x?o={start:"MSPointerDown",move:"MSPointerMove",end:"MSPointerUp"}:g?(o={start:"touchstart",move:"touchmove",end:"touchend, touchcancel"},w=O):o=O,_.prototype.on=function(t,i){var e,o=t.split(/[ ,]+/g);this._handlers_=this._handlers_||{};for(var n=0;n<o.length;n+=1)e=o[n],this._handlers_[e]=this._handlers_[e]||[],this._handlers_[e].push(i);return this},_.prototype.off=function(t,i){return this._handlers_=this._handlers_||{},void 0===t?this._handlers_={}:void 0===i?this._handlers_[t]=null:this._handlers_[t]&&this._handlers_[t].indexOf(i)>=0&&this._handlers_[t].splice(this._handlers_[t].indexOf(i),1),this},_.prototype.trigger=function(t,i){var e,o=this,n=t.split(/[ ,]+/g);o._handlers_=o._handlers_||{};for(var s=0;s<n.length;s+=1)e=n[s],o._handlers_[e]&&o._handlers_[e].length&&o._handlers_[e].forEach((function(t){t.call(o,{type:e,target:o},i)}))},_.prototype.config=function(t){this.options=this.defaults||{},t&&(this.options=function(t,i){var e={};for(var o in t)t.hasOwnProperty(o)&&i.hasOwnProperty(o)?e[o]=i[o]:t.hasOwnProperty(o)&&(e[o]=t[o]);return e}(this.options,t))},_.prototype.bindEvt=function(t,i){var e=this;return e._domHandlers_=e._domHandlers_||{},e._domHandlers_[i]=function(){"function"==typeof e["on"+i]?e["on"+i].apply(e,arguments):console.warn('[WARNING] : Missing "on'+i+'" handler.')},p(t,o[i],e._domHandlers_[i]),w[i]&&p(t,w[i],e._domHandlers_[i]),e},_.prototype.unbindEvt=function(t,i){return this._domHandlers_=this._domHandlers_||{},c(t,o[i],this._domHandlers_[i]),w[i]&&c(t,w[i],this._domHandlers_[i]),delete this._domHandlers_[i],this};var T=_;function k(t,i){return this.identifier=i.identifier,this.position=i.position,this.frontPosition=i.frontPosition,this.collection=t,this.defaults={size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,mode:"dynamic",zone:document.body,lockX:!1,lockY:!1,shape:"circle"},this.config(i),"dynamic"===this.options.mode&&(this.options.restOpacity=0),this.id=k.id,k.id+=1,this.buildEl().stylize(),this.instance={el:this.ui.el,on:this.on.bind(this),off:this.off.bind(this),show:this.show.bind(this),hide:this.hide.bind(this),add:this.addToDom.bind(this),remove:this.removeFromDom.bind(this),destroy:this.destroy.bind(this),setPosition:this.setPosition.bind(this),resetDirection:this.resetDirection.bind(this),computeDirection:this.computeDirection.bind(this),trigger:this.trigger.bind(this),position:this.position,frontPosition:this.frontPosition,ui:this.ui,identifier:this.identifier,id:this.id,options:this.options},this.instance}k.prototype=new T,k.constructor=k,k.id=0,k.prototype.buildEl=function(t){return this.ui={},this.options.dataOnly||(this.ui.el=document.createElement("div"),this.ui.back=document.createElement("div"),this.ui.front=document.createElement("div"),this.ui.el.className="nipple collection_"+this.collection.id,this.ui.back.className="back",this.ui.front.className="front",this.ui.el.setAttribute("id","nipple_"+this.collection.id+"_"+this.id),this.ui.el.appendChild(this.ui.back),this.ui.el.appendChild(this.ui.front)),this},k.prototype.stylize=function(){if(this.options.dataOnly)return this;var t=this.options.fadeTime+"ms",i=function(t,i){var e=y(t);for(var o in e)e.hasOwnProperty(o)&&(e[o]=i);return e}("borderRadius","50%"),e=f("transition","opacity",t),o={};return o.el={position:"absolute",opacity:this.options.restOpacity,display:"block",zIndex:999},o.back={position:"absolute",display:"block",width:this.options.size+"px",height:this.options.size+"px",marginLeft:-this.options.size/2+"px",marginTop:-this.options.size/2+"px",background:this.options.color,opacity:".5"},o.front={width:this.options.size/2+"px",height:this.options.size/2+"px",position:"absolute",display:"block",marginLeft:-this.options.size/4+"px",marginTop:-this.options.size/4+"px",background:this.options.color,opacity:".5",transform:"translate(0px, 0px)"},m(o.el,e),"circle"===this.options.shape&&m(o.back,i),m(o.front,i),this.applyStyles(o),this},k.prototype.applyStyles=function(t){for(var i in this.ui)if(this.ui.hasOwnProperty(i))for(var e in t[i])this.ui[i].style[e]=t[i][e];return this},k.prototype.addToDom=function(){return this.options.dataOnly||document.body.contains(this.ui.el)||this.options.zone.appendChild(this.ui.el),this},k.prototype.removeFromDom=function(){return this.options.dataOnly||!document.body.contains(this.ui.el)||this.options.zone.removeChild(this.ui.el),this},k.prototype.destroy=function(){clearTimeout(this.removeTimeout),clearTimeout(this.showTimeout),clearTimeout(this.restTimeout),this.trigger("destroyed",this.instance),this.removeFromDom(),this.off()},k.prototype.show=function(t){var i=this;return i.options.dataOnly||(clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.addToDom(),i.restCallback(),setTimeout((function(){i.ui.el.style.opacity=1}),0),i.showTimeout=setTimeout((function(){i.trigger("shown",i.instance),"function"==typeof t&&t.call(this)}),i.options.fadeTime)),i},k.prototype.hide=function(t){var i=this;if(i.options.dataOnly)return i;if(i.ui.el.style.opacity=i.options.restOpacity,clearTimeout(i.removeTimeout),clearTimeout(i.showTimeout),clearTimeout(i.restTimeout),i.removeTimeout=setTimeout((function(){var e="dynamic"===i.options.mode?"none":"block";i.ui.el.style.display=e,"function"==typeof t&&t.call(i),i.trigger("hidden",i.instance)}),i.options.fadeTime),i.options.restJoystick){var e=i.options.restJoystick,o={};o.x=!0===e||!1!==e.x?0:i.instance.frontPosition.x,o.y=!0===e||!1!==e.y?0:i.instance.frontPosition.y,i.setPosition(t,o)}return i},k.prototype.setPosition=function(t,i){var e=this;e.frontPosition={x:i.x,y:i.y};var o=e.options.fadeTime+"ms",n={};n.front=f("transition",["transform"],o);var s={front:{}};s.front={transform:"translate("+e.frontPosition.x+"px,"+e.frontPosition.y+"px)"},e.applyStyles(n),e.applyStyles(s),e.restTimeout=setTimeout((function(){"function"==typeof t&&t.call(e),e.restCallback()}),e.options.fadeTime)},k.prototype.restCallback=function(){var t={};t.front=f("transition","none",""),this.applyStyles(t),this.trigger("rested",this.instance)},k.prototype.resetDirection=function(){this.direction={x:!1,y:!1,angle:!1}},k.prototype.computeDirection=function(t){var i,e,o,n=t.angle.radian,s=Math.PI/4,r=Math.PI/2;if(n>s&&n<3*s&&!t.lockX?i="up":n>-s&&n<=s&&!t.lockY?i="left":n>3*-s&&n<=-s&&!t.lockX?i="down":t.lockY||(i="right"),t.lockY||(e=n>-r&&n<r?"left":"right"),t.lockX||(o=n>0?"up":"down"),t.force>this.options.threshold){var d,a={};for(d in this.direction)this.direction.hasOwnProperty(d)&&(a[d]=this.direction[d]);var p={};for(d in this.direction={x:e,y:o,angle:i},t.direction=this.direction,a)a[d]===this.direction[d]&&(p[d]=!0);if(p.x&&p.y&&p.angle)return t;p.x&&p.y||this.trigger("plain",t),p.x||this.trigger("plain:"+e,t),p.y||this.trigger("plain:"+o,t),p.angle||this.trigger("dir dir:"+i,t)}else this.resetDirection();return t};var P=k;function E(t,i){this.nipples=[],this.idles=[],this.actives=[],this.ids=[],this.pressureIntervals={},this.manager=t,this.id=E.id,E.id+=1,this.defaults={zone:document.body,multitouch:!1,maxNumberOfNipples:10,mode:"dynamic",position:{top:0,left:0},catchDistance:200,size:100,threshold:.1,color:"white",fadeTime:250,dataOnly:!1,restJoystick:!0,restOpacity:.5,lockX:!1,lockY:!1,shape:"circle",dynamicPage:!1,follow:!1},this.config(i),"static"!==this.options.mode&&"semi"!==this.options.mode||(this.options.multitouch=!1),this.options.multitouch||(this.options.maxNumberOfNipples=1);var e=getComputedStyle(this.options.zone.parentElement);return e&&"flex"===e.display&&(this.parentIsFlex=!0),this.updateBox(),this.prepareNipples(),this.bindings(),this.begin(),this.nipples}E.prototype=new T,E.constructor=E,E.id=0,E.prototype.prepareNipples=function(){var t=this.nipples;t.on=this.on.bind(this),t.off=this.off.bind(this),t.options=this.options,t.destroy=this.destroy.bind(this),t.ids=this.ids,t.id=this.id,t.processOnMove=this.processOnMove.bind(this),t.processOnEnd=this.processOnEnd.bind(this),t.get=function(i){if(void 0===i)return t[0];for(var e=0,o=t.length;e<o;e+=1)if(t[e].identifier===i)return t[e];return!1}},E.prototype.bindings=function(){this.bindEvt(this.options.zone,"start"),this.options.zone.style.touchAction="none",this.options.zone.style.msTouchAction="none"},E.prototype.begin=function(){var t=this.options;if("static"===t.mode){var i=this.createNipple(t.position,this.manager.getIdentifier());i.add(),this.idles.push(i)}},E.prototype.createNipple=function(t,i){var e=this.manager.scroll,o={},n=this.options,s=this.parentIsFlex?e.x:e.x+this.box.left,r=this.parentIsFlex?e.y:e.y+this.box.top;if(t.x&&t.y)o={x:t.x-s,y:t.y-r};else if(t.top||t.right||t.bottom||t.left){var d=document.createElement("DIV");d.style.display="hidden",d.style.top=t.top,d.style.right=t.right,d.style.bottom=t.bottom,d.style.left=t.left,d.style.position="absolute",n.zone.appendChild(d);var a=d.getBoundingClientRect();n.zone.removeChild(d),o=t,t={x:a.left+e.x,y:a.top+e.y}}var p=new P(this,{color:n.color,size:n.size,threshold:n.threshold,fadeTime:n.fadeTime,dataOnly:n.dataOnly,restJoystick:n.restJoystick,restOpacity:n.restOpacity,mode:n.mode,identifier:i,position:t,zone:n.zone,frontPosition:{x:0,y:0},shape:n.shape});return n.dataOnly||(u(p.ui.el,o),u(p.ui.front,p.frontPosition)),this.nipples.push(p),this.trigger("added "+p.identifier+":added",p),this.manager.trigger("added "+p.identifier+":added",p),this.bindNipple(p),p},E.prototype.updateBox=function(){this.box=this.options.zone.getBoundingClientRect()},E.prototype.bindNipple=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},E.prototype.pressureFn=function(t,i,e){var o=this,n=0;clearInterval(o.pressureIntervals[e]),o.pressureIntervals[e]=setInterval(function(){var e=t.force||t.pressure||t.webkitForce||0;e!==n&&(i.trigger("pressure",e),o.trigger("pressure "+i.identifier+":pressure",e),n=e)}.bind(o),100)},E.prototype.onstart=function(t){var i=this,e=i.options,o=t;t=l(t),i.updateBox();return v(t,(function(n){i.actives.length<e.maxNumberOfNipples?i.processOnStart(n):o.type.match(/^touch/)&&(Object.keys(i.manager.ids).forEach((function(e){if(Object.values(o.touches).findIndex((function(t){return t.identifier===e}))<0){var n=[t[0]];n.identifier=e,i.processOnEnd(n)}})),i.actives.length<e.maxNumberOfNipples&&i.processOnStart(n))})),i.manager.bindDocument(),!1},E.prototype.processOnStart=function(t){var i,e=this,o=e.options,s=e.manager.getIdentifier(t),r=t.force||t.pressure||t.webkitForce||0,d={x:t.pageX,y:t.pageY},a=e.getOrCreate(s,d);a.identifier!==s&&e.manager.removeIdentifier(a.identifier),a.identifier=s;var p=function(i){i.trigger("start",i),e.trigger("start "+i.id+":start",i),i.show(),r>0&&e.pressureFn(t,i,i.identifier),e.processOnMove(t)};if((i=e.idles.indexOf(a))>=0&&e.idles.splice(i,1),e.actives.push(a),e.ids.push(a.identifier),"semi"!==o.mode)p(a);else{if(!(n(d,a.position)<=o.catchDistance))return a.destroy(),void e.processOnStart(t);p(a)}return a},E.prototype.getOrCreate=function(t,i){var e,o=this.options;return/(semi|static)/.test(o.mode)?(e=this.idles[0])?(this.idles.splice(0,1),e):"semi"===o.mode?this.createNipple(i,t):(console.warn("Coudln't find the needed nipple."),!1):e=this.createNipple(i,t)},E.prototype.processOnMove=function(t){var i=this.options,e=this.manager.getIdentifier(t),o=this.nipples.get(e),d=this.manager.scroll;if(function(t){return isNaN(t.buttons)?0!==t.pressure:0!==t.buttons}(t)){if(!o)return console.error("Found zombie joystick with ID "+e),void this.manager.removeIdentifier(e);if(i.dynamicPage){var a=o.el.getBoundingClientRect();o.position={x:d.x+a.left,y:d.y+a.top}}o.identifier=e;var p=o.options.size/2,c={x:t.pageX,y:t.pageY};i.lockX&&(c.y=o.position.y),i.lockY&&(c.x=o.position.x);var l,h,u,f,y,m,v,g,b,x,O=n(c,o.position),w=(l=c,h=o.position,u=h.x-l.x,f=h.y-l.y,r(Math.atan2(f,u))),_=s(w),T=O/p,k={distance:O,position:c};if("circle"===o.options.shape?(y=Math.min(O,p),v=o.position,g=y,x={x:0,y:0},b=s(b=w),x.x=v.x-g*Math.cos(b),x.y=v.y-g*Math.sin(b),m=x):(m=function(t,i,e){return{x:Math.min(Math.max(t.x,i.x-e),i.x+e),y:Math.min(Math.max(t.y,i.y-e),i.y+e)}}(c,o.position,p),y=n(m,o.position)),i.follow){if(O>p){var P=c.x-m.x,E=c.y-m.y;o.position.x+=P,o.position.y+=E,o.el.style.top=o.position.y-(this.box.top+d.y)+"px",o.el.style.left=o.position.x-(this.box.left+d.x)+"px",O=n(c,o.position)}}else c=m,O=y;var I=c.x-o.position.x,z=c.y-o.position.y;o.frontPosition={x:I,y:z},i.dataOnly||(o.ui.front.style.transform="translate("+I+"px,"+z+"px)");var D={identifier:o.identifier,position:c,force:T,pressure:t.force||t.pressure||t.webkitForce||0,distance:O,angle:{radian:_,degree:w},vector:{x:I/p,y:-z/p},raw:k,instance:o,lockX:i.lockX,lockY:i.lockY};(D=o.computeDirection(D)).angle={radian:s(180-w),degree:180-w},o.trigger("move",D),this.trigger("move "+o.id+":move",D)}else this.processOnEnd(t)},E.prototype.processOnEnd=function(t){var i=this,e=i.options,o=i.manager.getIdentifier(t),n=i.nipples.get(o),s=i.manager.removeIdentifier(n.identifier);n&&(e.dataOnly||n.hide((function(){"dynamic"===e.mode&&(n.trigger("removed",n),i.trigger("removed "+n.id+":removed",n),i.manager.trigger("removed "+n.id+":removed",n),n.destroy())})),clearInterval(i.pressureIntervals[n.identifier]),n.resetDirection(),n.trigger("end",n),i.trigger("end "+n.id+":end",n),i.ids.indexOf(n.identifier)>=0&&i.ids.splice(i.ids.indexOf(n.identifier),1),i.actives.indexOf(n)>=0&&i.actives.splice(i.actives.indexOf(n),1),/(semi|static)/.test(e.mode)?i.idles.push(n):i.nipples.indexOf(n)>=0&&i.nipples.splice(i.nipples.indexOf(n),1),i.manager.unbindDocument(),/(semi|static)/.test(e.mode)&&(i.manager.ids[s.id]=s.identifier))},E.prototype.onDestroyed=function(t,i){this.nipples.indexOf(i)>=0&&this.nipples.splice(this.nipples.indexOf(i),1),this.actives.indexOf(i)>=0&&this.actives.splice(this.actives.indexOf(i),1),this.idles.indexOf(i)>=0&&this.idles.splice(this.idles.indexOf(i),1),this.ids.indexOf(i.identifier)>=0&&this.ids.splice(this.ids.indexOf(i.identifier),1),this.manager.removeIdentifier(i.identifier),this.manager.unbindDocument()},E.prototype.destroy=function(){for(var t in this.unbindEvt(this.options.zone,"start"),this.nipples.forEach((function(t){t.destroy()})),this.pressureIntervals)this.pressureIntervals.hasOwnProperty(t)&&clearInterval(this.pressureIntervals[t]);this.trigger("destroyed",this.nipples),this.manager.unbindDocument(),this.off()};var I=E;function z(t){var i=this;i.ids={},i.index=0,i.collections=[],i.scroll=h(),i.config(t),i.prepareCollections();var e=function(){var t;i.collections.forEach((function(e){e.forEach((function(e){t=e.el.getBoundingClientRect(),e.position={x:i.scroll.x+t.left,y:i.scroll.y+t.top}}))}))};p(window,"resize",(function(){a(e)}));var o=function(){i.scroll=h()};return p(window,"scroll",(function(){a(o)})),i.collections}z.prototype=new T,z.constructor=z,z.prototype.prepareCollections=function(){var t=this;t.collections.create=t.create.bind(t),t.collections.on=t.on.bind(t),t.collections.off=t.off.bind(t),t.collections.destroy=t.destroy.bind(t),t.collections.get=function(i){var e;return t.collections.every((function(t){return!(e=t.get(i))})),e}},z.prototype.create=function(t){return this.createCollection(t)},z.prototype.createCollection=function(t){var i=new I(this,t);return this.bindCollection(i),this.collections.push(i),i},z.prototype.bindCollection=function(t){var i,e=this,o=function(t,o){i=t.type+" "+o.id+":"+t.type,e.trigger(i,o)};t.on("destroyed",e.onDestroyed.bind(e)),t.on("shown hidden rested dir plain",o),t.on("dir:up dir:right dir:down dir:left",o),t.on("plain:up plain:right plain:down plain:left",o)},z.prototype.bindDocument=function(){this.binded||(this.bindEvt(document,"move").bindEvt(document,"end"),this.binded=!0)},z.prototype.unbindDocument=function(t){Object.keys(this.ids).length&&!0!==t||(this.unbindEvt(document,"move").unbindEvt(document,"end"),this.binded=!1)},z.prototype.getIdentifier=function(t){var i;return t?void 0===(i=void 0===t.identifier?t.pointerId:t.identifier)&&(i=this.latest||0):i=this.index,void 0===this.ids[i]&&(this.ids[i]=this.index,this.index+=1),this.latest=i,this.ids[i]},z.prototype.removeIdentifier=function(t){var i={};for(var e in this.ids)if(this.ids[e]===t){i.id=e,i.identifier=this.ids[e],delete this.ids[e];break}return i},z.prototype.onmove=function(t){return this.onAny("move",t),!1},z.prototype.onend=function(t){return this.onAny("end",t),!1},z.prototype.oncancel=function(t){return this.onAny("end",t),!1},z.prototype.onAny=function(t,i){var e,o=this,n="processOn"+t.charAt(0).toUpperCase()+t.slice(1);i=l(i);var s=function(t,i,e){e.ids.indexOf(i)>=0&&(e[n](t),t._found_=!0)};return v(i,(function(t){e=o.getIdentifier(t),v(o.collections,s.bind(null,t,e)),t._found_||o.removeIdentifier(e)})),!1},z.prototype.destroy=function(){this.unbindDocument(!0),this.ids={},this.index=0,this.collections.forEach((function(t){t.destroy()})),this.off()},z.prototype.onDestroyed=function(t,i){if(this.collections.indexOf(i)<0)return!1;this.collections.splice(this.collections.indexOf(i),1)};var D=new z;i.default={create:function(t){return D.create(t)},factory:D}}]).default}));


================================================
FILE: vizanti_server/public/js/lib/nipplejs_LICENSE.txt
================================================
The MIT License (MIT)

Copyright (c) 2014 Yoann Moinet <yoann.moinet@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.




================================================
FILE: vizanti_server/public/js/lib/numericjs_LICENSE.txt
================================================
(The MIT License)

Numeric Javascript
Copyright (C) 2011 by Sébastien Loisel
Copyright (c) 2011 Alberto Santini <albertosantini@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


================================================
FILE: vizanti_server/public/js/lib/quaternionjs_LICENSE.txt
================================================
MIT License

Copyright (c) 2017 Robert Eisele

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: vizanti_server/public/js/lib/roslibjs_LICENSE.txt
================================================
Software License Agreement (BSD License)

Copyright (c) 2014, Worcester Polytechnic Institute, Robert Bosch
LLC, Yujin Robot. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following
   disclaimer in the documentation and/or other materials provided
   with the distribution.
 * Neither the name of Worcester Polytechnic Institute, Robert
   Bosch LLC, Yujin Robot nor the names of its contributors may be
   used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: vizanti_server/public/js/modules/database.js
================================================
export class IndexedDatabase {
	constructor(storeName) {
		this.storeName = storeName;
		this.db = null;
	}

	async openDB() {
		return new Promise((resolve, reject) => {
			const request = indexedDB.open("vizantiDB", 1);

			request.onupgradeneeded = (event) => {
				const db = event.target.result;
				db.createObjectStore(this.storeName);
			};

			request.onsuccess = (event) => {
				this.db = event.target.result;
				resolve();
			};

			request.onerror = (event) => {
				reject(event.error);
			};
		});
	}

	async keyExists(key) {
		return await this._performTransaction('readonly', (store) => {
			return store.getKey(key);
		});
	}

	async setObject(key, value) {
		await this._performTransaction('readwrite', (store) => {
			store.put(value, key);
		});
	}

	async getObject(key) {
		return await this._performTransaction('readonly', (store) => {
			return store.get(key);
		});
	}

	async getAllKeys(){
		return await this._performTransaction('readonly', (store) => {
			return store.getAllKeys();
		});
	}

	async _performTransaction(mode, operation) {
		return new Promise((resolve, reject) => {
			if (!this.db) {
				reject('IndexedDB not opened');
				return;
			}

			const transaction = this.db.transaction(this.storeName, mode);
			const store = transaction.objectStore(this.storeName);

			const request = operation(store);
			if (request) {
				request.onsuccess = () => {
					resolve(request.result);
				};
			} else {
				resolve();
			}

			transaction.onerror = () => {
				reject(transaction.error);
			};
		});
	}
}


================================================
FILE: vizanti_server/public/js/modules/elements.js
================================================
import files from '../../templates/files';

async function loadElementTemplates() {
	let templates = {};

	files.forEach(file => {
		const filePathParts = file.path.split('/');
		const fileName = filePathParts[filePathParts.length - 1];
		const [category, typeWithExtension] = fileName.split('_');
		const type = typeWithExtension.split('.')[0];

		if (!templates[category]) {
			templates[category] = {};
		}

		templates[category][type] = file.content;
	});

	console.table("Loaded templates:",templates)

	return templates;
}

export const elementTemplatesPromise = loadElementTemplates();


================================================
FILE: vizanti_server/public/js/modules/joystick.js
================================================
 // Import nipplejs using the global window object
import '../lib/nipplejs.js';

// Export the library as a named export
export const nipplejs = window.nipplejs;

// Clean up the global namespace by removing the library from the window object
delete window.nipplejs;


================================================
FILE: vizanti_server/public/js/modules/navsat.js
================================================
import { IndexedDatabase } from './database.js';
import { imageToDataURL } from './util.js';

const db = new IndexedDatabase('tile_data');
await db.openDB();

async function dataToImage(data){
	return new Promise((resolve, reject) => {
		let image = new Image();
		image.onload = () => resolve(image);
		image.onerror = reject;
		image.src = data;
	})
}

export async function exportDatabase(filename) {
    const allData = [];
    
    async function dumpData() {
        const keylist = await db.getAllKeys();
        await Promise.all(keylist.map(async (url) => {
            const value = await db.getObject(url);
            allData.push({
                key: url,
                value: value
            });
        }));
    }
    
    await dumpData();
  
    const dataBlob = new Blob([JSON.stringify(allData)], {type: 'application/json'});
    
    const url = URL.createObjectURL(dataBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    
    URL.revokeObjectURL(url);
}

export async function importDatabase(file) {
	const data = JSON.parse(file);
	try {
		await Promise.all(data.map(item => db.setObject(item.key, item.value)));
		alert("Tiles imported successfully! (it might take a bit for them to save to disk and become available, be patient)");
	} catch (error) {
		console.error(error);
		alert("An error occurred during import. Please check the console for details.");
	}
}
  
export class Navsat {

	constructor (){
		this.tile_size = 256;
		this.live_cache = {};
		this.queue = new Set();
		this.queue_history = new Set();

		this.download_queue = new Set();
		this.currently_downloading = new Set();

		this.loadingloop = async ()=>{

			let items = Array.from(this.queue);
			for(let tile_url of items){
				
				//we already got it?
				if(this.live_cache[tile_url] !== undefined){
					this.queue.delete(tile_url);
					continue;
				}

				//check the indexed DB
				if(Boolean(await db.keyExists(tile_url))){
					const data = await db.getObject(tile_url);
					this.live_cache[tile_url] = await dataToImage(data);
					this.queue.delete(tile_url);
					window.dispatchEvent(new Event("navsat_tilecache_updated"));
					continue;
				}

				//hit up the CDN
				this.download_queue.add(tile_url);
			}

			setTimeout(this.loadingloop, 100);
		}
		this.loadingloop();

		this.downloadingloop = async ()=>{

			const attemptDownload = async (tile_url) => {
				//download from tile server, in case there's no internet we don't hang forever
				const timeout = new Promise(resolve => setTimeout(() => resolve(undefined), 4000));
				const data = await Promise.race([imageToDataURL(tile_url), timeout]);
			
				if (data) {
					await db.setObject(tile_url, data);
					this.live_cache[tile_url] = await dataToImage(data);
					this.download_queue.delete(tile_url);
					window.dispatchEvent(new Event("navsat_tilecache_updated"));
				}

				this.currently_downloading.delete(tile_url);
			}
			
			// Inside your loop
			let items = Array.from(this.download_queue);
			for (let tile_url of items) {
				if(tile_url && !this.currently_downloading.has(tile_url)){
					this.currently_downloading.add(tile_url);
					attemptDownload(tile_url);
				}
			}
			setTimeout(this.downloadingloop, 500);
		}
		this.downloadingloop();
	}

	async enqueue(keyurl){
		if(this.queue_history.has(keyurl))
			return;

		this.queue_history.add(keyurl);
		this.queue.add(keyurl);
	}

	async clear_queue(keyurl){
		this.queue = new Set();
		this.queue_history = new Set();
		this.download_queue = new Set();
	}

	//https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
	coordToTile(lon, lat, zoom) {
		return {
			y:(Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom))),
			x: (Math.floor((lon + 180) / 360 * Math.pow(2, zoom)))
		};
	}

	tileToCoord(x, y, z) {
		var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
		return {
			latitude:(180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)))),
			longitude: (x / Math.pow(2, z) * 360 - 180)
		};
	}

	metersToDegrees(meters, latitude, zoomLevel) {
		const earthRadius = 6378137; // Earth radius in meters
	
		// Calculate the number of meters per pixel at the given latitude and zoom level
		const metersPerPixel = (2 * Math.PI * earthRadius * Math.cos(latitude * Math.PI / 180)) / (this.tile_size * Math.pow(2, zoomLevel));
	
		// Convert the distance in meters to degrees	
		return meters / metersPerPixel;
	}

	tileSizeInMeters(latitude, zoom) {
		const earthCircumference = 40075016.686; // Earth circumference in meters
		
		// Calculate the horizontal distance per pixel in meters
		const distancePerPixel = (earthCircumference * Math.cos(latitude * Math.PI / 180)) / (Math.pow(2, zoom + 8));
	
		return this.tile_size * distancePerPixel;
	}

	tileSizeInDegrees(latitude, zoom) {
		const degreesPerPixel = 360 / Math.pow(2, zoom); // Calculate the degrees per pixel for longitude
	
		// Calculate the latitude degrees per pixel based on the latitude
		const latRadians = (latitude * Math.PI) / 180;
		const latRadiansPerPixel = Math.PI / (Math.pow(2, zoom) * this.tile_size);
		const latDegreesPerPixel = (180 / Math.PI) * (2 * Math.atan(Math.exp(latRadians + latRadiansPerPixel)) - Math.PI / 2) - latitude;
	
		return {
			latitude: this.tile_size * latDegreesPerPixel,
			longitude: this.tile_size * degreesPerPixel,
		};
	}

	haversine(lat1, lon1, lat2, lon2) {
		const toRad = (value) => (value * Math.PI) / 180;
		const R = 6378137; // Earth radius in meters
		const dLat = toRad(lat2 - lat1);
		const dLon = toRad(lon2 - lon1);
		const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return R * c;
	}	
}
export let navsat = new Navsat();


================================================
FILE: vizanti_server/public/js/modules/persistent.js
================================================
const defaultConfigModule = await import(`${base_url}/default_widget_config`);
const default_config = defaultConfigModule.default;

export function saveJsonToFile(data, filename) {
	const jsonData = JSON.stringify(data, null, 2);
	const blob = new Blob([jsonData], { type: 'application/json' });
	const url = URL.createObjectURL(blob);
  
	const a = document.createElement('a');
	a.href = url;
	a.download = filename;
	a.click();
  
	URL.revokeObjectURL(url);
}

export class Settings {

	constructor() {
		if (localStorage.hasOwnProperty("settings")) {
			this.fromJSON(localStorage.getItem("settings"));
		}else{
			this.fromJSON(default_config);
		}
	}

	fromJSON(settings_object){
		let storedSettings = JSON.parse(settings_object);
		Object.assign(this, storedSettings);
	}

	save() {
		localStorage.setItem("settings", JSON.stringify(this));
	}
}

export let settings = new Settings();


================================================
FILE: vizanti_server/public/js/modules/rosbridge.js
================================================
import '../lib/roslib.min.js';

const paramsModule = await import(`${base_url}/ros_launch_params`);
const params = paramsModule.default;

class Rosbridge {

	constructor(url) { 
		this.url = url;
		this.port = params.port_rosbridge;
		this.compression = params.compression;
		this.connected = false;

		this.connect();
		this.status = "Connecting...";

		this.reset_reconnect = false;
	}

	connect(){
		this.connected = false;

		this.ros = new ROSLIB.Ros({
			url: 'ws://' + this.url + ':' + this.port
		});

		this.ros.on('connection', () => {
			console.log('Connected to robot.');

			this.connected = true;
			this.status = "Connected.";

			if(this.reset_reconnect){
				location.reload(false); //otherwise topics won't re-subscribe automatically :/
			}

			window.dispatchEvent(new Event('rosbridge_change'));
		});

		this.ros.on('error', (error) => {
			this.connected = false;
			this.status = "Failed to connect.";
			window.dispatchEvent(new Event('rosbridge_change'));
		});

		this.ros.on('close', () => {
			this.connected = false;
			this.status = "Connection lost.";
			this.reset_reconnect = true;
			window.dispatchEvent(new Event('rosbridge_change'));

			setTimeout(() => {
				this.status = "Reconnecting...";
				this.connect();
			}, 1000);
		});

		this.topics_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/topics',
			serviceType : 'rosapi_msgs/srv/Topics',
		});

		this.nodes_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/nodes',
			serviceType : 'rosapi_msgs/srv/Nodes',
		});

		this.publishers_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/publishers',
			serviceType : 'rosapi/Publishers',
		});

		this.subscribers_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/subscribers',
			serviceType : 'rosapi/Subscribers',
		});

		this.services_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/services',
			serviceType : 'rosapi/Services',
		});
		
		this.services_for_type_client = new ROSLIB.Service({
			ros : this.ros,
			name : '/rosapi/services_for_type',
			serviceType : 'rosapi/ServicesForType',
		});

		window.dispatchEvent(new Event('rosbridge_change'));
	}

	async get_all_nodes() {
		return new Promise(async (resolve) => {
			this.nodes_client.callService(new ROSLIB.ServiceRequest({}), function (result) {
				resolve(result);
			});
		});
	}

	async get_all_topics() {
		return new Promise((resolve) => {
			this.topics_client.callService(new ROSLIB.ServiceRequest({}), (result) => {
				const combined = result.topics.map((t, i) => [t, result.types[i]]);
				combined.sort((a, b) => a[0].localeCompare(b[0]));
				result.topics = combined.map(([t]) => t);
				result.types = combined.map(([, ty]) => ty);
				resolve(result);
			});
		});
	}
	
	async get_topics(requested_type) {
		return new Promise(async (resolve) => {
			this.topics_client.callService(new ROSLIB.ServiceRequest({}), function (result) {
	
				let topics = result.topics;
				let types = result.types;
	
				let matching = [];
				for (let i = 0; i < topics.length; i++) {
					if (types[i] == requested_type) {
						matching.push(topics[i]);
					}
				}
					
				matching.sort();
				resolve(matching);
			});
		});
	}
	

	async get_services(requested_type) {
		return new Promise((resolve, reject) => {
			const request = new ROSLIB.ServiceRequest({ type: requested_type });
	
			this.services_for_type_client.callService(request, (result) => {
				resolve(result.services);
			}, (err) => {
				console.error(`Failed to fetch services for type ${requested_type}:`, err);
				resolve([]);
			});
		});
	}

	async get_topic_publishers_and_subscribers(topic) {
		const publishersRequest = new ROSLIB.ServiceRequest({ topic: topic });
		const subscribersRequest = new ROSLIB.ServiceRequest({ topic: topic });

		const publishersPromise = new Promise((resolve) => {
			this.publishers_client.callService(publishersRequest, (result) => {
				resolve(result.publishers);
			});
		});

		const subscribersPromise = new Promise((resolve) => {
			this.subscribers_client.callService(subscribersRequest, (result) => {
				resolve(result.subscribers);
			});
		});

		const [publishers, subscribers] = await Promise.all([publishersPromise, subscribersPromise]);

		return { publishers, subscribers };
	}
}

export var rosbridge = new Rosbridge(window.location.hostname);


================================================
FILE: vizanti_server/public/js/modules/status.js
================================================
export class Status {
    constructor(icon_element, message_element) {
        this.icon = icon_element;
        this.message = message_element;

        this._pendingStatus = null;
        this._pendingMessage = null;
        this._lastStatus = null;
        this._lastMessage = null;

        this._updateInterval = setInterval(() => {
            if (!this.icon == null || !this.icon.isConnected || this.message == null || !this.message.isConnected) {
                clearInterval(this._updateInterval);
                return;
            }

            if (this._pendingStatus !== this._lastStatus || this._pendingMessage !== this._lastMessage) {
                this._applyStatus(this._pendingStatus, this._pendingMessage);
                this._lastStatus = this._pendingStatus;
                this._lastMessage = this._pendingMessage;
            }
        }, 200);
    }

    _applyStatus(status, message) {
        // Reset classes
        this.icon.classList.remove("icon-error", "icon-warn");
        this.message.classList.remove("status-error", "status-warn");

        // Apply new state
        switch (status) {
            case "ok":
                this.message.innerText = "Status: " + (message || "Ok");
                break;
            case "warn":
                this.icon.classList.add("icon-warn");
                this.message.classList.add("status-warn");
                this.message.innerText = "Status: " + message;
                break;
            case "error":
                this.icon.classList.add("icon-error");
                this.message.classList.add("status-error");
                this.message.innerText = "Status: " + message;
                break;
        }
    }

    async setOK(message) {
        this._pendingStatus = "ok";
        this._pendingMessage = message;
    }

    async setWarn(message) {
        this._pendingStatus = "warn";
        this._pendingMessage = message;
    }

    async setError(message) {
        this._pendingStatus = "error";
        this._pendingMessage = message;
    }
}



================================================
FILE: vizanti_server/public/js/modules/tf.js
================================================
import { rosbridge } from './rosbridge.js';

/* class TimeStampedData {
	constructor(maxLength) {
		this.maxLength = maxLength;
		this.data = [];
		this.index = new Map();
	}

	getKey({ sec, nanosec }) {
		// Use the provided data structure to form a unique key
		// The precision should be enough for up to 1ns resolution over approximately 285 years.
		return sec * 1e9 + nanosec;
	}

	add(key, value) {
		const timestampKey = this.getKey(key);

		// If we're at maximum capacity, remove the oldest item
		if (this.data.length >= this.maxLength) {
			const oldestKey = this.getKey(this.data[0].key);
			this.index.delete(oldestKey);
			this.data.shift();
		}

		// Add the new item
		this.data.push({ key, value });
		this.index.set(timestampKey, value);
	}

	get(key) {
		const timestampKey = this.getKey(key);
		return this.index.get(timestampKey);
	}

	find(key) {
		const timestampKey = this.getKey(key);
		const keys = Array.from(this.index.keys());

		console.log("Find: ",timestampKey," in ",keys);

		// Find the key closest to the input timestamp
		const closestKey = keys.reduce((prev, curr) => {
			return (Math.abs(curr - timestampKey) < Math.abs(prev - timestampKey) ? curr : prev);
		});
		return this.index.get(closestKey);
	}
} */

export function applyRotation(vector, r, inverse){
	if(inverse)
		r = r.inverse();
		
	const v = r.rotateVector([
		vector.x,
		vector.y,
		vector.z
	]);

	return {
		x: v[0],
		y: v[1],
		z: v[2]
	}
}

export class TF {
	constructor() {
		this.fixed_frame = '';

		this.transforms = {};
		this.absoluteTransforms = {};
		//this.absoluteTransformsHistory = new TimeStampedData(20);
		this.frame_list = new Set();
		this.frame_timestamps = {};
		this.frame_headerstamps = {};

		this.tf_topic = new ROSLIB.Topic({
			ros: rosbridge.ros,
			name: '/vizanti/tf_consolidated',
			messageType: 'tf2_msgs/msg/TFMessage',
			throttle_rate: 33,
			compression: rosbridge.compression
		});

		this.tf_listener = this.tf_topic.subscribe((msg) => {
			//local timestamping for removing inactive frames
			const time_stamp = new Date();
			msg.transforms.forEach((pose) => {
				this.frame_timestamps[pose.child_frame_id] = time_stamp;
				this.frame_timestamps[pose.header.frame_id] = time_stamp;
				this.updateFrameTimestamp(pose.child_frame_id,pose.header.stamp);
			})

			this.updateTransforms(msg.transforms);
			//this.absoluteTransformsHistory.add(msg.transforms[0].header.stamp, this.absoluteTransforms);
		});

		this.tf_static_topic = new ROSLIB.Topic({
			ros: rosbridge.ros,
			name: '/tf_static',
			messageType: 'tf2_msgs/msg/TFMessage',
			latch: true,
			compression: rosbridge.compression
		});

		this.tf_static_listener = this.tf_static_topic.subscribe((msg) => {
			this.updateTransforms(msg.transforms);
		});

		this.event_timestamp = performance.now();

		window.addEventListener("view_changed", ()=> {
			this.event_timestamp = performance.now();
		});

		//removing inactive TF frames
		setInterval(()=>{
			const now = new Date()
			let deleted_anything = false;
			for (const [frame_id, time_stamp] of Object.entries(this.frame_timestamps)) {
				if(now - time_stamp > 1000 * 100){
					this.frame_list.delete(frame_id);
					delete this.transforms[frame_id];
					delete this.absoluteTransforms[frame_id];
					delete this.frame_headerstamps[frame_id];
					deleted_anything = true;
				}
			}

			if(deleted_anything){
				window.dispatchEvent(new Event("tf_changed"));
			}
		},5000)
	}

	updateFrameTimestamp(frame_id, stamp){
		this.frame_headerstamps[frame_id] = stamp;

		//update all child frames that were moved as well
		for (const frame in this.transforms) {
			if (this.transforms[frame].parent === frame_id) {
				this.frame_headerstamps[frame] = stamp; //we assume that the frame we just got is newer than what we already have
				this.updateFrameTimestamp(frame, stamp);
			}
		}
	}


	/* interpolateTransforms() {
		if (this.lastReceivedTransforms !== null && this.previousTransforms !== null && performance.now() - this.lastReceivedTime > 15) {
			const prevdelta = (this.lastReceivedTime - this.previousTime) / 1000;
			let delta = ((performance.now() - this.lastReceivedTime) / 1000) / prevdelta;

			console.log("interpolation")

			delta *= 0.005;

			const transformsMap = new Map();
			this.previousTransforms.forEach(transform => {
				transformsMap.set(transform.child_frame_id, { previous: transform });
			});
	
			this.lastReceivedTransforms.forEach(transform => {
				if (transformsMap.has(transform.child_frame_id)) {
					transformsMap.get(transform.child_frame_id).current = transform;
				}
			});
	
			const interpolatedTransforms = [];
	
			transformsMap.forEach(({ previous, current }, child_frame_id) => {
				if (current) {
					const positionDelta = {
						x: current.transform.translation.x - previous.transform.translation.x,
						y: current.transform.translation.y - previous.transform.translation.y
					};
					const velocity = {
						x: positionDelta.x * delta,
						y: positionDelta.y * delta,
					};

					const interpolatedTransform = {
						child_frame_id: child_frame_id,
						header: current.header,
						transform: {
							translation: {
								x: current.transform.translation.x + velocity.x,
								y: current.transform.translation.y + velocity.y,
								z: current.transform.translation.z
							},
							rotation: current.transform.rotation
						}
					};
					interpolatedTransforms.push(interpolatedTransform);
				}
			});
	
			this.updateTransforms(interpolatedTransforms);
		}
	} */

	async sendUpdateEvent(){
		if(performance.now() - this.event_timestamp > 12){
			window.dispatchEvent(new Event("tf_changed"));
			this.event_timestamp = performance.now();
		}
	}

	getPathToRoot(frame) {
		const currentFrame = this.transforms[frame];
		if (!currentFrame) {
			return [frame];
		}
		if (!currentFrame.parent) {
			return [frame];
		}
		return [frame].concat(this.getPathToRoot(currentFrame.parent));
	}
	
	findPath(startFrame, endFrame) {
		const p = this.getPathToRoot(startFrame);
		const q = this.getPathToRoot(endFrame);
	
		let common = null;
		while (p.length > 0 && q.length > 0 && p[p.length - 1] === q[q.length - 1]) {
			common = p.pop();
			q.pop();
		}
	
		return p.concat(common, q.reverse());
	}

	updateTransforms(newtransforms) {
		newtransforms.forEach((pose) => {

			const childFrameId = pose.child_frame_id;
			const parentFrameId = pose.header.frame_id;

			this.frame_list.add(childFrameId);
			this.frame_list.add(parentFrameId);
	
			this.transforms[childFrameId] = {
				translation: pose.transform.translation,
				rotation: new Quaternion(
					pose.transform.rotation.w,
					pose.transform.rotation.x,
					pose.transform.rotation.y,
					pose.transform.rotation.z
				),
				parent: parentFrameId
			};
		});

		this.recalculateAbsoluteTransforms();
		this.sendUpdateEvent();
	}

	setFixedFrame(newframe) {
		this.fixed_frame = newframe;
		this.recalculateAbsoluteTransforms();
		window.dispatchEvent(new Event("tf_fixed_frame_changed"));
	}

	recalculateAbsoluteTransforms() {
		for (const key of this.frame_list.values()) {
			this.absoluteTransforms[key] = this.transformPose(key, this.fixed_frame, {x: 0, y:0, z:0}, new Quaternion());
		}
	}

	getZeroFrame(){
		return {
			translation:{x: 0, y:0, z:0},
			rotation: new Quaternion()
		}
	}

	transformPose(sourceFrame, targetFrame, inputVector, inputQuat) {

		let outputVector = Object.assign({}, inputVector);
		let outputQuat = new Quaternion(inputQuat);

		if(sourceFrame == targetFrame){
			return {
				translation: outputVector,
				rotation: outputQuat
			};
		}

		const path = this.findPath(sourceFrame, targetFrame);

		for (let i = 0; i < path.length - 1; i++) {
			let source = this.transforms[path[i]];

			if(!source)
				source = this.getZeroFrame();

			if(source.parent == path[i+1]){
				outputQuat = source.rotation.mul(outputQuat);
	
				outputVector = applyRotation(outputVector, source.rotation, false);
				outputVector.x += source.translation.x;
				outputVector.y += source.translation.y;
				outputVector.z += source.translation.z;
			}else{
				source = this.transforms[path[i+1]];

				if(!source)
					source = this.getZeroFrame();

				outputQuat = source.rotation.inverse().mul(outputQuat);
	
				outputVector.x -= source.translation.x;
				outputVector.y -= source.translation.y;
				outputVector.z -= source.translation.z;
				outputVector = applyRotation(outputVector, source.rotation, true);
			}
		}
	
		return {
			translation: outputVector,
			rotation: outputQuat
		};
	}

	getTimeStampDelta(timestamp1, timestamp2) {
		return timestamp2.sec - timestamp1.sec + ((timestamp2.nanosec - timestamp1.nanosec) / 1e9);
	}
}

export let tf = new TF();



================================================
FILE: vizanti_server/public/js/modules/util.js
================================================
//webkit http compatible fetch-free implementation
export function imageToDataURL(url) {
	if(url.toLowerCase().endsWith(".svg")){
		return new Promise((resolve, reject) => {
			const object = document.createElement("object");
			object.style.position = "absolute";
  			object.style.left = "-9999px";//trick chrome to hide the elements, since it doesn't fetch if display is set to none
			object.style.visibility = "hidden";
			object.type = "image/svg+xml";
			object.data = url;
			object.onload = () => {
				const svgElement = object.contentDocument.documentElement;
				const svgCode = new XMLSerializer().serializeToString(svgElement);

				const dataURL = "data:image/svg+xml;base64," + btoa(svgCode);
				resolve(dataURL);
				document.body.removeChild(object);
			};
			document.body.appendChild(object);
		});
	}
	return new Promise((resolve, reject) => {
		const img = new Image();	
		img.crossOrigin = "anonymous";
		img.onload = () => {
			const canvas = document.createElement("canvas");

			canvas.width = img.width;
			canvas.height = img.height;

			const ctx = canvas.getContext("2d");
			ctx.drawImage(img, 0, 0);
			resolve(canvas.toDataURL());
		};
		img.onerror = (error) => {
			setTimeout(() => {
				img.src = url;
			}, 1000);
		};

		img.src = url;
	});
}
export function groupStringsByPrefix(strings, minPrefixLength=2) {

	function splitPrefix(string_list) {		
		class Node {
			constructor() {
				this.list = {};
			}
		}

		const root = new Node();
		for (const i of string_list) {
			const replaced = i.replaceAll("/","@@/")
							.replaceAll("_","@@_")
							.replaceAll("-","@@-");

			const path = replaced.split("@@");

			let currentNode = root;
			for(let j = 0; j < path.length; j++){
				const segment = path[j];
				if (!(segment in currentNode.list))
					currentNode.list[segment] = new Node();
				currentNode = currentNode.list[segment];
			}

			currentNode.link_name = i;
		}		
		return root;
	}

	function getLinks(tree){
		let links = "link_name" in tree ? [tree.link_name] : [];

		for (const [key, value] of Object.entries(tree.list)) {
			links = links.concat(getLinks(value));
		}

		return links;
	}

	function getGroups(tree){
		let groups = {};
		for (const [key, value] of Object.entries(tree.list)) {
			const links = getLinks(value);

			if(links.length < 8){
				groups[key] = links;
			}else{
				let subgroups = getGroups(value);
				for (const [subkey, subvalue] of Object.entries(subgroups)) {
					if(subvalue.length > 2){
						groups[key+subkey] = subvalue;
					}else{
						if(key in groups)
							groups[key] = groups[key].concat(subvalue);
						else
							groups[key] = subvalue;
					}					
				}
			}
		}
		return groups;
	}

	let fragmented = splitPrefix(strings);
	let dict = getGroups(fragmented);

	//format for rendering
	let result = [];
	for (const [key, value] of Object.entries(dict)) {
		if (value.length > 1)
			result.push([key, ...value])
		else
			result.push(value)
	}

	return result.sort((a,b) => {
		if (a[0] < b[0]) return -1;
		if (a[0] > b[0]) return 1;
		return 0;
	});
}

//SVG icons must have the objects that should be recolored flagged with id="fillColor" or id="strokeColor" depending on which part needs coloring
export function setIconColor(icon, hexcol){
	if (icon && icon.contentDocument) {
		const svgDoc = icon.contentDocument;
		const fillChange = svgDoc.querySelectorAll("#fillColor");
		for(let i = 0; i < fillChange.length; i++){
			fillChange[i].style.fill = hexcol;
		}

		const strokeChange = svgDoc.querySelectorAll("#strokeColor");
		for(let i = 0; i < strokeChange.length; i++){
			strokeChange[i].style.stroke = hexcol;
		}
		icon.dataset.color = hexcol;
	}
}


================================================
FILE: vizanti_server/public/js/modules/view.js
================================================
import { settings } from './persistent.js';

function clamp(val, from, to){
    if(val > to)
        return to;
    if(val < from)
        return from;
    return val;
}

function hasClass(element, className) {
	if (element.classList) {
		return element.classList.contains(className);
	} else {
		return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
	}
}

function hasClassInParentChain(element, className) {
	if (!element) {
		return false;
	}

	if (hasClass(element, className)) {
		return true;
	}

	return hasClassInParentChain(element.parentElement, className);
}

const MAX_SCALE = 5000;
const MIN_SCALE = 0.001;
const ZOOM_FACTOR = 1.05;

export class View {

	constructor() {
		this.center = settings.view.center ?? {
			x: 0,
			y: 0
		};
		this.scale = settings.view.scale ?? 50.0;

		this.drag_start = undefined;
		this.input_movement = true;

		if (document.readyState !== 'loading') {
			this.addListeners();
		} else {
			document.addEventListener('DOMContentLoaded', function () {
				this.addListeners();
			});
		}

		this.event_timestamp = performance.now();
		this.event_timeout = undefined;
	}

	async sendUpdateEvent(){

		if (this.event_timeout !== undefined) {
			clearTimeout(this.event_timeout);
		}
		const delta = performance.now() - this.event_timestamp

		if(delta > 12){
			window.dispatchEvent(new Event("view_changed"));
			this.event_timestamp = performance.now();
		}else{
			this.event_timeout = setTimeout(() => {
				window.dispatchEvent(new Event("view_changed"));
			}, 12 - delta);
		}
	}

	setInputMovementEnabled(value){
		this.input_movement = value;
	}

	reset(){
		this.center = { x: 0,y: 0};
		this.scale = 50.0;
		this.drag_start = undefined;

		settings.view.center = this.center;
		settings.view.scale = this.scale;
		settings.save();
		this.sendUpdateEvent();
	}

	fixedToScreen(coords) {
		return {
			x: (coords.x - this.center.x) * this.scale + window.innerWidth / 2,
			y: (-coords.y - this.center.y) * this.scale + window.innerHeight / 2,
			z: 0
		}
	}
	
	screenToFixed(coords) {
		return {
			x: (coords.x - window.innerWidth / 2) / this.scale + this.center.x,
			y: -(coords.y - window.innerHeight / 2) / this.scale - this.center.y,
			z: 0
		}
	}

	quaterionToProjectionMatrix(quaternion) {
		let quat = new Quaternion(
			quaternion.w, 
			-quaternion.x, 
			quaternion.y, 
			-quaternion.z
		);

		const w = quat.w;
		const x = quat.x;
		const y = quat.y;
		const z = quat.z;
		
		const m11 = 1 - 2 * (y * y + z * z);
		const m21 = 2 * (x * y + w * z);
		const m12 = 2 * (x * y - w * z);
		const m22 = 1 - 2 * (x * x + z * z);
		return [m11, m21, m12, m22];
	}


	getPixelsInMapUnits(length){
		let p1 = this.screenToFixed({
			x: 0,
			y: 0,
		});
	
		let p2 = this.screenToFixed({
			x: length,
			y: 0,
		});
	
		return Math.abs(p1.x-p2.x);
	}

	getMapUnitsInPixels(length){
		let p1 = this.fixedToScreen({
			x: 0,
			y: 0,
		});
	
		let p2 = this.fixedToScreen({
			x: length,
			y: 0,
		});
	
		return Math.abs(p1.x-p2.x);
	}
	

	handleDragStart(event) {
		if(!this.input_movement)
			return;

		const { clientX, clientY } = event.touches ? event.touches[0] : event;
		this.drag_start = {
			x: clientX,
			y: clientY,
			ref_center_x: this.center.x,
			ref_center_y: this.center.y,
		};
	}
	
	handleDragMove(event) {
		if (this.drag_start === undefined) return;

		if(!this.input_movement){
			this.drag_start = undefined;
			return;
		}

		if (hasClassInParentChain(event.target, 'inputelement')) {
			return;
		}
	
		const { clientX, clientY } = event.touches ? event.touches[0] : event;
		const delta = {
			x: this.drag_start.x - clientX,
			y: this.drag_start.y - clientY,
		};
	
		this.center = {
			x: this.drag_start.ref_center_x + delta.x / this.scale,
			y: this.drag_start.ref_center_y + delta.y / this.scale,
		};

		settings.view.center = this.center;
		settings.save();
		this.sendUpdateEvent();
	}
	
	handleDragEnd() {
		this.drag_start = undefined;
	}

	handleZoom(event) {
		if(!this.input_movement)
			return;

		let scaleChange;
		let centerX, centerY;
	
		if (event.touches) {
			if (event.touches.length !== 2) return;
			const [touch1, touch2] = event.touches;
			centerX = (touch1.clientX + touch2.clientX) / 2;
			centerY = (touch1.clientY + touch2.clientY) / 2;
			const dx = touch1.clientX - touch2.clientX;
			const dy = touch1.clientY - touch2.clientY;
			const distance = Math.sqrt(dx * dx + dy * dy);
			scaleChange = distance / this.initialTouchDistance;
			this.initialTouchDistance = distance;
			const new_scale = this.scale * scaleChange;
			this.scale = clamp(new_scale, MIN_SCALE, MAX_SCALE);
		} else {
			const new_scale = this.scale * (-event.deltaY < 0 ? 1 / ZOOM_FACTOR : ZOOM_FACTOR);
			const clamped_scale = clamp(new_scale, MIN_SCALE, MAX_SCALE);
			scaleChange = clamped_scale / this.scale;
			centerX = event.clientX;
			centerY = event.clientY;
			this.scale = clamped_scale;
		}
	
		const screenPoint = { x: centerX, y: centerY };
		const mapPoint = this.screenToFixed(screenPoint);
	
		const newCenter = {
			x: this.center.x + (mapPoint.x - this.center.x) * (1 - 1 / scaleChange),
			y: this.center.y + (-mapPoint.y - this.center.y) * (1 - 1 / scaleChange),
		};
	
		this.center = newCenter;
		settings.view.center = this.center;
		settings.view.scale = this.scale;
		settings.save();
		this.sendUpdateEvent();
	}

	addListeners(){
		let view = document.getElementById("view_container");
		
		view.addEventListener('mousedown', this.handleDragStart.bind(this));
		view.addEventListener('mousemove', this.handleDragMove.bind(this));
		view.addEventListener('mouseup', this.handleDragEnd.bind(this));
		
		view.addEventListener('touchstart', (event) => {
			if (event.touches.length === 2) {
				if (!this.touch1 || !this.touch2) {
					this.touch1 = {
						clientX: event.touches[0].clientX,
						clientY: event.touches[0].clientY,
					};
					this.touch2 = {
						clientX: event.touches[1].clientX,
						clientY: event.touches[1].clientY,
					};
					const dx = this.touch1.clientX - this.touch2.clientX;
					const dy = this.touch1.clientY - this.touch2.clientY;
					this.initialTouchDistance = Math.sqrt(dx * dx + dy * dy);
				}
			} else {
				this.touch1 = null;
				this.touch2 = null;
				this.handleDragStart(event);
			}
		});	

		view.addEventListener('touchmove', (event) => {
			if (event.touches.length === 2) {
				this.handleZoom(event);
			} else {
				this.handleDragMove(event);
			}
		});

		view.addEventListener('touchend', (event) => {
			this.touch1 = null;
			this.touch2 = null;
			this.handleDragEnd(event);
		});

		view.addEventListener("mouseleave", (event) => {
			this.touch1 = null;
			this.touch2 = null;
			this.handleDragEnd(event);
		});

		view.addEventListener('wheel', this.handleZoom.bind(this));
	}

}

export let view = new View();


================================================
FILE: vizanti_server/public/templates/add/add_icon.html
================================================
<div class="icon noselect">
	<img src="assets/add.svg" alt="+" width="50" height="50" onclick="openModal('modal_add_element')">
</div>


================================================
FILE: vizanti_server/public/templates/add/add_modal.html
================================================
<div id="modal_add_element" class="modal_outer noselect" style="z-index:10">
	<div class="modal_inner noselect">
		<h3>Add Widgets</h3>
		
		<div class="spacer"></div>

		<div class="tab">
			<button class="tablinks active-tab" id="add_set_type">By Type</button>
			<button class="tablinks" id="add_set_topics">By Topic</button>
		</div>

		<div id="add_topics_container" style="display: none">

		</div>

		<div id="add_types_container">

			<!--<div class="widget_entry" onclick="addWidget('rosbridge')">
				<img src="assets/rosbridge_disconnected.svg" alt="Rosbridge" class="card_icon">
				<div class="card">
					<b class="card_title">Rosbridge Client</b>
					<p class="card_desc">Adds another connection to a Rosbridge server</p>
				</div>
			</div>-->

			<div class="widget_entry" onclick="addWidget('grid','')">
				<img src="assets/grid.svg" alt="Grid" class="card_icon">
				<div class="card">
					<b class="card_title">Grid</b>
					<p class="card_desc">Infinite grid centered at the origin of the target frame of reference</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('tf','')">
				<img src="assets/tf.svg" alt="TF" class="card_icon">
				<div class="card">
					<b class="card_title">TF</b>
					<p class="card_desc">TF transform hierarchy</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('robotmodel','')">
				<img src="assets/robotmodel.svg" alt="RobotModel" class="card_icon">
				<div class="card">
					<b class="card_title">Robot Model</b>
					<p class="card_desc">Custom robot sprite</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('reconfigure','')">
				<img src="assets/reconfigure.svg" alt="Parameter Reconfigure" class="card_icon">
				<div class="card">
					<b class="card_title">Parameter Reconfigure</b>
					<p class="card_desc">View and edit parameters</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('rosbag','')">
				<img src="assets/rosbag.svg" alt="Bag Rec" class="card_icon">
				<div class="card">
					<b class="card_title">Bag Recorder</b>
					<p class="card_desc">Record rosbags</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('nodemgr','')">
				<img src="assets/nodemgr.svg" alt="Node Mgr" class="card_icon">
				<div class="card">
					<b class="card_title">Node Manager</b>
					<p class="card_desc">Start and stop nodes</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('folder','')">
				<img src="assets/folder.svg" alt="Folder" class="card_icon">
				<div class="card">
					<b class="card_title">Folder</b>
					<p class="card_desc">Group your widgets together</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('inspector','')">
				<img src="assets/inspector.svg" alt="Topic Inspector" class="card_icon">
				<div class="card">
					<b class="card_title">Topic Inspector</b>
					<p class="card_desc">View messages as text</p>
				</div>
			</div>

			<hr>

			<div class="widget_entry" onclick="addWidget('teleop','')" data-topic="geometry_msgs/msg/Twist">
				<img src="assets/joystick.svg" alt="Teleop" class="card_icon">
				<div class="card">
					<b class="card_title">Teleop Joystick</b>
					<p class="card_desc">geometry_msgs/Twist</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('initialpose','')" data-topic="geometry_msgs/msg/PoseWithCovarianceStamped">
				<img src="assets/initialpose.svg" alt="Initialpose" class="card_icon">
				<div class="card">
					<b class="card_title">2D Pose Estimate</b>
					<p class="card_desc">Send an initialpose [geometry_msgs/PoseWithCovarianceStamped]</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('simplegoal','')" data-topic="geometry_msgs/msg/PoseStamped">
				<img src="assets/simplegoal.svg" alt="Simplegoal" class="card_icon">
				<div class="card">
					<b class="card_title">2D Nav Goal</b>
					<p class="card_desc">Send a goal pose [geometry_msgs/PoseStamped]</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('waypoints','')" data-topic="nav_msgs/msg/Path,geometry_msgs/msg/PoseArray">
				<img src="assets/waypoints.svg" alt="Waypoints" class="card_icon">
				<div class="card">
					<b class="card_title">Waypoint Mission</b>
					<p class="card_desc">Send a list of goals [nav_msgs/Path] or [geometry_msgs/PoseArray]</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('area','')" data-topic="geometry_msgs/msg/PolygonStamped">
				<img src="assets/area.svg" alt="Area" class="card_icon">
				<div class="card">
					<b class="card_title">Area Mission</b>
					<p class="card_desc">Send vertices of a box [geometry_msgs/PolygonStamped]</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('button','')" data-topic="std_msgs/msg/Bool,std_msgs/msg/Empty">
				<img src="assets/button.svg" alt="Button" class="card_icon">
				<div class="card">
					<b class="card_title">Button</b>
					<p class="card_desc">Display and toggle [std_msgs/Bool], or send [std_msgs/Empty]</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('altimeter','')" data-topic="std_msgs/msg/Float32">
				<img src="assets/altimeter.svg" alt="Altimeter" class="card_icon">
				<div class="card">
					<b class="card_title">Altimeter</b>
					<p class="card_desc">Track Z height of a TF link, send a [std_msgs/Float32] target.</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('speedometer','')">
				<img src="assets/speedometer_icon.svg" alt="Speedometer" class="card_icon">
				<div class="card">
					<b class="card_title">Speedometer</b>
					<p class="card_desc">Track the speed of a TF link.</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('odom','')" data-topic="nav_msgs/msg/Odometry">
				<img src="assets/odom.svg" alt="Tracker" class="card_icon">
				<div class="card">
					<b class="card_title">Pose Tracker</b>
					<p class="card_desc">Track a TF link or [nav_msgs/Odometry] data over time</p>
				</div>
			</div>

			<hr>


			<div class="widget_entry" onclick="addWidget('map','')" data-topic="nav_msgs/msg/OccupancyGrid">
				<img src="assets/map.svg" alt="Map" class="card_icon">
				<div class="card">
					<b class="card_title">Map</b>
					<p class="card_desc">nav_msgs/OccupancyGrid</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('satelite','')" data-topic="sensor_msgs/msg/NavSatFix">
				<img src="assets/satelite.svg" alt="Satelite" class="card_icon">
				<div class="card">
					<b class="card_title">Satelite Tiles</b>
					<p class="card_desc">sensor_msgs/NavSatFix</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('gridcells','')" data-topic="nav_msgs/msg/GridCells">
				<img src="assets/gridcells.svg" alt="Grid Cells" class="card_icon">
				<div class="card">
					<b class="card_title">Grid Cells</b>
					<p class="card_desc">nav_msgs/GridCells</p>
				</div>
			</div>

			<hr>

			<div class="widget_entry" onclick="addWidget('battery','')" data-topic="sensor_msgs/msg/BatteryState">
				<img src="assets/battery_80.svg" alt="Battery" class="card_icon">
				<div class="card">
					<b class="card_title">Battery</b>
					<p class="card_desc">sensor_msgs/BatteryState</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('compressedimage','')" data-topic="sensor_msgs/msg/CompressedImage">
				<img src="assets/image.svg" alt="CompressedImage" class="card_icon">
				<div class="card">
					<b class="card_title">Compressed Image</b>
					<p class="card_desc">sensor_msgs/CompressedImage</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('markerarray','')" data-topic="visualization_msgs/msg/MarkerArray">
				<img src="assets/markerarray.svg" alt="MarkerArray" class="card_icon">
				<div class="card">
					<b class="card_title">Marker Array</b>
					<p class="card_desc">visualization_msgs/MarkerArray</p>
				</div>
			</div>	

			<div class="widget_entry" onclick="addWidget('scan','')" data-topic="sensor_msgs/msg/LaserScan">
				<img src="assets/scan.svg" alt="Scan" class="card_icon">
				<div class="card">
					<b class="card_title">Laser Scan</b>
					<p class="card_desc">sensor_msgs/LaserScan</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('pointcloud','')" data-topic="sensor_msgs/msg/PointCloud2">
				<img src="assets/pointcloud.svg" alt="Pointcloud" class="card_icon">
				<div class="card">
					<b class="card_title">Point Cloud</b>
					<p class="card_desc">sensor_msgs/PointCloud2</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('path','')" data-topic="nav_msgs/msg/Path">
				<img src="assets/path.svg" alt="Path" class="card_icon">
				<div class="card">
					<b class="card_title">Path</b>
					<p class="card_desc">nav_msgs/Path</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('posewithcovariancestamped','')" data-topic="geometry_msgs/msg/PoseWithCovarianceStamped,geometry_msgs/msg/PoseStamped">
				<img src="assets/posewithcovariancestamped.svg" alt="PoseCovStamped" class="card_icon">
				<div class="card">
					<b class="card_title">Pose</b>
					<p class="card_desc">geometry_msgs/PoseWithCovarianceStamped, geometry_msgs/PoseStamped</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('posearray','')" data-topic="geometry_msgs/msg/PoseArray">
				<img src="assets/posearray.svg" alt="PoseArray" class="card_icon">
				<div class="card">
					<b class="card_title">Pose Array</b>
					<p class="card_desc">geometry_msgs/PoseArray</p>
				</div>
			</div>

			<div class="widget_entry" onclick="addWidget('range','')" data-topic="sensor_msgs/msg/Range">
				<img src="assets/range.svg" alt="Range" class="card_icon">
				<div class="card">
					<b class="card_title">Range</b>
					<p class="card_desc">sensor_msgs/Range</p>
				</div>
			</div>


			<div class="widget_entry" onclick="addWidget('temperature','')" data-topic="sensor_msgs/msg/Temperature">
				<img src="assets/temp_warm.svg" alt="Temperature" class="card_icon">
				<div class="card">
					<b class="card_title">Temperature</b>
					<p class="card_desc">sensor_msgs/Temperature</p>
				</div>
			</div>

		</div>

	</div>
</div>



================================================
FILE: vizanti_server/public/templates/add/add_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);

let rosbridge = rosbridgeModule.rosbridge;

const typeButton = document.getElementById('add_set_type');
const topicButton = document.getElementById('add_set_topics');

const topicDiv = document.getElementById('add_topics_container');
const typeDiv = document.getElementById('add_types_container');

let types = {};

//gather the cards
const widgets = typeDiv.children;
for (let i = 0; i < widgets.length; i++) {
	let topics = widgets[i].dataset.topic;
	if(topics !== undefined){
		topics.split(",").forEach(topic => {
			if(topic !== undefined){
				if(topic in types){
					types[topic].push(widgets[i]);
				}else{
					types[topic] = [widgets[i]];
				}
			}
		});
	}
}

//tabs swapping
typeButton.addEventListener("click", (event) => {
	topicButton.classList.remove("active-tab");
	typeButton.classList.add("active-tab");

	typeDiv.style.display = "block";
	topicDiv.style.display = "none";
});

topicButton.addEventListener("click", (event) => {
	update_topics();
	typeButton.classList.remove("active-tab");
	topicButton.classList.add("active-tab");

	typeDiv.style.display = "none";
	topicDiv.style.display = "block";
});

// rebuild topic list
async function update_topics(){
	let result = await rosbridge.get_all_topics();

	topicDiv.innerHTML = "";
	for (let i = 0; i < result.types.length; i++) {
		let type = result.types[i];
		if(type in types){
			types[type].forEach(element => {
				let newnode = element.cloneNode(true);
				let title = newnode.querySelector('.card_title');
				let desc = newnode.querySelector('.card_desc');
				
				newnode.setAttribute('onclick', newnode.getAttribute("onclick").replace(",\'\')",",\'"+result.topics[i]+"\')"));

				desc.innerText = title.innerText + " ["+type + "]";
				title.innerText = result.topics[i];
				topicDiv.appendChild(newnode);
			});
		}
	}
}


update_topics();

console.log("Add Widgets Loaded.");


================================================
FILE: vizanti_server/public/templates/altimeter/altimeter_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/altimeter.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/altimeter/altimeter_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">

	<div id="{uniqueID}_imgpreview" class="noselect compressedimage_preview">
		<img  src="assets/joypos.svg" alt="Image Preview" width="100" height="100">
	</div> 

	<div class="modal_inner noselect">
		<h3>Altimeter</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_frame">Robot Frame:</label>
		<select id="{uniqueID}_frame" name="topic">
			<option value='base_link'>base_link</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_mode">Display Mode:</label>
		<select id="{uniqueID}_mode" name="topic">
			<option value='altitude_positive'>Altitude (Z+)</option>
			<option value='depth_negative'>Depth (Z-)</option>
			<option value='altitude_negative'>Altitude inverted (Z-)</option>
			<option value='depth_positive'>Depth inverted (Z+)</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_step">Step (meter):</label>
		<input type="number" value="1.0" step="0.1" min="0.1" max="1000" id="{uniqueID}_step">

		<div class="spacer"></div>

		<div class="live_data_display">
			<p id="{uniqueID}_altitude_text">Altitude: ?</p>
			<p id="{uniqueID}_target_text">Target: N/A</p>
		</div>

		Displays the Z value of the frame on a depth/altitude gauge. Inverted modes treat negative values to positive.

		<div class="spacer"></div>

		<h4>Send Target</h4>

		<div class="spacer"></div>

		<label for="{uniqueID}_topic">Value Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<option value="/depth_tgt">/depth_tgt</option>
		</select>

		<p>Send a std_msgs/Float32 value to this topic.</p>

		<p class="comment">Clicking the altimeter will mark the depth/alitude with a yellow flag and publish it. Or click the button below and input it manually.</p>

		<button id="{uniqueID}_manual_target" class="export_button">Input and send target manually</button>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>

	<div style="height: 180vh; width: 1px;">
		<!-- Scroll spacer-->
	</div>

</div>


================================================
FILE: vizanti_server/public/templates/altimeter/altimeter_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let MODES = {
	"altitude_positive": {dir: "altitude", invert: false},
	"altitude_negative": {dir: "altitude", invert: true},
	"depth_negative": {dir: "depth", invert: true},
	"depth_positive": {dir: "depth", invert: false},
};

let step = 1.0;
let meters = 0;
let meters_smooth = 0;
let target = NaN;

let frame = "";
let topic = getTopic("{uniqueID}");

let float_topic = undefined;
let listener = undefined;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let img_offset_x = "0";

const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

const arrow = document.getElementById('{uniqueID}_arrow');
const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const icon_bar = document.getElementById("icon_bar");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const selectionbox = document.getElementById("{uniqueID}_topic");
const frameSelector = document.getElementById("{uniqueID}_frame");
const modeSelector = document.getElementById("{uniqueID}_mode");
const stepBox = document.getElementById("{uniqueID}_step");

const text_altitude = document.getElementById("{uniqueID}_altitude_text");
const text_target = document.getElementById("{uniqueID}_target_text");

const imgpreview = document.getElementById('{uniqueID}_imgpreview');

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	modeSelector.value = loaded_data.mode;
	frame = loaded_data.frame;
	topic = loaded_data.topic;

	stepBox.value = loaded_data.step;
	frameSelector.value = frame;
	selectionbox.value = topic;

	step = loaded_data.step;
	img_offset_x = loaded_data.img_offset_x;
}else{

	if(frame == ""){
		frame = "base_link";
		status.setWarn("No frame found, defaulting to base_link");
	}

	/* if(topic == ""){
		topic = "/depth_tgt";
		status.setWarn("No topic found, defaulting to /depth_tgt");
	} */

	img_offset_x = (document.querySelectorAll('.altimeter_canvas').length-1) * 110;
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		mode: modeSelector.value,
		frame: frame,
		topic: topic,
		step: step,
		img_offset_x: img_offset_x
	}
	settings.save();
}

//topic
function connect(){

	if(topic == ""){
		status.setWarn("Empty topic.");
		return;
	}

	if(float_topic !== undefined){
		float_topic.unsubscribe(listener);
	}

	float_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'std_msgs/msg/Float32'
	});
	
	listener = float_topic.subscribe((msg) => {
		const mode = MODES[modeSelector.value];
		target = Math.abs(msg.data);
		if(msg.data > 0){
			if(mode.dir == "depth" && mode.invert)
				target = NaN;

			if(mode.dir == "altitude" && mode.invert)
				target = NaN;

		}else if (msg.data < 0){
			if(mode.dir == "depth" && !mode.invert)
				target = NaN;

			if(mode.dir == "altitude" && !mode.invert)
				target = NaN;
		}

		if(isNaN(target))
			text_target.innerText = "Target: N/A";
		else
			text_target.innerText = "Target: "+target.toFixed(3)+" m";
		
		drawWidget();
	});

	saveSettings();
}

function publishTarget(value){

	if(topic == "")
		return;

	if(MODES[modeSelector.value].invert)
		value = -value;

	const publisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: 'std_msgs/msg/Float32'
	});

	const floatMsg = new ROSLIB.Message({
		data: value
	});

	publisher.publish(floatMsg);
}

function getMeters(){
	const robotframe = tf.absoluteTransforms[frame];
	if(robotframe)
	{
		const mode = MODES[modeSelector.value];
		let z_meters = robotframe.translation.z;

		if(mode.invert)
			z_meters = -z_meters;

		if(z_meters < 0)
			z_meters = 0;

		status.setOK();
		return parseFloat(z_meters.toFixed(3));
	}
	else
	{
		status.setError("Required transform frame \""+frame+"\" not found.");
		return 0;
	}
}

function drawTarget(flip_offset, flip_mult, pos){
	ctx.fillStyle = "#e3df6f";
	ctx.lineWidth = 1;
	ctx.beginPath();
	ctx.moveTo(flip_offset, pos-25);
	ctx.lineTo(flip_offset+ 25 * flip_mult, pos);
	ctx.lineTo(flip_offset+ 25 * flip_mult, pos);
	ctx.lineTo(flip_offset, pos+25);
	ctx.lineTo(flip_offset, pos-25);
	ctx.fill();
}

function drawDepth(){

	const hei = canvas.height;
	const centerY = hei/2;
    const pixelOffset = (meters_smooth / step) * -100 + centerY;

	const flip = img_offset_x > window.innerWidth/2;
	const flip_offset = flip ? 110: 0;
	const flip_mult = flip ? -1: 1;

	ctx.fillStyle = "#4070bfff";
	ctx.fillRect(flip ? 60: 0, pixelOffset-50, 50, 50);

	ctx.strokeStyle = "lightgray";
	ctx.lineWidth = 1;
	ctx.beginPath();
	for (let y = pixelOffset, x = 0; y <= hei; y += 10, x+=1) {
		if(x % 5 == 0 || y < 0)
			continue;

		ctx.moveTo(flip_offset, y);
		ctx.lineTo(flip_offset + 25 * flip_mult, y);
	}
	ctx.stroke();

	ctx.strokeStyle = "white";
	ctx.lineWidth = 2;

	ctx.font = "bold 16px Monospace";
	ctx.fillStyle = "white";
	ctx.textAlign = flip ? "right" : "left";

	ctx.beginPath();
	let lineCount = 0.0;
	for (let y = pixelOffset, x = 0; y <= hei; y += 50, x+=1) {

		if(y < 0){
			if(x % 2 == 0)
				lineCount += step;
			continue;
		}
			
		if(x % 2 == 0){
			ctx.moveTo(flip_offset, y);
			ctx.lineTo(flip_offset + 50 * flip_mult, y);

			ctx.fillText(Number.isInteger(lineCount) ? lineCount : lineCount.toFixed(1), 55, y + 4);
			lineCount += step;
		}else{
			ctx.moveTo(flip_offset, y);
			ctx.lineTo(flip_offset + 35 * flip_mult, y);
		}
	}
	ctx.stroke();

	if(!isNaN(target)){
		const pos = pixelOffset + ((target / step) * 100);
		drawTarget(flip_offset, flip_mult, pos);
	}
}

function drawAltitude(){

	const hei = canvas.height;
	const centerY = hei/2;
    const pixelOffset = (meters_smooth / step) * 100 + centerY;

	const flip = img_offset_x > window.innerWidth/2;
	const flip_offset = flip ? 110: 0;
	const flip_mult = flip ? -1: 1;

	ctx.fillStyle = "#5a9558ff";
	ctx.fillRect(flip ? 60: 0, pixelOffset, 50, 50);

	ctx.strokeStyle = "lightgray";
	ctx.lineWidth = 1;
	ctx.beginPath();
	for (let y = pixelOffset, x = 0; y >= 0; y -= 10, x+=1) {
		if(x % 5 == 0 || y > hei)
			continue;

		ctx.moveTo(flip_offset, y);
		ctx.lineTo(flip_offset + 25 * flip_mult, y);
	}
	ctx.stroke();

	ctx.strokeStyle = "white";
	ctx.lineWidth = 2;

	ctx.font = "bold 16px Monospace";
	ctx.fillStyle = "white";
	ctx.textAlign = flip ? "right" : "left";

	ctx.beginPath();
	let lineCount = 0.0;
	for (let y = pixelOffset, x = 0; y >= 0; y -= 50, x+=1) {

		if(y > hei){
			if(x % 2 == 0)
				lineCount += step;
			continue;
		}

		if(x % 2 == 0){
			ctx.moveTo(flip_offset, y);
			ctx.lineTo(flip_offset + 50 * flip_mult, y);

			ctx.fillText(Number.isInteger(lineCount) ? lineCount : lineCount.toFixed(1), 55, y + 4);
			lineCount += step;
		}else{
			ctx.moveTo(flip_offset, y);
			ctx.lineTo(flip_offset + 35 * flip_mult, y);
		}

	}
	ctx.stroke();

	if(!isNaN(target)){
		const pos = pixelOffset + ((target / step) * -100);
		drawTarget(flip_offset, flip_mult, pos);

	}
}

async function drawWidget() {
	const mode = MODES[modeSelector.value];

	if(mode.dir === "depth")
		text_altitude.innerText = "Depth: "+meters.toFixed(3)+" m";
	else
		text_altitude.innerText = "Altitude: "+meters.toFixed(3)+" m";

	ctx.clearRect(0, 0, canvas.width, canvas.height);

 	if(mode.dir === "depth"){
		drawDepth();
	}else{
		drawAltitude();
	}
}

function enqueueRender() {
	if(Math.abs(meters - meters_smooth) > step * 0.01){
		meters_smooth = meters_smooth * 0.95 + meters * 0.05;
		drawWidget();
	}

	window.requestAnimationFrame(enqueueRender);
}

function resizeScreen(){
	canvas.width = 110;
	canvas.height = window.innerHeight - icon_bar.offsetHeight;

	canvas.style.height = (window.innerHeight - icon_bar.offsetHeight) +"px";
	canvas.style.width = "110px";

	if(MODES[modeSelector.value].dir == "depth")
		arrow.style.bottom = (canvas.height/2 - 60) +"px";
	else
		arrow.style.bottom = (canvas.height/2 - 60) +"px";

	drawWidget();
}

window.addEventListener("tf_fixed_frame_changed", drawWidget);
window.addEventListener("tf_changed", ()=>{
	let new_val = getMeters();
	if(new_val != meters){
		meters = new_val;
		drawWidget();
	}
});

window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);
window.addEventListener("iconbar_height_change", resizeScreen);

// TF frame list
function setFrameList(){
	let framelist = "";
	for (const key of tf.frame_list.values()) {
		framelist += "<option value='"+key+"'>"+key+"</option>"
	}
	frameSelector.innerHTML = framelist;

	if(tf.transforms.hasOwnProperty(frame)){
		frameSelector.value = frame;
	}else{
		framelist += "<option value='"+frame+"'>"+frame+"</option>"
		frameSelector.innerHTML = framelist
		frameSelector.value = frame;
	}
}

modeSelector.addEventListener("change", (event) => {
	target = NaN;
	text_target.innerText = "Target: N/A";
	saveSettings();
	refreshStyleSetup();
	drawWidget();
});

frameSelector.addEventListener("change", (event) =>{
	frame = frameSelector.value;
	saveSettings();
	refreshStyleSetup();
	drawWidget();
});

stepBox.addEventListener("change", (event) =>{	
	step = Math.min(Math.max(0.1, parseFloat(stepBox.value)), 1000);
	saveSettings();
	refreshStyleSetup();
	drawWidget();
});


// Topics
async function loadTopics(){
	let result = await rosbridge.get_topics("std_msgs/msg/Float32");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}

	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
	connect();
});

icon.addEventListener("click", ()=>{
	setFrameList();
	loadTopics();
});

resizeScreen();
loadTopics();

//targeting
function getEventXY(event){
	let globalX, globalY;
	if (event.type === "touchmove") {
		globalX = event.touches[0].clientX;
		globalY = event.touches[0].clientY;
	} else {
		globalX = event.clientX;
		globalY = event.clientY;
	}
	return [globalX, globalY];
}

function getEventLocalXY(event){

	const [globalX, globalY] = getEventXY(event);

	const rect = event.target.getBoundingClientRect();
	let x = globalX - rect.left;
	let y = globalY - rect.top;

	//are we flipped
	if(img_offset_x > window.innerWidth/2)
		x = rect.width - x;

	return [x, y];
}

function setTargetFromPixels(y){
	
	const centerY = canvas.height/2;
	let newtgt = 0;

	if(MODES[modeSelector.value].dir == "depth"){
		newtgt = ((y - centerY) / 100 + (meters_smooth / step)) * step;
	}else{
		newtgt = ((y - centerY) / -100 + (meters_smooth / step)) * step;
	}

	if(newtgt > -1){
		publishTarget(newtgt > 0 ? newtgt: 0);
	}
}

let targeting_active = false;
let targeting_point = {
	x: 0, 
	y: 0
};

function onTargetStart(event) {

	if(topic == "")
		return;

	const [x, y] = getEventLocalXY(event);
	if(x > 30)
		return;

	const [globalX, globalY] = getEventXY(event);

	targeting_active = true;
	targeting_point.x = globalX;
	targeting_point.y = globalY;

	document.addEventListener('mouseup', onTargetEnd);
	document.addEventListener('touchend', onTargetEnd);
}

function onTargetEnd(event) {

	targeting_active = false;
	document.removeEventListener('mouseup', onTargetEnd);
	document.removeEventListener('touchend', onTargetEnd);

	const [globalX, globalY] = getEventXY(event);

	if(Math.hypot(targeting_point.y - globalY, targeting_point.x - globalX) < 15){
		const [x, y] = getEventLocalXY(event);
		setTargetFromPixels(y);
	}
}
  
canvas.addEventListener('mousedown', onTargetStart);
canvas.addEventListener('touchstart', onTargetStart);


//preview for definining position
let preview_active = false;

function refreshStyleSetup(){
	imgpreview.style.left = img_offset_x + canvas.width/2 + "px";
	canvas.style.left = img_offset_x +"px";

	let color;
	if(MODES[modeSelector.value].dir == "depth"){
		arrow.src = "assets/altimeter_arrow.svg"
		icon.src = "assets/altimeter.svg";
		color = "#4070bfff";
	}else{
		arrow.src = "assets/altimeter_arrow_green.svg";
		icon.src = "assets/altimeter_green.svg";
		color = "#5a9558ff";
	}

	if(img_offset_x > window.innerWidth/2){
		canvas.style.borderLeft = "5px none transparent";
		canvas.style.borderRight = "5px solid "+color;
		canvas.style.backgroundImage = "linear-gradient(to left, rgba(0, 0, 0, 0.589) , transparent)";
		icon.style.transform = "rotate(180deg)";

		arrow.style.left = (img_offset_x + 55) +"px";
		arrow.style.transform = "translateY(-50%) rotate(180deg)";
	}else{

		canvas.style.borderRight = "5px none transparent";
		canvas.style.borderLeft = "5px solid "+color;
		canvas.style.backgroundImage = "linear-gradient(to right, rgba(0, 0, 0, 0.589) , transparent)";
		icon.style.transform = "";

		arrow.style.left = img_offset_x +"px";
		arrow.style.transform = "translateY(-50%)";
	}
}

window.addEventListener('resize', ()=>{
	refreshStyleSetup();
});

function onStart(event) {
	preview_active = true;
	document.addEventListener('mousemove', onMove);
	document.addEventListener('touchmove', onMove);
	document.addEventListener('mouseup', onEnd);
	document.addEventListener('touchend', onEnd);
}

function onMove(event) {
	if (preview_active) {
		event.preventDefault();
		const wid = window.innerWidth-5;
		let [currentX, currentY] = getEventXY(event);

		if(currentX > wid/2){
			currentX = wid - currentX + 110;
			img_offset_x = wid - parseInt(currentX/110)*110;
		}else{
			img_offset_x = parseInt(currentX/110)*110;
		}

		refreshStyleSetup();
		saveSettings();
	}
}

function onEnd() {
	preview_active = false;
	document.removeEventListener('mousemove', onMove);
	document.removeEventListener('touchmove', onMove);
	document.removeEventListener('mouseup', onEnd);
	document.removeEventListener('touchend', onEnd);
}
  
imgpreview.addEventListener('mousedown', onStart);
imgpreview.addEventListener('touchstart', onStart);

refreshStyleSetup();
enqueueRender();

//manual targeting
document.getElementById("{uniqueID}_manual_target").addEventListener("click", async (event) =>{

	let value = await prompt("Enter target "+MODES[modeSelector.value].dir+" (meters, positive only):", "0.0");
	if (value != null) {
		publishTarget(Math.abs(value));
		drawWidget();
	}
});

console.log("Altimeter Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/altimeter/altimeter_view.html
================================================
<img id="{uniqueID}_arrow" src="assets/altimeter_arrow.svg" class="altimeter_arrow" alt="?" width="60" height="60">
<canvas id="{uniqueID}_canvas" class="altimeter_canvas"></canvas>



================================================
FILE: vizanti_server/public/templates/area/area_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/area.svg" alt="model" width="50" height="50">
</div> 


================================================
FILE: vizanti_server/public/templates/area/area_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Area</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<option value=""></option>
		</select>

		<p>Defines an axis-alligned area in the fixed frame by dragging, and publishes it as a geometry_msgs/PolygonStamped rectangle.</p>

		<p class="comment">Click the icon once to enable, drag on the view area and release to publish. Long press the icon to open this menu.</p>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/area/area_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;


let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic
	}
	settings.save();
}

function getStamp(){
	const currentTime = new Date();
	const currentTimeSecs = Math.floor(currentTime.getTime() / 1000);
	const currentTimeNsecs = (currentTime.getTime() % 1000) * 1e6;

	return {
		sec: currentTimeSecs,
		nanosec: currentTimeNsecs
	}
}

function sendMessage(start, end){
	if(!start || !end){
		status.setError("Could not send message, area invalid.");
		return;
	}

	let start_pos = view.screenToFixed(start);
	start_pos.z = 0;

	let end_pos = view.screenToFixed(end);
	end_pos.z = 0;

	// Compute the other two points of the square.
	let vector = {
		x: end_pos.x - start_pos.x,
		y: end_pos.y - start_pos.y
	};

	let point2 = {
		x: start_pos.x + vector.x,
		y: start_pos.y,
		z: 0
	};

	let point3 = {
		x: start_pos.x, 
		y: start_pos.y + vector.y,
		z: 0
	};

	const publisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: 'geometry_msgs/msg/PolygonStamped'
	});

	const polygonMsg = new ROSLIB.Message({
		header: {
			stamp: getStamp(),
			frame_id: tf.fixed_frame
		},
		polygon: {
			points: [
				start_pos,
				point2,
				end_pos,
				point3,
			]
		},
	});

	publisher.publish(polygonMsg);
	status.setOK();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const view_container = document.getElementById("view_container");

const icon = document.getElementById("{uniqueID}_icon");
const iconImg = icon.getElementsByTagName('img')[0];

let active = false;
let start_point = undefined;
let end_point = undefined;

async function drawBox() {
    const wid = canvas.width;
    const hei = canvas.height;

    ctx.clearRect(0, 0, wid, hei);

	if(end_point !== undefined)
	{
		ctx.fillStyle = "lime";
		ctx.globalAlpha = 0.3;
	
		ctx.fillRect(
			start_point.x, 
			start_point.y, 
			end_point.x - start_point.x, 
			end_point.y - start_point.y
		);
	}
}

function startDrag(event){
	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	start_point = {
		x: clientX,
		y: clientY
	};
}

function drag(event){
	if (start_point === undefined) return;

	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	end_point = {
		x: clientX,
		y: clientY
	};

	drawBox();	
}

function endDrag(event){
	sendMessage(start_point, end_point);

	start_point = undefined;
	end_point = undefined;
	drawBox();
	setActive(false);
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
}

window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

view_container.addEventListener("mouseleave", (event) => {
	start_point = undefined;
	end_point = undefined;
	drawBox();
	setActive(false);
});

function addListeners(){
	view_container.addEventListener('mousedown', startDrag);
	view_container.addEventListener('mousemove', drag);
	view_container.addEventListener('mouseup', endDrag);

	view_container.addEventListener('touchstart', startDrag);
	view_container.addEventListener('touchmove', drag);
	view_container.addEventListener('touchend', endDrag);	
}

function removeListeners(){
	view_container.removeEventListener('mousedown', startDrag);
	view_container.removeEventListener('mousemove', drag);
	view_container.removeEventListener('mouseup', endDrag);

	view_container.removeEventListener('touchstart', startDrag);
	view_container.removeEventListener('touchmove', drag);
	view_container.removeEventListener('touchend', endDrag);	
}

function setActive(value){
	active = value;
	view.setInputMovementEnabled(!active);

	if(active){
		addListeners();
		icon.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
		view_container.style.cursor = "pointer";
	}else{
		removeListeners()
		icon.style.backgroundColor = "rgba(124, 124, 124, 0.3)";
		view_container.style.cursor = "";
	}
}

// Topics
const selectionbox = document.getElementById("{uniqueID}_topic");

async function loadTopics(){
	let result = await rosbridge.get_topics("geometry_msgs/msg/PolygonStamped");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
});

// Long press modal open stuff

let longPressTimer;
let isLongPress = false;

icon.addEventListener("click", (event) =>{
	if(!isLongPress)
		setActive(!active);
	else
		isLongPress = false;
});

icon.addEventListener("mousedown", startLongPress);
icon.addEventListener("touchstart", startLongPress);

icon.addEventListener("mouseup", cancelLongPress);
icon.addEventListener("mouseleave", cancelLongPress);
icon.addEventListener("touchend", cancelLongPress);
icon.addEventListener("touchcancel", cancelLongPress);

icon.addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

function startLongPress(event) {
	isLongPress = false;
	longPressTimer = setTimeout(() => {
		isLongPress = true;
		loadTopics();
		openModal("{uniqueID}_modal");
	}, 500);
}

function cancelLongPress(event) {
	clearTimeout(longPressTimer);
}

resizeScreen();
loadTopics();

console.log("Area Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/area/area_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 6;"></canvas>


================================================
FILE: vizanti_server/public/templates/battery/battery_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/battery_unknown.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/battery/battery_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Battery Info</h3>
		
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>

		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_pecentage">Percentage: ?</p>
			<p id="{uniqueID}_voltage">Voltage: ?</p>
			<p id="{uniqueID}_cell_voltage">Cell Voltages: ?</p>
	
			<p id="{uniqueID}_current">Current draw: ?</p>
			<p id="{uniqueID}_charge">Charge: ?</p>
	
			<p id="{uniqueID}_charging_status" style="color: lightgray;">Status: ?</p>
			<p id="{uniqueID}_health" style="color: lightgray;">Health: ?</p>
			<p id="{uniqueID}_chemistry" style="color: lightgray;">Type: ?</p>
		</div>

		<p>Read and display battery data from sensor_msgs/BatteryState messages.</p>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/battery/battery_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;


let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
	}
	settings.save();
}

let icons = {};
icons["20%"] = await imageToDataURL("assets/battery_20.svg");
icons["40%"] = await imageToDataURL("assets/battery_40.svg");
icons["60%"] = await imageToDataURL("assets/battery_60.svg");
icons["80%"] = await imageToDataURL("assets/battery_80.svg");
icons["100%"] = await imageToDataURL("assets/battery_100.svg");
icons["charging_20%"] = await imageToDataURL("assets/battery_20_charging.svg");
icons["charging_40%"] = await imageToDataURL("assets/battery_40_charging.svg");
icons["charging_60%"] = await imageToDataURL("assets/battery_60_charging.svg");
icons["charging_80%"] = await imageToDataURL("assets/battery_80_charging.svg");
icons["charging_100%"] = await imageToDataURL("assets/battery_100_charging.svg");
icons["unknown"] = await imageToDataURL("assets/battery_unknown.svg");

const STATUS = [
	"UNKNOWN",
	"CHARGING",
	"DISCHARGING",
	"NOT CHARGING",
	"FULL",
]

const HEALTH = [
	"UNKNOWN",
	"GOOD",
	"OVERHEAT",
	"DEAD",
	"OVERVOLTAGE",
	"UNSPEC FAILURE",
	"COLD",
	"WATCHDOG TIMER EXPIRED",
	"SAFETY TIMER EXPIRED"
]

const CHEMISTRY = [
	"UNKNOWN",
	"NIMH",
	"LION",
	"LIPO",
	"LIFE",
	"NICD",
	"LIMN"
]

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const text_percent = document.getElementById("{uniqueID}_pecentage");
const text_voltage = document.getElementById("{uniqueID}_voltage");
const text_cell_voltage = document.getElementById("{uniqueID}_cell_voltage");
const text_current = document.getElementById("{uniqueID}_current");
const text_charge = document.getElementById("{uniqueID}_charge");

const text_status = document.getElementById("{uniqueID}_charging_status");
const text_health = document.getElementById("{uniqueID}_health");
const text_chemistry = document.getElementById("{uniqueID}_chemistry");

let listener = undefined;
let batterytopic = undefined;

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(batterytopic !== undefined){
		batterytopic.unsubscribe(listener);
	}

	batterytopic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/BatteryState',
		throttle_rate: 500, // throttle to twice a second max
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	
	listener = batterytopic.subscribe((msg) => {

		let chg_prefix = msg.power_supply_status == 1 ? "charging_": "";

		if(msg.percentage <= 0.2){
			icon.src = icons[chg_prefix+"20%"];
		}
		else if(msg.percentage <= 0.4){
			icon.src = icons[chg_prefix+"40%"];
		}
		else if(msg.percentage <= 0.6){
			icon.src = icons[chg_prefix+"60%"];
		}
		else if(msg.percentage <= 0.8){
			icon.src = icons[chg_prefix+"80%"];
		}
		else{
			icon.src = icons[chg_prefix+"100%"];
		}

		text_percent.innerText = "Percentage: "+parseInt(msg.percentage*100)+" %";

		if(msg.voltage)
			text_voltage.innerText = "Voltage: "+msg.voltage.toFixed(2)+" V";

		if(msg.current)
			text_current.innerText = "Current draw: "+msg.current.toFixed(2)+" A";

		if(msg.charge)
			text_charge.innerText = "Charge: "+msg.charge.toFixed(2)+"/"+msg.capacity.toFixed(2)+" Ah";

		if(msg.cell_voltage.length > 0){
			let cellstr = "Cell Voltages: ";

			for(let i = 0; i < msg.cell_voltage.length; i++){
				cellstr += msg.cell_voltage[i].toFixed(2)+" V, ";
			}

			text_cell_voltage.innerText = cellstr.substring(0, cellstr.length - 2);
		}

		text_status.innerText = "Status: "+STATUS[msg.power_supply_status];
		text_health.innerText = "Health: "+HEALTH[msg.power_supply_health];
		text_chemistry.innerText = "Type: "+CHEMISTRY[msg.power_supply_technology];

		status.setOK();
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/BatteryState");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	icon.src = icons["unknown"];
	connect();
	saveSettings();
});

selectionbox.addEventListener("click", connect);
icon.addEventListener("click", loadTopics);

loadTopics();

console.log("Battery Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/button/button_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/button.svg" alt="?" width="50" height="50">
	<p id="{uniqueID}_buttontext" class="icon-text">Text</p>
</div> 


================================================
FILE: vizanti_server/public/templates/button/button_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Button</h3>
		
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>

		<hr class="dark_hr"/>

		<label for="{uniqueID}_name">Display Text:</label>
		<input id="{uniqueID}_name" type="text" value="Text">

		<div class="spacer"></div>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<hr class="dark_hr"/>

		<p>Multifunctional button. Behavior depends on the selected topic/service type:</p>
		<ul>
			<li><b  style="color:rgb(204, 204, 204)">std_msgs/Empty</b>: Sends an Empty message on click.</li>
			<li><b  style="color:rgb(204, 204, 204)">std_srvs/Trigger</b>: Calls a Trigger service.</li>
			<li><b  style="color:rgb(204, 204, 204)">std_srvs/Empty</b>: Calls a Empty service.</li>

			<li><b style="color:rgb(203, 255, 201)">std_msgs/Bool</b>: Displays topic state and sends a negated value on click.</li>
			<li><b style="color:rgb(203, 255, 201)">std_srvs/SetBool</b>: Negates internal boolean with each call, displays state.</li>
		</ul>

		<p style="color:#b4b4b4;">Click the icon to trigger. Long press to reopen this menu.</p>
		
		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/button/button_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let typedict = {};

//persistent loading, so we don't re-fetch on every update
let icons = {};
icons["true"] = await imageToDataURL("assets/button_true.svg");
icons["false"] = await imageToDataURL("assets/button_false.svg");
icons["default"] = await imageToDataURL("assets/button.svg");

const selectionbox = document.getElementById("{uniqueID}_topic");
const icondiv = document.getElementById("{uniqueID}_icon");
const icon = icondiv.getElementsByTagName('img')[0];
const icontext = icondiv.getElementsByTagName('p')[0];
const namebox = document.getElementById("{uniqueID}_name");

namebox.addEventListener('input', function() {
	icontext.textContent = namebox.value;
	saveSettings();
});

//Settings

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	namebox.value = loaded_data.text;
	icontext.textContent = loaded_data.text;
	typedict = loaded_data.typedict ?? {};
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		text: namebox.value,
		typedict: typedict
	}
	settings.save();
}

//Messaging

function sendMessage(){

	icondiv.classList.add("button-press-effect");

	setTimeout(() => {
		icondiv.classList.remove("button-press-effect");
	}, 200);

	if(typedict[topic] == "std_msgs/msg/Bool" || typedict[topic] == "std_msgs/msg/Empty"){
		const publisher = new ROSLIB.Topic({
			ros: rosbridge.ros,
			name: topic,
			messageType: typedict[topic],
			throttle_rate: 33
		});

		if(typedict[topic] == "std_msgs/msg/Bool"){
			publisher.publish(new ROSLIB.Message({
				data: !value,
			}));
		}else{
			publisher.publish(new ROSLIB.Message({}));
		}
	}
	else if(typedict[topic] == "std_srvs/srv/Empty"){
		const service = new ROSLIB.Service({
			ros: rosbridge.ros,
			name: topic,
			serviceType: "std_srvs/srv/Empty"
		});
		const request = new ROSLIB.ServiceRequest({});
		service.callService(request, (result) => {
			console.log("Empty service called.");
		});
	}
	else if(typedict[topic] == "std_srvs/srv/Trigger"){
		const service = new ROSLIB.Service({
			ros: rosbridge.ros,
			name: topic,
			serviceType: "std_srvs/srv/Trigger"
		});
		const request = new ROSLIB.ServiceRequest({});
		service.callService(request, (result) => {
			if(result.success){
				status.setOK(result.message);
			}else{
				status.setError(result.message);
			}
		});
	}
	else if(typedict[topic] == "std_srvs/srv/SetBool"){
		const service = new ROSLIB.Service({
			ros: rosbridge.ros,
			name: topic,
			serviceType: "std_srvs/srv/SetBool"
		});
		const request = new ROSLIB.ServiceRequest({
			data: !value  // toggle the value
		});
		service.callService(request, (result) => {
			if(result.success){
				value = !value;
				icon.src = icons[value];
				status.setOK(result.message);
			}else{
				status.setError(result.message);
			}
		});
	}

}

let value = false;
let listener = undefined;
let booltopic = undefined;

function connect(){

	if(topic == ""){
		status.setError("Empty topic/service.");
		return;
	}

	if(booltopic !== undefined){
		booltopic.unsubscribe(listener);
	}

	if(typedict[topic] == "std_msgs/msg/Bool"){

		status.setWarn("No data received.");

		booltopic = new ROSLIB.Topic({
			ros : rosbridge.ros,
			name : topic,
			messageType : "std_msgs/msg/Bool",
			throttle_rate: 33
		});	
		
		listener = booltopic.subscribe((msg) => {
			value = msg.data;
			icon.src = icons[value];
			status.setOK();
		});

		icon.src = icons["false"];
	}
	else if(typedict[topic] == "std_srvs/srv/SetBool"){
		icon.src = icons["false"];
	}	
	else{
		icon.src = icons["default"];
	}

	saveSettings();
}

async function loadTopics(){
	let booltopics = await rosbridge.get_topics("std_msgs/msg/Bool");
	let emptypubs = await rosbridge.get_topics("std_msgs/msg/Empty");
	let emptysrvs = await rosbridge.get_services("std_srvs/srv/Empty");
	let triggersrvs = await rosbridge.get_services("std_srvs/srv/Trigger");
	let setboolsrvs = await rosbridge.get_services("std_srvs/srv/SetBool");

	let topiclist = "";

	booltopics.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (msgs/Bool)</option>";
		typedict[element] = "std_msgs/msg/Bool";
	});

	emptypubs.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (msgs/Empty)</option>";
		typedict[element] = "std_msgs/msg/Empty";
	});

	emptysrvs.forEach(element => {
		if(!element.includes("/vizanti/")){
			topiclist += "<option value='"+element+"'>"+element+" (srvs/Empty)</option>";
			typedict[element] = "std_srvs/srv/Empty";
		}
	});

	triggersrvs.forEach(element => {
		if(!element.includes("/vizanti/")){
			topiclist += "<option value='"+element+"'>"+element+" (srvs/Trigger)</option>";
			typedict[element] = "std_srvs/srv/Trigger";
		}
	});

	setboolsrvs.forEach(element => {
		if(!element.includes("/vizanti/")){
			topiclist += "<option value='"+element+"'>"+element+" (srvs/SetBool)</option>";
			typedict[element] = "std_srvs/srv/SetBool";
		}
	});

	selectionbox.innerHTML = topiclist;

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(typedict.hasOwnProperty(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>";
			selectionbox.innerHTML = topiclist;
			selectionbox.value = topic;
		}
	}
}


selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	icon.src = icons["default"];
	connect();
});

selectionbox.addEventListener("click", connect);
icon.addEventListener("click", loadTopics);

loadTopics();
connect();

// Long press modal open stuff
let longPressTimer;
let isLongPress = false;

icondiv.addEventListener("click", (event) =>{
	if(!isLongPress){
		sendMessage();
	}else{
		isLongPress = false;
	}
});

icondiv.addEventListener("mousedown", startLongPress);
icondiv.addEventListener("touchstart", startLongPress);

icondiv.addEventListener("mouseup", cancelLongPress);
icondiv.addEventListener("mouseleave", cancelLongPress);
icondiv.addEventListener("touchend", cancelLongPress);
icondiv.addEventListener("touchcancel", cancelLongPress);

icondiv.addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

function startLongPress(event) {
	isLongPress = false;
	longPressTimer = setTimeout(() => {
		isLongPress = true;
		loadTopics();
		connect();
		openModal("{uniqueID}_modal");
	}, 500);
}

function cancelLongPress(event) {
	clearTimeout(longPressTimer);
}

console.log("Button Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/compressedimage/compressedimage_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/image.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/compressedimage/compressedimage_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">

	<div id="{uniqueID}_imgpreview" class="noselect compressedimage_preview">
		<img  src="assets/joypos.svg" alt="Image Preview" width="100" height="100">
	</div> 


	<div class="modal_inner noselect">
		<h3>Compressed Image</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_rotation">Rotation:</label>
		<select id="{uniqueID}_rotation" name="rotation">
			<option value="0">0 degrees</option>
			<option value="90">90 degrees</option>
			<option value="180">180 degrees</option>
			<option value="270">270 degrees</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">0.85</span>
		<input type="range" value="0.85" step="0.05" min="0.1" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<label for="{uniqueID}_width">Width (screen %):</label>
		<span id="{uniqueID}_width_value">25</span>
		<input type="range" value="25" step="1" min="5" max="100" id="{uniqueID}_width">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="500" step="0" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<p>Sending images through rosbridge may cause TCP congestion. Lower the socket throttle rate to get faster data updates, but note that other visualizers may stutter.</p>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>

	<div style="height: 180vh; width: 1px;">
		<!-- Scroll spacer-->
	</div>

</div>


================================================
FILE: vizanti_server/public/templates/compressedimage/compressedimage_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let img_offset_x = "-999";
let img_offset_y = "-999";

const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const vwToVh = vw => (vw * window.innerWidth) / window.innerHeight;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

//persistent loading, so we don't re-fetch on every update
let stock_images = {};
stock_images["loading"] = await imageToDataURL("assets/tile_loading.png");
stock_images["error"] = await imageToDataURL("assets/tile_error.png");

let image_topic = undefined;
let listener = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const rotationbox = document.getElementById("{uniqueID}_rotation");

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const canvas = document.getElementById('{uniqueID}_image');
const imgpreview = document.getElementById('{uniqueID}_imgpreview');

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');
opacitySlider.addEventListener('input', () =>  {
	opacityValue.textContent = opacitySlider.value;
	saveSettings();
});

const widthSlider = document.getElementById('{uniqueID}_width');
const widthValue = document.getElementById('{uniqueID}_width_value');
widthSlider.addEventListener('input', () =>  {
	widthValue.textContent = widthSlider.value;
	saveSettings();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

rotationbox.addEventListener("change", (event) => {
	saveSettings();
});

//Settings

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	img_offset_x = loaded_data.img_offset_x;
	img_offset_y = loaded_data.img_offset_y;

	throttle.value = loaded_data.throttle;

	opacitySlider.value = loaded_data.opacity;
	opacityValue.innerText = loaded_data.opacity;
	canvas.style.opacity = loaded_data.opacity;

	widthSlider.value = loaded_data.width;
	widthValue.innerText = loaded_data.width;
	rotationbox.value = loaded_data.rotation;

	canvas.style.transform = `translate(-50%, -50%) rotate(${loaded_data.rotation}deg)`;
	displayImageOffset(img_offset_x, img_offset_y);
}else{
	displayImageOffset(0, 100);
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		throttle: throttle.value,
		width: widthSlider.value,
		img_offset_x: img_offset_x,
		img_offset_y: img_offset_y,
		rotation: rotationbox.value
	}
	settings.save();

	canvas.style.opacity = opacitySlider.value;
	canvas.style.transform = `translate(-50%, -50%) rotate(${rotationbox.value}deg)`;
	displayImageOffset(img_offset_x, img_offset_y);
}

//Topic
async function getImage(src) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = () => resolve(src);
        img.onerror = () => reject(src);
        img.src = src;
    });
}

function connect(){

	canvas.src = stock_images["loading"];
	displayImageOffset(img_offset_x, img_offset_y);

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(image_topic !== undefined){
		image_topic.unsubscribe(listener);
	}

	status.setWarn("No data received.");

	image_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/CompressedImage',
		throttle_rate: parseInt(throttle.value)
	});
	
	let received = false;
	listener = image_topic.subscribe(async (msg) => {  
		const src = 'data:image/jpeg;base64,' + msg.data

		getImage(src)
			.then(() => {
				canvas.src = src;
				if(!received){
					displayImageOffset(img_offset_x, img_offset_y);
					status.setOK();
				}
			})
			.catch((e) => {
				canvas.src = stock_images["error"];
				displayImageOffset(img_offset_x, img_offset_y);
				status.setError(e.message);
			});
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/CompressedImage");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	connect();
});

selectionbox.addEventListener("click", connect);

icon.addEventListener("click", ()=> {
	loadTopics();
});

loadTopics();

//preview for definining position
let preview_active = false;

function onStart(event) {
	preview_active = true;
	document.addEventListener('mousemove', onMove);
	document.addEventListener('touchmove', onMove);
	document.addEventListener('mouseup', onEnd);
	document.addEventListener('touchend', onEnd);
}

function displayImageOffset(x, y){

	if(canvas.naturalWidth == 0)
		return;

	let img_width = widthSlider.value;
	let img_height = (vwToVh(img_width) * canvas.naturalHeight)/canvas.naturalWidth;

	canvas.style.width = img_width+"vw";
	canvas.style.height = img_height+"vh";

	let offset_x = clamp(x, img_width/2, 100 - img_width/2);
	let offset_y = clamp(y, img_height/2, 100 - img_height/2);

	imgpreview.style.left = offset_x+"vw";
	imgpreview.style.top = offset_y+"vh";

	canvas.style.left = offset_x+"vw";
	canvas.style.top = offset_y+"vh";
}

window.addEventListener('resize', ()=>{
	displayImageOffset(img_offset_x, img_offset_y);
});

function onMove(event) {
	if (preview_active) {
		event.preventDefault();
		let currentX, currentY;

		if (event.type === "touchmove") {
			currentX = event.touches[0].clientX;
			currentY = event.touches[0].clientY;
		} else {
			currentX = event.clientX;
			currentY = event.clientY;
		}
	
		let img_width = widthSlider.value/2;
		let img_height = (vwToVh(img_width) * canvas.naturalHeight)/canvas.naturalWidth;
	
		img_offset_x = clamp(currentX/window.innerWidth * 100, img_width, 100 - img_width);
		img_offset_y = clamp(currentY/window.innerHeight * 100, img_height, 100 - img_height);

		saveSettings();
	}
}

function onEnd() {
	preview_active = false;
	document.removeEventListener('mousemove', onMove);
	document.removeEventListener('touchmove', onMove);
	document.removeEventListener('mouseup', onEnd);
	document.removeEventListener('touchend', onEnd);
}
  
imgpreview.addEventListener('mousedown', onStart);
imgpreview.addEventListener('touchstart', onStart);

displayImageOffset(img_offset_x, img_offset_y);

console.log("Image Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/compressedimage/compressedimage_view.html
================================================
<image src="assets/tile_loading.png" id="{uniqueID}_image" alt="{uniqueID}_compresedimg" style="pointer-events: none; z-index: 14; left: -9999px;" class="compressedimage"></canvas>


================================================
FILE: vizanti_server/public/templates/folder/folder_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" style="background-color: transparent">
	<img src="assets/folder.svg" alt="?" width="50" height="50" style="opacity: 0.7" onclick="openModal('{uniqueID}_modal')">
	<object id="{uniqueID}_subicon0" class="icon-img" type="image/svg+xml" data="assets/folder.svg" alt=" " width="28" height="28" style="left: 30%;"></object>
	<object id="{uniqueID}_subicon1" class="icon-img" type="image/svg+xml" data="assets/folder.svg" alt=" " width="28" height="28" style="left: 70%;"></object>
</div>


================================================
FILE: vizanti_server/public/templates/folder/folder_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect folder_modal">

		<div id="{uniqueID}_widget_container" class="folder_icon_container">
			<div data-uniqueid="addbutton">
				<div class="icon noselect">
					<img src="assets/add.svg" alt="+" width="50" height="50" onclick="openModal('modal_add_element', '{uniqueID}_widget_container')">
				</div>
			</div>
		</div>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button">Remove Folder</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/folder/folder_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const icon_container = document.getElementById("{uniqueID}_widget_container");
const remove_button = document.getElementById("{uniqueID}_remove");

const subicons = [
	document.getElementById("{uniqueID}_subicon0"),
	document.getElementById("{uniqueID}_subicon1")
];

const observers = [];

function set_icons(){

	for(const observer of observers) {
		observer.disconnect();
	}
	observers.length = 0;

	let sources = [];
	const icon_list = icon_container.getElementsByClassName('icon');
	for(let i = 0; i < icon_list.length; i++){
		const firstChild = icon_list[i].firstElementChild;
        if (firstChild) {
            if (firstChild.tagName.toLowerCase() === 'img') {
                sources.push([firstChild, firstChild.src]);
            } else if (firstChild.tagName.toLowerCase() === 'object') {
                sources.push([firstChild, firstChild.data]);
            }
        }
	}

	for(let i = 0; i < sources.length && i < 2; i++){
		subicons[i].style.display = "none";
		if(!sources[i][1].endsWith("add.svg")){
			subicons[i].style.display = "block";

			if(subicons[i].data != sources[i][1]){
				subicons[i].data = sources[i][1];
				if(sources[i][0].hasAttribute("data-color")){
					subicons[i].onload = ()=>{
						utilModule.setIconColor(subicons[i], sources[i][0].dataset.color);
					};
				}
			}

			const observer = new MutationObserver((mutationsList) => {
				for(const mutation of mutationsList) {
					if(mutation.type === 'attributes' && mutation.attributeName === 'data-color') {
						utilModule.setIconColor(subicons[i], sources[i][0].dataset.color);
					}
				}
			});

			observer.observe(sources[i][0], {attributes: true, attributeFilter: ['data-color']});
			observers.push(observer);
		}
	}
}

//updating the two icons when any are added
const observer = new MutationObserver(set_icons);
observer.observe(icon_container, { childList: true });

//on click
icon.addEventListener("click", set_icons);

//and once after start
setTimeout(set_icons, 200);

remove_button.addEventListener('click', async () => {
	if(await confirm("Are you sure you want to delete this folder (all widgets inside it will be deleted too)?")){

		Array.from(icon_container.children).forEach(child => {
			const id = child.getAttribute('data-uniqueid');
			if(id != "addbutton"){
				removeWidget(id);
			}
		});
		removeWidget('{uniqueID}');
	}
});

console.log("Folder Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/grid/grid_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/grid.svg" alt="grid" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/grid/grid_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Grid Renderer</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<label for="{uniqueID}_autoscale">Autoscale</label>
		<!-- <input type="checkbox" checked id="{uniqueID}_autoscale"> -->
		<select id="{uniqueID}_autoscale">
			<option value="Off" selected>Off</option>
			<option value="Rough">Rough</option>
			<option value="Coarse">Coarse</option>
			<option value="Fine">Fine</option>
			<option value="Very Fine">Very Fine</option>
		</select>

		<p class="comment">If autoscale is off, the fixed size grid will stop rendering when the line density gets too high (to prevent lag).</p>

		<hr class="dark_hr"/>

		<h4>Style and Size</h4>

		<p class="comment">Renders a grid relative to the fixed frame.</p>

		<label for="{uniqueID}_step">Step (meter):</label>
		<input type="number" value="1.0" step="0.01" min="0.01" max="10000" id="{uniqueID}_step">

		<div class="spacer"></div>

		<label for="{uniqueID}_thickness">Line thickness (px):</label>
		<input type="number" value="1" step="1" min="1" max="20" id="{uniqueID}_thickness">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Color:</label>
		<input type="color" value="#3e556a" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<h4>Subdivison Style</h4>

		<p class="comment">Each step can be divided further.</p>

		<label for="{uniqueID}_subdivisions">Number of subcells per cell:</label>
		<input type="number" value="2" step="1" min="1" max="20" id="{uniqueID}_subdivisions">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Color:</label>
		<input type="color" value="#3e556a" id="{uniqueID}_colorpicker_sub">

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>



================================================
FILE: vizanti_server/public/templates/grid/grid_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('object')[0];
const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

let grid_size = 1.0;
let grid_thickness = 1;
let grid_colour = "#3e556a";
let grid_colour_sub = "#294056";
let grid_autoscale = 'Coarse';
let grid_subdivisions = 2;

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
const colourpicker_sub = document.getElementById("{uniqueID}_colorpicker_sub");
const autoscale = document.getElementById("{uniqueID}_autoscale");
const linethickness = document.getElementById("{uniqueID}_thickness");
const subdivisions = document.getElementById("{uniqueID}_subdivisions");
const gridstep = document.getElementById("{uniqueID}_step");


if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	grid_size = loaded_data.size;
	grid_thickness = loaded_data.thickness;
	grid_colour = loaded_data.colour;
	grid_colour_sub = loaded_data.colour_sub ?? "#294056"; //for legacy config compatibility
	grid_autoscale = loaded_data.autoscale ?? 'Off'; 
	grid_subdivisions = loaded_data.subdivisions ?? 1;
}else{
	saveSettings();
}

linethickness.value = grid_thickness;
colourpicker.value = grid_colour;
autoscale.value = grid_autoscale;
colourpicker_sub.value = grid_colour_sub;
gridstep.value = grid_size;
subdivisions.value = grid_subdivisions;

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}


function saveSettings(){
	settings["{uniqueID}"] = {
		size: grid_size,
		thickness: grid_thickness,
		colour: grid_colour,
		colour_sub: grid_colour_sub,
		autoscale: grid_autoscale,
		subdivisions: grid_subdivisions
	}
	settings.save();
}

function calculateScale(value) {
    const magnitude = Math.floor(Math.log10(value));
    value /= Math.pow(10, magnitude);

    if (value < 1.5) {
        value = 1.0;
    } else if (value < 3.5) {
        value = 2.0;
    } else if (value < 7.5) {
        value = 5.0;
    } else {
        value = 10.0;
    }

    value *= Math.pow(10, magnitude);
    return value;
}

/* function drawFixedLine(start_x, start_y, end_x, end_y, color, line_width) {
	ctx.beginPath();
	ctx.strokeStyle = color;
	ctx.lineWidth = line_width;

    let from = view.fixedToScreen({x: start_x, y: start_y});
    let to = view.fixedToScreen({x: end_x, y: end_y});

    ctx.moveTo(parseInt(from.x), parseInt(from.y));
    ctx.lineTo(parseInt(to.x), parseInt(to.y));

	ctx.stroke();
} */

function drawScreenLine(start_x, start_y, end_x, end_y, color, line_width) {
	ctx.beginPath();
	ctx.strokeStyle = color;
	ctx.lineWidth = line_width;
	
    ctx.moveTo(parseInt(start_x), parseInt(start_y));
    ctx.lineTo(parseInt(end_x), parseInt(end_y));

	ctx.stroke();
}

function drawGridLines(minX, minY, maxX, maxY, grid_size, subdivisions) {
    const subdivision_size = grid_size/subdivisions;
    
    // First, calculate screen positions of all grid intersections we'll need
    // This avoids recalculating the same points multiple times, fixedToScreen is kinda expensive
    const xPositions = new Map();
    const yPositions = new Map();
    
    // Calculate main grid positions
    for (let x = minX; x <= maxX; x += grid_size) {
        const screenPos = view.fixedToScreen({x: x, y: 0}).x;
        xPositions.set(x, parseInt(screenPos));
    }
    
    for (let y = minY; y <= maxY; y += grid_size) {
        const screenPos = view.fixedToScreen({x: 0, y: y}).y;
        yPositions.set(y, parseInt(screenPos));
    }

	if(subdivisions > 1)
	{
		// Calculate subdivision positions
		for (let x = minX; x <= maxX; x += grid_size) {
			for (let sub_x = 1; sub_x < subdivisions; sub_x++) {
				const cur_sub_x = x + sub_x * subdivision_size;
				const screenPos = view.fixedToScreen({x: cur_sub_x, y: 0}).x;
				xPositions.set(cur_sub_x, parseInt(screenPos));
			}
		}
		
		for (let y = minY; y <= maxY; y += grid_size) {
			for (let sub_y = 1; sub_y < subdivisions; sub_y++) {
				const cur_sub_y = y + sub_y * subdivision_size;
				const screenPos = view.fixedToScreen({x: 0, y: cur_sub_y}).y;
				yPositions.set(cur_sub_y, parseInt(screenPos));
			}
		}
	}
    
    // Draw subdivision lines
    ctx.beginPath();
    ctx.globalAlpha = 0.65;
    ctx.strokeStyle = grid_colour_sub;
    ctx.lineWidth = 1;

    // Vertical subdivisions
    for (let x = minX; x <= maxX; x += grid_size) {
        for (let sub_x = 1; sub_x < subdivisions; sub_x++) {
            const cur_sub_x = x + sub_x * subdivision_size;
            const screenX = xPositions.get(cur_sub_x);
            ctx.moveTo(screenX, 0);
            ctx.lineTo(screenX, canvas.height);
        }
    }

    // Horizontal subdivisions
    for (let y = minY; y <= maxY; y += grid_size) {
        for (let sub_y = 1; sub_y < subdivisions; sub_y++) {
            const cur_sub_y = y + sub_y * subdivision_size;
            const screenY = yPositions.get(cur_sub_y);
            ctx.moveTo(0, screenY);
            ctx.lineTo(canvas.width, screenY);
        }
    }
    
    ctx.stroke();

    // Draw main grid lines
    ctx.beginPath();
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = grid_colour;
    ctx.lineWidth = grid_thickness;

    // Vertical main lines
    for (let x = minX; x <= maxX; x += grid_size) {
        const screenX = xPositions.get(x);
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, canvas.height);
    }

    // Horizontal main lines
    for (let y = minY; y <= maxY; y += grid_size) {
        const screenY = yPositions.get(y);
        ctx.moveTo(0, screenY);
        ctx.lineTo(canvas.width, screenY);
    }

    ctx.stroke();
}

function drawGridScale(grid_size, wid, hei) {

	const xoffset = canvas.width < canvas.height? 40 : 100; //compact on vertical/mobile
	const yoffset = 40;

	// Draw scale info in bottom right corner
	const scale_to = view.screenToFixed({ x: wid-xoffset, y: hei-yoffset });
	const xscale_start = view.fixedToScreen({x: scale_to.x-grid_size, y: 0}).x;
	drawScreenLine(xscale_start, parseInt(hei-yoffset), parseInt(wid-xoffset), parseInt(hei-yoffset), grid_colour, 2);
	drawScreenLine(xscale_start, parseInt(hei-yoffset-5), xscale_start, parseInt(hei-yoffset+5), grid_colour, 2);
	drawScreenLine(parseInt(wid-xoffset), parseInt(hei-yoffset-5), parseInt(wid-xoffset), parseInt(hei-yoffset+5), grid_colour, 2);

	const line_length = parseInt(wid-xoffset) - xscale_start;

	let scale_text = String(grid_size) + ' m';
	if(grid_size >= 1000)
		scale_text = String(grid_size/1000) + ' km';
	else if(grid_size < 1)
		scale_text = String(grid_size*100) + ' cm';

	ctx.font = "16px Monospace";
	ctx.textAlign = "center";
	ctx.fillStyle = grid_colour;
	ctx.fillText(scale_text, parseInt(xscale_start + line_length/2), parseInt(hei-23));
}

async function drawGrid() {
    const wid = canvas.width;
    const hei = canvas.height;

    ctx.strokeStyle = grid_colour;
	ctx.lineWidth = grid_thickness;

	const topLeft = view.screenToFixed({ x: 0, y: 0 });
	const bottomRight = view.screenToFixed({ x: wid, y: hei });

	const width_meters = Math.abs(bottomRight.x - topLeft.x);
	const height_meters = Math.abs(bottomRight.y - topLeft.y);

	if(grid_autoscale === 'Very Fine')
		grid_size = calculateScale(Math.min(width_meters, height_meters)/21);
	else if(grid_autoscale === 'Fine')
		grid_size = calculateScale(Math.min(width_meters, height_meters)/14);
	else if(grid_autoscale === 'Coarse')
		grid_size = calculateScale(Math.min(width_meters, height_meters)/7);
	else if(grid_autoscale === 'Rough')
		grid_size = calculateScale(Math.min(width_meters, height_meters)/3);
	
	const minX = topLeft.x - (topLeft.x % grid_size) - grid_size;
	const maxX = bottomRight.x + (grid_size - (bottomRight.x % grid_size));
	
	const minY = bottomRight.y - (bottomRight.y % grid_size) - grid_size;
	const maxY = topLeft.y + (grid_size - (topLeft.y % grid_size));
	
	ctx.clearRect(0, 0, wid, hei);

	let temp_subdivisions = grid_subdivisions;

	if (grid_autoscale == 'Off') {
		let linesX = (maxX - minX) / (grid_size / (temp_subdivisions + 1));
		let linesY = (maxY - minY) / (grid_size / (temp_subdivisions + 1));
		
		// While we have too many lines and can still reduce subdivisions
		while ((linesX > 300 || linesY > 300) && temp_subdivisions > 0) {
			temp_subdivisions--;
			linesX = (maxX - minX) / (grid_size / (temp_subdivisions + 1));
			linesY = (maxY - minY) / (grid_size / (temp_subdivisions + 1));
		}
	
		// If we still have too many lines even with no subdivisions
		if (linesX > 300 || linesY > 300) {
			ctx.clearRect(0, 0, wid, hei);
			status.setWarn("Too many lines to render, increase step size");
			return;
		}
	}

    drawGridLines(minX, minY, maxX, maxY, grid_size, temp_subdivisions);

	if(grid_autoscale != 'Off'){
		drawGridScale(grid_size, wid, hei);
	}
	
	status.setOK();
}


function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawGrid();
}

window.addEventListener("view_changed", drawGrid);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

linethickness.addEventListener("input", (event) =>{
	if(linethickness.value > 20)
		grid_thickness = 20;
	else if(linethickness.value < 1)
		grid_thickness = 1;	
	else if(isNaN(linethickness.value))
		grid_thickness = 1;
	else
		grid_thickness = parseFloat(linethickness.value);	

	drawGrid();
	saveSettings();
});

gridstep.addEventListener("input", (event) =>{
	if(gridstep.value > 1000000)
		grid_size = 1000000;	
	else if(gridstep.value < 0.01)
		grid_size = 0.01;	
	else if(isNaN(gridstep.value))
		grid_size = 1.0;
	else
		grid_size = parseFloat(gridstep.value);	

	drawGrid();
	saveSettings();
});

colourpicker.addEventListener("input", (event) =>{
	grid_colour = colourpicker.value;
	utilModule.setIconColor(icon, grid_colour);
	drawGrid();
	saveSettings();
});

colourpicker_sub.addEventListener("input", (event) =>{
	grid_colour_sub = colourpicker_sub.value;
	drawGrid();
	saveSettings();
});

autoscale.addEventListener("input", (event) =>{
	grid_autoscale = autoscale.value;
	if(gridstep.value > 1000000)
		grid_size = 1000000;	
	else if(gridstep.value < 0.01)
		grid_size = 0.01;	
	else if(isNaN(gridstep.value))
		grid_size = 1.0;
	else
		grid_size = parseFloat(gridstep.value);
	
	drawGrid();
	saveSettings();
});

subdivisions.addEventListener("input", (event) =>{
	grid_subdivisions = parseInt(subdivisions.value);
	drawGrid();
	saveSettings();
});

resizeScreen();

console.log("Grid Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/grid/grid_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 1;"></canvas>


================================================
FILE: vizanti_server/public/templates/gridcells/gridcells_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/gridcells.svg" alt="gridcells" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/gridcells/gridcells_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Grid Cells</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Display a nav_msgs/GridCells message that typically represents sparse navigational obstacles.</p>

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">1.0</span>
		<input type="range" value="1.0" step="0.05" min="0.1" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#74ce6c" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="500" step="0" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<label>Use Timestamp:</label>
		<input type="checkbox" id="{uniqueID}_use_timestamp">	

		<p class="comment">Rendering fixed objects at their published timestamp causes them to lag behind when focusing on frames other than the map frame. Rviz uses the latest timestamp instead, which this emulates. Enable for techincally correct rendering.</p>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/gridcells/gridcells_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let range_topic = undefined;
let listener = undefined;

let data = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const timestampCheckbox = document.getElementById('{uniqueID}_use_timestamp');
timestampCheckbox.addEventListener('change', saveSettings);

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');
opacitySlider.addEventListener('input', () =>  {
	opacityValue.textContent = opacitySlider.value;
	saveSettings();
	drawCells();
});

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawCells();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	opacitySlider.value = loaded_data.opacity;
	opacityValue.innerText = loaded_data.opacity;

	timestampCheckbox.checked = loaded_data.use_timestamp ?? false;

	colourpicker.value = loaded_data.color;
	throttle.value = loaded_data.throttle ?? 100;
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}


function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		color: colourpicker.value,
		throttle: throttle.value,
		use_timestamp: timestampCheckbox.checked
	}
	settings.save();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

async function drawCells() {

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	if(!data){
		return;
	}

	ctx.globalAlpha = opacitySlider.value;
	ctx.fillStyle = colourpicker.value;

	let tf_pose = timestampCheckbox.checked ? data.pose : tf.absoluteTransforms[data.msg.header.frame_id];

	if(!tf_pose){
		return;
	}

	const pos = view.fixedToScreen({
		x: tf_pose.translation.x,
		y: tf_pose.translation.y,
	});

	const matrix = view.quaterionToProjectionMatrix(tf_pose.rotation);
	ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], pos.x, pos.y); //sx,0,0,sy,px,py
	ctx.scale(1.0, -1.0);

	const unit = view.getMapUnitsInPixels(1.0);
	const wid = Math.abs(data.msg.cell_width) * unit;
	const hei = Math.abs(data.msg.cell_height) * unit;

	ctx.beginPath();
	for(let i = 0; i < data.msg.cells.length; i++){
		const x = data.msg.cells[i].x * unit - wid / 2 + 1;
		const y = data.msg.cells[i].y * unit - hei / 2 + 1;
		ctx.moveTo(x, y);
		ctx.lineTo(x + wid - 1, y);
		ctx.lineTo(x + wid - 1, y + hei - 1);
		ctx.lineTo(x, y + hei - 1);
		ctx.lineTo(x, y);
	}
	ctx.fill();
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawCells();
}

window.addEventListener("tf_fixed_frame_changed", drawCells);
window.addEventListener("tf_changed", ()=>{
	if (data && data.msg.frame_id != tf.fixed_frame){
		drawCells();
	}
});

window.addEventListener("view_changed", drawCells);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

//Topic

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}
	
	if(range_topic !== undefined){
		range_topic.unsubscribe(listener);
	}

	range_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'nav_msgs/msg/GridCells',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	
	listener = range_topic.subscribe((msg) => {	

		if(msg.cells === undefined || msg.cells.length == 0){
			status.setWarn("Received empty grid. Oh no! Anyway...");
			data = undefined;
			drawCells();
			return;
		}

		if(msg.cell_width == 0 | msg.cell_height == 0){
			status.setError("Grid cell size must be nonzero, received width="+msg.cell_width+" height="+msg.cell_height+".");
			data = undefined;
			drawCells();
			return;
		}

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		const pose = tf.absoluteTransforms[msg.header.frame_id];

		if(!pose){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			data = undefined;
			drawCells();
			return;
		}

		data = {};
		data.pose = pose;
		data.msg = msg		
		drawCells();

		if(!error){
			status.setOK();
		}
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("nav_msgs/msg/GridCells");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	data = undefined;
	connect();
});

selectionbox.addEventListener("click", connect);
click_icon.addEventListener("click", loadTopics);

loadTopics();
resizeScreen();

console.log("Gridcells Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/gridcells/gridcells_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 10;"></canvas>


================================================
FILE: vizanti_server/public/templates/initialpose/initialpose_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/initialpose.svg" alt="model" width="50" height="50">
</div> 


================================================
FILE: vizanti_server/public/templates/initialpose/initialpose_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>2D Pose Estimate</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<option value="/initialpose">/initialpose</option>
		</select>

		<p>Initialize the localization system by sending a starting geometry_msgs/PoseStamped in the global fixed frame.</p>

		<p style="color:#b4b4b4;">Click the icon once to enable, drag on the view area and release to publish. Long press the icon to open this menu.</p>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/initialpose/initialpose_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
}else{
	saveSettings();
}

if(topic == ""){
	topic = "/initialpose";
	status.setWarn("No topic found, defaulting to /initialpose");
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic
	}
	settings.save();
}

function sendMessage(pos, delta){
	if(!pos || !delta){
		status.setError("Could not send message, pose invalid.");
		return;
	}

	let yaw = Math.atan2(delta.y, -delta.x);
	let quat = Quaternion.fromEuler(yaw, 0, 0, 'ZXY');

	let map_pos = view.screenToFixed(pos);

	const currentTime = new Date();
	const currentTimeSecs = Math.floor(currentTime.getTime() / 1000);
	const currentTimeNsecs = (currentTime.getTime() % 1000) * 1e6;

	const publisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: 'geometry_msgs/msg/PoseWithCovarianceStamped',
	});

	const poseMessage = new ROSLIB.Message({
		header: {
			stamp: {
				sec: currentTimeSecs,
				nanosec: currentTimeNsecs
			},
			frame_id: tf.fixed_frame
		},
		pose: {
			pose: {
				position: {
					x: map_pos.x,
					y: map_pos.y,
					z: 0.0
				},
				orientation: {
					x: quat.x,
					y: quat.y,
					z: quat.z,
					w: quat.w
				}
			},
			covariance: [0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.25, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06853892326654787]
		}
	});	
	publisher.publish(poseMessage);

	status.setOK();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const view_container = document.getElementById("view_container");
const icon = document.getElementById("{uniqueID}_icon");

let active = false;
let sprite = new Image();
let start_point = undefined;
let delta = undefined;
sprite.src = "assets/initialpose.png";

function drawArrow() {
    const wid = canvas.width;
    const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, wid, hei);

	if(delta){
		let ratio = sprite.naturalHeight/sprite.naturalWidth;
		ctx.setTransform(1,0,0,1,start_point.x, start_point.y); //sx,0,0,sy,px,py
		ctx.rotate(Math.atan2(-delta.y, -delta.x));
		ctx.drawImage(sprite, -80, -80*ratio, 160, 160*ratio);
	}
}

function startDrag(event){
	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	start_point = {
		x: clientX,
		y: clientY
	};
}

function drag(event){
	if (start_point === undefined) return;

	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	delta = {
		x: start_point.x - clientX,
		y: start_point.y - clientY,
	};

	drawArrow();	
}

function endDrag(event){
	sendMessage(start_point, delta);

	start_point = undefined;
	delta = undefined;
	drawArrow();
	setActive(false);
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
}

window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

function addListeners(){
	view_container.addEventListener('mousedown', startDrag);
	view_container.addEventListener('mousemove', drag);
	view_container.addEventListener('mouseup', endDrag);

	view_container.addEventListener('touchstart', startDrag);
	view_container.addEventListener('touchmove', drag);
	view_container.addEventListener('touchend', endDrag);	
}

function removeListeners(){
	view_container.removeEventListener('mousedown', startDrag);
	view_container.removeEventListener('mousemove', drag);
	view_container.removeEventListener('mouseup', endDrag);

	view_container.removeEventListener('touchstart', startDrag);
	view_container.removeEventListener('touchmove', drag);
	view_container.removeEventListener('touchend', endDrag);	
}

function setActive(value){
	active = value;
	view.setInputMovementEnabled(!active);

	if(active){
		addListeners();
		icon.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
		view_container.style.cursor = "pointer";
	}else{
		removeListeners()
		icon.style.backgroundColor = "rgba(124, 124, 124, 0.3)";
		view_container.style.cursor = "";
	}
}

// Topics

const selectionbox = document.getElementById("{uniqueID}_topic");

async function loadTopics(){
	let result = await rosbridge.get_topics("geometry_msgs/msg/PoseWithCovarianceStamped");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(result.includes(topic)){
		selectionbox.value = topic;
	}else{
		topiclist += "<option value='"+topic+"'>"+topic+"</option>"
		selectionbox.innerHTML = topiclist
		selectionbox.value = topic;
	}
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
	status.setOK();
});

loadTopics();

// Long press modal open stuff

let longPressTimer;
let isLongPress = false;

icon.addEventListener("click", (event) =>{
	if(!isLongPress)
		setActive(!active);
	else
		isLongPress = false;
});

icon.addEventListener("mousedown", startLongPress);
icon.addEventListener("touchstart", startLongPress);

icon.addEventListener("mouseup", cancelLongPress);
icon.addEventListener("mouseleave", cancelLongPress);
icon.addEventListener("touchend", cancelLongPress);
icon.addEventListener("touchcancel", cancelLongPress);

icon.addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

function startLongPress(event) {
	isLongPress = false;
	longPressTimer = setTimeout(() => {
		isLongPress = true;
		loadTopics();
		openModal("{uniqueID}_modal");
	}, 500);
}

function cancelLongPress(event) {
	clearTimeout(longPressTimer);
}

resizeScreen();

console.log("Initialpose Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/initialpose/initialpose_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 6;"></canvas>


================================================
FILE: vizanti_server/public/templates/inspector/inspector_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/inspector.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/inspector/inspector_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Topic Inspector</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>

		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here -->
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="500" step="0" min="0" max="10000" id="{uniqueID}_throttle">

		<h4>Info</h4>

		<p class="comment">Information about publishers and subscribers.</p>

		<div id="{uniqueID}_info_display" class="live_data_display">
			<!-- add sub/pub info here -->
		</div>

		<h4>Echo</h4>

		<p class="comment">View raw messages as text for debugging.</p>

		<div id="{uniqueID}_live_data_display" class="live_data_display">
			<!-- add params here -->
		</div>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/inspector/inspector_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const info_div = document.getElementById("{uniqueID}_info_display");
const live_data_div = document.getElementById("{uniqueID}_live_data_display");

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	throttle.value = loaded_data.throttle;
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		throttle: throttle.value
	}
	settings.save();
}

let listener = undefined;
let topicobj = undefined;
let topic_type = await getTopicType();

let prevtopic = undefined;

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(topicobj !== undefined){
		topicobj.unsubscribe(listener);
	}

	topicobj = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : topic_type,
		throttle_rate: parseInt(throttle.value)
	});

	status.setWarn("No data received.");

	if(prevtopic != topic){
		//clear data when the topic changes
		live_data_div.innerHTML = '<p>Waiting for data...</p>';
		info_div.innerHTML = '<p>Waiting for data...</p>';
		prevtopic = topic;
	}

	listener = topicobj.subscribe(async (msg) => {

		function createNestedDisplay(obj, indent = 0) {
			const container = document.createElement('div');
			const indentSize = 20; // pixels per level of indentation
			const maxStringLength = 200; // maximum length for string values
			const maxArrayLength = 50; // maximum number of array items to display
			
			// Helper function to truncate strings
			const truncateString = (str) => {
				if (typeof str !== 'string') return str;
				if (str.length <= maxStringLength) return str;
				return str.substring(0, maxStringLength) + '... [truncated]';
			};
			
			Object.entries(obj).forEach(([key, value]) => {
				const p = document.createElement('p');
				p.style.marginLeft = `${indent * indentSize}px`;
				p.style.marginTop = '2px';
				p.style.marginBottom = '2px';
				
				if (Array.isArray(value)) {
					// Handle arrays
					p.textContent = `${key}: Array(${value.length})`;
					container.appendChild(p);
					
					// Truncate array if too long
					const displayArray = value.length > maxArrayLength 
						? value.slice(0, maxArrayLength) 
						: value;
					
					displayArray.forEach((item, index) => {
						const arrayItem = document.createElement('p');
						arrayItem.style.marginLeft = `${(indent + 1) * indentSize}px`;
						arrayItem.style.marginTop = '2px';
						arrayItem.style.marginBottom = '2px';
						
						if (typeof item === 'object' && item !== null) {
							// Recursive call for objects within arrays
							const nestedContent = createNestedDisplay(item, indent + 2);
							container.appendChild(nestedContent);
						} else {
							arrayItem.textContent = `[${index}]: ${truncateString(item)}`;
							container.appendChild(arrayItem);
						}
					});
					
					if (value.length > maxArrayLength) {
						const omitted = document.createElement('p');
						omitted.style.marginLeft = `${(indent + 1) * indentSize}px`;
						omitted.style.marginTop = '2px';
						omitted.style.marginBottom = '2px';
						omitted.textContent = `... ${value.length - maxArrayLength} more items`;
						container.appendChild(omitted);
					}
					
				} else if (typeof value === 'object' && value !== null) {
					// Handle nested objects
					p.textContent = `${key}:`;
					container.appendChild(p);
					const nestedContent = createNestedDisplay(value, indent + 1);
					container.appendChild(nestedContent);
					
				} else {
					// Handle primitive values
					p.textContent = `${key}: ${truncateString(value)}`;
					container.appendChild(p);
				}
			});
			
			return container;
		}
		
		live_data_div.innerHTML = '';
		live_data_div.appendChild(createNestedDisplay(msg));

		let results = await rosbridge.get_topic_publishers_and_subscribers(topic);
		info_div.innerHTML = '';
		info_div.appendChild(createNestedDisplay(results));
		
		status.setOK();
	});

	saveSettings();
}

async function getTopicType(){
	let results = await rosbridge.get_all_topics();
	for (let i = 0; i < results.topics.length; i++) {
		if(results.topics[i] == topic)
			return results.types[i]
	}
	return undefined;
}

async function loadTopics(){
	let results = await rosbridge.get_all_topics();

	let topiclist = "";
	for (let i = 0; i < results.topics.length; i++) {
		topiclist += `<option value='${results.topics[i]}'>${results.topics[i]} (${results.types[i]})</option>`;
	}
	selectionbox.innerHTML = topiclist

	if(topic == ""){
		topic = selectionbox.value;
		topic_type = getTopicType();
	}else{
		if(results.topics.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", async (event) => {
	topic = selectionbox.value;
	topic_type = await getTopicType();
	connect();
	saveSettings();
});

selectionbox.addEventListener("click", connect);
icon.addEventListener("click", loadTopics);

loadTopics();

console.log("Inspector Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/map/map_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/map.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/map/map_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Map</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Display a nav_msgs/OccupancyGrid message that typically represents a 2D map or navigational costmap.</p>
		<div class="spacer"></div>

		<label for="{uniqueID}_colour_scheme">Colour scheme:</label>
		<select id="{uniqueID}_colour_scheme">
		  <option value="map">Map</option>
		  <option value="costmap">Costmap</option>
		  <option value="raw">Raw</option>
		  <option value="raw_transparent">Raw Transparent</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">0.7</span>
		<input type="range" value="0.7" step="0.05" min="0.0" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="1000" step="0" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<label>Use Timestamp:</label>
		<input type="checkbox" id="{uniqueID}_use_timestamp">	

		<p class="comment">Rendering maps at their published timestamp causes them to lag behind when focusing on frames other than the map frame. Rviz uses the latest timestamp instead, which this emulates. Enable for techincally correct rendering.</p>

		<div class="spacer"></div>

		<h4>Management</h4>

		<p class="comment">Relay services for calling map loading and saving nodes.</p>

		<i>💾 map_saver</i>
		<div class="spacer"></div>

		<label for="{uniqueID}_savepath">Save to path:</label>
		<input id="{uniqueID}_savepath" type="text" value="~/.ros/map">
		<div class="spacer"></div>

		<button id="{uniqueID}_save">Save</button>

		<div class="spacer"></div>

		<i>🖶 map_server</i>
		<div class="spacer"></div>

		<label for="{uniqueID}_loadpath">Load from path:</label>
		<input id="{uniqueID}_loadpath" type="text" value="~/.ros/map">

		<div class="spacer"></div>


		<label for="{uniqueID}_loadtopic">Publish on topic:</label>
		<input id="{uniqueID}_loadtopic" type="text" value="/map">

		<div class="spacer"></div>

		<button id="{uniqueID}_load">Load</button>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/map/map_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let paramsModule = await import(`${base_url}/ros_launch_params`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;
let params = paramsModule.default;


async function saveMap(save_path, topic) {
	const saveMapService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/save_map",
		serviceType: "vizanti_msgs/srv/SaveMap",
	});

	const request = new ROSLIB.ServiceRequest({
		file_path: save_path,
		topic: topic
	});

	return new Promise((resolve, reject) => {
		saveMapService.callService(request, (result) => {
			resolve(result);
		}, (error) => {
			reject(error);
		});
	});
}

async function loadMap(load_path, topic) {
	const loadMapService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/load_map",
		serviceType: "vizanti_msgs/srv/LoadMap",
	});

	const request = new ROSLIB.ServiceRequest({
		file_path: load_path,
		topic: topic,
	});

	return new Promise((resolve, reject) => {
		loadMapService.callService(request, (result) => {
			resolve(result);
		}, (error) => {
			reject(error);
		});
	});
}

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let icons = {};
icons["map"] = await imageToDataURL("assets/map.svg");
icons["costmap"] = await imageToDataURL("assets/costmap.svg");
icons["raw"] = await imageToDataURL("assets/rawmap.svg");
icons["raw_transparent"] = await imageToDataURL("assets/rawmap_transparent.svg");

let listener = undefined;
let map_topic = undefined;
let map_data = undefined;
let new_map_data = undefined;

let received_msg = undefined;

//firefox bug workaround
const temp_canvas = document.createElement('canvas');

const worker_thread = new Worker(`${base_url}/templates/map/map_worker.js`);
const map_canvas = document.createElement('canvas');

//offscreen rendering is currently half broken in firefox
//https://bugzilla.mozilla.org/show_bug.cgi?id=1833496
const offscreen_canvas = map_canvas.transferControlToOffscreen();
worker_thread.postMessage({	canvas: offscreen_canvas}, [offscreen_canvas]);

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');

function setOpacityText(val){
	if(val == 0.0)
		opacityValue.textContent = "0.0 (Map rendering disabled)";
	else
		opacityValue.textContent = val;
}

opacitySlider.addEventListener('input', () =>  {
	setOpacityText(opacitySlider.value)
	saveSettings();
	drawMap();
});


const loadPathBox = document.getElementById("{uniqueID}_loadpath");
const loadTopicBox = document.getElementById("{uniqueID}_loadtopic");
const savePathBox = document.getElementById("{uniqueID}_savepath");
const loadButton = document.getElementById('{uniqueID}_load');
const saveButton = document.getElementById('{uniqueID}_save');

//rendring colour modes: 0 = map, 1 = costmap, 2 = raw
const colourSchemeBox = document.getElementById('{uniqueID}_colour_scheme');
colourSchemeBox.selectedIndex = topic.includes("cost") ? 1 : 0;
colourSchemeBox.addEventListener('change', saveSettings);

const timestampCheckbox = document.getElementById('{uniqueID}_use_timestamp');
timestampCheckbox.addEventListener('change', saveSettings);

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

loadButton.addEventListener('click',  async () => {
	let path = loadPathBox.value;

	if (path.endsWith(".pgm")) {
		path = path.slice(0, -4) + ".yaml";
	} else if (!path.endsWith(".yaml")) {
		path += ".yaml";
	}

	loadPathBox.value = path;

	try {
		const result = await loadMap(path, loadTopicBox.value);
		alert(result.message);
	} catch (error) {
		alert(error);
	}
});

saveButton.addEventListener('click', async () => {
	let path = savePathBox.value;

	if (path.endsWith(".pgm")) {
		path = path.slice(0, -4);
	} else if (path.endsWith(".yaml")) {
		path = path.slice(0, -5);
	}

	savePathBox.value = path;

	try {
		const result = await saveMap(path, topic);
		alert(result.message);
	} catch (error) {
		alert(error);
	}
});

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	opacitySlider.value = loaded_data.opacity;
	setOpacityText(loaded_data.opacity);

	if(loaded_data.costmap_mode !== undefined){
		colourSchemeBox.selectedIndex = loaded_data.costmap_mode ? 1 : 0;
	}else{
		colourSchemeBox.selectedIndex = loaded_data.colour_scheme > 0 ? loaded_data.colour_scheme: 0;
	}

	timestampCheckbox.checked = loaded_data.use_timestamp ?? false;
	throttle.value = loaded_data.throttle ?? 1000;
}else{
	saveSettings();
}

icon.src = icons[colourSchemeBox.value];

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		colour_scheme: colourSchemeBox.selectedIndex,
		throttle: throttle.value,
		use_timestamp: timestampCheckbox.checked
	}
	settings.save();
}

//Rendering

async function drawMap(){

	if(!map_data)
		return;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.imageSmoothingEnabled = false;

	if(opacitySlider.value == 0.0)
		return;

	const map_width = view.getMapUnitsInPixels(
		temp_canvas.width * map_data.info.resolution
	);

	const map_height = view.getMapUnitsInPixels(
		temp_canvas.height * map_data.info.resolution
	);

	let tf_pose = map_data.pose;

	if(!timestampCheckbox.checked){
		tf_pose = tf.transformPose(
			map_data.header.frame_id,
			tf.fixed_frame,
			map_data.info.origin.position,
			map_data.info.origin.orientation
		);
	}

	const pos = view.fixedToScreen({
		x: tf_pose.translation.x,
		y: tf_pose.translation.y,
	});

	const matrix = view.quaterionToProjectionMatrix(tf_pose.rotation);

	ctx.globalAlpha = opacitySlider.value;
	ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], pos.x, pos.y); //sx,0,0,sy,px,py
	ctx.scale(1.0, -1.0);
	ctx.drawImage(temp_canvas, 0, 0, map_width, map_height);
}

//Topic

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(map_topic !== undefined){
		map_topic.unsubscribe(listener);
	}

	map_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'nav_msgs/msg/OccupancyGrid',
		throttle_rate: parseInt(throttle.value), // throttle to once every two seconds max
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");

	worker_thread.onmessage = (e) => {
		setTimeout(()=>{

			const img = e.data.image
			temp_canvas.width = img.width
			temp_canvas.height = img.height
			temp_canvas.getContext('2d', { colorSpace: 'srgb' }).putImageData(img, 0, 0);
			map_data = new_map_data;
			drawMap();
			status.setOK();
		},12);
	};
	
	listener = map_topic.subscribe((msg) => {

		if(msg.info.width == 0 || msg.info.height == 0){
			status.setWarn("Received empty map.");
			return;
		}

		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
		}

		if(!tf.absoluteTransforms[msg.header.frame_id]){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		queueWorkerMsg(msg);
		received_msg = msg;
	});

	saveSettings();
}

function queueWorkerMsg(msg){
	msg.pose = tf.transformPose(
		msg.header.frame_id,
		tf.fixed_frame,
		msg.info.origin.position,
		msg.info.origin.orientation
	);

	new_map_data = msg;
	map_data = undefined;

	worker_thread.postMessage({
		map_msg: msg,
		colour_scheme: colourSchemeBox.value,
	});
}

async function loadTopics(){
	let result = await rosbridge.get_topics("nav_msgs/msg/OccupancyGrid");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

colourSchemeBox.addEventListener("change", (event) => {
	icon.src = icons[colourSchemeBox.value];
	queueWorkerMsg(received_msg);
});

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;

	map_data = undefined;
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.imageSmoothingEnabled = false;

	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawMap();
}

window.addEventListener("tf_fixed_frame_changed", drawMap);
window.addEventListener("tf_changed", ()=>{
	if(received_msg && received_msg.header.frame_id != tf.fixed_frame){
		drawMap();
	}
});

window.addEventListener("view_changed", drawMap);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("Map Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/map/map_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: -5;"></canvas>


================================================
FILE: vizanti_server/public/templates/map/map_worker.js
================================================
let canvas = undefined

self.addEventListener('message', function(event) {

    if(event.data.canvas){
        canvas = event.data.canvas;
        return;
    }

    const msg = event.data.map_msg;
    const colour_scheme = event.data.colour_scheme;

    const width = msg.info.width;
    const height = msg.info.height;

    canvas.width = width;
    canvas.height = height;

    const mapctx = canvas.getContext('2d', { colorSpace: 'srgb' });
    
    const data = msg.data;
    
    let map_img = mapctx.createImageData(width, height);
    
    if(colour_scheme == "costmap")
    {
        // Iterate through the data array and set the canvas pixel colors
        for (let i = 0; i < data.length; i++) {
            let occupancyValue = data[i];
            if(occupancyValue < 0)
                occupancyValue += 256;

            let color = [0, 255, 0, 0]; // Green for illegal positive values
        
            if (occupancyValue === 0) {
                color = [0, 0, 0, 0]; // Black for value 0
            } else if (occupancyValue >= 1 && occupancyValue <= 98) {
                let v = (255 * occupancyValue) / 100;
                color = [v, 0, 255 - v, 255]; // Gradient from blue to green
            } else if (occupancyValue === 99) {
                color = [0, 255, 255, 255]; // Cyan for obstacle values
            } else if (occupancyValue === 100) {
                color = [255, 0, 255, 255]; // Purple for lethal obstacle values
            } else if (occupancyValue < 0) {
                color = [0x70, 0x89, 0x86, 15]; // Legal negative value -1
            }
        
            map_img.data[i * 4] = color[0]; // R
            map_img.data[i * 4 + 1] = color[1]; // G
            map_img.data[i * 4 + 2] = color[2]; // B
            map_img.data[i * 4 + 3] = color[3]; // A
        }
    }
    else if(colour_scheme == "map")
    {
        for (let i = 0; i < data.length; i++) {
            let occupancyValue = data[i];
            if(occupancyValue < 0)
                occupancyValue += 256;
            
            let color = [255, 255, 255, 255]; // White for clear
            if (occupancyValue >= 0 && occupancyValue <= 100) {
                let v = 255 - (255 * occupancyValue) / 100;
                color = [v, v, v, 255];
            } else if (occupancyValue < 0) {
                color = [0x70, 0x89, 0x86, 30]; // Legal negative value -1
            } else if (occupancyValue > 100) {
                color = [0, 255, 0, 30]; // Illegal positive value
            }
        
            map_img.data[i * 4] = color[0]; // R
            map_img.data[i * 4 + 1] = color[1]; // G
            map_img.data[i * 4 + 2] = color[2]; // B
            map_img.data[i * 4 + 3] = color[3]; // A
        }
    }
    else if(colour_scheme == "raw_transparent")
    {
        for (let i = 0; i < data.length; i++) {
            let val = data[i];

            if(val < 0)
                val += 256;

            map_img.data[i * 4] = val; // R
            map_img.data[i * 4 + 1] = val; // G
            map_img.data[i * 4 + 2] = val; // B
            map_img.data[i * 4 + 3] = 255-val; // A
        }
    }
    else
    {
        for (let i = 0; i < data.length; i++) {
            let val = data[i];

            if(val < 0)
                val += 256;

            map_img.data[i * 4] = val; // R
            map_img.data[i * 4 + 1] = val; // G
            map_img.data[i * 4 + 2] = val; // B
            map_img.data[i * 4 + 3] = 255; // A
        }
    }

    //mapctx.putImageData(map_img, 0, 0);

    self.postMessage({image: map_img});

}, false);


================================================
FILE: vizanti_server/public/templates/markerarray/markerarray_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/markerarray.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/markerarray/markerarray_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Marker Array</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Render primitive shapes to the 2D view. Note that not all marker types are currently supported (yet!).</p>

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="100" step="1" min="0" max="10000" id="{uniqueID}_throttle">


		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/markerarray/markerarray_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let listener = undefined;
let marker_topic = undefined;

let markers = {};

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	throttle.value = loaded_data.throttle ?? 100;
}else{
	saveSettings();
}


function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		throttle: throttle.value
	}
	settings.save();
}

//Rendering

/* 
Header header                        # header for time/frame information
string ns                            # Namespace to place this object in... used in conjunction with id to create a unique name for the object
int32 id                           # object ID useful in conjunction with the namespace for manipulating and deleting the object later
int32 type                         # Type of object
int32 action                         # 0 add/modify an object, 1 (deprecated), 2 deletes an object, 3 deletes all objects
geometry_msgs/Pose pose                 # Pose of the object
geometry_msgs/Vector3 scale             # Scale of the object 1,1,1 means default (usually 1 meter square)
std_msgs/ColorRGBA color             # Color [0.0-1.0]
duration lifetime                    # How long the object should last before being automatically deleted.  0 means forever
bool frame_locked                    # If this marker should be frame-locked, i.e. retransformed into its frame every timestep

#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
geometry_msgs/Point[] points
#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
#number of colors must either be 0 or equal to the number of points
#NOTE: alpha is not yet used
std_msgs/ColorRGBA[] colors

# NOTE: only used for text markers
string text

# NOTE: only used for MESH_RESOURCE markers
string mesh_resource
bool mesh_use_embedded_materials */

function rgbaToFillColor(rosColorRGBA) {

	if(rosColorRGBA === undefined)
		return `white`;

	// Clamp the RGBA values between 0 and 1
	const r = Math.min(Math.max(rosColorRGBA.r, 0), 1);
	const g = Math.min(Math.max(rosColorRGBA.g, 0), 1);
	const b = Math.min(Math.max(rosColorRGBA.b, 0), 1);
	const a = Math.min(Math.max(rosColorRGBA.a, 0), 1);
  
	// Convert the RGBA values from the range [0, 1] to the range [0, 255]
	const r255 = Math.round(r * 255);
	const g255 = Math.round(g * 255);
	const b255 = Math.round(b * 255);
  
	// Return the RGBA color string for HTML canvas context
	return `rgba(${r255}, ${g255}, ${b255}, ${a})`;
}

async function drawMarkers(){

	function drawCircle(marker, size){
		ctx.scale(marker.scale.x, marker.scale.y);
		ctx.beginPath();
		ctx.arc(0, 0, size/2, 0, 2 * Math.PI, false);
		ctx.fill();
	}

	function drawCube(marker, size){
		ctx.scale(marker.scale.x, marker.scale.y);
		ctx.fillRect(-size/2, -size/2, size, size);
	}

	function drawArrow(marker, size){
		const height = parseInt(size*marker.scale.x);
		const width = parseInt(size*0.2*marker.scale.y)+1;
		const tip = parseInt(size*0.3*marker.scale.x)+1;
		const tipwidth = parseInt(size*0.6*marker.scale.y)+1;

		ctx.beginPath();
		ctx.moveTo(0, -width);
		ctx.lineTo(height - tip, -width);
		ctx.lineTo(height - tip, -tipwidth);
		ctx.lineTo(height, 0);
		ctx.lineTo(height - tip, tipwidth);
		ctx.lineTo(height - tip, width);
		ctx.lineTo(0, width);
		ctx.lineTo(0, -width);
		ctx.fill();
	}

	function drawLine(marker, size){
		ctx.lineWidth = parseInt(marker.scale.x*size);
		ctx.strokeStyle = rgbaToFillColor(marker.colors[0]); // for now

		ctx.beginPath();
		marker.points.forEach((point, index) => {
			const x = point.x * size;
			const y = -point.y * size;
			if (index === 0) {
				ctx.moveTo(x, y);
			} else {
				ctx.lineTo(x, y);
			}
		});

		ctx.stroke();
	}

	function drawText(marker, size){
		ctx.scale(0.1, 0.1);

		ctx.font = (marker.scale.z*10.0*size)+"px Monospace";
		ctx.textAlign = "center";
		ctx.fillStyle = rgbaToFillColor(marker.color);
	
		ctx.strokeStyle = "#161B21";
		ctx.lineWidth = 0.3*size;

		ctx.translate(0, marker.scale.z*size*2.0);
		ctx.strokeText(marker.text, 0, 0);
		ctx.fillText(marker.text, 0, 0);
	}

	const unit = view.getMapUnitsInPixels(1.0);

	const wid = canvas.width;
    const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, wid, hei);

	let current_time = new Date();

	for (const [key, marker] of Object.entries(markers)) {
		ctx.fillStyle = rgbaToFillColor(marker.color);

		const frame = tf.absoluteTransforms[marker.header.frame_id];

		if(!frame)
			continue;

		//skip old markers
		if((current_time - marker.stamp)/1000.0 > marker.lifetime.sec + marker.lifetime.nanosec*1e-9)
			continue;

		const pos = view.fixedToScreen({
			x: marker.transformed.translation.x,
			y: marker.transformed.translation.y
		});

		const matrix = view.quaterionToProjectionMatrix(marker.transformed.rotation);
		ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], pos.x, pos.y); //sx,0,0,sy,px,py

		switch(marker.type)
		{
			case 0: drawArrow(marker, unit); break;//ARROW=0
			case 1: drawCube(marker, unit);break;//CUBE=1
			case 2: 
			case 3: drawCircle(marker, unit); break; //SPHERE=2 CYLINDER=3
			case 4: drawLine(marker, unit); break; //LINE_STRIP=4
			case 5: status.setWarn("LINE_LIST markers are not supported yet."); break; //LINE_LIST=5
			case 6: status.setWarn("CUBE_LIST markers are not supported yet."); break; //CUBE_LIST=6
			case 7: status.setWarn("SPHERE_LIST markers are not supported yet."); break; //SPHERE_LIST=7
			case 8: status.setWarn("POINTS markers are not supported yet."); break; //POINTS=8
			case 9: drawText(marker, unit); break;//TEXT_VIEW_FACING=9
			case 10: status.setWarn("MESH_RESOURCE markers are not supported yet."); break; //MESH_RESOURCE=10
			case 11: status.setWarn("TRIANGLE_LIST markers are not supported yet."); break; //TRIANGLE_LIST=11
		}
	}
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(marker_topic !== undefined){
		marker_topic.unsubscribe(listener);
	}

	marker_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'visualization_msgs/msg/MarkerArray',
		compression: rosbridge.compression,
		throttle_rate: parseInt(throttle.value)
	});

	status.setWarn("No data received.");
	
	listener = marker_topic.subscribe((msg) => {

		let error = false;
		msg.markers.forEach(m => {
			if(m.action == 3){
				markers = {};
				return;
			}
			const id = m.ns + m.id;
			if(m.action == 2){
				if(markers.hasOwnProperty(id)){
					delete markers[id];
				}
				return;
			}

			const q = m.pose.orientation;
			if(q.x == 0 && q.y == 0 && q.z == 0 && q.w == 0){
				m.pose.orientation = new Quaternion();
			}

			if(m.header.frame_id == ""){
				status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
				m.header.frame_id = tf.fixed_frame;
				error = true;
			}
		
			m.transformed = tf.transformPose(
				m.header.frame_id, 
				tf.fixed_frame, 
				m.pose.position, 
				m.pose.orientation
			);

			m.stamp = new Date();	
			markers[id] = m;
		});

		if(!error){
			status.setOK();
		}
		drawMarkers();
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("visualization_msgs/msg/MarkerArray");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	markers = {};
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawMarkers();
}

window.addEventListener("tf_fixed_frame_changed", drawMarkers);
window.addEventListener("view_changed", drawMarkers);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("MarkerArray Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/markerarray/markerarray_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 3;"></canvas>


================================================
FILE: vizanti_server/public/templates/nodemgr/nodemgr_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/nodemgr.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/nodemgr/nodemgr_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Node Manager</h3>
		<hr class="dark_hr"/>

		<b>Launch Node:</b>

		<div class="spacer"></div>

		<select id="{uniqueID}_type">
			<option value="ros2 run">ros2 run</option>
			<option value="ros2 launch">ros2 launch</option>
		</select>


		<input list="{uniqueID}_package_datalist" id="{uniqueID}_package" class="datalist_input">
		<datalist id="{uniqueID}_package_datalist">
			<!--Add packages here-->
		</datalist>


		<select id="{uniqueID}_name">
			<!--Add nodes here-->
		</select>

		<p style="color: lightgray">Note: Package executable detection is experimental so not all or too many files might show up.</p>

		<div class="spacer"></div>

		<button id="{uniqueID}_execute">Execute</button>

		<div class="spacer"></div>

		<hr class="dark_hr"/>
		<b>Diagnostics:</b>

		<div class="spacer"></div>

		<button id="{uniqueID}_roswtf">ros2 doctor</button>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<b>Running Nodes:</b>
		<div class="spacer"></div>
		<div id="{uniqueID}_nodelist">
			
		</div>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>

<div id="{uniqueID}_contextmodal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3 id="{uniqueID}_context_title"></h3>
		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<p id="{uniqueID}_rosnode_lifecycle" style="color:lightgray">Lifecycle status: Not a lifecycle node.</p>

		<br>

		<p id="{uniqueID}_rosnode_info" style="color:lightgray">Waiting for ros2 node info...</p>
		
		<hr class="dark_hr"/>

		<p>Note that if a node is set to respawn, it'll automatically restart itself. Also given that ros 2 has no way of shutting down nodes, it may seem like killed nodes are running for a while after they died until the node list polls again.</p>

		<button id="{uniqueID}_nodekill" style="background-color: rgb(131, 17, 17);">Kill node</button>
	</div>
</div>


<div id="{uniqueID}_roswtfmodal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Doctor Diagnostics</h3>
		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<p id="{uniqueID}_roswtf_data" style="color:lightgray">Waiting for doctor report...</p>
		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/nodemgr/nodemgr_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);

let rosbridge = rosbridgeModule.rosbridge;
let packages = [];

async function runRosWTF() {
	const wtfService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/roswtf",
		serviceType: "std_srvs/srv/Trigger",
	});

	return new Promise((resolve, reject) => {
		wtfService.callService(new ROSLIB.ServiceRequest(), (result) => {
			// The ASCII code for escape is 27, represented in hexadecimal as \x1B
			resolve(result.message.replace(/\x1B\[1m/g, '').replace(/\x1B\[0m/g, '').replace(/ /g, '\u00a0'));
		}, (error) => {
			reject(error);
			alert(error);
		});
	});
}

//https://docs.ros2.org/foxy/api/lifecycle_msgs/msg/State.html
const LIFECYCLES = {
	0: "Unknown",
	1: "Unconfigured",
	2: "Inactive",
	3: "Active",
	4: "Finalized",
	10: "Configuring",
	11: "Cleaning Up",
	12: "Shutting Down",
	13: "Activating",
	14: "Deactivating",
	15: "Error Processing"
};

const LIFECYCLE_COLORS = {
	0: "lightgray", //Unknown
	1: "#c296d6", //Unconfigured
	2: "#9995c9", //Inactive
	3: "#5fd980", //Active
	4: "#5997ba", //Finalized
	10: "#f8ff30", //Configuring
	11: "#ffcf30", //Cleaningup
	12: "#ffa530", //Shutting Down
	13: "#7be1e3", //Activating
	14: "#e67f5a", //Deactivating
	15: "#cc4747" //Error Processing
};

let lifecycles = {};

async function getLifecycles() {
	const getExecutablesService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/list_lifecycle_nodes",
		serviceType: "vizanti_msgs/srv/ListLifecycles",
	});

	return new Promise((resolve, reject) => {
		getExecutablesService.callService(new ROSLIB.ServiceRequest(), (result) => {
			const map = {};
			for(let i = 0; i < result.nodes.length; i++){
				const name = result.nodes[i];
				const state = result.states[i];
				map[name] = state;
			}
			resolve(map);
		}, (error) => {
			reject(error);
		});
	});
}

async function getExecutables(pkg_name) {
	const getExecutablesService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/list_executables",
		serviceType: "vizanti_msgs/srv/ListExecutables",
	});

	return new Promise((resolve, reject) => {
		getExecutablesService.callService(new ROSLIB.ServiceRequest({package : pkg_name}), (result) => {
			resolve(result.executables);
		}, (error) => {
			reject(error);
		});
	});
}

async function getPackages() {
	const getPackagesService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/list_packages",
		serviceType: "vizanti_msgs/srv/ListPackages",
	});

	return new Promise((resolve, reject) => {
		getPackagesService.callService(new ROSLIB.ServiceRequest(), (result) => {
			resolve(result.packages);
		}, (error) => {
			reject(error);
		});
	});
}

async function startNode(command) {
	const startService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/node/start",
		serviceType: "vizanti_msgs/srv/ManageNode",
	});

	return new Promise((resolve, reject) => {
		startService.callService(new ROSLIB.ServiceRequest({ node: command }), (result) => {
			resolve(result);
		}, (error) => {
			reject(error);
		});
	});
}

async function killNode(name) {
	const killService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/node/kill",
		serviceType: "vizanti_msgs/srv/ManageNode",
	});

	return new Promise((resolve, reject) => {
		killService.callService(new ROSLIB.ServiceRequest({ node: name }), (result) => {
			resolve(result);
		}, (error) => {
			reject(error);
			alert(error);
		});
	});
}

async function nodeInfo(name) {
	const infoService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/node/info",
		serviceType: "vizanti_msgs/srv/ManageNode",
	});

	return new Promise((resolve, reject) => {
		infoService.callService(new ROSLIB.ServiceRequest({ node: name }), (result) => {
			resolve(result.message.replace(/ /g, '\u00a0'));
		}, (error) => {
			reject(error);
			alert(error);
		});
	});
}

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const nodeDiv = document.getElementById('{uniqueID}_nodelist');

const contextTitle = document.getElementById('{uniqueID}_context_title');
const killButton = document.getElementById('{uniqueID}_nodekill');
const infoText = document.getElementById('{uniqueID}_rosnode_info');
const lifecycleText = document.getElementById('{uniqueID}_rosnode_lifecycle');

let currentNode = "";

killButton.addEventListener('click', async () => {
	if(await confirm("Do you really want to kill "+currentNode+"?")){
		console.log("Killing "+currentNode);
		await killNode(currentNode);
		closeModal("{uniqueID}_contextmodal");
		updateNodeList();
	}
});

async function updateNodeList(){

	function renderLifeCycle(element, node){
		const state = lifecycles[node];
		element.textContent = "("+LIFECYCLES[state]+")";
		element.style.color = LIFECYCLE_COLORS[state];
		element.parentElement.style.borderLeft = "6px solid "+LIFECYCLE_COLORS[state];
	}

	let result = await rosbridge.get_all_nodes();

	nodeDiv.innerHTML = '';
	result.nodes.forEach(node => {

		if(node.includes("vizanti"))
			return;

		const nodeBox = document.createElement('div');
		nodeBox.className = 'node-box';
	
		const nodeName = document.createElement('span');
		nodeName.textContent = node;

		const nodeStatus = document.createElement('span');
		nodeStatus.style.marginLeft = "15px";
		nodeStatus.style.marginRight = "15px";
		nodeStatus.id = "{uniqueID}_nodestatus_"+node;
	
		nodeBox.addEventListener('click', async () => {

			if(node in lifecycles){
				const state = lifecycles[node];
				lifecycleText.innerText = "Lifecycle status: "+LIFECYCLES[state];
				lifecycleText.style.color = LIFECYCLE_COLORS[state];
			}else{
				lifecycleText.innerText = "Lifecycle status: Not a lifecycle node.";
				lifecycleText.style.color = "lightgray";
			}

			infoText.innerText = "Waiting for rosnode info...";

			currentNode = node;
			contextTitle.innerText = node;
			openModal("{uniqueID}_contextmodal");

			infoText.innerText = await nodeInfo(node);
		});
	
		nodeBox.appendChild(nodeName);
		nodeBox.appendChild(nodeStatus);
		nodeDiv.appendChild(nodeBox);

		if(node in lifecycles)
			renderLifeCycle(nodeStatus, node);

	});

	lifecycles = await getLifecycles();
	for (const [name, state] of Object.entries(lifecycles)) {
		const element = document.getElementById("{uniqueID}_nodestatus_"+name);
		renderLifeCycle(element, name);
	}
}

// roswtf

const wtfText = document.getElementById('{uniqueID}_roswtf_data');
const wtfButton = document.getElementById('{uniqueID}_roswtf');

wtfButton.addEventListener('click', async () => {
	wtfText.innerText = "Waiting for roswtf report (might take several seconds)...";
	openModal("{uniqueID}_roswtfmodal");
	wtfText.innerText = await runRosWTF();
});


// package picking
const executeButton = document.getElementById('{uniqueID}_execute');

const typeBox = document.getElementById('{uniqueID}_type');
const packageBox = document.getElementById('{uniqueID}_package');
const packageDataList = document.getElementById('{uniqueID}_package_datalist');
const nameBox = document.getElementById('{uniqueID}_name');

packageBox.addEventListener('change', async function(e) {
	const val = packageBox.value;

	if(packages.includes(val)) {
		let executables = await getExecutables(val);
		let nodelist = "";
		for (const exe of executables) {
			nodelist += "<option value='"+exe+"'>"+exe+"</option>"
		}
		nameBox.innerHTML = nodelist;

		if(nameBox.value.includes("launch")){
			typeBox.value = "ros2 launch";
		}else{
			typeBox.value = "ros2 run";
		}
	}
});

nameBox.addEventListener('change', async function(e) {
	if(nameBox.value.includes("launch")){
		typeBox.value = "ros2 launch";
	}else{
		typeBox.value = "ros2 run";
	}
});

async function updatePackageList(){
	packages = await getPackages();
	packages.forEach(pkg => {
		let option = document.createElement('option');
		option.value = pkg;
		packageDataList.appendChild(option);
	});
}

executeButton.addEventListener('click', async () => {
	if(await confirm("Do you really want to run '"+typeBox.value+" "+packageBox.value+" "+nameBox.value+"'?")){
		console.log("Executing "+typeBox.value+" "+packageBox.value+" "+nameBox.value);
		let response = await startNode(typeBox.value+" "+packageBox.value+" "+nameBox.value);
		alert(response.message);
		setTimeout(updateNodeList,1000);
	}
});

icon.addEventListener("click", updateNodeList);

updateNodeList();
updatePackageList();

console.log("Node Manager Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/odom/odom_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/odom.svg" alt="path" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/odom/odom_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Pose Tracker</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Target:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Track a TF link or nav_msgs/Odometry data.</p>

		<hr class="dark_hr"/>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#c43b00" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_history">History (N):</label>
		<input type="number" value="200" step="1" min="2" max="10000" id="{uniqueID}_history">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Sample delay (ms):</label>
		<input type="number" value="500" step="1" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<label>Draw path:</label>
		<input type="checkbox" checked id="{uniqueID}_draw_path">

		<div class="spacer"></div>

		<label>Draw arrows:</label>
		<input type="checkbox" checked id="{uniqueID}_draw_arrows">

		<div class="spacer"></div>

		<button id="{uniqueID}_clearhistory" style="background-color: rgb(104, 78, 31);">Clear history</button>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/odom/odom_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");

if(topic != "")
	topic += " (Odometry)";

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let listener = undefined;
let odom_topic = undefined;

let sample_array = [];

let mode = "" //see setMode()
let raw_target = "";

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const drawarrows = document.getElementById('{uniqueID}_draw_arrows');
drawarrows.addEventListener('change', ()=>{
	saveSettings();
	drawHistory();
});

const drawpath = document.getElementById('{uniqueID}_draw_path');
drawpath.addEventListener('change', ()=>{
	saveSettings();
	drawHistory();
});

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawHistory();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const historypicker = document.getElementById('{uniqueID}_history');
historypicker.addEventListener("input", (event) =>{
	saveSettings();

	while (sample_array.length > historypicker.value) {
		sample_array.shift();
	}

	drawHistory();
});

const clearHistoryButton = document.getElementById("{uniqueID}_clearhistory");
clearHistoryButton.addEventListener('click', ()=>{
	sample_array = [];
});

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	historypicker.value = loaded_data.history;
	drawarrows.checked =  loaded_data.draw_arrows;
	drawpath.checked =  loaded_data.draw_path;
	throttle.value = loaded_data.throttle;
	colourpicker.value = loaded_data.color ?? "#54db67";
	setMode();
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}

function saveSettings(){
	setMode();
	settings["{uniqueID}"] = {
		topic: topic,
		history: historypicker.value,
		color: colourpicker.value,
		throttle: throttle.value,
		draw_arrows: drawarrows.checked,
		draw_path: drawpath.checked
	}
	settings.save();
}

//Rendering
async function drawHistory(){

	function drawArrow(height, tipwidth) {
		const half = height/2;
		ctx.moveTo(-half, -tipwidth); 
		ctx.lineTo(half, 0);
		ctx.lineTo(-half, tipwidth);
	}

	const wid = canvas.width;
    const hei = canvas.height;
	ctx.setTransform(1,0,0,1,0,0); 
	ctx.clearRect(0, 0, wid, hei);

	if(!drawarrows.checked && !drawpath.checked)
		return;

	if(sample_array.length < 2){
		status.setWarn("No data yet!");
		return;
	}

	ctx.lineWidth = 3;
	ctx.strokeStyle = colourpicker.value;
	ctx.fillStyle = colourpicker.value;
	ctx.beginPath();

	let view_points = [];
	for (let i = 0; i < sample_array.length; i++) {
		view_points[i] = view.fixedToScreen(sample_array[i]);
		view_points[i].yaw = sample_array[i].yaw;
	}

	//continious line 
	if(drawpath.checked){
		ctx.moveTo(view_points[0].x, view_points[0].y);
		for (let i = 1; i < view_points.length; i++) {
			ctx.lineTo(view_points[i].x, view_points[i].y);
		}
		ctx.globalAlpha = 0.6;
		ctx.stroke();
	}

	//yaw indicator
	if(drawarrows.checked){
		ctx.beginPath();

		let prev_p = Infinity;
		for (let i = 0; i < view_points.length; i++) {
			const p = view_points[i];
			if(i == 0 || Math.hypot(p.x - prev_p.x, p.y - prev_p.y) > 20){
				ctx.setTransform(1,0,0,-1,p.x, p.y); //sx,0,0,sy,px,py
				ctx.rotate(p.yaw);
				drawArrow(15, 5);
				prev_p = p;
			}
		}

		ctx.globalAlpha = 1.0;
		ctx.fill();
	}
}

function appendPose(pose){
	const pose2D = {
		x: pose.translation.x,
		y: pose.translation.y,
		yaw: pose.rotation.toEuler().h
	};

	if(sample_array.length > 2){
		const last = sample_array[sample_array.length-1];
		const delta = Math.hypot(last.x - pose2D.x, last.y - pose2D.y);
		if(delta > 0.03){
			sample_array.push(pose2D);
		}else{
			return false;
		}
	}else{
		sample_array.push(pose2D);
	}

	while (sample_array.length > historypicker.value) {
		sample_array.shift();
	}

	return true;
}

//Topic
function connect(){
	if(topic == ""){
		status.setError("No target.");
		return;
	}

	if(odom_topic !== undefined){
		odom_topic.unsubscribe(listener);
	}

	if(mode != "topic")
		return;

	odom_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : raw_target,
		messageType : 'nav_msgs/msg/Odometry',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	
	listener = odom_topic.subscribe((msg) => {
		
		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		const frame = tf.absoluteTransforms[msg.header.frame_id];

		if(!frame){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			error = true;
			return;
		}

		const transformed = tf.transformPose(
			msg.header.frame_id,
			tf.fixed_frame, 
			msg.pose.pose.position, 
			msg.pose.pose.orientation
		)

		if(appendPose(transformed)){
			drawHistory();
			if(!error){
				status.setOK();
			}
		}
	});

	saveSettings();
}

async function loadTopics(){
	let odom_array = await rosbridge.get_topics("nav_msgs/msg/Odometry");
	let tf_array = Array.from(tf.frame_list);

	let topiclist = "";
	odom_array.forEach(element => {
		topiclist += "<option value='"+element+" (Odometry)'>"+element+" (Odometry)</option>"
	});

	tf_array.forEach(frame => {
		topiclist += "<option value='"+frame+" (Frame)'>"+frame+" (Frame)</option>"
	});

	selectionbox.innerHTML = topiclist

	if(topic == ""){
		topic = selectionbox.value;
		setMode();
	}else{
		setMode();
		if(odom_array.includes(raw_target) || tf_array.includes(raw_target)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}

	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	sample_array = [];
	saveSettings();
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

click_icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function setMode(){
	if(topic.endsWith("(Frame)")){
		mode = "tf";
		raw_target = topic.replace(" (Frame)", "");
	}else if(topic.endsWith("(Odometry)")){
		mode = "topic";
		raw_target = topic.replace(" (Odometry)", "");
	}else{
		mode = "";
		raw_target = "";
	}
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawHistory();
}

let tf_throttle_stamp = 0;
window.addEventListener("tf_changed", ()=>{
	if(mode == "tf"){
		const now = Date.now();
		if(now - tf_throttle_stamp >= parseInt(throttle.value)){
			const frame = tf.absoluteTransforms[raw_target];

			if(!frame){
				status.setError("Required transform frame \""+raw_target+"\" not found.");
				return;
			}

			if(appendPose(frame)){
				drawHistory();
				status.setOK();
				tf_throttle_stamp = now;
			}
		}
	}
});

window.addEventListener("tf_fixed_frame_changed", ()=>{
	sample_array = []; //TODO keep a ref to the old frame and trasform the history
	drawHistory();
});

window.addEventListener("view_changed", drawHistory);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("Odom Pose Tracker Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/odom/odom_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 3;"></canvas>


================================================
FILE: vizanti_server/public/templates/path/path_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/path.svg" alt="path" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/path/path_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Path</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#54db67" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="100" step="1" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<p>Display a nav_msgs/Path.</p>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/path/path_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let listener = undefined;
let path_topic = undefined;

let pose_array = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawPath();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});


//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	colourpicker.value = loaded_data.color ?? "#54db67";
	throttle.value = loaded_data.throttle ?? 100;
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		color: colourpicker.value,
		throttle: throttle.value	
	}
	settings.save();
}

//Rendering
async function drawPath(){

	const wid = canvas.width;
    const hei = canvas.height;
	ctx.clearRect(0, 0, wid, hei);

	if(pose_array === undefined || pose_array.length < 2){
		return false;
	}

	ctx.lineWidth = 2;
	ctx.strokeStyle = colourpicker.value;
	ctx.beginPath();

	const firstPos = view.fixedToScreen({
		x: pose_array[0].translation.x,
		y: pose_array[0].translation.y
	});
	ctx.moveTo(firstPos.x, firstPos.y);

	for (let i = 1; i < pose_array.length; i++) {
		const point = pose_array[i];
		const pos = view.fixedToScreen({
			x: point.translation.x,
			y: point.translation.y
		});
		ctx.lineTo(pos.x, pos.y);
	}

	ctx.stroke();
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(path_topic !== undefined){
		path_topic.unsubscribe(listener);
	}

	path_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'nav_msgs/msg/Path',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	
	listener = path_topic.subscribe((msg) => {
		
		let error = false;
		let newposes = [];

		if(msg.poses == undefined){
			status.setWarn("Received uninitialized list of poses. Wat.");
			error = true;
			return;
		}

		msg.poses.forEach((point, index) => {

			if(point.header.frame_id == ""){
				status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
				point.header.frame_id = tf.fixed_frame;
				error = true;
			}

			const frame = tf.absoluteTransforms[point.header.frame_id];
	
			if(!frame){
				status.setError("Required transform frame \""+point.header.frame_id+"\" not found.");
				error = true;
				return;
			}
	
			newposes.push(tf.transformPose(
				point.header.frame_id, 
				tf.fixed_frame, 
				point.pose.position, 
				point.pose.orientation
			));
		});

		pose_array = newposes;
		drawPath();

		if(!error){
			status.setOK();
		}
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("nav_msgs/msg/Path");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	pose_array = undefined;
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

click_icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawPath();
}

window.addEventListener("tf_fixed_frame_changed", connect);
window.addEventListener("view_changed", drawPath);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("MarkerArray Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/path/path_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 3;"></canvas>


================================================
FILE: vizanti_server/public/templates/pointcloud/pointcloud_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/pointcloud.svg" alt="cloud" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/pointcloud/pointcloud_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Point Cloud</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">1.0</span>
		<input type="range" value="1.0" step="0.05" min="0.1" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<label for="{uniqueID}_thickness">Thickness (m):</label>
		<span id="{uniqueID}_thickness_value">0.02</span>
		<input type="range" value="0.02" step="0.01" min="0.01" max="0.2" id="{uniqueID}_thickness">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#1f8eec" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="2000" step="0" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<p>Point clouds are very high bandwidth topics, and as such can easily cause TCP congestion. Lower the socket throttle rate to get faster data updates, but note that other visualizers may stutter.</p>

		<p style="color:#b4b4b4;">Currently experimental and might not decode all cloud formats correctly. XYZ coordinate data is required, the rest is ignored for now.</p>


		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/pointcloud/pointcloud_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let range_topic = undefined;
let listener = undefined;
let data = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');
opacitySlider.addEventListener('input', () =>  {
	opacityValue.textContent = opacitySlider.value;
	saveSettings();
	drawCloud();
});

const thicknessSlider = document.getElementById('{uniqueID}_thickness');
const thicknessValue = document.getElementById('{uniqueID}_thickness_value');
thicknessSlider.addEventListener('input', () =>  {
	thicknessValue.textContent = thicknessSlider.value;
	saveSettings();
	drawCloud();
});

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawCloud();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});


//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	opacitySlider.value = loaded_data.opacity;
	opacityValue.innerText = loaded_data.opacity;

	thicknessSlider.value = loaded_data.thickness;
	thicknessValue.innerText = loaded_data.thickness;

	colourpicker.value = loaded_data.color;
	throttle.value = loaded_data.throttle;
	
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		thickness: thicknessSlider.value,
		color: colourpicker.value,
		throttle: throttle.value
	};
	settings.save();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

async function drawCloud() {

	const pixel = view.getMapUnitsInPixels(thicknessSlider.value);

	const wid = canvas.width;
	const hei = canvas.height;

	ctx.clearRect(0, 0, wid, hei);
	ctx.globalAlpha = opacitySlider.value;
	ctx.fillStyle = colourpicker.value;

	if(data == undefined){
		return;
	}

	let delta = parseInt(pixel/2);
	ctx.beginPath();
	for(let i = 0; i < data.points.length; i++){
		const screenpos = view.fixedToScreen(data.points[i].translation);
		const x = screenpos.x - delta;
		const y = screenpos.y - delta;
		
		ctx.moveTo(x, y);
		ctx.lineTo(x + pixel, y);
		ctx.lineTo(x + pixel, y + pixel);
		ctx.lineTo(x, y + pixel); 
		ctx.lineTo(x, y);
	}
	ctx.fill();
	ctx.restore();
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawCloud();
}

window.addEventListener("tf_fixed_frame_changed", drawCloud);
window.addEventListener("view_changed", drawCloud);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

function bytes_to_datatype(view, offset, type, littleEndian){
	switch(type){
		case 1: return parseFloat(view.getInt8(offset)); //INT8    = 1
		case 2: return parseFloat(view.getUint8(offset)); //UINT8   = 2
		case 3: return parseFloat(view.getInt16(offset, littleEndian)); //INT16   = 3
		case 4: return parseFloat(view.getUInt16(offset, littleEndian)); //UINT16  = 4
		case 5: return parseFloat(view.getInt32(offset, littleEndian)); //INT32   = 5
		case 6: return parseFloat(view.getUInt32(offset, littleEndian)); //UINT32  = 6
		case 7: return view.getFloat32(offset, littleEndian); //FLOAT32 = 7
		case 8: return view.getFloat64(offset, littleEndian); //FLOAT64 = 8
		default: return 0;
	}	
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}
	
	if(range_topic !== undefined){
		range_topic.unsubscribe(listener);
	}

	range_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/PointCloud2',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");

	listener = range_topic.subscribe((msg) => {	

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		const pose = tf.absoluteTransforms[msg.header.frame_id];

		if(!pose){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		/* if(msg.width * msg.height != msg.data.length / msg.point_step){
			status.setError("Invalid cloud data, point count is inconsistent with binary blob length.");
			return;
		} */

		const xData = msg.fields.find(field => field.name === 'x');
		const yData = msg.fields.find(field => field.name === 'y');
		const zData = msg.fields.find(field => field.name === 'z');

		if(xData === undefined || yData === undefined || zData === undefined){
			status.setError("XYZ coordinate data not found in cloud.");
			return;
		}

		const littleEndian = !msg.is_bigendian;

		const buffer = new ArrayBuffer(msg.data.length);
		const dataview = new DataView(buffer);

		//for some reason these two aren't equal, so we have to throw each byte in separately like cavemen, not great but works for now
		//console.log(buffer.slice(0, msg.point_step))
		//console.log(msg.data.buffer.slice(0, msg.point_step))
		for(let i = 0; i < msg.data.length; i++){
			dataview.setUint8(i, msg.data[i]);
		}

		let pointarray = [];
		for(let i = 0; i < msg.data.length; i += msg.point_step){
			//const dataview = new DataView(msg.data.buffer.slice(i, i+msg.point_step));
			
			const point = {
				x: bytes_to_datatype(dataview, i+xData.offset, xData.datatype, littleEndian),
				y: bytes_to_datatype(dataview, i+yData.offset, yData.datatype, littleEndian),
				z: bytes_to_datatype(dataview, i+zData.offset, zData.datatype, littleEndian)
			};
			pointarray.push(tf.transformPose(msg.header.frame_id, tf.fixed_frame, point, new Quaternion()));
		}

		if(pointarray.length > 0){
			data = {};
			data.pose = pose;
			data.points = pointarray;
			drawCloud();
			if(!error){
				status.setOK();
			}
		}
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/PointCloud2");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	data = undefined;
	connect();
});

selectionbox.addEventListener("click", connect);
click_icon.addEventListener("click", loadTopics);

loadTopics();
resizeScreen();

console.log("Point Cloud Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/pointcloud/pointcloud_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 10;"></canvas>


================================================
FILE: vizanti_server/public/templates/posearray/posearray_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/posearray.svg" alt="posearray" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/posearray/posearray_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Pose Array</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Display an array of Poses as a cloud of arrows.</p>

		<hr class="dark_hr"/>
		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#f74127" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="100" step="1" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>
		<div class="spacer"></div>

		<label for="{uniqueID}_scale">Arrow scale:</label>
		<span id="{uniqueID}_scale_value">1.0</span>
		<input type="range" value="1.0" step="0.01" min="0.1" max="10.0" id="{uniqueID}_scale">

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/posearray/posearray_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let listener = undefined;
let poses_topic = undefined;

let poses = [];
let frame = "";

const scaleSlider = document.getElementById('{uniqueID}_scale');
const scaleSliderValue = document.getElementById('{uniqueID}_scale_value');

scaleSlider.addEventListener('input', function () {
	scaleSliderValue.textContent = this.value;
	drawArrows();
});

scaleSlider.addEventListener('change', saveSettings);

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawArrows();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	colourpicker.value = loaded_data.color ?? "#f74127";

	scaleSlider.value = loaded_data.scale;
	scaleSliderValue.textContent = scaleSlider.value;
	throttle.value = loaded_data.throttle ?? 100;
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		scale: parseFloat(scaleSlider.value),
		color: colourpicker.value,
		throttle: throttle.value
	}
	settings.save();
}

//Rendering

async function drawArrows(){

	function drawTriangle(height, width){
		ctx.moveTo(0, -width);
		ctx.lineTo(height, 0);
		ctx.lineTo(0, width);
		ctx.lineTo(0, -width);
	}

	function drawArrow(height, width, height_to_tip, tipwidth){
		ctx.moveTo(0, -width);
		ctx.lineTo(height_to_tip, -width);
		ctx.lineTo(height_to_tip, -tipwidth);
		ctx.lineTo(height, 0);
		ctx.lineTo(height_to_tip, tipwidth);
		ctx.lineTo(height_to_tip, width);
		ctx.lineTo(0, width);
		ctx.lineTo(0, -width);
	}

	const unit = view.getMapUnitsInPixels(1.0);

	const wid = canvas.width;
    const hei = canvas.height;

	const scale = unit * parseFloat(scaleSlider.value);
	const arrow_height = parseInt(scale*0.5);
	const arrow_width = parseInt(scale*0.01)+1;
	const arrow_tip = parseInt(scale*0.07)+1;
	const arrow_tipwidth = parseInt(scale*0.07)+1;
	const arrow_height_to_tip = arrow_height - arrow_tip;

	const triangle_width = parseInt(scale*0.06)+1;
	const triangle_height = parseInt(scale*0.3)+1;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, wid, hei);
	ctx.fillStyle = colourpicker.value;

	if(frame === tf.fixed_frame && poses.length > 0){
		ctx.beginPath();

		if(poses.length < 100){
			for (let i = 0; i < poses.length; i++) {
				const p = poses[i];
				const screenpos = view.fixedToScreen(p);
	
				ctx.setTransform(1,0,0,-1,screenpos.x, screenpos.y); //sx,0,0,sy,px,py
				ctx.rotate(p.yaw);
	
				drawArrow(arrow_height, arrow_width, arrow_height_to_tip, arrow_tipwidth);
			}
		}else{
			for (let i = 0; i < poses.length; i++) {
				const p = poses[i];
				const screenpos = view.fixedToScreen(p);
	
				ctx.setTransform(1,0,0,-1,screenpos.x, screenpos.y); //sx,0,0,sy,px,py
				ctx.rotate(p.yaw);
	
				drawTriangle(triangle_height, triangle_width);
			}
		}



		ctx.fill();
	}
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(poses_topic !== undefined){
		poses_topic.unsubscribe(listener);
	}

	poses_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'geometry_msgs/msg/PoseArray',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	
	listener = poses_topic.subscribe((msg) => {

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		if(!tf.absoluteTransforms[msg.header.frame_id]){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		poses = [];
		frame = tf.fixed_frame;

		msg.poses.forEach(p => {
			const transformed = tf.transformPose(
				msg.header.frame_id, 
				tf.fixed_frame, 
				p.position, 
				p.orientation
			);

			poses.push({
				x: transformed.translation.x,
				y: transformed.translation.y,
				yaw: transformed.rotation.toEuler().h
			});
		});
		drawArrows();

		if(!error){
			status.setOK();
		}		
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("geometry_msgs/msg/PoseArray");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	poses = [];
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

click_icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawArrows();
}

window.addEventListener("tf_fixed_frame_changed", drawArrows);
window.addEventListener("view_changed", drawArrows);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("PoseArray Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/posearray/posearray_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 3;"></canvas>


================================================
FILE: vizanti_server/public/templates/posewithcovariancestamped/posewithcovariancestamped_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/posewithcovariancestamped.svg" alt="pose" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/posewithcovariancestamped/posewithcovariancestamped_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Pose</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_live_x">X: ?</p>
			<p id="{uniqueID}_live_y">Y: ?</p> 
			<p id="{uniqueID}_live_z">Z: ?</p>
			<p id="{uniqueID}_live_dist">Distance: ?</p>
			<p id="{uniqueID}_live_roll">Roll: ?</p>
			<p id="{uniqueID}_live_pitch">Pitch: ?</p>
			<p id="{uniqueID}_live_yaw">Yaw: ?</p>
		</div>

		<p>Render a single PoseStamped or PoseWithCovarianceStamped.</p>

		<p class="comment">Note: Covariance rendering assumes a 2D pose for simplicity. Side effects may include inaccuracy in high roll/pitch orientations, ask your PhD if 2D covariance rendering is right for you.</p>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<label for="{uniqueID}_rendermode">Render mode:</label>
		<select id="{uniqueID}_rendermode" name="topic">
			<option value='long_arrow'>Long Arrow</option>
			<option value='axes'>Axes</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="100" step="1" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<label for="{uniqueID}_decay">Decay time (ms):</label>
		<input type="number" value="10000" step="0" min="-1" max="100000" id="{uniqueID}_decay">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#f74127" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>
		<div class="spacer"></div>

		<label for="{uniqueID}_scale">Render scale:</label>
		<span id="{uniqueID}_scale_value">1.0</span>
		<input type="range" value="1.0" step="0.01" min="0.01" max="15.0" id="{uniqueID}_scale">

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/posewithcovariancestamped/posewithcovariancestamped_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let applyRotation = tfModule.applyRotation;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;
let imageToDataURL = utilModule.imageToDataURL;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const icon_pose = 'assets/pose.svg'//await imageToDataURL('assets/pose.svg');
const icon_pose_with_covariance = 'assets/posewithcovariancestamped.svg'//await imageToDataURL('assets/posewithcovariancestamped.svg');

let typedict = {};
let listener = undefined;
let marker_topic = undefined;

let posemsg = undefined;
let frame = "";

const text_x = document.getElementById("{uniqueID}_live_x");
const text_y = document.getElementById("{uniqueID}_live_y");
const text_z = document.getElementById("{uniqueID}_live_z");
const text_dist = document.getElementById("{uniqueID}_live_dist");
const text_roll = document.getElementById("{uniqueID}_live_roll");
const text_pitch = document.getElementById("{uniqueID}_live_pitch");
const text_yaw = document.getElementById("{uniqueID}_live_yaw");

const rendermodebox = document.getElementById("{uniqueID}_rendermode");
const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const scaleSlider = document.getElementById('{uniqueID}_scale');
const scaleSliderValue = document.getElementById('{uniqueID}_scale_value');
scaleSlider.addEventListener('change', saveSettings);
scaleSlider.addEventListener('input', function () {
	scaleSliderValue.textContent = this.value;
	saveSettings();
	drawMarkers();
});

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawMarkers();
});

const decay = document.getElementById('{uniqueID}_decay');
decay.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	colourpicker.value = loaded_data.color ?? "#f74127";

	scaleSlider.value = loaded_data.scale;
	scaleSliderValue.textContent = scaleSlider.value;

	typedict = loaded_data.typedict ?? {};

	decay.value = loaded_data.decay ?? 10000;
	throttle.value = loaded_data.throttle ?? 100;

	rendermodebox.value = loaded_data.rendermode ?? "long_arrow";

}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}


function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		scale: parseFloat(scaleSlider.value),
		typedict: typedict,
		color: colourpicker.value,
		decay: decay.value,
		throttle: throttle.value,
		rendermode: rendermodebox.value
	}
	settings.save();
}

async function drawMarkers(){

	function drawAxes(size) {

		const length = parseFloat(scaleSlider.value);

		function getBasisPoints(basis, translation, rotation){
			let basis_x = applyRotation(basis, rotation);
			return [
				view.fixedToScreen({
					x: translation.x,
					y: translation.y,
				}), 
				view.fixedToScreen({
					x: translation.x + basis_x.x,
					y: translation.y + basis_x.y,
				})
			];
		}
	
		ctx.lineCap = 'round';
		ctx.lineWidth = size*0.1;
		ctx.strokeStyle = "#bf0009"; //red
		ctx.beginPath();
		let p = getBasisPoints(
			{x: length, y: 0, z: 0},
			posemsg.vec,
			posemsg.quat
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
		ctx.stroke();
	
		ctx.strokeStyle = "#21cc1f"; //green
		ctx.beginPath();
	
		p = getBasisPoints(
			{x: 0, y: length, z: 0},
			posemsg.vec,
			posemsg.quat
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
		ctx.stroke();
	
		ctx.strokeStyle = "#0249c4"; //blue
		ctx.beginPath();

		p = getBasisPoints(
			{x: 0, y: 0, z: length},
			posemsg.vec,
			posemsg.quat
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
		ctx.stroke();
	
	}

	function drawCircle(size){
		ctx.fillStyle = colourpicker.value;
		ctx.beginPath();
		ctx.arc(0, 0, size/2, 0, 2 * Math.PI, false);
		ctx.fill();
	}

	function drawArrow(size){
		ctx.fillStyle = colourpicker.value;
		const height = parseInt(size*2.0);
		const width = parseInt(size*0.1*0.6)+1;
		const tip = parseInt(size*0.24)+1;
		const tipwidth = parseInt(size*0.3*0.6)+1;

		ctx.beginPath();
		ctx.moveTo(0, -width);
		ctx.lineTo(height - tip, -width);
		ctx.lineTo(height - tip, -tipwidth);
		ctx.lineTo(height, 0);
		ctx.lineTo(height - tip, tipwidth);
		ctx.lineTo(height - tip, width);
		ctx.lineTo(0, width);
		ctx.lineTo(0, -width);
		ctx.fill();
	}
	function drawPizza(start_angle, end_angle, min_len, max_len){
        ctx.beginPath();
        ctx.arc(0, 0, min_len, start_angle, end_angle);
        ctx.lineTo(max_len * Math.cos(end_angle), max_len * Math.sin(end_angle));
        ctx.arc(0, 0, max_len, end_angle, start_angle, true);
        ctx.lineTo(min_len * Math.cos(start_angle), min_len * Math.sin(start_angle));
        ctx.closePath();
        ctx.fill();
	}
	
	function drawTranslationalCovariance(eigenvalues, size) {
		if (eigenvalues === undefined)
			return;
	
		const radiusX = Math.sqrt(eigenvalues.lambda1) * size;
		const radiusY = Math.sqrt(eigenvalues.lambda2) * size;
		const theta = Math.atan2(eigenvalues.eigenvector1[1], eigenvalues.eigenvector1[0]);

		ctx.fillStyle = 'rgba(204, 51, 204, 0.4)';
		ctx.rotate(theta);
		ctx.beginPath();
		ctx.ellipse(0, 0, radiusX, radiusY, 0, 0, 2 * Math.PI);
		ctx.fill();
	}

	function drawAngularCovariance(covariance, size) {

		if(covariance === undefined)
			return;

		// Calculate the 2-sigma standard deviation 
		let angleUncertainty = 2 * Math.sqrt(covariance[35]);

		if(angleUncertainty > Math.PI*2)
			angleUncertainty = Math.PI*2;

		const halfAngleZ = angleUncertainty * 0.5;

		ctx.fillStyle = 'rgba(255, 255, 0, 0.4)'; // Yellow, semi-transparent
		drawPizza(-halfAngleZ, halfAngleZ, 0, size*2);
	}

	const unit = view.getMapUnitsInPixels(1.0);

	const wid = canvas.width;
    const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, wid, hei);

	if(!posemsg)
		return;

	if(decay.value > 0 && new Date() - posemsg.stamp > decay.value)
		return;

	if(frame === tf.fixed_frame){

		const screenpos = view.fixedToScreen(posemsg);
		const scale = unit*parseFloat(scaleSlider.value);

		ctx.setTransform(1,0,0,-1,screenpos.x, screenpos.y); //sx,0,0,sy,px,py
		
		drawTranslationalCovariance(posemsg.eigenvalues, unit);
		ctx.setTransform(1,0,0,-1,screenpos.x, screenpos.y);

		if(!posemsg.rotation_invalid){
			ctx.rotate(posemsg.yaw);
			drawAngularCovariance(posemsg.covariance, scale);

			if(rendermodebox.value == "long_arrow"){
				drawArrow(scale);
			}else{
				ctx.setTransform(1,0,0,1,0, 0);
				drawAxes(scale);
			}
				
		}else{
			drawCircle(scale*0.4);
		}
	}
}

function calculateEigen(covariance){
	//2x2 covariance submatrix for x and y.
	const covMatrix = [
		[covariance[0], covariance[1]],
		[covariance[6], covariance[7]]
	];

	const a = covMatrix[0][0];
	const b = covMatrix[0][1];
	const c = covMatrix[1][1];
	const trace = a + c;
	const det = a * c - b * b;
	const lambda1 = trace / 2 + Math.sqrt(trace * trace / 4 - det);
	const lambda2 = trace / 2 - Math.sqrt(trace * trace / 4 - det);

	let eigenvector1, eigenvector2;

	if (b !== 0) {
		eigenvector1 = [lambda1 - c, b];
		eigenvector2 = [lambda2 - c, b];
	} else {
		eigenvector1 = [1, 0];  // If off-diagonal is 0, the eigenvectors are aligned with the axes.
		eigenvector2 = [0, 1];
	}

	const norm1 = Math.sqrt(eigenvector1[0] * eigenvector1[0] + eigenvector1[1] * eigenvector1[1]);
	const norm2 = Math.sqrt(eigenvector2[0] * eigenvector2[0] + eigenvector2[1] * eigenvector2[1]);

	eigenvector1 = [eigenvector1[0] / norm1, eigenvector1[1] / norm1];
	eigenvector2 = [eigenvector2[0] / norm2, eigenvector2[1] / norm2];

	return {
		eigenvector1: eigenvector1,
		eigenvector2: eigenvector2,
		lambda1: lambda1,
		lambda2: lambda2
	}
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(marker_topic !== undefined){
		marker_topic.unsubscribe(listener);
	}

	marker_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : typedict[topic],
		throttle_rate: parseInt(throttle.value)
	});

	status.setWarn("No data received.");

	const skip_covariance = typedict[topic] == "geometry_msgs/msg/PoseStamped";
	icon.data = skip_covariance ? icon_pose : icon_pose_with_covariance;
	
	listener = marker_topic.subscribe((msg) => {

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}
		
		if(!tf.absoluteTransforms[msg.header.frame_id]){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		frame = tf.fixed_frame;

		let pose = skip_covariance ? msg.pose : msg.pose.pose;

		let q = pose.orientation;
		const rotation_invalid = q.x == 0 && q.y == 0 && q.z == 0 && q.w == 0

		if(rotation_invalid){
			status.setWarn("Received invalid rotation, defaulting to indentity quat.");
			q = new Quaternion();
		}

		const transformed = tf.transformPose(
			msg.header.frame_id, 
			tf.fixed_frame, 
			pose.position, 
			q
		);

		//Todo: transform covariance
		posemsg = {
			x: transformed.translation.x,
			y: transformed.translation.y,
			vec: transformed.translation,
			quat: transformed.rotation,
			yaw: transformed.rotation.toEuler().h,
			rotation_invalid: rotation_invalid,
			covariance: skip_covariance ? undefined : msg.pose.covariance,
			eigenvalues: skip_covariance ? undefined : calculateEigen(msg.pose.covariance),
			stamp: new Date()
		};

		let angles = (new Quaternion(q)).toEuler()
		text_x.innerText = "X: "+pose.position.x.toFixed(2)+" m";
		text_y.innerText = "Y: "+pose.position.y.toFixed(2)+" m";
		text_z.innerText = "Z: "+pose.position.z.toFixed(2)+" m";
		text_dist.innerText = "Distance: "+Math.hypot(pose.position.x, pose.position.y, pose.position.z).toFixed(2)+" m";
		text_roll.innerText = "Roll: "+(angles.g * (180/Math.PI)).toFixed(1)+"°";
		text_pitch.innerText = "Pitch: "+(angles.pitch * (180/Math.PI)).toFixed(1)+"°";
		text_yaw.innerText = "Yaw: "+(angles.h * (180/Math.PI)).toFixed(1)+"°";
	
		drawMarkers();
		
		if(!error){
			status.setOK();
		}
	});

	saveSettings();
}

async function loadTopics(){
	let pose_topics = await rosbridge.get_topics("geometry_msgs/msg/PoseStamped");
	let posecov_topics = await rosbridge.get_topics("geometry_msgs/msg/PoseWithCovarianceStamped");

	let topiclist = "";
	pose_topics.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (PoseStamped)</option>"
		typedict[element] = "geometry_msgs/msg/PoseStamped";
	});
	posecov_topics.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (PoseWithCovarianceStamped)</option>"
		typedict[element] = "geometry_msgs/msg/PoseWithCovarianceStamped";
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(pose_topics.includes(topic) || posecov_topics.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	text_x.innerText = "X: ?";
	text_y.innerText = "Y: ?";
	text_z.innerText = "Z: ?";
	text_dist.innerText = "Distance: ?";
	text_roll.innerText = "Roll: ?";
	text_pitch.innerText = "Pitch: ?";
	text_yaw.innerText = "Yaw: ?";

	topic = selectionbox.value;
	posemsg = undefined;
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

click_icon.addEventListener("click", (event) => {
	loadTopics();
});

rendermodebox.addEventListener("change", (event) => {
	saveSettings();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawMarkers();
}

window.addEventListener("tf_fixed_frame_changed", drawMarkers);
window.addEventListener("tf_changed", ()=>{
	if(frame != tf.fixed_frame){
		drawMarkers();
	}
});

window.addEventListener("view_changed", drawMarkers);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

console.log("Pose Widget Loaded {uniqueID}")




================================================
FILE: vizanti_server/public/templates/posewithcovariancestamped/posewithcovariancestamped_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 3;"></canvas>


================================================
FILE: vizanti_server/public/templates/range/range_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/range.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/range/range_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Range</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_rangetext">Range: ?</p>
			<p id="{uniqueID}_rangemintext">Min: ?</p> 
			<p id="{uniqueID}_rangemaxtext">Max: ?</p>
			<p id="{uniqueID}_fovtext">Field of view: ?</p>
			<p id="{uniqueID}_typetext">Type: ?</p>
		</div>

		<p>Render a range measurement, typically from sonar or infrared sensors.</p>

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="100" step="1" min="0" max="10000" id="{uniqueID}_throttle">
			
		<div class="spacer"></div>

		<label for="{uniqueID}_decay">Decay time (ms):</label>
		<input type="number" value="2000" step="0" min="-1" max="60000" id="{uniqueID}_decay">

		<div class="spacer"></div>
		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">0.9</span>
		<input type="range" value="0.9" step="0.05" min="0.1" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>


		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/range/range_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let range_topic = undefined;
let listener = undefined;

let data = {};

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');

const text_range = document.getElementById("{uniqueID}_rangetext");
const text_min = document.getElementById("{uniqueID}_rangemintext");
const text_max = document.getElementById("{uniqueID}_rangemaxtext");
const text_fov = document.getElementById("{uniqueID}_fovtext");
const text_type = document.getElementById("{uniqueID}_typetext");

opacitySlider.addEventListener('input', () =>  {
	opacityValue.textContent = opacitySlider.value;
	saveSettings();
});

const decay = document.getElementById('{uniqueID}_decay');
decay.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	opacitySlider.value = loaded_data.opacity;
	opacityValue.innerText = loaded_data.opacity;

	decay.value = loaded_data.decay ?? 2000;
	throttle.value = loaded_data.throttle ?? 100;
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		decay: decay.value,
		throttle: throttle.value
	}
	settings.save();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

async function drawRanges() {

	function drawCircle(min_size, max_size) {
        ctx.beginPath();
        ctx.arc(0, 0, (min_size+max_size)/2, 0, 2 * Math.PI);
        ctx.closePath();
		ctx.lineWidth = max_size - min_size;
        ctx.stroke();
		ctx.lineWidth = 1;
	  }

	function drawPizza(start_angle, end_angle, min_len, max_len){
        ctx.beginPath();
        ctx.arc(0, 0, min_len, start_angle, end_angle);
        ctx.lineTo(max_len * Math.cos(end_angle), max_len * Math.sin(end_angle));
        ctx.arc(0, 0, max_len, end_angle, start_angle, true);
        ctx.lineTo(min_len * Math.cos(start_angle), min_len * Math.sin(start_angle));
        ctx.closePath();
        ctx.fill();
	} 

	const unit = view.getMapUnitsInPixels(1.0);

	const wid = canvas.width;
	const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, wid, hei);
	ctx.globalAlpha = opacitySlider.value;

	let current_time = new Date();

	for (const [key, sample] of Object.entries(data)) {

		//skip old messages
		if(decay.value > 0 && current_time - sample.stamp > decay.value)
			continue;

		if(sample.max_range == 0)
			continue;

		const pos = view.fixedToScreen({
			x: sample.pose.translation.x,
			y: sample.pose.translation.y,
		});

		const start_angle = -sample.field_of_view/2;
		const end_angle = sample.field_of_view/2;

		ctx.setTransform(1,0,0,-1,pos.x, pos.y); //sx,0,0,sy,px,py
		ctx.rotate(sample.yaw);

		if(sample.cone_half_width < sample.max_range)
		{
			ctx.fillStyle = "#33414e96";
			drawPizza(start_angle, end_angle, unit*sample.min_range, unit*sample.max_range, unit*sample.cone_half_width)

			ctx.fillStyle = "#5eb4ffff";
			let minarc = unit*sample.range-10;
	
			if(minarc < 0)
				minarc = 1;
	
			drawPizza(start_angle, end_angle, minarc, unit*sample.range, unit*sample.cone_half_width)
			
		}
		else
		{
			ctx.strokeStyle = "#33414e96";
			const scale = sample.cone_half_width / sample.max_range;
			const min_range = sample.min_range * scale * unit;
			const range = sample.range * scale * unit;

			drawCircle(min_range, unit*sample.cone_half_width);

			ctx.strokeStyle = "#5eb4ffff";
			let minarc = range-10;
			if(minarc < 0)
				minarc = 1;

			drawCircle(minarc, range)

		}

		yieldToMainThread();

	}
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawRanges();
}

window.addEventListener("tf_fixed_frame_changed", drawRanges);
window.addEventListener("view_changed", drawRanges);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

//Topic

const RADIATION_TYPE = {
	0: "Ultrasound",
	1: "Infrared"
}

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(range_topic !== undefined){
		range_topic.unsubscribe(listener);
	}

	range_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/Range',
		compression: rosbridge.compression,
		throttle_rate: parseInt(throttle.value)
	});

	status.setWarn("No data received.");	
	listener = range_topic.subscribe((msg) => {

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		const pose = tf.absoluteTransforms[msg.header.frame_id];

		if(!pose){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		text_range.innerText = "Range: "+msg.range.toFixed(3)+" m";
		text_min.innerText = "Min: "+msg.min_range.toFixed(3)+" m";
		text_max.innerText = "Max: "+msg.max_range.toFixed(3)+" m";
		text_fov.innerText = "Field of view: "+(msg.field_of_view * (180/Math.PI)).toFixed(2)+"°";
		text_type.innerText = "Type: "+RADIATION_TYPE[msg.radiation_type];

		const front_vector = tfModule.applyRotation(
			{
				x: msg.max_range, 
				y: 0,
				z: 0 
			}, 
			pose.rotation, 
			false
		);

		//calculate the new values for displaying the cone in a rotated projection
		const yaw = Math.atan2(front_vector.y, front_vector.x);
		const ratio = Math.hypot(front_vector.y, front_vector.x) / msg.max_range;

		const cone_half_width = Math.tan(msg.field_of_view * 0.5) * msg.max_range;
		const ratio_fov = 2 * Math.atan(cone_half_width / (ratio * msg.max_range));

		data[msg.header.frame_id] = {
			yaw: yaw,
			cone_half_width: cone_half_width,
			field_of_view: ratio_fov,
			min_range: ratio * msg.min_range,
			max_range: ratio * msg.max_range,
			range: ratio * msg.range,
			type: msg.radiation_type,
			pose: pose,
			stamp: new Date()
		}
		drawRanges();

		if(!error){
			status.setOK();
		}
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/Range");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	text_range.innerText = "Range: ?";
	text_min.innerText = "Min: ?";
	text_max.innerText = "Max: ?";
	text_fov.innerText = "Field of view: ?";
	text_type.innerText = "Type: ?";

	topic = selectionbox.value;
	connect();
});

selectionbox.addEventListener("click", connect);
icon.addEventListener("click", loadTopics);

loadTopics();
resizeScreen();

console.log("Range Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/range/range_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 10;"></canvas>


================================================
FILE: vizanti_server/public/templates/reconfigure/reconfigure_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/reconfigure.svg" alt="Reconfigure" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/reconfigure/reconfigure_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Parameter Reconfigure</h3>
		<hr class="dark_hr"/>
		<label for="{uniqueID}_node">Node name:</label>
		<select id="{uniqueID}_node" name="node">
			<!-- add topics here-->
		</select>

		<span style="display:flex; align-items: center;"><button id="{uniqueID}_refresh" style="margin-top: 12px; margin-bottom: 6px;">Refresh</button><div id="{uniqueID}_loader" class="loader"></div></span>

		<hr class="dark_hr"/>

		<div id="{uniqueID}_params">
			<!-- add params here-->

		</div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/reconfigure/reconfigure_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);

let rosbridge = rosbridgeModule.rosbridge;

const PARAM_TYPES = [
	"NOT_SET",		//0
	"BOOL",			//1
	"INTEGER",		//2
	"DOUBLE",		//3
	"STRING",		//4
	"BYTE_ARRAY",	//5
	"BOOL_ARRAY",	//6
	"INTEGER_ARRAY",//7
	"DOUBLE_ARRAY",	//8
	"STRING_ARRAY"	//9
]

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const nodeSelector = document.getElementById("{uniqueID}_node");
const loaderSpinner = document.getElementById("{uniqueID}_loader");
const paramBox = document.getElementById("{uniqueID}_params");
const refreshButton = document.getElementById("{uniqueID}_refresh");

let nodeName = "";
let cached_params = {};

async function getNodeParameters(node) {
	const getNodeParametersService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/get_node_parameters",
		serviceType: "vizanti_msgs/srv/GetNodeParameters",
	});

	return new Promise((resolve, reject) => {
		const request = new ROSLIB.ServiceRequest({ node });
		getNodeParametersService.callService(request, (result) => {
			resolve(JSON.parse(result.parameters));
		}, (error) => {
			reject(error);
		});
	});
}

async function setNodeParameter(node, param, newValue) {
	const setParamClient = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: '/vizanti/set_node_parameter',
		serviceType: 'vizanti_msgs/srv/SetNodeParameter',
	});

	return new Promise((resolve, reject) => {
		const request = new ROSLIB.ServiceRequest({
			 node: node+"",
			 param: param.toLocaleString('en-US'),
			 value: newValue.toLocaleString('en-US')
		});
		setParamClient.callService(request, (response) => {
			resolve(response);
		}, (error) => {
			console.error(`Failed to call set_parameters service for ${node}:`, error);
			reject(error);
		});
	});
}


function createParameterInput(fullname, defaultValue, type, element) {
	const name = fullname.split(".").at(-1);
	const id = "${uniqueID}_"+fullname;
	const arrowId = `${id}_arrow`;
	let inputElement;

	switch (type) {
		case "STRING":
			inputElement = `
				<label for="${id}"><i>string </i> ${name}:</label>
				<span><input id="${id}" type="text" value="${defaultValue}"><span id="${arrowId}" class="arrow" style="visibility: hidden;">➡</span></span>
				<div class="spacer"></div>`;
			break;
		case "INTEGER":
			inputElement = `
				<label for="${id}"><i>int </i> ${name}:</label>
				<span><input type="number" value="${defaultValue}" step="1" id="${id}"><span id="${arrowId}" class="arrow" style="visibility: hidden;">➡</span></span>
				<div class="spacer"></div>`;
			break;
		case "DOUBLE":
			inputElement = `
				<label for="${id}"><i>float </i>${name}:</label>
				<span><input type="number" value="${defaultValue}" step="0.001" id="${id}"><span id="${arrowId}" class="arrow" style="visibility: hidden;">➡</span></span>
				<div class="spacer"></div>`;
			break;
		case "BOOL":
			inputElement = `
				<label for="${id}"><i>bool </i>${name}:</label>
				<span><input type="checkbox" id="${id}" ${defaultValue ? "checked" : ""}><span id="${arrowId}" class="arrow" style="visibility: hidden;">➡</span></span>
				<div class="spacer"></div>`;
			break;
		default:
			console.error("Invalid parameter type:", type);
			return;
	}

	element.insertAdjacentHTML("beforeend", inputElement);

	setTimeout(()=>{
		document.getElementById(id).addEventListener("change", (event) => {
			let val;

			switch(type){
				case "STRING": val = event.target.value; break;
				case "INTEGER": val = parseInt(event.target.value); break;
				case "DOUBLE": val = parseFloat(event.target.value); break;
				case "BOOL": val = event.target.checked; break;
			}
			setNodeParameter(nodeName, fullname, val);

			const arrowElement = document.getElementById(arrowId);
			arrowElement.style.visibility = "visible";
			arrowElement.style.animation = "none";
			// Force reflow to make the new animation take effect
			arrowElement.offsetHeight;
			arrowElement.style.animation = null;

			arrowElement.addEventListener('animationend', () => {
				arrowElement.style.visibility = "hidden";
			}, {once: true});
		});
	}, 1);
}

function addParams(list, element){
	for (const name of Object.keys(list)) {
		const entry = list[name];
		if (Array.isArray(entry)) {
			const [fullname, value, type_ord] = entry;
			createParameterInput(fullname, value, PARAM_TYPES[type_ord], element);
		}else{ 
			const detailsElement = document.createElement('details');
			detailsElement.innerHTML = "<summary>"+name+"</summary>";
			element.appendChild(detailsElement);
			addParams(entry, detailsElement);
		}
	}
}

async function listParameters(){

	function buildRecursiveDict(list) {
		const result = {};
	
		list.forEach(([name, value, type_ordinal]) => {
			const parts = name.split('.'); // Split the name by dot as per apparent convention
			let current = result;
	
			for (let i = 0; i < parts.length; i++) {
				const part = parts[i];
				if (i === parts.length - 1) {
					current[part] = [name, value, type_ordinal];
				} else {
					if (!current[part]) {
						current[part] = {};
					}
					current = current[part];
				}
			}
		});
	
		return result;
	}

	if(nodeName == ""){
		return;
	}

	loaderSpinner.style.display = "block";
	paramBox.innerHTML = "";

	if(cached_params[nodeName]){
		addParams(cached_params[nodeName], paramBox);
	}
	
	const data = await getNodeParameters(nodeName);
	const grouped_data = buildRecursiveDict(data);
	paramBox.innerHTML = "";
	addParams(grouped_data, paramBox);
	cached_params[nodeName] = grouped_data;

	loaderSpinner.style.display = "none";
}

async function setNodeList(){
	let results = await rosbridge.get_all_nodes();
	let nodelist = "";
	let value = "";
	let nodes = [];
	for (const node of results.nodes) {
		if(!node.includes("vizanti")){
			nodelist += "<option value='"+node+"'>"+node+"</option>"
			nodes.push(node);
		}

		if(node.includes(nodeName)){
			value = nodeName;
		}
	}
	nodeSelector.innerHTML = nodelist;
	loaderSpinner.style.display = "none";

	//keep last selected if still available
	if(value == "")
		nodeName = nodeSelector.value;
	else
		nodeSelector.value = value;

	listParameters();
}

nodeSelector.addEventListener("change", (event)=>{
	nodeName = nodeSelector.value;
	listParameters();
});

refreshButton.addEventListener("click", listParameters);
icon.addEventListener("click", setNodeList);

console.log("Reconfigure Widget Loaded {uniqueID}");


================================================
FILE: vizanti_server/public/templates/robotmodel/robotmodel_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/robotmodel.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/robotmodel/robotmodel_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Robot Model</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<div class="sprite-selector">
			<div class="tab" id="{uniqueID}_gallery_tabs">
				<button class="tablinks active-tab" id="{uniqueID}_ground">Ground</button>
				<button class="tablinks" id="{uniqueID}_sea">Sea</button>
				<button class="tablinks" id="{uniqueID}_air">Air</button>
				<button class="tablinks" id="{uniqueID}_misc">Misc</button>
			</div>
			
			<div class="thumbnail-gallery" id="{uniqueID}_gallery">
				<!-- Thumbnails will be populated here -->
			</div>
		</div>

		<p class="comment">Renders a simple 2D sprite of a fixed size relative to a TF link, for scale. </p>


		<label for="{uniqueID}_frame">TF Frame:</label>
		<select id="{uniqueID}_frame" name="topic">
			<option value='base_link'>base_link</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_length">Robot Length (m):</label>
		<input type="number" value="0.5" step="0.01" min="0.01" id="{uniqueID}_length">

		<div class="spacer"></div>

		<label for="{uniqueID}_offset_x">X offset (m):</label>
		<input type="number" value="0.0" step="0.01" id="{uniqueID}_offset_x">

		<div class="spacer"></div>

		<label for="{uniqueID}_offset_y">Y offset (m):</label>
		<input type="number" value="0.0" step="0.01"  id="{uniqueID}_offset_y">

		<div class="spacer"></div>

		<label for="{uniqueID}_offset_yaw">Yaw offset (deg):</label>
		<input type="number" value="0.0" step="0.01" min="-180" max="180" id="{uniqueID}_offset_yaw">

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">1.0</span>
		<input type="range" value="1.0" step="0.05" min="0.1" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<h4>Adding custom sprites</h4>

		<p class="comment">The sprites are sourced from vizanti/public/assets/robot_model/ and should start with an underscore, must be in .png format and will rotate around the image center.</p>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/robotmodel/robotmodel_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let pathsModule = await import(`${base_url}/assets/robot_model/paths`);

let view = viewModule.view;
let tf = tfModule.tf;
let settings = persistentModule.settings;
let Status = StatusModule.Status;
let paths = pathsModule.default;

let models = {};
let categorizedModels = {};
let thumbnailCache = {};

// Since paths is now categorized, we need to handle it differently
Object.keys(paths).forEach(category => {
	categorizedModels[category] = [];

	paths[category].forEach(file => {
		const name = file.split('.png')[0].split("_").join(" ").trim();
		categorizedModels[category].push(name);
		
		if (!models[name]) {
			models[name] = new Image();
			models[name].category = category;

			if(category == "misc")
				models[name].src = `${base_url}/assets/robot_model/${file}`;
			else
				models[name].src = `${base_url}/assets/robot_model/${category}/${file}`;
		}
	});
});

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const frameSelector = document.getElementById("{uniqueID}_frame");
const lengthSelector = document.getElementById("{uniqueID}_length");
const galleryTabs = document.getElementById("{uniqueID}_gallery_tabs");
const gallery = document.getElementById('{uniqueID}_gallery');

const offsetXSelector = document.getElementById("{uniqueID}_offset_x");
const offsetYSelector = document.getElementById("{uniqueID}_offset_y");
const offsetYawSelector = document.getElementById("{uniqueID}_offset_yaw");

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');
opacitySlider.addEventListener('input', () =>  {
	opacityValue.textContent = opacitySlider.value;
	saveSettings();
});

offsetXSelector.addEventListener('input', saveSettings);
offsetYSelector.addEventListener('input', saveSettings);
offsetYawSelector.addEventListener('input', saveSettings);

let frame = find_base_frame();
let sprite = "4wd";

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	frame = loaded_data.frame;
	lengthSelector.value = loaded_data.length;

	offsetXSelector.value = loaded_data.offset_x ?? 0.0;
	offsetYSelector.value = loaded_data.offset_y ?? 0.0;
	offsetYawSelector.value = loaded_data.offset_yaw ?? 0.0;

	opacitySlider.value = loaded_data.opacity  ?? 1.0;
	opacityValue.innerText = opacitySlider.value;
	canvas.style.opacity = opacitySlider.value;

	sprite = loaded_data.sprite.trim() ?? "4wd";
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		frame: frame,
		sprite: sprite,
		opacity: opacitySlider.value,
		length: lengthSelector.value,
		offset_x: offsetXSelector.value,
		offset_y: offsetYSelector.value,
		offset_yaw: offsetYawSelector.value,
	}
	settings.save();

	canvas.style.opacity = opacitySlider.value;
}

function find_base_frame(){
	//try base_link first
	for (const key of tf.frame_list.values()) {
		if (key.includes("base_link")) {
			return key
		}
	}

	//maybe footprint?
	for (const key of tf.frame_list.values()) {
		if (key.includes("base_footprint")) {
			return key
		}
	}

	//ok just base then...?
	for (const key of tf.frame_list.values()) {
		if (key.includes("base")) {
			return key
		}
	}

	//eh screw it
	return "base_link";
}

async function drawRobot() {

	const unit = view.getMapUnitsInPixels(1.0);
	const length = lengthSelector.value * unit;

    const wid = canvas.width;
    const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, wid, hei);

	const robotframe = tf.absoluteTransforms[frame];
	const modelimg = models[sprite];

	if(robotframe && modelimg){

		const pos = view.fixedToScreen({
			x: robotframe.translation.x,
			y: robotframe.translation.y
		});

		const matrix = view.quaterionToProjectionMatrix(robotframe.rotation);

		let ratio = modelimg.naturalHeight/modelimg.naturalWidth;
		ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], pos.x, pos.y); //sx,0,0,sy,px,py

		const offset_x = parseFloat(offsetXSelector.value) * unit;
		const offset_y = parseFloat(offsetYSelector.value) * unit;
		const offset_yaw = (parseFloat(offsetYawSelector.value) * (Math.PI / 180.0)) + Math.PI;

		ctx.transform(1, 0, 0, 1,  offset_x, offset_y);
		ctx.rotate(offset_yaw)

		ctx.drawImage(modelimg, -length/2, -(length*ratio)/2, length, length*ratio);
		
		status.setOK();
	}else{
		if(robotframe){
			status.setError("Required robot sprite not found..?");
		}else{
			status.setError("Required transform frame \""+frame+"\" not found.");
		}
	}
}

function buildThumbnailGallery() {

	function generateThumbnail(image, size = 64) {
		const scale = Math.min(size / image.naturalWidth, size / image.naturalHeight);
		const scaledWidth = image.naturalWidth * scale;
		const scaledHeight = image.naturalHeight * scale;

		const canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;

		const ctx = canvas.getContext('2d');
		ctx.clearRect(0, 0, size, size);
		ctx.drawImage(
			image, 
			(size - scaledWidth) / 2, //x
			(size - scaledHeight) / 2, //y
			scaledWidth, 
			scaledHeight
		);
		
		return canvas.toDataURL();
	}

	function selectSprite(event, modelName) {
		sprite = modelName;

		gallery.querySelectorAll('.thumbnail-item').forEach(item => {
			item.classList.remove('selected');
		});

		gallery.querySelectorAll('.thumbnail-item').forEach(item => {
			if (item.querySelector('.thumb-label').textContent === modelName) {
				item.classList.add('selected');
			}
		});

		event.currentTarget.classList.add('selected');
		
		saveSettings();
	}

    const activeTab = galleryTabs.querySelector('.active-tab');
    const category = activeTab.id.replace("{uniqueID}_","");
    
    gallery.innerHTML = '';
    if (categorizedModels[category]) {

        categorizedModels[category].sort().forEach(modelName => {
            const model = models[modelName];
            if (!model) return;
            
            // Generate or get cached thumbnail
            if (!thumbnailCache[modelName]) {
                thumbnailCache[modelName] = generateThumbnail(model);
            }
            
            // Create thumbnail element
            const thumbDiv = document.createElement('div');
            thumbDiv.className = 'thumbnail-item';

            if (sprite === modelName)
				thumbDiv.classList.add('selected');
            
            thumbDiv.innerHTML = `
                <img src="${thumbnailCache[modelName]}" alt="${modelName}">
                <span class="thumb-label">${modelName}</span>
            `;
            
            thumbDiv.addEventListener('click', (event) => selectSprite(event, modelName));
            gallery.appendChild(thumbDiv);
        });
    }
}

function setActiveCategory(element){
	galleryTabs.querySelectorAll('.active-tab').forEach(item => {
		item.classList.remove('active-tab');
	});

	element.classList.add('active-tab');
	buildThumbnailGallery();
}

galleryTabs.addEventListener('click', (event) => {
	if(event.target != null && event.target.classList.contains("tablinks")){
		setActiveCategory(event.target);
		drawRobot();
	}	
});

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawRobot();
}

window.addEventListener("tf_fixed_frame_changed", drawRobot);
window.addEventListener("tf_changed", ()=>{
	if(frame != tf.fixed_frame){
		drawRobot();
	}
});

window.addEventListener("view_changed", drawRobot);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

// TF frame list
function setFrameList(){
	let framelist = "";
	for (const key of tf.frame_list.values()) {
		framelist += "<option value='"+key+"'>"+key+"</option>"
	}
	frameSelector.innerHTML = framelist;

	if(tf.transforms.hasOwnProperty(frame)){
		frameSelector.value = frame;
	}else{
		framelist += "<option value='"+frame+"'>"+frame+"</option>"
		frameSelector.innerHTML = framelist
		frameSelector.value = frame;
	}

	if(models[sprite]){
		const element = document.getElementById("{uniqueID}_"+models[sprite].category);
		setActiveCategory(element);
	}
}

frameSelector.addEventListener("change", (event) => {
	frame = frameSelector.value;
	saveSettings();
});

lengthSelector.addEventListener("input", saveSettings);

frameSelector.addEventListener("click", setFrameList);
icon.addEventListener("click", setFrameList);

frameSelector.addEventListener("change", (event) =>{
	frame = frameSelector.value;
	drawRobot();
	saveSettings();
});

resizeScreen();

console.log("Model Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/robotmodel/robotmodel_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 9;"></canvas>


================================================
FILE: vizanti_server/public/templates/rosbag/rosbag_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/rosbag.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/rosbag/rosbag_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Bag Recorder</h3>
		<hr class="dark_hr"/>


		<label for="{uniqueID}_savepath">Save to path:</label>
		<input id="{uniqueID}_savepath" type="text" value="~/recording.bag">

		<div class="spacer"></div>


		<button id="{uniqueID}_selectall">Select All</button>

		<div class="spacer"></div>

		<button id="{uniqueID}_selectnone">Select None</button>
		
		<div class="spacer"></div>

		<button id="{uniqueID}_toggle" style="background-color: rgb(38, 104, 31);">Start recording</button>

		<div class="spacer"></div>

		<b>Topics:</b>
		<div class="spacer"></div>
		<div id="{uniqueID}_topics">
			
		</div>

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/rosbag/rosbag_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;

const savePathBox = document.getElementById("{uniqueID}_savepath");
const selectAllButton = document.getElementById('{uniqueID}_selectall');
const selectNoneButton = document.getElementById('{uniqueID}_selectnone');
const startButton = document.getElementById('{uniqueID}_toggle');

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

let path = "~/recording.bag";
let topic_list = new Set();
let active = false;

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	path = loaded_data.path;
	topic_list = new Set(loaded_data.topic_list);
}else{
	saveSettings();
}

savePathBox.value = path;

function saveSettings(){
	settings["{uniqueID}"] = {
		path: path,
		topic_list: Array.from(topic_list)
	}
	settings.save();
}

async function getRecordingStatus(topics, start, path) {
	const recordRosbagService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/bag/status",
		serviceType: "std_srvs/srv/Trigger",
	});

	return new Promise((resolve, reject) => {
		const request = new ROSLIB.ServiceRequest({ topics, start, path });
		recordRosbagService.callService(request, (result) => {
			setState(result.success);
			resolve(result.success);		
		}, (error) => {
			console.log(error);
			resolve(false);
		});
	});
}

function getCurrentDateTimeString() {
	const date = new Date();
	const year = date.getFullYear();
	const month = (date.getMonth() + 1).toString().padStart(2, '0');
	const day = date.getDate().toString().padStart(2, '0');
	const hours = date.getHours().toString().padStart(2, '0');
	const minutes = date.getMinutes().toString().padStart(2, '0');

	return `${year}-${month}-${day}-${hours}-${minutes}`;
}

async function recordRosbag(topics, start, path) {
	const recordRosbagService = new ROSLIB.Service({
		ros: rosbridge.ros,
		name: "/vizanti/bag/setup",
		serviceType: "vizanti_msgs/srv/RecordRosbag",
	});

	const timestamp = getCurrentDateTimeString();
    const pathArray = path.split("/");
    const fileName = pathArray.pop();
    const timepath = `${pathArray.join("/")}/${timestamp}-${fileName}`;

	return new Promise((resolve, reject) => {
		const request = new ROSLIB.ServiceRequest({ topics, start, path: timepath });
		recordRosbagService.callService(request, (result) => {
			resolve(result);
		}, (error) => {
			reject(error);
			alert(error);
		});
	});
}

function setState(state){
	if(state){
		startButton.style.backgroundColor = "#e14044ff";
		startButton.style.color = "black";
		startButton.innerText = "Stop recording";
		icon.src = "assets/rosbag_active.svg";
	}else{
		startButton.style.backgroundColor = "rgb(38, 104, 31)";
		startButton.style.color = "white";
		startButton.innerText = "Start recording";
		icon.src = "assets/rosbag.svg";
	}

	active = state;
}

async function startRecording() {
	if(await confirm("Are you sure you want to start recording a bag?")){
		const result = await recordRosbag(Array.from(topic_list), true, path);
		setState(result.success);
		alert(result.message)
	}
}

async function stopRecording() {
	if(await confirm("Are you sure you want to stop recording?")){
		const result = await recordRosbag([], false, '');
		setState(!result.success);
		alert(result.message)
	}
}

startButton.addEventListener('click', async () => {
	if(active){
		stopRecording();
	}else{
		startRecording();
	}
	saveSettings();
});

selectAllButton.addEventListener('click', async () => {
	let result = await rosbridge.get_all_topics();

	result.topics.forEach((topic) => {
		if(!topic.includes("/vizanti/tf_consolidated")){
			topic_list.add(topic);
		}
	});
	
	updateTopics();
	saveSettings();
});

selectNoneButton.addEventListener('click', async () => {
	topic_list = new Set();	
	updateTopics();
	saveSettings();
});

savePathBox.addEventListener('input', async () => {
	path = savePathBox.value;
	saveSettings();
});

const topicsDiv = document.getElementById('{uniqueID}_topics');

async function updateTopics(){
	//recheck in case another client started a recording
	await getRecordingStatus();

	let result = await rosbridge.get_all_topics();

	topicsDiv.innerHTML = '';

	// Group topics by type
	let topicsByType = new Map();
	result.topics.forEach((topic, index) => {
		if(!topic.includes("/vizanti/tf_consolidated")){
			const type = result.types[index];
			if (topicsByType.has(type)) {
				topicsByType.get(type).push(topic);
			} else {
				topicsByType.set(type, [topic]);
			}
		}
	});

	// Create checkboxes for each group of topics
	topicsByType.forEach((topics, type) => {
		const brBefore = document.createElement('div');
		brBefore.className = 'spacer';
		topicsDiv.appendChild(brBefore);

		const button = document.createElement('button');
		button.textContent = type;
		button.className = 'collapsible';

		const div = document.createElement('div');
		div.className = 'content';
	   	div.style.display = 'none';  // Initially hide the content

		topics.forEach(topic => {
			const checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.id = `${uniqueID}_${topic}`;
			checkbox.checked = topic_list.has(topic);
			checkbox.addEventListener('change', (event) => {
				if(checkbox.checked){
					topic_list.add(topic);
				}else{
					topic_list.delete(topic);
				}
				saveSettings();
			});

			const label = document.createElement('label');
			label.textContent = ` ${topic}`;

			const span = document.createElement('span');
			span.style.whiteSpace = "nowrap";
			span.appendChild(checkbox);
			span.appendChild(label);
			div.appendChild(span);

			const br = document.createElement('div');
			br.className = 'spacer';
			div.appendChild(br);

			if(checkbox.checked)
				div.style.display = 'block';
		});

		topicsDiv.appendChild(button);
		topicsDiv.appendChild(div);
	});

	// Add event listener to all collapsible buttons
	let coll = document.getElementsByClassName('collapsible');
	for (let i = 0; i < coll.length; i++) {
		coll[i].addEventListener('click', function() {
			this.classList.toggle('active');
			let content = this.nextElementSibling;
			if (content.style.display === 'block') {
				content.style.display = 'none';
			} else {
				content.style.display = 'block';
			}
		});
	}

	saveSettings();
}

icon.addEventListener("click", updateTopics);
updateTopics();

console.log("Rosbag Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/rosbridge/rosbridge_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/rosbridge_disconnected.svg" alt="Rosbridge" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 




================================================
FILE: vizanti_server/public/templates/rosbridge/rosbridge_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Rosbridge Connection</h3>
		<hr class="dark_hr"/>
		<p id="{uniqueID}_status" class="status" style="font-size: 1rem;"></p>
		<p id="{uniqueID}_url"></p>
		<p id="{uniqueID}_compression"></p>

		<p class="comment">A WS (not WSS) rosbridge instance is expected on port 5001 by default.</p>

		<div class="spacer"></div>

		<button id="{uniqueID}_reload">Force reload</button>

	</div>
</div>



================================================
FILE: vizanti_server/public/templates/rosbridge/rosbridge_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let url = document.getElementById("{uniqueID}_url");
let compression = document.getElementById("{uniqueID}_compression");
let icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

let button_reload = document.getElementById("{uniqueID}_reload");
button_reload.addEventListener("click", (event) => {
	location.reload(false);
});

// can't show images about reconnecting without preloading them before we lose connection
let img_reconnect = await imageToDataURL('assets/rosbridge_reconnect.svg');
let img_connect = await imageToDataURL('assets/rosbridge_connected.svg');
let img_disconnect = await imageToDataURL('assets/rosbridge_disconnected.svg');

function update_gui(){
	url.innerText = "Bridge URL: ws://"+rosbridge.url + ":"+rosbridge.port;
	compression.innerText = "Topic compression type: "+rosbridge.compression;

	switch (rosbridge.status) {
		case "Reconnecting...":
			icon.src = img_reconnect;
			status.setError(rosbridge.status);
			break;
		case "Connecting...":
			icon.src = img_connect;
			status.setWarn(rosbridge.status);
			break;
		case 'Connection lost.':
		case 'Failed to connect.':
			icon.src = img_disconnect;
			status.setError(rosbridge.status);
			break;
		default:
			icon.src = img_connect;
			status.setOK(rosbridge.status);
	}
}

window.addEventListener("rosbridge_change", function(event){
	update_gui();    
});

update_gui();


================================================
FILE: vizanti_server/public/templates/satelite/satelite_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/satelite.svg" alt="model" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/satelite/satelite_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Satelite Tiles</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_latitude">Latitude: ?</p>
			<p id="{uniqueID}_longitude">Longitude: ?</p> 
			<p id="{uniqueID}_altitude">Altitude: ?</p>
			<p id="{uniqueID}_covariance">Ground Covariance: ?</p>
		</div>


		Renders a tile map based on sensor_msgs/NavSatFix positional data. Use with a local origin for best results.

		<div class="spacer"></div>
		<hr class="dark_hr"/>
		<div class="spacer"></div>

		<label for="{uniqueID}_tileserver">Tile server URL:</label>
		<input list="tileserver" style="margin-top: 0.3em; margin-bottom: 0.3em; width: 95%" id="{uniqueID}_tileserver" type="text" value="https://tile.openstreetmap.org/{z}/{x}/{y}.png">

		<!-- Known usable providers -->
		<datalist id="tileserver">
			<option value="https://tile.openstreetmap.org/{z}/{x}/{y}.png">
			<option value="https://tiles.stadiamaps.com/tiles/outdoors/{z}/{x}/{y}.png">
			<option value="https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}"></option>
		</datalist> 


		<p class="comment">The tile server can be changed to anything that uses 265x256 sized tiles, the Web Mercator projection, and follows the same {x},{y},{z} convention. </p>

		<div class="spacer"></div>

		<label>Texture smoothing:</label>
		<input type="checkbox" checked id="{uniqueID}_smoothing">

		<p class="comment">Max tile zoom doesn't provide much detail up close, so you get to chose between pixelated or blurry.</p>

		<div class="spacer"></div>

		<label>Ignore tf rotations:</label>
		<input type="checkbox" checked id="{uniqueID}_ignore_rotation">

		<p class="comment">Displaying the map with 0 yaw rotation can make viewing raw NavSatFix data from receivers more stable, but don't expect the robot to be facing the right way.</p>

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">0.7</span>
		<input type="range" value="0.7" step="0.05" min="0.0" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<h4>Tile Management</h4>

		<p>Import and export downloaded tiles to a file.</p>

		<div class="spacer"></div>

		<span><button id="{uniqueID}_export_DB" class="export_button">⇑ Export</button><button id="{uniqueID}_import_DB" class="export_button">⇓ Import</button></span>

		<div class="spacer"></div>

		<p class="comment">All fetched tiles are stored in IndexedDB for quick loading and offline use. However, browser-cached data is tied to the site's URL, so if your robot's IP changes (e.g. switching from a local network to offline AP mode), the tiles won't be accessible. To solve this, fetch and export the database while online, and reimport it in offline mode or on other machines.</p>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/satelite/satelite_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let navsatModule = await import(`${base_url}/js/modules/navsat.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let navsat = navsatModule.navsat;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let copyright = "© OpenStreetMap";
let topic = getTopic("{uniqueID}");
let server_url = "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
let listener = undefined;
let zoomLevel = 12;

let map_topic = undefined;
let map_fix = undefined;
let fix_data = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const tileServerString = document.getElementById('{uniqueID}_tileserver');
const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');
const smoothingCheckbox = document.getElementById('{uniqueID}_smoothing');
const ignoreRotationCheckbox = document.getElementById('{uniqueID}_ignore_rotation');

const text_lat = document.getElementById("{uniqueID}_latitude");
const text_lon = document.getElementById("{uniqueID}_longitude");
const text_alt = document.getElementById("{uniqueID}_altitude");
const text_cov = document.getElementById("{uniqueID}_covariance");

const placeholder = new Image();
placeholder.src = "assets/tile_loading.png";

function setOpacityText(val){
	if(val == 0.0)
		opacityValue.textContent = "0.0 (Tile rendering disabled)";
	else
		opacityValue.textContent = val;
}

opacitySlider.addEventListener('input', function () {
	setOpacityText(this.value);
	saveSettings();
});

smoothingCheckbox.addEventListener('change', saveSettings);
ignoreRotationCheckbox.addEventListener('change', saveSettings);

tileServerString.addEventListener('input', function () {
	server_url = this.value;

	if(server_url.includes("tile.openstreetmap.org"))
		copyright = "© OpenStreetMap";
	else
		copyright = "";

	saveSettings();
});

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });
ctx.clip = function(){};

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	server_url = loaded_data.server_url;

	if(server_url.includes("tile.openstreetmap.org"))
		copyright = "© OpenStreetMap";
	else
		copyright = "";

	smoothingCheckbox.checked = loaded_data.smoothing;
	ignoreRotationCheckbox.checked = loaded_data.ignore_rotation ?? false;

	opacitySlider.value = loaded_data.opacity;
	setOpacityText(loaded_data.opacity);
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		server_url: server_url,
		opacity: opacitySlider.value,
		smoothing: smoothingCheckbox.checked,
		ignore_rotation: ignoreRotationCheckbox.checked
	}
	settings.save();
}

function drawTile(screenSize, i, j, tempMeterSize, tempZoomLevel, maxtile){

	//wrap around the date line
	const x = (fix_data.tilePos.x + i + maxtile + 1) % (maxtile + 1);
	const y = (fix_data.tilePos.y + j + maxtile + 1) % (maxtile + 1);

	const offsetX = fix_data.offset.x - i * tempMeterSize;
	const offsetY = fix_data.offset.y - j * tempMeterSize;

	const tileURL = server_url.replace("{z}",tempZoomLevel).replace("{x}",x).replace("{y}",y);
	let tileImage = navsat.live_cache[tileURL];

	if(!tileImage || !tileImage.complete){
		tileImage = placeholder;
		navsat.enqueue(tileURL);
	}

	let transformed = undefined;

	if(!ignoreRotationCheckbox.checked){
		transformed = tf.transformPose(
			map_fix.header.frame_id,
			tf.fixed_frame,
			{x: -offsetX, y: offsetY, z: 0},
			new Quaternion()
		);
	}else{
		transformed = tf.transformPose(
			map_fix.header.frame_id,
			tf.fixed_frame,
			{x: 0, y: 0, z: 0},
			new Quaternion()
		);

		transformed.translation.x -= offsetX;
		transformed.translation.y += offsetY;
		transformed.rotation = Quaternion()
	}

	const pos = view.fixedToScreen({
		x: transformed.translation.x,
		y: transformed.translation.y,
	});

	const matrix = view.quaterionToProjectionMatrix(transformed.rotation);
	ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], pos.x, pos.y);
	ctx.drawImage(tileImage, 0, 0, screenSize, screenSize);
}

function clamp(val, from, to){
    if(val > to)
        return to;
    if(val < from)
        return from;
    return val;
}

//Rendering
async function drawTiles(){

	const wid = canvas.width;
    const hei = canvas.height;

	ctx.clearRect(0, 0, wid, hei);
	ctx.globalAlpha = opacitySlider.value;
	ctx.imageSmoothingEnabled = smoothingCheckbox.checked;

	if(!map_fix){
		return;
	}

	if(opacitySlider.value == 0.0){
		status.setOK();
		return;
	}

	const frame = tf.absoluteTransforms[map_fix.header.frame_id];

	let	tempZoomLevel = Math.round(Math.log2(view.scale)+17);
	tempZoomLevel = clamp(tempZoomLevel, 7, 19);
	if(tempZoomLevel != zoomLevel){
		navsat.clear_queue();
		zoomLevel = tempZoomLevel;
		updateFixData();
	}


	if(frame){

		let metersSize = navsat.tileSizeInMeters(map_fix.latitude, tempZoomLevel)
		const tileScreenSize = view.getMapUnitsInPixels(metersSize);
		const corners = [
			{ x: 0, y: 0, z: 0 },
			{ x: wid, y: 0, z: 0 },
			{ x: wid, y: hei, z: 0  },
			{ x: 0, y: hei, z: 0  },
		];

		// Convert the corners from pixels to meters, transform them to map_fix frame and convert to latitude, longitude
		const cornerCoords = corners.map((corner) => {
			const meters = view.screenToFixed(corner);

			let transformed;
			if(ignoreRotationCheckbox.checked){
				transformed = {
					translation: {
						x: -tf.absoluteTransforms[map_fix.header.frame_id].translation.x + meters.x,
						y: -tf.absoluteTransforms[map_fix.header.frame_id].translation.y + meters.y
					}
				}
			}else{
				transformed = tf.transformPose(
					tf.fixed_frame,
					map_fix.header.frame_id,
					meters,
					new Quaternion()
				);
			}
			return {
				latitude: map_fix.latitude + (transformed.translation.y * fix_data.degreesPerMeter.latitude),
				longitude: map_fix.longitude + (transformed.translation.x * fix_data.degreesPerMeter.longitude)
			};
		});

		// Convert the corners to tile coordinates
		const cornerTileCoords = cornerCoords.map((coord) =>
			navsat.coordToTile(coord.longitude, coord.latitude, tempZoomLevel)
		);

		// Calculate the range of tiles to cover the screen
		const minX = Math.min(...cornerTileCoords.map((coord) => coord.x)) - fix_data.tilePos.x - 1;
		const maxX = Math.max(...cornerTileCoords.map((coord) => coord.x)) - fix_data.tilePos.x + 1;
		const minY = Math.min(...cornerTileCoords.map((coord) => coord.y)) - fix_data.tilePos.y - 1;
		const maxY = Math.max(...cornerTileCoords.map((coord) => coord.y)) - fix_data.tilePos.y + 1;

		//draw tiles in concentric circles, starting from the center of the screen
		const matrixWidth = (maxX - minX)+2;
		const matrixHeight = (maxY - minY)+2;
		const centerX = Math.round((maxX+minX)/2);
		const centerY = Math.round((maxY+minY)/2)-1;
		const maxtile = Math.pow(2, tempZoomLevel) - 1;

		let x = 0;
		let y = 0;
		let dx = 0;
		let dy = -1;

		const maxDimension = Math.max(matrixWidth, matrixHeight);
		for (let i = 0; i < maxDimension ** 2; i++) {
			if (-matrixWidth / 2 < x && x <= matrixWidth / 2 && -matrixHeight / 2 < y && y <= matrixHeight / 2) {
				drawTile(tileScreenSize, centerX+x, centerY+y, metersSize, tempZoomLevel, maxtile);
			}
			if (x === y || (x < 0 && x === -y) || (x > 0 && x === 1 - y)) {
				[dx, dy] = [-dy, dx];
			}
			x += dx;
			y += dy;
		}

		//transform reset
		ctx.setTransform(1, 0, 0, 1, 0, 0);

		ctx.globalAlpha = 0.6;
		ctx.fillStyle = "#171717";
		ctx.fillRect(0, hei-20, 120, 20);

		ctx.globalAlpha = 1.0;
		ctx.font = "12px Monospace";
		ctx.fillStyle = "white";
		ctx.fillText(copyright, 5, hei-5);

		status.setOK();
	}else{
		status.setError("Required transform frame \""+map_fix.header.frame_id+"\" not found.");
	}
}

const COVARIANCE_TYPE = {
	0: "(unknown)",
	1: "(approximated)",
	2: "(diagonal known)",
	3: "(known)"
}

//Topic
function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(map_topic !== undefined){
		map_topic.unsubscribe(listener);
	}

	map_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/NavSatFix',
		throttle_rate: 33
	});

	status.setWarn("No data received.");
	text_lat.innerText = "Latitude: ?";
	text_lon.innerText = "Longitude: ?";
	text_alt.innerText = "Altitude: ?";
	text_cov.innerText = "Ground Covariance: ?";
	
	listener = map_topic.subscribe((msg) => {

		const cov_mat = msg.position_covariance;
		const covariance_meters = Math.hypot(Math.sqrt(cov_mat[0]), Math.sqrt(cov_mat[4]))

		if(msg.latitude != null)
			text_lat.innerText = "Latitude: " + msg.latitude.toFixed(8)+"°";

		if(msg.longitude != null)
			text_lon.innerText = "Longitude: " + msg.longitude.toFixed(8)+"°";

		if(msg.altitude != null)
			text_alt.innerText = "Altitude: " + msg.altitude.toFixed(2)+" m";

		text_cov.innerText = "Ground Covariance: " + covariance_meters.toFixed(2)+ " m " + COVARIANCE_TYPE[msg.position_covariance_type];

		if(msg.status.status == -1 || isNaN(msg.longitude) || isNaN(msg.latitude)){
			status.setWarn("No fix.");
			return;
		}

		map_fix = msg;
		updateFixData();
		drawTiles();
	});

	saveSettings();
}

function updateFixData(){
	const tilePos = navsat.coordToTile(map_fix.longitude, map_fix.latitude, zoomLevel);
	const tileCoords = navsat.tileToCoord(tilePos.x, tilePos.y, zoomLevel);
	const nextTileCoords = navsat.tileToCoord(tilePos.x+1, tilePos.y+1, zoomLevel);
	const metersSize = navsat.tileSizeInMeters(map_fix.latitude, zoomLevel);

	fix_data = {
		tilePos: tilePos,
		tileCoords: tileCoords,
		offset:{
			x: navsat.haversine(map_fix.latitude, tileCoords.longitude, map_fix.latitude, map_fix.longitude),
			y: navsat.haversine(tileCoords.latitude, map_fix.longitude, map_fix.latitude, map_fix.longitude)
		},
		metersSize: metersSize,
		degreesPerMeter: {
			longitude: Math.abs(tileCoords.longitude - nextTileCoords.longitude)/metersSize,
			latitude: Math.abs(tileCoords.latitude - nextTileCoords.latitude)/metersSize
		}
	}
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/NavSatFix");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawTiles();
}

window.addEventListener("navsat_tilecache_updated", drawTiles);
window.addEventListener("tf_fixed_frame_changed", drawTiles);
window.addEventListener("tf_changed", ()=>{
	if(map_fix && map_fix.header.frame_id != tf.fixed_frame){
		drawTiles();
	}
});

window.addEventListener("view_changed", drawTiles);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

document.getElementById("{uniqueID}_export_DB").addEventListener("click", async (event) =>{

	let filename = await prompt("Enter file name for tile DB export (.json will be appended automatically):", "navsat_tile_db");
	if (filename != null) {
		navsatModule.exportDatabase(filename+'.json');
	}
});

document.getElementById("{uniqueID}_import_DB").addEventListener("click", (event) =>{

	const input = document.createElement('input');
	input.type = 'file';
	input.accept = '.json';

	input.onchange = (event) => {
		const file = event.target.files[0];
		const reader = new FileReader();
		reader.onload = () => {
			try {
				navsatModule.importDatabase(reader.result);
			} catch (error) {
				console.error('Error importing DB file:', error);
			}
		};

		reader.readAsText(file);
	};

	input.click();
});

resizeScreen();

console.log("Satelite Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/satelite/satelite_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: -5;"></canvas>


================================================
FILE: vizanti_server/public/templates/scan/scan_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<object type="image/svg+xml" data="assets/scan.svg" alt="scan" width="50" height="50"></object>
</div> 


================================================
FILE: vizanti_server/public/templates/scan/scan_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Laser Scan</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_frame_text">TF Frame: ?</p>
			<p id="{uniqueID}_angle_text">Angle: ?</p>
			<p id="{uniqueID}_angleinc_text">Angle increment: ?</p>
			<p id="{uniqueID}_points_text">Points: ?</p>
			<p id="{uniqueID}_scan_time_text">Scan time: ?</p>
			<p id="{uniqueID}_rangemin_text">Min: ?</p>
			<p id="{uniqueID}_rangemax_text">Max: ?</p>
		</div>


		Renders lidar scan points based on sensor_msgs/LaserScan data.

		<div class="spacer"></div>

		<label for="{uniqueID}_opacity">Opacity:</label>
		<span id="{uniqueID}_opacity_value">1.0</span>
		<input type="range" value="1.0" step="0.05" min="0.0" max="1.0" id="{uniqueID}_opacity">

		<div class="spacer"></div>

		<label for="{uniqueID}_thickness">Thickness (m):</label>
		<span id="{uniqueID}_thickness_value">0.02</span>
		<input type="range" value="0.02" step="0.01" min="0.01" max="0.5" id="{uniqueID}_thickness">

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Colour:</label>
		<input type="color" value="#ff0000" id="{uniqueID}_colorpicker">

		<div class="spacer"></div>

		<label for="{uniqueID}_throttle">Socket throttle (ms):</label>
		<input type="number" value="2000" step="1" min="0" max="10000" id="{uniqueID}_throttle">

		<div class="spacer"></div>

		<p class="comment">Laser scans are typically high bandwidth topics, and as such can easily cause TCP congestion. Lower the socket throttle rate to get faster data updates, but note that other visualizers may stutter.</p>


		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/scan/scan_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let range_topic = undefined;
let listener = undefined;

let data = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const click_icon = document.getElementById("{uniqueID}_icon");
const icon = click_icon.getElementsByTagName('object')[0];

const text_angle = document.getElementById("{uniqueID}_angle_text");
const text_frame = document.getElementById("{uniqueID}_frame_text");
const text_angleinc = document.getElementById("{uniqueID}_angleinc_text");
const text_pointscount = document.getElementById("{uniqueID}_points_text");
const text_scantime = document.getElementById("{uniqueID}_scan_time_text");
const text_min = document.getElementById("{uniqueID}_rangemin_text");
const text_max = document.getElementById("{uniqueID}_rangemax_text");

const opacitySlider = document.getElementById('{uniqueID}_opacity');
const opacityValue = document.getElementById('{uniqueID}_opacity_value');

function setOpacityText(val){
	if(val == 0.0)
		opacityValue.textContent = "0.0 (Scan rendering disabled)";
	else
		opacityValue.textContent = val;
}

opacitySlider.addEventListener('input', () =>  {
	setOpacityText(opacitySlider.value);
	saveSettings();
	drawScan();
});

const thicknessSlider = document.getElementById('{uniqueID}_thickness');
const thicknessValue = document.getElementById('{uniqueID}_thickness_value');
thicknessSlider.addEventListener('input', () =>  {
	thicknessValue.textContent = thicknessSlider.value;
	saveSettings();
	drawScan();
});

const colourpicker = document.getElementById("{uniqueID}_colorpicker");
colourpicker.addEventListener("input", (event) =>{
	utilModule.setIconColor(icon, colourpicker.value);
	saveSettings();
	drawScan();
});

const throttle = document.getElementById('{uniqueID}_throttle');
throttle.addEventListener("input", (event) =>{
	saveSettings();
	connect();
});

//Settings
if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;

	opacitySlider.value = loaded_data.opacity;
	setOpacityText(loaded_data.opacity);

	thicknessSlider.value = loaded_data.thickness;
	thicknessValue.innerText = loaded_data.thickness;

	colourpicker.value = loaded_data.color;
	throttle.value = loaded_data.throttle;
}else{
	saveSettings();
}

//update the icon colour when it's loaded or when the image source changes
icon.onload = () => {
	utilModule.setIconColor(icon, colourpicker.value);
};
if (icon.contentDocument) {
	utilModule.setIconColor(icon, colourpicker.value);
}


function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		opacity: opacitySlider.value,
		thickness: thicknessSlider.value,
		color: colourpicker.value,
		throttle: throttle.value
	}
	settings.save();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

async function drawScan() {

	const wid = canvas.width;
	const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
	ctx.clearRect(0, 0, wid, hei);
	ctx.globalAlpha = opacitySlider.value;
	ctx.fillStyle = colourpicker.value;

	if(data == undefined || opacitySlider.value == 0.0){
		return;
	}

	const unit = view.getMapUnitsInPixels(1.0);
	const pixel = view.getMapUnitsInPixels(thicknessSlider.value);

	let pos = view.fixedToScreen({
		x: data.pose.translation.x,
		y: data.pose.translation.y,
	});

	ctx.setTransform(1,0,0,-1,pos.x, pos.y); //sx,0,0,sy,px,py
	const delta = parseInt(pixel/2);

	ctx.beginPath();
	for(let i = 0; i < data.points.length; i++){
		const x = data.points[i].x * unit - delta;
		const y = data.points[i].y * unit - delta;
		ctx.moveTo(x, y);
		ctx.lineTo(x + pixel, y);
		ctx.lineTo(x + pixel, y + pixel);
		ctx.lineTo(x, y + pixel);
		ctx.lineTo(x, y);
	}
	ctx.fill();
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawScan();
}

window.addEventListener("tf_fixed_frame_changed", drawScan);
window.addEventListener("view_changed", drawScan);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

//Topic

function radToDeg(val){
	return (val * (180/Math.PI)).toFixed(2)
}

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(range_topic !== undefined){
		range_topic.unsubscribe(listener);
	}

	range_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/LaserScan',
		throttle_rate: parseInt(throttle.value),
		compression: rosbridge.compression
	});

	status.setWarn("No data received.");
	text_angle.innerText = "Angle: ?";
	text_frame.innerText = "TF Frame: ?";
	text_angleinc.innerText = "Angle increment: ?";
	text_pointscount.innerText = "Points: ?";
	text_scantime.innerText = "Scan time: ?";
	text_min.innerText = "Min: ?";
	text_max.innerText = "Max: ?";

	listener = range_topic.subscribe((msg) => {	

		let error = false;
		if(msg.header.frame_id == ""){
			status.setWarn("Transform frame is an empty string, falling back to fixed frame. Fix your publisher ;)");
			msg.header.frame_id = tf.fixed_frame;
			error = true;
		}

		const pose = tf.absoluteTransforms[msg.header.frame_id];

		if(!pose){
			status.setError("Required transform frame \""+msg.header.frame_id+"\" not found.");
			return;
		}

		text_angle.innerText = "Angle: "+radToDeg(msg.angle_min)+"°"+" to "+radToDeg(msg.angle_max)+"°";
		text_angleinc.innerText = "Angle increment: "+radToDeg(msg.angle_increment)+"°";
		text_frame.innerText = "TF frame: "+msg.header.frame_id;
		text_pointscount.innerText = "Points: "+msg.ranges.length;
		text_scantime.innerText = "Scan time: "+msg.scan_time.toFixed(5)+" s";
		text_min.innerText = "Min: "+msg.range_min.toFixed(2)+" m";
		text_max.innerText = "Max: "+msg.range_max.toFixed(2)+" m";

		let rotatedPointCloud = [];
		msg.ranges.forEach(function (item, index) {
			if (item >= msg.range_min && item <= msg.range_max) {
				const angle = msg.angle_min + index * msg.angle_increment;
				rotatedPointCloud.push(tfModule.applyRotation(
					{
						x: item * Math.cos(angle), 
						y: item * Math.sin(angle), 
						z: 0 
					}, 
					pose.rotation, 
					false
				));
			}
		});

		data = {};
		data.pose = pose;
		data.points = rotatedPointCloud
		drawScan();

		if(!error){
			status.setOK();
		}
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/LaserScan");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	data = undefined;
	connect();
});

selectionbox.addEventListener("click", connect);
click_icon.addEventListener("click", loadTopics);

loadTopics();
resizeScreen();

console.log("Laserscan Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/scan/scan_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 10;"></canvas>


================================================
FILE: vizanti_server/public/templates/settings/settings_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/settings.svg" alt="Settings" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/settings/settings_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Global Settings</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_fixedframe">Fixed Frame:</label>
		<select id="{uniqueID}_fixedframe" name="topic">
			
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_colorpicker">Background Color:</label>
		<input type="color" value="#273444" id="{uniqueID}_colorpicker">


		<div class="spacer"></div>
		<hr class="dark_hr"/>

		<h4>Manage settings</h4>

		<span><button id="{uniqueID}_export_persistent" class="export_button">⇑ Export</button><button id="{uniqueID}_import_persistent" class="export_button">⇓ Import</button></span>
		<p class="comment">
			Exporting the current configuration will save the widget layout, settings, camera pose, and other info, so it can be imported later, 
			or so it can be <a href="https://github.com/MoffKalast/vizanti/wiki/Advanced-Configuration#adding-a-default-config" class="highlight-link">set as a default config</a>.
		</p>

		<div class="spacer"></div>

		<button id="{uniqueID}_reset_view">Reset Camera View</button>
		<p class="comment">Reset only the camera to its default pose (zero relative to the fixed frame link).</p>

		<div class="spacer"></div>

		<button id="{uniqueID}_delete_persistent" style="border: 3px solid #784b4b; background-color: #4d2626;" style="float: left;" >Reset Layout to default</button>
		<p class="comment">Clear layout and import server defaults.</p>

		<div class="spacer"></div>
		
	</div>
</div>



================================================
FILE: vizanti_server/public/templates/settings/settings_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let settings = persistentModule.settings;
let saveJsonToFile = persistentModule.saveJsonToFile;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];
const selectionbox = document.getElementById("{uniqueID}_fixedframe");
const colourpicker = document.getElementById("{uniqueID}_colorpicker");

colourpicker.addEventListener("input", (event) =>{
	document.body.style.backgroundColor = colourpicker.value;
	saveSettings();
});

// Settings
if (settings.hasOwnProperty('{uniqueID}')) {
	const loadedData = settings['{uniqueID}'];
	tf.setFixedFrame(loadedData.fixed_frame);
	document.body.style.backgroundColor = loadedData.background_color;
}else{
	if(tf.fixed_frame == ""){
		tf.setFixedFrame("odom");
		status.setWarn("No frame selected, defaulting to odom");
	}
	saveSettings();
}

function saveSettings() {
	settings['{uniqueID}'] = {
		fixed_frame: tf.fixed_frame,
		background_color: colourpicker.value
	};
	settings.save();
}

// TF frame list
function setFrameList(){

	let framelist = "";
	for (const key of tf.frame_list.values()) {
		framelist += "<option value='"+key+"'>"+key+"</option>"
	}
	selectionbox.innerHTML = framelist;

	if(tf.frame_list.has(tf.fixed_frame)){
		selectionbox.value = tf.fixed_frame;
	}else{
		framelist += "<option value='"+tf.fixed_frame+"'>"+tf.fixed_frame+"</option>"
		selectionbox.innerHTML = framelist
		selectionbox.value = tf.fixed_frame;
	}
}

selectionbox.addEventListener("change", (event) => {
	tf.setFixedFrame(selectionbox.value);
	status.setOK();
	saveSettings();
});

selectionbox.addEventListener("click", setFrameList);
icon.addEventListener("click", setFrameList);

// Buttons
const modal = document.getElementById("{uniqueID}_modal");

document.getElementById("{uniqueID}_reset_view").addEventListener("click", (event) =>{
	view.reset();
	modal.style.display = "none";
});

document.getElementById("{uniqueID}_delete_persistent").addEventListener("click", async (event) =>{
	status.setWarn("Are you sure about that?");
	let del_ok = await confirm("Are you sure you want to delete your saved widget setup? This will refresh the page.");

	if(del_ok){
		localStorage.removeItem("settings");
		window.location.reload();
	}

	status.setOK();
});

document.getElementById("{uniqueID}_export_persistent").addEventListener("click", async (event) =>{

	let filename = await prompt("Save as file (.json will be appended automatically):", "robot_config");
	if (filename != null) {
		saveJsonToFile(settings, filename+'.json');
		modal.style.display = "none";
	}
});

document.getElementById("{uniqueID}_import_persistent").addEventListener("click", (event) =>{

	const input = document.createElement('input');
	input.type = 'file';
	input.accept = '.json';

	input.onchange = (event) => {
		const file = event.target.files[0];
		const reader = new FileReader();

		reader.onload = () => {
			try {
				settings.fromJSON(reader.result);
				settings.save();
				location.reload(false);
			} catch (error) {
				console.error('Error importing JSON file:', error);
			}
		};

		reader.readAsText(file);
	};

	input.click();

	modal.style.display = "none";
});


console.log("Settings Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/simplegoal/simplegoal_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/simplegoal.svg" alt="model" width="50" height="50">
</div> 


================================================
FILE: vizanti_server/public/templates/simplegoal/simplegoal_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>2D Nav Goal</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<option value="/move_base_simple/goal">/move_base_simple/goal</option>
		</select>

		<p>Send a goal to the navigation stack as a geometry_msgs/PoseStamped.</p>

		<p style="color:#b4b4b4;">Click the icon once to enable, drag on the view area and release to publish. Long press the icon to open this menu.</p>


		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/simplegoal/simplegoal_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
}else{
	saveSettings();
}

if(topic == ""){
	topic = "/goal_pose";
	status.setWarn("No topic found, defaulting to /goal_pose");
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic
	}
	settings.save();
}

function sendMessage(pos, delta){
	if(!pos || !delta){
		status.setError("Could not send message, pose invalid.");
		return;
	}

	let yaw = Math.atan2(delta.y, -delta.x);
	let quat = Quaternion.fromEuler(yaw, 0, 0, 'ZXY');

	let map_pos = view.screenToFixed(pos);

	const currentTime = new Date();
	const currentTimeSecs = Math.floor(currentTime.getTime() / 1000);
	const currentTimeNsecs = (currentTime.getTime() % 1000) * 1e6;

	const publisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: 'geometry_msgs/msg/PoseStamped',
	});

	const poseMessage = new ROSLIB.Message({
		header: {
			stamp: {
				sec: currentTimeSecs,
				nanosec: currentTimeNsecs
			},
			frame_id: tf.fixed_frame
		},
		pose: {
			position: {
				x: map_pos.x,
				y: map_pos.y,
				z: 0.0
			},
			orientation: {
				x: quat.x,
				y: quat.y,
				z: quat.z,
				w: quat.w
			}
		}
	});	
	publisher.publish(poseMessage);
	status.setOK();
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const view_container = document.getElementById("view_container");

const icon = document.getElementById("{uniqueID}_icon");
const iconImg = icon.getElementsByTagName('img')[0];

let active = false;
let sprite = new Image();
let start_point = undefined;
let delta = undefined;
sprite.src = "assets/simplegoal.png";

function drawArrow() {
    const wid = canvas.width;
    const hei = canvas.height;

	ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, wid, hei);

	if(delta){
		let ratio = sprite.naturalHeight/sprite.naturalWidth;
		ctx.setTransform(1,0,0,1,start_point.x, start_point.y); //sx,0,0,sy,px,py
		ctx.rotate(Math.atan2(-delta.y, -delta.x));
		ctx.drawImage(sprite, -80, -80*ratio, 160, 160*ratio);
	}
}

function startDrag(event){
	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	start_point = {
		x: clientX,
		y: clientY
	};
}

function drag(event){
	if (start_point === undefined) return;

	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	delta = {
		x: start_point.x - clientX,
		y: start_point.y - clientY,
	};

	drawArrow();	
}

function endDrag(event){
	sendMessage(start_point, delta);

	start_point = undefined;
	delta = undefined;
	drawArrow();
	setActive(false);
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
}

window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

function addListeners(){
	view_container.addEventListener('mousedown', startDrag);
	view_container.addEventListener('mousemove', drag);
	view_container.addEventListener('mouseup', endDrag);

	view_container.addEventListener('touchstart', startDrag);
	view_container.addEventListener('touchmove', drag);
	view_container.addEventListener('touchend', endDrag);	
}

function removeListeners(){
	view_container.removeEventListener('mousedown', startDrag);
	view_container.removeEventListener('mousemove', drag);
	view_container.removeEventListener('mouseup', endDrag);

	view_container.removeEventListener('touchstart', startDrag);
	view_container.removeEventListener('touchmove', drag);
	view_container.removeEventListener('touchend', endDrag);	
}

function setActive(value){
	active = value;
	view.setInputMovementEnabled(!active);

	if(active){
		addListeners();
		icon.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
		view_container.style.cursor = "pointer";
	}else{
		removeListeners()
		icon.style.backgroundColor = "rgba(124, 124, 124, 0.3)";
		view_container.style.cursor = "";
	}
}

// Topics

const selectionbox = document.getElementById("{uniqueID}_topic");

async function loadTopics(){
	let result = await rosbridge.get_topics("geometry_msgs/msg/PoseStamped");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(result.includes(topic)){
		selectionbox.value = topic;
	}else{
		topiclist += "<option value='"+topic+"'>"+topic+"</option>"
		selectionbox.innerHTML = topiclist
		selectionbox.value = topic;
	}
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
	status.setOK();
});

loadTopics();

// Long press modal open stuff

let longPressTimer;
let isLongPress = false;

icon.addEventListener("click", (event) =>{
	if(!isLongPress)
		setActive(!active);
	else
		isLongPress = false;
});

icon.addEventListener("mousedown", startLongPress);
icon.addEventListener("touchstart", startLongPress);

icon.addEventListener("mouseup", cancelLongPress);
icon.addEventListener("mouseleave", cancelLongPress);
icon.addEventListener("touchend", cancelLongPress);
icon.addEventListener("touchcancel", cancelLongPress);

icon.addEventListener("contextmenu", (event) => {
	event.preventDefault();
});

function startLongPress(event) {
	isLongPress = false;
	longPressTimer = setTimeout(() => {
		isLongPress = true;
		loadTopics();
		openModal("{uniqueID}_modal");
	}, 500);
}

function cancelLongPress(event) {
	clearTimeout(longPressTimer);
}

resizeScreen();

console.log("Simple Goal Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/simplegoal/simplegoal_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 6;"></canvas>


================================================
FILE: vizanti_server/public/templates/speedometer/speedometer_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect" onclick="openModal('{uniqueID}_modal')">
	<img src="assets/speedometer.svg" alt="?" width="50" height="50" style="pointer-events: none;">
	<img src="assets/speedometer_dial.svg" alt="?" width="50" height="50" style="position: absolute; margin-left: -50px; pointer-events: none; transition: transform 0.2s ease;">
	<p id="{uniqueID}_dialtext" class="icon-text-dial">0.000</p>
	<p id="{uniqueID}_unittext" class="icon-text-dial-unit">m/s</p>
</div> 


================================================
FILE: vizanti_server/public/templates/speedometer/speedometer_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Speedometer</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_frame">Measure speed of TF link</label>
		<select id="{uniqueID}_frame" name="topic">
			<option value='base_link'>base_link</option>
		</select>

		<label for="{uniqueID}_fixed_frame">relative to</label>
		<select id="{uniqueID}_fixed_frame" name="topic">
			<option value='map'>map</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_units">Units:</label>
		<select id="{uniqueID}_units" name="topic">
			<option value='m/s'>Meter per second (m/s)</option>
			<option value='km/h'>Kilometers per hour (km/h)</option>
			<option value='kts'>Knots / NM per hour (kts)</option>
			<option value='mph'>Miles per hour (mph)</option>
			<option value='ft/s'>Feet per second (ft/s)</option>
			<option value='b/s'>Bananas per second (b/s)</option>
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_spd">Speed: ?</p>
			<p id="{uniqueID}_spd_max">Max Speed: ?</p> 
			<p id="{uniqueID}_spd_min">Min Speed: ?</p>
		</div>

		<button id="{uniqueID}_reset">Reset Tracking</button>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/speedometer/speedometer_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let tf = tfModule.tf;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let base_link_frame = "base_link";
let fixed_frame = tf.fixed_frame;
let units = "m/s";

let min_speed = Infinity;
let max_speed = 0;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

const baseLinkFrameBox = document.getElementById("{uniqueID}_frame");
const fixedFrameBox = document.getElementById("{uniqueID}_fixed_frame");
const unitBox = document.getElementById("{uniqueID}_units");

const icondiv = document.getElementById("{uniqueID}_icon");
const icon = icondiv.getElementsByTagName('img')[0];
const icon_dial = icondiv.getElementsByTagName('img')[1];

const text_spd = document.getElementById("{uniqueID}_spd");
const text_spd_min = document.getElementById("{uniqueID}_spd_min");
const text_spd_max = document.getElementById("{uniqueID}_spd_max");
const text_dial = document.getElementById("{uniqueID}_dialtext");
const text_unit = document.getElementById("{uniqueID}_unittext");

const reset_button = document.getElementById("{uniqueID}_reset");
reset_button.addEventListener("click",resetTracking);

function resetTracking(){
	speed_samples = [];
	min_speed = Infinity;
	max_speed = 0;
}


if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	base_link_frame = loaded_data.frame;
	fixed_frame = loaded_data.fixed_frame;
	units = loaded_data.units;

	baseLinkFrameBox.value = base_link_frame;
	fixedFrameBox.value = fixed_frame;
	unitBox.value = units;

}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		frame: baseLinkFrameBox.value,
		fixed_frame: fixedFrameBox.value,
		units: unitBox.value,
	}
	settings.save();
}

let prev = undefined;
let prev_stamp = undefined;
let speed_samples = [];
const sample_size = 10;  // Number of samples to average
const smoothing_factor = 0.5;  // Low-pass filter smoothing factor (0.0 - 1.0)

function writeText(speed_ms, minspeed_ms, maxspeed_ms){
	let mult = 1.0;

	text_unit.innerText = units;

	switch(units){
		case 'km/h': mult = 3.6; break;
		case 'kts': mult = 1.943844; break;
		case 'mph': mult = 2.236936; break;
		case 'ft/s': mult = 3.28084; break;
		case 'b/s': mult = 6.56167; break;
		default: break;
	}

	function formatDial(num) {
		if (num >= 10000) return "9999";
		if (num >= 1000) return Math.floor(num).toString();
		if (num >= 100) return num.toFixed(2);
		if (num >= 10) return num.toFixed(2);
		return num.toFixed(3);
	}

	text_spd.innerText = "Speed: " + (speed_ms * mult).toFixed(2) + " " + units;
    text_spd_min.innerText = "Min Speed: " + (minspeed_ms * mult).toFixed(2) + " " + units;
    text_spd_max.innerText = "Max Speed: " + (maxspeed_ms * mult).toFixed(2) + " " + units;
    text_dial.innerText = formatDial(speed_ms * mult);
}

function calculateSpeed() {

    if (!tf.absoluteTransforms[base_link_frame] || !tf.frame_headerstamps[base_link_frame]) {
        status.setError("Required transform frame \"" + base_link_frame + "\" not found.");
        return;
    }

    if (!tf.absoluteTransforms[fixed_frame]) {
        status.setError("Required transform frame \"" + fixed_frame + "\" not found.");
        return;
    }

    const transformed = tf.transformPose(
        base_link_frame,
        fixed_frame,
        { x: 0, y: 0, z: 0 },
        new Quaternion()
    );

    status.setOK();

    if (prev === undefined) {
        prev = transformed;
        prev_stamp = tf.frame_headerstamps[base_link_frame];
        return;
    }

    const time_now = tf.frame_headerstamps[base_link_frame];
    const deltaTimeSec = tf.getTimeStampDelta(prev_stamp, time_now);

    // Skip duplicated calls
    if (deltaTimeSec < 0.01){
		prev = transformed;
    	prev_stamp = time_now;
		return;
	}

	const dist = Math.hypot(
        prev.translation.x - transformed.translation.x,
        prev.translation.y - transformed.translation.y,
        prev.translation.z - transformed.translation.z
    );

    let current_speed = dist / deltaTimeSec;

    // Low-pass filter
    if (speed_samples.length > 0) {
        current_speed = (current_speed * smoothing_factor) + (speed_samples[speed_samples.length - 1] * (1.0 - smoothing_factor));
    }

    // Add new sample
    speed_samples.push(current_speed);
    if (speed_samples.length > sample_size) {
        speed_samples.shift();
    }

    const average_speed = speed_samples.reduce((a, b) => a + b, 0) / speed_samples.length;
    min_speed = Math.min(min_speed, average_speed);
    max_speed = Math.max(max_speed, average_speed);

	//dial needle
	const angle = ((average_speed - min_speed) / (max_speed - min_speed)) * 195;
	icon_dial.style.transform = "rotate(" + angle + "deg)";

	writeText(average_speed, min_speed, max_speed);

    prev = transformed;
    prev_stamp = time_now;
}

window.addEventListener("tf_fixed_frame_changed", calculateSpeed);
window.addEventListener("tf_changed", calculateSpeed);

// TF frame list
function setFrameList(){
	//find world frames
	let framelist = "";
	for (const key of tf.frame_list.values()) {
		framelist += "<option value='"+key+"'>"+key+"</option>"
	}
	baseLinkFrameBox.innerHTML = framelist;
	fixedFrameBox.innerHTML = framelist;

	if(tf.frame_list.has(fixed_frame)){
		fixedFrameBox.value = fixed_frame;
	}else{
		fixedFrameBox.innerHTML = framelist + "<option value='"+fixed_frame+"'>"+fixed_frame+"</option>";
		fixedFrameBox.value = fixed_frame;
	}

	if(tf.frame_list.has(base_link_frame)){
		baseLinkFrameBox.value = base_link_frame;
	}else{
		baseLinkFrameBox.innerHTML = framelist + "<option value='"+base_link_frame+"'>"+base_link_frame+"</option>";
		baseLinkFrameBox.value = base_link_frame;
	}
}

baseLinkFrameBox.addEventListener("change", (event) => {
	base_link_frame = baseLinkFrameBox.value;
	saveSettings();
	resetTracking();
});

fixedFrameBox.addEventListener("change", (event) => {
	fixed_frame = fixedFrameBox.value;
	saveSettings();
	resetTracking();
});

unitBox.addEventListener("change", (event) => {
	units = unitBox.value;
	saveSettings();
});

baseLinkFrameBox.addEventListener("click", setFrameList);
fixedFrameBox.addEventListener("click", setFrameList);
icon.addEventListener("click", setFrameList);

setFrameList();

console.log("Speedometer Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/teleop/teleop_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/joystick.svg" alt="Teleop" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/teleop/teleop_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">

	<div id="{uniqueID}_joypreview" style="position: fixed; bottom: calc( 15vh - 50px ); left: calc( 50vw - 50px )" class="noselect">
		<img  src="assets/joypos.svg" alt="Joystick Preview" width="100" height="100">
	</div> 

	<div class="modal_inner noselect">
		<h3>Joystick Teleop</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>
		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<p>Adds a joystick overlay to the main view that can be used to send geometry_msgs/Twist movement commands.</p>

		<p style="color:#b4b4b4;">Scroll up and drag the preview box to position the joystick on the screen.</p>


		<label for="{uniqueID}_linear_velocity">Linear Velocity (m/s):</label>
		<span id="{uniqueID}_linear_velocity_value">0.5</span>
		<input type="range" value="0.4" step="0.05" min="0.05" max="3.0" id="{uniqueID}_linear_velocity">

		<div class="spacer"></div>

		<label for="{uniqueID}_angular_velocity">Angular Velocity (m/s):</label>
		<span id="{uniqueID}_angular_velocity_value">0.5</span>
		<input type="range" value="0.8" step="0.05" min="0.05" max="6.0" id="{uniqueID}_angular_velocity">

		<div class="spacer"></div>

		<label for="{uniqueID}_accel">Linear Acceleration (m/s²):</label>
		<span id="{uniqueID}_accel_value">0.05</span>
		<input type="range" value="0.05" step="0.01" min="0.01" max="1.0" id="{uniqueID}_accel">


		<label>Invert angular velocity when reversing:</label>
		<input type="checkbox" checked id="{uniqueID}_invert_angular">

		<div class="spacer"></div>

		<label>Use holonomic linear Y instead of angular Z:</label>
		<input type="checkbox" id="{uniqueID}_holonomic">

		<div class="spacer"></div>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>

	<div style="height: 180vh; width: 1px;">
		<!-- Scroll spacer-->
	</div>

</div>


================================================
FILE: vizanti_server/public/templates/teleop/teleop_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let joystickModule = await import(`${base_url}/js/modules/joystick.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let nipplejs = joystickModule.nipplejs;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let joy_offset_x = "50%";
let joy_offset_y = "85%";
let cmdVelPublisher = undefined;

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

// Sliders and checkboxes

const linearVelSlider = document.getElementById('{uniqueID}_linear_velocity');
const angularVelSlider = document.getElementById('{uniqueID}_angular_velocity');
const accelSlider = document.getElementById('{uniqueID}_accel');

const linearVelValue = document.getElementById('{uniqueID}_linear_velocity_value');
const angularVelValue = document.getElementById('{uniqueID}_angular_velocity_value');
const accelValue = document.getElementById('{uniqueID}_accel_value');

const invertAngularCheckbox = document.getElementById('{uniqueID}_invert_angular');
const holonomicSwapCheckbox = document.getElementById('{uniqueID}_holonomic');

linearVelSlider.addEventListener('input', function () {
	linearVelValue.textContent = this.value;
	saveSettings();
});

angularVelSlider.addEventListener('input', function () {
	angularVelValue.textContent = this.value;
	saveSettings();
});

accelSlider.addEventListener('input', function () {
	accelValue.textContent = this.value;
	saveSettings();
});

linearVelSlider.addEventListener('change', saveSettings);
angularVelSlider.addEventListener('change', saveSettings);
accelSlider.addEventListener('change', saveSettings);

invertAngularCheckbox.addEventListener('change', saveSettings);
holonomicSwapCheckbox.addEventListener('change', saveSettings);

// Settings

if (settings.hasOwnProperty('{uniqueID}')) {
	const loaded_data = settings['{uniqueID}'];
	topic = loaded_data.topic;

	joy_offset_x = loaded_data.joy_offset_x;
	joy_offset_y = loaded_data.joy_offset_y;

	linearVelSlider.value = loaded_data.linear_velocity;
	angularVelSlider.value = loaded_data.angular_velocity;
	accelSlider.value = loaded_data.accel;

	invertAngularCheckbox.checked = loaded_data.invert_angular;
	holonomicSwapCheckbox.checked = loaded_data.holonomic_swap;

	linearVelValue.textContent = linearVelSlider.value;
	angularVelValue.textContent = angularVelSlider.value;
	accelValue.textContent = accelSlider.value;
}else{
	saveSettings();
}

if(topic == ""){
	topic = "/cmd_vel";
	status.setWarn("No topic found, defaulting to /cmd_vel");
	saveSettings();
}

function saveSettings() {
	settings['{uniqueID}'] = {
		topic: topic,
		linear_velocity: parseFloat(linearVelSlider.value),
		angular_velocity: parseFloat(angularVelSlider.value),
		joy_offset_x: joy_offset_x,
		joy_offset_y: joy_offset_y,
		accel: parseFloat(accelSlider.value),
		invert_angular: invertAngularCheckbox.checked,
		holonomic_swap: holonomicSwapCheckbox.checked,
	};
	settings.save();
}

// Topic and connections

async function loadTopics(){
	let result = await rosbridge.get_topics("geometry_msgs/msg/Twist");
	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist;

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

function connect(){
	cmdVelPublisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: 'geometry_msgs/msg/Twist',
		queue_size: 1
	});
}

function publishTwist(linearX, linearY, angularZ) {
	const twist = new ROSLIB.Message({
		linear: { x: linearX, y: linearY, z: 0 },
		angular: { x: 0, y: 0, z: angularZ },
	});
	cmdVelPublisher.publish(twist);
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
	connect();
	status.setOK();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

// Joystick
linearVelSlider.addEventListener('input', function () {
	linearVelValue.textContent = this.value;
});

angularVelSlider.addEventListener('input', function () {
	angularVelValue.textContent = this.value;
});

// Teleop logic
let linearVel = 0;
let angularVel = 0;

let targetLinearVel = 0;
let targetAngularVel = 0;

let interval = undefined;

const joystickContainer  = document.getElementById('{uniqueID}_joystick');
const joypreview = document.getElementById('{uniqueID}_joypreview');
joypreview.style.left = `calc(${joy_offset_x} - 50px)`;
joypreview.style.top = `calc(${joy_offset_y} - 50px)`;

function makeJoystick(){
	return nipplejs.create({
		zone: joystickContainer,
		mode: 'static',
		position: {
			left: joy_offset_x,
			top: joy_offset_y 
		},
		size: 150,
		threshold: 0.1,
		color: 'black',
		restOpacity: 0.7
	})
}

let joystick = makeJoystick();

function addJoystickListeners(){
	joystick.on('move', onJoystickMove);
	joystick.on('touchmove', onJoystickMove);
	joystick.on('end', onJoystickEnd);
	joystick.on('touchend', onJoystickEnd);
}

function onJoystickMove(event, data) {
	const maxLinearVel = parseFloat(linearVelSlider.value);
	const maxAngularVel = parseFloat(angularVelSlider.value);
	const force = Math.min(Math.max(data.force, 0.0), 1.0);

	targetLinearVel = maxLinearVel * Math.sin(data.angle.radian) * force;
	targetAngularVel = - maxAngularVel * Math.cos(data.angle.radian) * force;

	if (settings['{uniqueID}'].invert_angular && targetLinearVel < 0 && !settings['{uniqueID}'].holonomic_swap) {
		targetAngularVel = -targetAngularVel;
	}

	if(interval === undefined){
		interval = setInterval(() => {
			let accel = settings['{uniqueID}'].accel;

			if (targetLinearVel == 0 && targetAngularVel == 0)
				accel *= 2;
		
			if(linearVel != targetLinearVel){
				if(linearVel < targetLinearVel){
					linearVel += accel;
		
					if(linearVel > targetLinearVel)
						linearVel = targetLinearVel;
				}
				else if(linearVel > targetLinearVel){
					linearVel -= accel;
		
					if(linearVel < targetLinearVel)
						linearVel = targetLinearVel;
				}
			}

			let angular_accel = settings['{uniqueID}'].accel * 10;

			if(settings['{uniqueID}'].holonomic_swap)
				angular_accel = accel;


			if(angularVel != targetAngularVel){
				if(angularVel < targetAngularVel){
					angularVel += angular_accel;
		
					if(angularVel > targetAngularVel)
						angularVel = targetAngularVel;
				}
				else if(angularVel > targetAngularVel){
					angularVel -= angular_accel;
		
					if(angularVel < targetAngularVel)
						angularVel = targetAngularVel;
				}
			}
		
			if(Math.abs(linearVel) < 0.005 && Math.abs(angularVel) < 0.005){
				linearVel = 0;
				targetLinearVel = 0;
				targetAngularVel = 0;
				publishTwist(0, 0, 0);
				clearInterval(interval);
				interval = undefined;
				return;
			}
		
			if(settings['{uniqueID}'].holonomic_swap){
				publishTwist(linearVel, angularVel, 0);
			}
			else{
				publishTwist(linearVel, 0, angularVel);
			}
			
		}, 1000 / 20);
	}
};

function onJoystickEnd(event) {
	targetLinearVel = 0;
	targetAngularVel = 0;
}

addJoystickListeners();

//preview for moving around

let preview_active = false;

function onStart(event) {
	preview_active = true;
	document.addEventListener('mousemove', onMove);
	document.addEventListener('mouseup', onEnd);
	document.addEventListener('touchmove', onMove);
	document.addEventListener('touchend', onEnd);
}

function onMove(event) {
	if (preview_active) {
		event.preventDefault();
		let currentX, currentY;

		if (event.type === "touchmove") {
			currentX = event.touches[0].clientX;
			currentY = event.touches[0].clientY;
		} else {
			currentX = event.clientX;
			currentY = event.clientY;
		}

		joy_offset_x = (currentX/window.innerWidth * 100) +"%";
		joy_offset_y = (currentY/window.innerHeight * 100) +"%";
		saveSettings();

		joypreview.style.left = `calc(${joy_offset_x} - 50px)`;
		joypreview.style.top = `calc(${joy_offset_y} - 50px)`;

		joystick.destroy();
		joystick = makeJoystick();
	
		addJoystickListeners(joystick);
	}
}

function onEnd() {
	preview_active = false;
	document.removeEventListener('mousemove', onMove);
	document.removeEventListener('mouseup', onEnd);
	document.removeEventListener('touchmove', onMove);
	document.removeEventListener('touchend', onEnd);
}
  
joypreview.addEventListener('mousedown', onStart);
joypreview.addEventListener('touchstart', onStart);

console.log("Teleop Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/teleop/teleop_view.html
================================================
<div id="{uniqueID}_joystick" class="inputelement noselect" style="z-index: 15"></div>



================================================
FILE: vizanti_server/public/templates/temperature/temperature_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/temp_unknown.svg" alt="?" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/temperature/temperature_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Temperature</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>
		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<!-- add topics here-->
		</select>

		<div class="live_data_display">
			<p id="{uniqueID}_temperature">Temperature (°C): ?</p>
			<p id="{uniqueID}_variance">Variance: ?</p>
			<p id="{uniqueID}_tflink">TF Frame: ?</p>
		</div>

		<p>Set indicator values:</p>

		<img src="assets/temp_hot.svg" alt="" width="35" height="35" style="vertical-align: middle;">
		<label for="{uniqueID}_hightemp">High (°C):</label>
		<input type="number" value="60" step="0.1" min="-272" max="3000" id="{uniqueID}_hightemp">

		<div class="spacer"></div>

		<img src="assets/temp_cold.svg" alt="" width="35" height="35" style="vertical-align: middle;">
		<label for="{uniqueID}_lowtemp">Low (°C):</label>
		<input type="number" value="20" step="0.1" min="-272" max="3000" id="{uniqueID}_lowtemp">

		<div class="spacer"></div>

		<p class="comment">The indicator icon will change based on the above defined threshold values.</p>


		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/temperature/temperature_script.js
================================================
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let imageToDataURL = utilModule.imageToDataURL;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let listener = undefined;
let temperature_topic = undefined;

//persistent loading, so we don't re-fetch on every update
let icons = {};
icons["hot"] = await imageToDataURL("assets/temp_hot.svg");
icons["cold"] = await imageToDataURL("assets/temp_cold.svg");
icons["warm"] = await imageToDataURL("assets/temp_warm.svg");
icons["unknown"] = await imageToDataURL("assets/temp_warm.svg");

const selectionbox = document.getElementById("{uniqueID}_topic");
const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const highBox = document.getElementById('{uniqueID}_hightemp');
const lowBox = document.getElementById('{uniqueID}_lowtemp');

const text_temperature = document.getElementById("{uniqueID}_temperature");
const text_variance = document.getElementById("{uniqueID}_variance");
const text_link = document.getElementById("{uniqueID}_tflink");

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	highBox.value = loaded_data.high;
	lowBox.value = loaded_data.low;
}else{
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		low: lowBox.value,
		high: highBox.value
	}
	settings.save();
}

function connect(){

	if(topic == ""){
		status.setError("Empty topic.");
		return;
	}

	if(temperature_topic !== undefined){
		temperature_topic.unsubscribe(listener);
	}

	temperature_topic = new ROSLIB.Topic({
		ros : rosbridge.ros,
		name : topic,
		messageType : 'sensor_msgs/msg/Temperature',
		compression: rosbridge.compression,
		throttle_rate: 500 // throttle to twice a second max
	});

	status.setWarn("No data received.");
	
	listener = temperature_topic.subscribe((msg) => {

		if(msg.temperature > highBox.value){
			icon.src = icons["hot"];
		}
		else if(msg.temperature < lowBox.value){
			icon.src = icons["cold"];
		}
		else{
			icon.src = icons["warm"];
		}

		text_temperature.innerText = "Temperature (°C): "+(Math.round(msg.temperature * 100) / 100).toFixed(2);
		text_variance.innerText = "Variance: "+(Math.round(msg.variance * 100) / 100).toFixed(2);
		text_link.innerText = "TF Frame: "+msg.header.frame_id;

		status.setOK();
	});

	saveSettings();
}

async function loadTopics(){
	let result = await rosbridge.get_topics("sensor_msgs/msg/Temperature");

	let topiclist = "";
	result.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+"</option>"
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}
	connect();
}

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	icon.src = icons["unknown"];
	connect();
});

selectionbox.addEventListener("click", (event) => {
	connect();
});

icon.addEventListener("click", (event) => {
	loadTopics();
});

loadTopics();

console.log("Temperature Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/tf/tf_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/tf.svg" alt="tf" width="50" height="50" onclick="openModal('{uniqueID}_modal')">
</div> 


================================================
FILE: vizanti_server/public/templates/tf/tf_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>TF Frame Renderer</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label>Names:</label>
		<input type="checkbox" checked id="{uniqueID}_shownames">

		<div class="spacer"></div>

		<label>Axes:</label>
		<input type="checkbox" checked id="{uniqueID}_showaxes">

		<div class="spacer"></div>

		<label>Lines:</label>
		<input type="checkbox" checked id="{uniqueID}_showlines">

		<div class="spacer"></div>

		<label for="{uniqueID}_scale">Scale:</label>
		<span id="{uniqueID}_scale_value">1.0</span>
		<input type="range" value="1.0" step="0.01" min="0.3" max="2.5" id="{uniqueID}_scale">

		<div class="spacer"></div>

		<b>Frames:</b>

		<div class="spacer"></div>

		<button id="{uniqueID}_enable_all" style="background-color: #2f4d26" class="enable_all_button">Enable All</button>
		<button id="{uniqueID}_standard_only" style="background-color: #5e602c" class="standard_only_button">Standard Only</button>
		<button id="{uniqueID}_disable_all" style="background-color: #4d2626" class="disable_all_button">Disable All</button>

		<div class="spacer"></div>

		<div id="{uniqueID}_frames">
			
		</div>

		<hr class="dark_hr"/>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

	</div>
</div>


================================================
FILE: vizanti_server/public/templates/tf/tf_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);
let utilModule = await import(`${base_url}/js/modules/util.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let applyRotation = tfModule.applyRotation;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);
status.setWarn("No TF data received yet.");

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const icon = document.getElementById("{uniqueID}_icon").getElementsByTagName('img')[0];

const namesCheckbox = document.getElementById('{uniqueID}_shownames');
const axesCheckbox = document.getElementById('{uniqueID}_showaxes');
const linesCheckbox = document.getElementById('{uniqueID}_showlines');
const scaleSlider = document.getElementById('{uniqueID}_scale');
const scaleSliderValue = document.getElementById('{uniqueID}_scale_value');

scaleSlider.addEventListener('input', function () {
	scaleSliderValue.textContent = this.value;
});

namesCheckbox.addEventListener('change', saveSettings);
axesCheckbox.addEventListener('change', saveSettings);
linesCheckbox.addEventListener('change', saveSettings);
scaleSlider.addEventListener('change', saveSettings);

let frame_visibility = {};

// Settings

if (settings.hasOwnProperty('{uniqueID}')) {
	const loadedData = settings['{uniqueID}'];

	namesCheckbox.checked = loadedData.show_names;
	axesCheckbox.checked = loadedData.show_axes;
	linesCheckbox.checked = loadedData.show_lines;

	scaleSlider.value = loadedData.scale;
	scaleSliderValue.textContent = scaleSlider.value;

	frame_visibility = loadedData.frame_visibility;
}else{
	saveSettings();
}

function saveSettings() {
	settings['{uniqueID}'] = {
		show_names: namesCheckbox.checked,
		show_axes: axesCheckbox.checked,
		show_lines: linesCheckbox.checked,
		scale: parseFloat(scaleSlider.value),
		frame_visibility: frame_visibility
	};
	settings.save();
}

// Rendering

async function drawLines(origin, relative, absolute){

	ctx.strokeStyle = "#eba834";
	ctx.lineWidth = 1*parseFloat(scaleSlider.value);
	ctx.beginPath();

	Object.keys(absolute).forEach(key => {

		let transform = absolute[key];

		let point = view.fixedToScreen({
			x: transform.translation.x,
			y: transform.translation.y,
		});

		if(relative[key])
		{
			let parent = absolute[relative[key].parent];
			if(parent !== undefined){
	
				let parentpoint = view.fixedToScreen({
					x: parent.translation.x,
					y: parent.translation.y,
				});
	
				ctx.moveTo(parseInt(point.x), parseInt(point.y));
				ctx.lineTo(parseInt(parentpoint.x), parseInt(parentpoint.y));
			}
		}	
	});

	ctx.stroke();

}

async function drawText(origin, relative, absolute){

	ctx.lineJoin = 'round';
	ctx.miterLimit = 2;
	ctx.font = (12*parseFloat(scaleSlider.value))+"px Monospace";
	ctx.textAlign = "center";
	ctx.fillStyle = "white";

	ctx.strokeStyle = "#161B21";
	ctx.lineWidth = 5*parseFloat(scaleSlider.value);

	//ctx.strokeText(tf.fixed_frame, origin.x, origin.y+15);
	//ctx.fillText(tf.fixed_frame, origin.x, origin.y+15);

	Object.keys(absolute).forEach(key => {

		let transform = absolute[key];

		let point = view.fixedToScreen({
			x: transform.translation.x,
			y: transform.translation.y,
		});

		ctx.strokeText(key, point.x, point.y+15);
		ctx.fillText(key, point.x, point.y+15);	
	});
}

function getBasisPoints(basis, translation, rotation){
	let basis_x = applyRotation(basis, rotation);
	return [
		view.fixedToScreen({
			x: translation.x,
			y: translation.y,
		}), 
		view.fixedToScreen({
			x: translation.x + basis_x.x,
			y: translation.y + basis_x.y,
		})
	];
}

async function drawAxes(origin, relative, absolute) {

	const unit = view.getPixelsInMapUnits(30*parseFloat(scaleSlider.value));

	ctx.lineWidth = 2*parseFloat(scaleSlider.value);
	ctx.strokeStyle = "#E0000B"; //red
	ctx.beginPath();

	Object.keys(absolute).forEach(key => {
		let transform = absolute[key];
		let p = getBasisPoints(
			{x: unit, y: 0, z: 0},
			transform.translation,
			transform.rotation
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
	});
	
	ctx.stroke();

	ctx.strokeStyle = "#29FF26"; //green
	ctx.beginPath();

	Object.keys(absolute).forEach(key => {
		let transform = absolute[key];
		let p = getBasisPoints(
			{x: 0, y: unit, z: 0},
			transform.translation,
			transform.rotation
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
	});

	ctx.stroke();


	ctx.strokeStyle = "#005DFF"; //blue
	ctx.beginPath();

	Object.keys(absolute).forEach(key => {
		let transform = absolute[key];
		let p = getBasisPoints(
			{x: 0, y: 0, z: unit},
			transform.translation,
			transform.rotation
		);
		ctx.moveTo(parseInt(p[0].x), parseInt(p[0].y));
		ctx.lineTo(parseInt(p[1].x), parseInt(p[1].y));
	});

	ctx.stroke();

}

function filterFrames(framelist){
	let filteredlist = {};
	Object.keys(framelist).forEach(key => {
		if(frame_visibility.hasOwnProperty(key) && frame_visibility[key])
			filteredlist[key] = framelist[key];
	});
	return filteredlist;
}

async function drawFrames() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	const relative = filterFrames(tf.transforms);
	const absolute = filterFrames(tf.absoluteTransforms);

	let origin = view.fixedToScreen({
		x: 0,
		y: 0,
	});

	if(linesCheckbox.checked)
		drawLines(origin, relative, absolute);

	if(axesCheckbox.checked)
		drawAxes(origin, relative, absolute);

	if(namesCheckbox.checked)
		drawText(origin, relative, absolute);
}

const framesDiv = document.getElementById('{uniqueID}_frames');

let prev_transforms = new Set();
let grouped_frames = [];

function updateVisibility(){

	const eqSet = (xs, ys) => xs.size === ys.size && [...xs].every((x) => ys.has(x));

	let current_transforms = new Set();

	Object.keys(tf.transforms).forEach(key => {
		const child = key;
		const parent = tf.transforms[key].parent;

		if(!frame_visibility.hasOwnProperty(child)){
			frame_visibility[child] = true;
		}

		if(!frame_visibility.hasOwnProperty(parent)){
			frame_visibility[parent] = true;
		}

		current_transforms.add(child);
		current_transforms.add(parent);
	});

	function getEntry(key){
		const checkbox = document.createElement('input');
		checkbox.type = 'checkbox';
		checkbox.id = `{uniqueID}_${key}`;
		checkbox.checked = frame_visibility[key];
		checkbox.addEventListener('change', (event) => {
			frame_visibility[key] = event.target.checked;
			saveSettings();
		});

		const label = document.createElement('label');
		label.textContent = ` ${key}`;

		const div = document.createElement('div');
		div.classList.add('tf_label');
		div.appendChild(checkbox);
		div.appendChild(label);
		return div;
	}

	if (!eqSet(prev_transforms, current_transforms)){
		grouped_frames = utilModule.groupStringsByPrefix(Array.from(current_transforms), 2);
		prev_transforms = current_transforms;
	}

	framesDiv.innerHTML = '';
	for(let i = 0; i < grouped_frames.length; i++){
		const elementlist = grouped_frames[i];

		if(elementlist.length == 1){
			framesDiv.appendChild(getEntry(elementlist[0]));
		}else{
			const detailsElement = document.createElement("details");
			detailsElement.setAttribute("open", "open");
			detailsElement.classList.add("tf_details");

			const summaryElement = document.createElement("summary");
			summaryElement.classList.add("tf_summary");
			summaryElement.textContent = elementlist[0].replace(/_+$/, '');

			detailsElement.appendChild(summaryElement);
			detailsElement.appendChild(document.createElement('br'));
			for(let j = 1; j < elementlist.length; j++){
				detailsElement.appendChild(getEntry(elementlist[j]));
				detailsElement.appendChild(document.createElement('br'));
			}		  
			framesDiv.appendChild(detailsElement);
		}

		framesDiv.appendChild(document.createElement('br'));
	}
}

document.getElementById('{uniqueID}_enable_all').addEventListener('click',  async () => {
	for (const [key, value] of Object.entries(frame_visibility)) {
		frame_visibility[key] = true;
	}
	saveSettings();
	updateVisibility();
});

document.getElementById('{uniqueID}_standard_only').addEventListener('click',  async () => {
	const standard_frames = ["world", "earth", "map", "odom", "base_link", "base_footprint", "laser", "base_stabilized"];
	const hasStandardFrame = (str) => standard_frames.some(frame => str.includes(frame));

	for (const [key, value] of Object.entries(frame_visibility)) {
		frame_visibility[key] = hasStandardFrame(key);
	}
	saveSettings();
	updateVisibility();

});

document.getElementById('{uniqueID}_disable_all').addEventListener('click',  async () => {
	for (const [key, value] of Object.entries(frame_visibility)) {
		frame_visibility[key] = false;
	}
	saveSettings();
	updateVisibility();
});

icon.addEventListener("click", updateVisibility);

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawFrames();
}

window.addEventListener("tf_changed", ()=>{
	status.setOK();
	drawFrames();
});

window.addEventListener("view_changed", drawFrames);
window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);

resizeScreen();

window.addEventListener("tf_changed", updateVisibility, {once : true});

console.log("TF Widget Loaded {uniqueID}")



================================================
FILE: vizanti_server/public/templates/tf/tf_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 11;"></canvas>


================================================
FILE: vizanti_server/public/templates/waypoints/waypoints_icon.html
================================================
<div id="{uniqueID}_icon" class="icon noselect">
	<img src="assets/waypoints.svg" alt="model" width="50" height="50">
	<p id="{uniqueID}_buttontext" class="icon-text" style="top: 30%; left: 70%; color:black; font-size: 0.6em;"></p>
</div> 

<!-- Dropdown Menu -->
<div id="{uniqueID}_dropdown" class="dropdown-menu" style="display: none">
	<div class="dropdown-inner">
		<div class="dropdown-item" id="{uniqueID}_sendAction">
			<img src="assets/dropdown_start.svg" class="dropdown-icon"> Start
		</div>
		<div class="dropdown-item" id="{uniqueID}_stopAction">
			<img src="assets/dropdown_stop.svg" class="dropdown-icon"> Stop
		</div>
		<div class="dropdown-item" id="{uniqueID}_editXY">
			<img src="assets/dropdown_xy.svg" class="dropdown-icon"> Edit XY
		</div>
		<div class="dropdown-item" id="{uniqueID}_editZ">
			<img src="assets/dropdown_z.svg" class="dropdown-icon"> Edit Z
		</div>
		<div class="dropdown-item" id="{uniqueID}_config">
			<img src="assets/dropdown_setup.svg" class="dropdown-icon"> Setup
		</div>
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/waypoints/waypoints_modal.html
================================================
<div id="{uniqueID}_modal" class="modal_outer noselect">
	<div class="modal_inner noselect">
		<h3>Waypoint Mission</h3>
		<p id="{uniqueID}_status" class="status">Status: Ok.</p>
		<hr class="dark_hr"/>

		<label for="{uniqueID}_topic">Topic:</label>
		<select id="{uniqueID}_topic" name="topic">
			<option value="/waypoints">/waypoints</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_fixed_frame">Fixed Frame:</label>
		<select id="{uniqueID}_fixed_frame" name="topic">
			<option value="map">map</option>
		</select>

		<div class="spacer"></div>

		<label for="{uniqueID}_base_link_frame">Robot Frame:</label>
		<select id="{uniqueID}_base_link_frame" name="topic">
			<option value="base_link">base_link</option>
		</select>

		<p style="color: #b4b4b4;">Defines a sequence of poses and publishes them as a nav_msgs/Path or geometry_msgs/PoseArray.</p>

		<p><strong>X/Y Axis:</strong> Edit horizontal positions.</p>
		<ul>
			<li><strong style="color:rgb(167, 255, 196)">Add Points:</strong> Click on the view area.</li>
			<li><strong style="color:rgb(255, 185, 158)">Delete Points:</strong> Tap an existing point.</li>
			<li><strong style="color:rgb(255, 254, 188)">Move Points:</strong> Drag an existing point to reposition it.</li>
			<li><strong style="color: white">Snap to Grid:</strong> Hold the Shift key while dragging to snap to the pixel grid.</li>
			<li><button id="{uniqueID}_flip" >Flip waypoint order</button></li>
		</ul>
		
		<p><strong>Z Axis:</strong> Edit vertical positions.</p>
		<ul>
			<li><strong  style="color:rgb(255, 254, 188)">Set Height:</strong> Click and drag a point to set a rough Z value.</li>
			<li><strong  style="color:rgb(255, 254, 188)">Fine Adjust:</strong> Release and drag a point a second time to fine adjust its height.</li>
			<li><button id="{uniqueID}_z_set" >Set all Z values</button></li>
		</ul>
		
		
		<p style="color: #b4b4b4;">When editing X/Y/Z positions, click the icon again to stop editing.</p>
		
		<div class="spacer"></div>

		<label for="{uniqueID}_margin">Safety margin visual indicator (meters):</label>
		<input type="number" value="0.8" step="0.1" min="0" max="1000" id="{uniqueID}_margin">

		<div class="spacer"></div>

		<label>Start from closest waypoint:</label>
		<input type="checkbox" id="{uniqueID}_startclosest">

		<div class="spacer"></div>

		<h4>Clear Path</h4>

		<button id="{uniqueID}_delete" style="background-color: rgb(104, 78, 31);">Remove all waypoints</button>

		<div class="spacer"></div>

		<p style="color: #b4b4b4;">Tip: If you're using a nav stack that doesn't use Paths or PoseArrays, but will accept simple goals, see the demo node at ros2 run vizanti_demos waypoints_to_simple_goals.py</p>

		<hr class="dark_hr"/>

		<div class="spacer"></div>

		<button id="{uniqueID}_remove" class="delete_button" onclick="removeWidget('{uniqueID}')">Remove Widget</button>

		
	</div>
</div>


================================================
FILE: vizanti_server/public/templates/waypoints/waypoints_script.js
================================================
let viewModule = await import(`${base_url}/js/modules/view.js`);
let tfModule = await import(`${base_url}/js/modules/tf.js`);
let rosbridgeModule = await import(`${base_url}/js/modules/rosbridge.js`);
let persistentModule = await import(`${base_url}/js/modules/persistent.js`);
let StatusModule = await import(`${base_url}/js/modules/status.js`);

let view = viewModule.view;
let tf = tfModule.tf;
let rosbridge = rosbridgeModule.rosbridge;
let settings = persistentModule.settings;
let Status = StatusModule.Status;

let topic = getTopic("{uniqueID}");
let status = new Status(
	document.getElementById("{uniqueID}_icon"),
	document.getElementById("{uniqueID}_status")
);

let typedict = {};
let fixed_frame = tf.fixed_frame;
let base_link_frame = find_base_frame();
let mode = "IDLE";
let points = [];
let shift_pressed = false;

const icon_bar = document.getElementById("icon_bar");
const icon = document.getElementById("{uniqueID}_icon");
const dropdown = document.getElementById("{uniqueID}_dropdown");

const buttontext = document.getElementById("{uniqueID}_buttontext");
const margin = document.getElementById("{uniqueID}_margin");
const startCheckbox = document.getElementById('{uniqueID}_startclosest');

const flipButton = document.getElementById("{uniqueID}_flip");
const zSetButton = document.getElementById("{uniqueID}_z_set");
const deleteButton = document.getElementById("{uniqueID}_delete");

flipButton.addEventListener('click', ()=>{
	points.reverse();
	drawWaypoints();
	saveSettings();
});

zSetButton.addEventListener('click', async ()=>{
	let zval = await prompt("Set the height of all points to this value:", "0");
	if (zval != null) {
		const newz = parseFloat(zval);
		for (let i = 0; i < points.length; i++) {
			points[i].z = newz;
		}
	}
});

deleteButton.addEventListener('click', async ()=>{
	if(await confirm("Are you sure you want to delete all waypoints?")){
		points = [];
		drawWaypoints();
		saveSettings();
	}
});

startCheckbox.addEventListener('change', ()=>{
	drawWaypoints();
	saveSettings();
});

// Settings

if(settings.hasOwnProperty("{uniqueID}")){
	const loaded_data  = settings["{uniqueID}"];
	topic = loaded_data.topic;
	points = loaded_data.points;
	fixed_frame = loaded_data.fixed_frame ?? tf.fixed_frame;
	base_link_frame = loaded_data.base_link_frame ?? "base_link";

	margin.value = loaded_data.margin ?? 0.8;
	startCheckbox.checked = loaded_data.start_closest;

	if(loaded_data.topic_type != undefined)
		typedict[topic] = loaded_data.topic_type;

	for (let i = 0; i < points.length; i++) {
		if (points[i].z == null || points[i].z == undefined)
			points[i].z = 0;
	}

}else{
	saveSettings();
}

if(topic == ""){
	topic = "/waypoints";
	status.setWarn("No topic found, defaulting to /waypoints");
	saveSettings();
}

function saveSettings(){
	settings["{uniqueID}"] = {
		topic: topic,
		topic_type: typedict[topic],
		fixed_frame: fixed_frame,
		base_link_frame: base_link_frame,
		points: points,
		start_closest: startCheckbox.checked,
		margin: margin.value
	}
	settings.save();
}

// Message sending

function getStamp(){
	const currentTime = new Date();
	const currentTimeSecs = Math.floor(currentTime.getTime() / 1000);
	const currentTimeNsecs = (currentTime.getTime() % 1000) * 1e6;

	return {
		sec: currentTimeSecs,
		nanosec: currentTimeNsecs
	}
}

function getPoseStamped(index, timeStamp, x, y, z, quat){
	return new ROSLIB.Message({
		header: {
			stamp: timeStamp,
			frame_id: fixed_frame
		},
		pose: {
			position: {
				x: x,
				y: y,
				z: z
			},
			orientation: quat
		}
	});
}

function getPose(x, y, z, quat){
	return new ROSLIB.Message({
		position: {
			x: x,
			y: y,
			z: z
		},
		orientation: quat
	});
}

function sendMessage(pointlist){
	let timeStamp = getStamp();
	let poseList = [];
	let stamped = typedict[topic] == "nav_msgs/msg/Path";

	if(pointlist.length > 0)
	{
		if(pointlist.length  == 1){
			if(stamped){
				poseList.push(getPoseStamped(0, timeStamp, pointlist[0].x, pointlist[0].y, pointlist[0].z, new Quaternion()));
			}else{
				poseList.push(getPose(pointlist[0].x, pointlist[0].y, pointlist[0].z, new Quaternion()));
			}
		}else{
			pointlist.forEach((point, index) => {
				let p0;
				let p1;

				if(index < pointlist.length-1){
					p0 = point;
					p1 = pointlist[index+1];
				}else{
					p0 = pointlist[index-1];
					p1 = point;
				}

				const rotation = Quaternion.fromEuler(Math.atan2(p1.y - p0.y, p1.x - p0.x), 0, 0, 'ZXY');

				if(stamped){
					poseList.push(getPoseStamped(index, timeStamp, point.x, point.y, point.z, rotation));
				}else{
					poseList.push(getPose(point.x, point.y, point.z, rotation));
				}
			});
		}
	}

	const publisher = new ROSLIB.Topic({
		ros: rosbridge.ros,
		name: topic,
		messageType: stamped ? 'nav_msgs/msg/Path' : 'geometry_msgs/msg/PoseArray',
		latched: true
	});

	const pathMessage = new ROSLIB.Message({
		header: {
			stamp: timeStamp,
			frame_id: fixed_frame
		},
		poses: poseList
	});
	
	publisher.publish(pathMessage);
	status.setOK();

	setMode("IDLE");
	closeModal("{uniqueID}_modal");
}

const canvas = document.getElementById('{uniqueID}_canvas');
const ctx = canvas.getContext('2d', { colorSpace: 'srgb' });

const view_container = document.getElementById("view_container");

function getStartIndex(){

	if(base_link_frame == ""){
		status.setError("Base link frame not selected or the TF data is missing.");
		return 0;
	}

	let link = tf.transformPose(
		base_link_frame, 
		fixed_frame, 
		{x: 0, y: 0, z: 0}, 
		new Quaternion()
	);

    let minDistance = Number.POSITIVE_INFINITY;
    let minIndex = 0;

    for (let i = 0; i < points.length; i++) {
        let distance = 0;

		distance += Math.pow((link.translation.x - points[i].x), 2);
		distance += Math.pow((link.translation.y - points[i].y), 2);
		distance += Math.pow((link.translation.z - points[i].z), 2);

        if (distance < minDistance) {
            minDistance = distance;
            minIndex = i;
        }
    }
    return minIndex;
}

function pointToScreen(point){
	let transformed = tf.transformPose(
		fixed_frame, 
		tf.fixed_frame, 
		point, 
		new Quaternion()
	);

	return view.fixedToScreen({
		x: transformed.translation.x,
		y: transformed.translation.y
	});
}

function screenToPoint(click){
	return tf.transformPose(
		tf.fixed_frame, 
		fixed_frame, 
		view.screenToFixed(click), 
		new Quaternion()
	).translation;
}

function drawOffsetPath(viewPoints, offset, startIndex) {
	ctx.lineWidth = offset;
	ctx.strokeStyle = "rgba(20,20,20,0.35)";
	ctx.lineCap = "round";

	ctx.beginPath();
	for (let i = 0; i < viewPoints.length - 1; i++) {

		if(startCheckbox.checked && i < startIndex)
			continue;

        const p1 = viewPoints[i];
        const p2 = viewPoints[i + 1];

		ctx.moveTo(p1.x, p1.y);
		ctx.lineTo(p2.x, p2.y);
	}

	ctx.stroke();
}

const LIGHT_YELLOW = [255, 248, 199];
const PURE_YELLOW =  [235, 206, 0];
const DARK_YELLOW = [54, 47, 0];

const LIGHT_BLUE = [181, 209, 255];
const PURE_BLUE = [105, 162, 255];
const DARK_BLUE = [0, 25, 69];

function drawWaypoints() {

	const active = mode != "IDLE";
    const wid = canvas.width;
    const hei = canvas.height;

    ctx.clearRect(0, 0, wid, hei);

	const frame = tf.absoluteTransforms[fixed_frame];
	if(!frame){
		status.setError("Fixed transform frame not selected or the TF data is missing.");
		return;
	}

	const color = mode != "Z" ? "#EBCE00" : "#abcbff";
	const OUTLINE_PX = mode != "Z" ? 13 : 18;
	const INNER_PX = mode != "Z" ? 10 : 15;

	const startIndex = getStartIndex();
	const viewPoints = points.map((point) =>
		pointToScreen(point)
	);

	if(margin.value > 0){
		drawOffsetPath(viewPoints, margin.value * view.getMapUnitsInPixels(1.0), startIndex);
	}

	ctx.lineWidth = 3;
	ctx.fillStyle = active ? "white" : color
	if(startCheckbox.checked)
		ctx.strokeStyle = "#4a4a4a";
	else
		ctx.strokeStyle = color;

	const minZ = Math.min(...points.map(p => p.z));
	const maxZ = Math.max(...points.map(p => p.z));

	//draw path gradients
	if(minZ != maxZ)
	{
		function scale_color(x, y, z, scale){
			let r = y[0];
			let g = y[1];
			let b = y[2];
			if(scale < 0.5){
				scale = scale*2;
				const scaleinv = 1.0 - scale;
				r = scaleinv*x[0] + scale*r;
				g = scaleinv*x[1] + scale*g;
				b = scaleinv*x[2] + scale*b;
			}else if(scale > 0.5){
				scale = (scale-0.5)*2;
				const scaleinv = 1.0 - scale;
				r = scale*z[0] + scaleinv*r;
				g = scale*z[1] + scaleinv*g;
				b = scale*z[2]+ scaleinv*b;
			}
			return `rgba(${r},${g},${b},1.0)`;
		}

		for (let i = 0; i < viewPoints.length-1; i++) {
			const pos = viewPoints[i];
			const next = viewPoints[i+1];

			const grad = ctx.createLinearGradient(pos.x, pos.y, next.x, next.y)
			const start_scale = (points[i].z - minZ) / (maxZ - minZ);
			const end_scale = (points[i+1].z - minZ) / (maxZ - minZ);
			const mid_scale = (start_scale + end_scale) * 0.5;

			if(mode != "Z"){
				grad.addColorStop(0.0, scale_color(DARK_YELLOW, PURE_YELLOW, LIGHT_YELLOW, start_scale));
				grad.addColorStop(0.5, scale_color(DARK_YELLOW, PURE_YELLOW, LIGHT_YELLOW, mid_scale));
				grad.addColorStop(1.0, scale_color(DARK_YELLOW, PURE_YELLOW, LIGHT_YELLOW, end_scale));
			}else{//blue
				grad.addColorStop(0.0, scale_color(DARK_BLUE, PURE_BLUE, LIGHT_BLUE, start_scale));
				grad.addColorStop(0.5, scale_color(DARK_BLUE, PURE_BLUE, LIGHT_BLUE, mid_scale));
				grad.addColorStop(1.0, scale_color(DARK_BLUE, PURE_BLUE, LIGHT_BLUE, end_scale));
			}

			if(startCheckbox.checked && i < startIndex){
				ctx.strokeStyle = "#545454";
			}else{
				ctx.strokeStyle = grad;
			}
				
			ctx.beginPath();
			ctx.moveTo(pos.x, pos.y);
			ctx.lineTo(next.x, next.y);
			ctx.stroke();
		}
		
	}
	else //draw monocolour path
	{
		ctx.beginPath();
		for (let i = 0; i < viewPoints.length; i++) {
			const pos = viewPoints[i];
	
			if(i == startIndex && startCheckbox.checked){
				ctx.lineTo(pos.x, pos.y);
				ctx.stroke();
				ctx.strokeStyle = color; 
				ctx.beginPath();
			}
	
			if (i === 0) {
				ctx.moveTo(pos.x, pos.y);
			} else {
				ctx.lineTo(pos.x, pos.y);
			}
		};
		ctx.stroke();
	}

	function drawCircles(){
		//circle outlines
		ctx.fillStyle = "#292929";
		ctx.beginPath();
		for (let i = 0; i < viewPoints.length; i++) {
			const pos = viewPoints[i];
			ctx.moveTo(pos.x+OUTLINE_PX, pos.y);
			ctx.arc(pos.x, pos.y, OUTLINE_PX, 0, 2 * Math.PI, false);
		};
		ctx.fill();

		//circle middle
		if(startCheckbox.checked)
		{
			ctx.fillStyle = active ? "white" : "#827c52";
			ctx.beginPath();
			for (let i = 0; i < startIndex; i++) {
				const pos = viewPoints[i];
				ctx.moveTo(pos.x+INNER_PX, pos.y);
				ctx.arc(pos.x, pos.y, INNER_PX, 0, 2 * Math.PI, false);
			}
			ctx.fill();

			ctx.fillStyle = active ? "white" : color;
			ctx.beginPath();
			for (let i = startIndex; i < viewPoints.length; i++) {
				const pos = viewPoints[i];
				ctx.moveTo(pos.x+INNER_PX, pos.y);
				ctx.arc(pos.x, pos.y, INNER_PX, 0, 2 * Math.PI, false);
			}
			ctx.fill();
		}
		else
		{
			ctx.fillStyle = active ? "white" : color;
			ctx.beginPath();
			for (let i = 0; i < viewPoints.length; i++) {
				const pos = viewPoints[i];
				ctx.moveTo(pos.x+INNER_PX, pos.y);
				ctx.arc(pos.x, pos.y, INNER_PX, 0, 2 * Math.PI, false);
			}
			ctx.fill();
		}
	}

	function drawRectangles(){

		function traceRect(pos, width, height){
			const x = pos.x - width/2;
			const y = pos.y - height/2;
			ctx.moveTo(x, y);
			ctx.lineTo(x + width, y);
			ctx.lineTo(x + width, y + height);
			ctx.lineTo(x, y + height);
			ctx.lineTo(x, y);
		}

		const BORDER_PX = (OUTLINE_PX - INNER_PX) * 2;

		//rect outlines
		ctx.lineWidth = 1;
		ctx.fillStyle = "#292929";
		ctx.beginPath();
		for (let i = 0; i < viewPoints.length; i++) {
			traceRect(viewPoints[i], INNER_PX*3.5+BORDER_PX, INNER_PX*1.3+BORDER_PX);
		}
		ctx.fill();

		//rect middle
		ctx.fillStyle = active ? "white" : color;
		ctx.beginPath();
		for (let i = 0; i < viewPoints.length; i++) {
			traceRect(viewPoints[i], INNER_PX*3.5, INNER_PX*1.3);
		}
		ctx.fill();

		//draw depth scale
		if(drag_point >= 0){
			const p = viewPoints[drag_point];

			const grad = ctx.createLinearGradient(p.x-60, p.y, p.x+25, p.y)
			grad.addColorStop(0.0, "rgba(0, 0, 0, 0.75)");
			grad.addColorStop(1.0, "transparent");
			ctx.fillStyle = grad;
			ctx.fillRect(p.x-60, icon_bar.offsetHeight, 85, window.innerHeight-icon_bar.offsetHeight)

			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			ctx.beginPath();

			//0
			ctx.moveTo(p.x-60, p.y);
			ctx.lineTo(p.x-30, p.y);

			const steps = [1, 10, 100, 1000, 10000]
			for(const i of steps){
				const scaled = stepToLinearScale(i) / 1.25;
				ctx.moveTo(p.x-60, p.y+scaled);
				ctx.lineTo(p.x, p.y+scaled);

				ctx.moveTo(p.x-60, p.y-scaled);
				ctx.lineTo(p.x, p.y-scaled);
			}
			ctx.stroke();

			ctx.lineJoin = 'round';
			ctx.miterLimit = 2;
			ctx.font = (12)+"px Monospace";
			ctx.textAlign = "left";
			ctx.fillStyle = "white";

			for(const i of steps){
				const scaled = stepToLinearScale(i) / 1.25;

				const text = Math.round(drag_point_z+i).toFixed(0);
				const text_neg = Math.round(drag_point_z-i).toFixed(0);

				ctx.fillText(text_neg, p.x-25, p.y+scaled-5);
				ctx.fillText(text, p.x-25, p.y-scaled-5);
			}

			ctx.lineWidth = 1;
			ctx.strokeStyle = "lightgray";
			ctx.beginPath();
			const micro_steps = [
				0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,
				1, 2, 3, 4, 5, 6, 7, 8, 9,
				10, 20, 30, 40, 50, 60, 70, 80, 90, 
				100, 200, 300, 400, 500, 600, 700, 800, 900,
				1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000
			]

			for(const i of micro_steps){
				const scaled = stepToLinearScale(i) / 1.25;
				ctx.moveTo(p.x-60, p.y+scaled);
				ctx.lineTo(p.x-30, p.y+scaled);

				ctx.moveTo(p.x-60, p.y-scaled);
				ctx.lineTo(p.x-30, p.y-scaled);
			}

			ctx.stroke();

			ctx.lineWidth = 5;
			ctx.strokeStyle = "#446294";
			ctx.beginPath();
			ctx.moveTo(p.x-60, icon_bar.offsetHeight);
			ctx.lineTo(p.x-60, window.innerHeight);

			//up arrow
			ctx.moveTo(p.x-65, icon_bar.offsetHeight+10);
			ctx.lineTo(p.x-60, icon_bar.offsetHeight);
			ctx.lineTo(p.x-55, icon_bar.offsetHeight+10);

			//down arrow
			ctx.moveTo(p.x-65, window.innerHeight-10);
			ctx.lineTo(p.x-60, window.innerHeight);
			ctx.lineTo(p.x-55, window.innerHeight-10);
			ctx.stroke();
		}
		
	}

	if(mode == "Z")
		drawRectangles();
	else
		drawCircles();

	ctx.font = "bold 12px Monospace";
	ctx.textAlign = "center";
	ctx.fillStyle = "#21252b";

	function formatZ(num) {
		if(num > 0){
			if (num >= 10000) return "9999";
			if (num >= 100) return Math.floor(num).toString();
			return num.toFixed(1);
		}
		const absnum = Math.abs(num);
		if (absnum >= 10000) return "-9999";
		if (absnum >= 100) return Math.floor(num).toString();
		return num.toFixed(1);
	}
	viewPoints.forEach((pos, index) => {
		if(mode == "Z")
			ctx.fillText(formatZ(points[index].z)+"m", pos.x, pos.y+5);
		else
			ctx.fillText(index, pos.x, pos.y+5);
	});

	status.setOK();
}

let start_stamp = undefined;
let start_point = undefined;
let delta = undefined;
let drag_point = -1;
let drag_point_z = 0;

function findPoint(newpoint){
	let i = -1;
	points.forEach((point, index) => {
		const screenpoint = pointToScreen(point);
		const dist = Math.hypot(
			screenpoint.x - newpoint.x,
			screenpoint.y - newpoint.y,
		)
		if(mode == "XY" && dist < 15){
			i = index;
		}else if(mode == "Z" && dist < 20){
			i = index;
		}
	});
	return i;
}

const Z_SCALE_MULT = 170;

function stepToLinearScale(x) {
    const absX = Math.abs(x);
    let result;
    if (absX <= 1) {
        result = absX;
    } else if (absX <= 10) {
        result = 1 + (absX - 1) / 9;
    } else if (absX <= 100) {
        result = 2 + (absX - 10) / 90;
    } else if (absX <= 1000) {
        result = 3 + (absX - 100) / 900;
    } else if (absX <= 10000) {
        result = 4 + (absX - 1000) / 9000;
    } else {
        result = 5;
    }
    return result * Math.sign(x) * Z_SCALE_MULT;
}

function linearToStepScale(y) {
	y/=Z_SCALE_MULT;
    const absY = Math.abs(y);
    let result;
    if (absY <= 1) {
        result = absY;
    } else if (absY <= 2) {
        result = 1 + (absY - 1) * 9;
    } else if (absY <= 3) {
        result = 10 + (absY - 2) * 90;
    } else if (absY <= 4) {
        result = 100 + (absY - 3) * 900;
	} else if (absY <= 5) {
        result = 1000 + (absY - 4) * 9000;
	}else{
		result = 10000;
	}
    return result * Math.sign(y);
}

function startDrag(event){
	const { clientX, clientY } = event.touches ? event.touches[0] : event;
	start_point = {
		x: clientX,
		y: clientY
	};

	drag_point = findPoint(start_point);
	if(drag_point >= 0){
		view.setInputMovementEnabled(false);
		drag_point_z = points[drag_point].z;
	}

	start_stamp = new Date();
}

function drag(event){
	let { clientX, clientY } = event.touches ? event.touches[0] : event;

	if(shift_pressed){
		clientX = Math.round(clientX/20) * 20;
		clientY = Math.round(clientY/20) * 20;
	}

	if(mode == "XY"){
		if(drag_point >= 0){
			const newpos = screenToPoint({
				x: clientX,
				y: clientY
			})
	
			points[drag_point].x = newpos.x;
			points[drag_point].y = newpos.y;
			drawWaypoints();
		}
	} 

	if (start_point === undefined) 
		return;

	delta = {
		x: start_point.x - clientX,
		y: start_point.y - clientY,
	};

	if(mode == "Z" && drag_point >= 0){	
		points[drag_point].z = drag_point_z + linearToStepScale(delta.y * 1.25); 

		if(points[drag_point].z > 9999.99)
			points[drag_point].z = 9999;
		else if(points[drag_point].z < -9999.99)
			points[drag_point].z = -9999;

		if (Math.abs(points[drag_point].z) >= 100)
			points[drag_point].z = parseInt(points[drag_point].z);
		else
			points[drag_point].z = parseInt(points[drag_point].z*10)/10;

		drawWaypoints();
	}
}

function distancePointToLineSegment(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;
	const lengthSquared = dx * dx + dy * dy;

	let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
	t = Math.max(0, Math.min(1, t));

	const closestX = x1 + t * dx;
	const closestY = y1 + t * dy;

	const distanceSquared = (px - closestX) * (px - closestX) + (py - closestY) * (py - closestY);

	return Math.sqrt(distanceSquared);
}

function endDrag(event){

	if(drag_point >= 0){
		view.setInputMovementEnabled(true);
		drag_point = -1;
	}

	let moveDist = 0;

	if(delta !== undefined){
		moveDist = Math.hypot(delta.x,delta.y);
	}

	if(moveDist < 10 && new Date() - start_stamp  < 300 && mode == "XY"){

		start_stamp = new Date("2010-3-2"); //debounce, and also when ROS box turtle was released

		let { clientX, clientY } = event.touches ? event.touches[0] : event;

		if(shift_pressed){
			clientX = Math.round(clientX/20) * 20;
			clientY = Math.round(clientY/20) * 20;
		}

		const newpoint = {
			x: clientX,
			y: clientY
		};

		let index = findPoint(newpoint);

		if(index >= 0){ // remove point
			points.splice(index, 1);
		}else{
			let before = -1;
			for (let i = 0; i < points.length - 1; i++) {
				const p0 = pointToScreen(points[i]);
				const p1 = pointToScreen(points[i+1]);

				const distance = distancePointToLineSegment(
					newpoint.x, newpoint.y,
					p0.x, p0.y,
					p1.x, p1.y
				);

				if (distance <= 10) {
					before = i+1;
					break;
				}
			}
		
			if(before > 0){
				// insert new point between two others
				const p = screenToPoint(newpoint);
				const p0 = points[before-1];
				const p1 = points[before];

				// Calculate the weight as the ratio of distances
				const distP0P1 = Math.hypot(p1.x - p0.x, p1.y - p0.y);
				const distP0P = Math.hypot(p.x - p0.x, p.y - p0.y);
				p.z = p0.z + distP0P / distP0P1 * (p1.z - p0.z);
				points.splice(before, 0, p);
			}else{
				// add point to the end
				const p = screenToPoint(newpoint);

				if (points.length > 0)
					p.z = points[points.length-1].z;

				points.push(p);
			}
		}
		saveSettings();
	}

	drawWaypoints();

	start_point = undefined;
	delta = undefined;
}

function resizeScreen(){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth;
	drawWaypoints();
}

window.addEventListener('resize', resizeScreen);
window.addEventListener('orientationchange', resizeScreen);
window.addEventListener("view_changed", drawWaypoints);

window.addEventListener("tf_fixed_frame_changed", drawWaypoints);
window.addEventListener("tf_changed", ()=>{
	if(fixed_frame != tf.fixed_frame){
		drawWaypoints();
	}
});

view_container.addEventListener("mouseleave", (event) => {
	delta = undefined;
	endDrag(event);
});

function addListeners(){
	view_container.addEventListener('mousedown', startDrag);
	view_container.addEventListener('mousemove', drag);
	view_container.addEventListener('mouseup', endDrag);

	view_container.addEventListener('touchstart', startDrag);
	view_container.addEventListener('touchmove', drag);
	view_container.addEventListener('touchend', endDrag);	
}

function removeListeners(){
	view_container.removeEventListener('mousedown', startDrag);
	view_container.removeEventListener('mousemove', drag);
	view_container.removeEventListener('mouseup', endDrag);

	view_container.removeEventListener('touchstart', startDrag);
	view_container.removeEventListener('touchmove', drag);
	view_container.removeEventListener('touchend', endDrag);	
}

function setMode(newmode){
	mode = newmode;

	switch(mode){
		case "IDLE":
			removeListeners()
			icon.style.backgroundColor = "rgba(124, 124, 124, 0.3)";
			view_container.style.cursor = "";
			buttontext.innerText = "";
			canvas.style.zIndex = "2";
			break;

		case "XY":
			addListeners();
			icon.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
			view_container.style.cursor = "pointer";
			buttontext.innerText = "X,Y";
			canvas.style.zIndex = "999";
			break;

		case "Z":
			addListeners();
			icon.style.backgroundColor = "rgba(255, 255, 255, 1.0)";
			view_container.style.cursor = "pointer";
			buttontext.innerText = "Z";
			canvas.style.zIndex = "999";
			break;
	}

	drawWaypoints();
}

// Shift clamp to axis
function handleKeyDown(event) {
	if (event.key === "Shift") {
		shift_pressed = true;
	}
}

function handleKeyUp(event) {
	if (event.key === "Shift") {
		shift_pressed = false;
	}
}

window.addEventListener("keydown", handleKeyDown);
window.addEventListener("keyup", handleKeyUp);

// Topics
const selectionbox = document.getElementById("{uniqueID}_topic");
const fixedFrameBox = document.getElementById("{uniqueID}_fixed_frame");
const baseLinkFrameBox = document.getElementById("{uniqueID}_base_link_frame");

selectionbox.addEventListener("change", (event) => {
	topic = selectionbox.value;
	saveSettings();
	status.setOK();
});

fixedFrameBox.addEventListener("change", (event) => {
	fixed_frame = fixedFrameBox.value;
	saveSettings();
});

baseLinkFrameBox.addEventListener("change", (event) => {
	base_link_frame = baseLinkFrameBox.value;
	saveSettings();
});

margin.addEventListener("input", (event) =>{
	drawWaypoints();
	saveSettings();
});

function find_base_frame(){
	//try base_link first
	for (const key of tf.frame_list.values()) {
		if (key.includes("base_link")) {
			return key
		}
	}

	//maybe footprint?
	for (const key of tf.frame_list.values()) {
		if (key.includes("base_footprint")) {
			return key
		}
	}

	//ok just base then...?
	for (const key of tf.frame_list.values()) {
		if (key.includes("base")) {
			return key
		}
	}

	//eh screw it
	return "base_link";
}

async function loadTopics(){
	const result_path = await rosbridge.get_topics("nav_msgs/msg/Path");
	const result_array = await rosbridge.get_topics("geometry_msgs/msg/PoseArray");

	let topiclist = "";
	result_path.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (Path)</option>";
		typedict[element] = "nav_msgs/msg/Path";
	});
	result_array.forEach(element => {
		topiclist += "<option value='"+element+"'>"+element+" (PoseArray)</option>";
		typedict[element] = "geometry_msgs/msg/PoseArray";
	});
	selectionbox.innerHTML = topiclist

	if(topic == "")
		topic = selectionbox.value;
	else{
		if(result_path.includes(topic) || result_array.includes(topic)){
			selectionbox.value = topic;
		}else{
			topiclist += "<option value='"+topic+"'>"+topic+"</option>"
			selectionbox.innerHTML = topiclist
			selectionbox.value = topic;
		}
	}

	//find frames
	let framelist = "";
	for (const key of tf.frame_list.values()) {
		framelist += "<option value='"+key+"'>"+key+"</option>"
	}
	fixedFrameBox.innerHTML = framelist;

	if(tf.frame_list.has(fixed_frame)){
		fixedFrameBox.value = fixed_frame;
	}else{
		framelist += "<option value='"+fixed_frame+"'>"+fixed_frame+"</option>"
		fixedFrameBox.innerHTML = framelist;
		fixedFrameBox.value = fixed_frame;
	}

	baseLinkFrameBox.innerHTML = framelist;
	
	if(tf.frame_list.has(base_link_frame)){
		baseLinkFrameBox.value = base_link_frame;
	}else{
		framelist += "<option value='"+fixed_frame+"'>"+fixed_frame+"</option>"
		baseLinkFrameBox.innerHTML = framelist;
		baseLinkFrameBox.value = base_link_frame;
	}
}

loadTopics();

//dropdown stuff

function dropdown_visibility(open){
	if(open)
		dropdown.style.display = "block";
	else
		dropdown.style.display = "none";
}

// Toggle dropdown on click
icon.addEventListener("click", (event) => {
	event.stopPropagation();

	if(mode != "IDLE"){
		setMode("IDLE");
	}else{
		const rect = icon.getBoundingClientRect();
		const dropdownWidth = 90;
		let top = rect.bottom + 5; // Default: below the icon
		let left = rect.left;

		if (left + dropdownWidth > window.innerWidth) {
			left = window.innerWidth - dropdownWidth - 5;
		}

		if (left < 5) {
			left = 5;
		}

		dropdown.style.top = `${top}px`;
		dropdown.style.left = `${left}px`;
	
		dropdown_visibility(dropdown.style.display == "none")
	}
});

// Close dropdown when clicking outside
document.addEventListener("click", (event) => {
	if (!dropdown.contains(event.target) && !icon.contains(event.target)) {
		dropdown_visibility(false);
	}
});

const drop_start = document.getElementById("{uniqueID}_sendAction");
const drop_stop = document.getElementById("{uniqueID}_stopAction");
const drop_xy = document.getElementById("{uniqueID}_editXY");
const drop_z = document.getElementById("{uniqueID}_editZ");
const drop_config = document.getElementById("{uniqueID}_config");

const startButton = document.getElementById("{uniqueID}_start");
const stopButton = document.getElementById("{uniqueID}_stop");

drop_start.addEventListener("click", (event) => {
	if(startCheckbox.checked)
		sendMessage(points.slice(getStartIndex()))
	else
		sendMessage(points)
	dropdown_visibility(false);
});

drop_stop.addEventListener("click", (event) => {
	sendMessage([]);
	dropdown_visibility(false);
});

drop_xy.addEventListener("click", (event) => {
	setMode("XY");
	dropdown_visibility(false);
});

drop_z.addEventListener("click", (event) => {
	setMode("Z");
	dropdown_visibility(false);
});

drop_config.addEventListener("click", (event) => {
	loadTopics();
	openModal("{uniqueID}_modal");
	dropdown_visibility(false);
});

resizeScreen();

console.log("Waypoints Widget Loaded {uniqueID}")


================================================
FILE: vizanti_server/public/templates/waypoints/waypoints_view.html
================================================
<canvas id="{uniqueID}_canvas" style="pointer-events: none; z-index: 2;"></canvas>


================================================
FILE: vizanti_server/resource/vizanti_server
================================================
[Empty file]


================================================
FILE: vizanti_server/scripts/__init__.py
================================================
[Empty file]


================================================
FILE: vizanti_server/scripts/rqt_reconfigure_param_api.py
================================================
# Copyright (c) 2019 Open Source Robotics Foundation, Inc.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#    * Neither the name of the copyright holder nor the names of its
#      contributors may be used to endorse or promote products derived from
#      this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

# Copied from https://github.com/ros-visualization/rqt_reconfigure/tree/jazzy/src/rqt_reconfigure because rqt_reconfigure comes with 360MB of dependencies

from threading import Event

from rcl_interfaces.msg import Parameter as ParameterMsg
from rcl_interfaces.msg import ParameterEvent
from rcl_interfaces.srv import DescribeParameters
from rcl_interfaces.srv import GetParameters
from rcl_interfaces.srv import ListParameters
from rcl_interfaces.srv import SetParameters

from rclpy.parameter import Parameter
from rclpy.qos import qos_profile_parameter_events

class AsyncServiceCallFailed(Exception):

    def __init__(self, message='asynchronous service call failed', hint=''):
        self.message = message if not hint else message + ': ' + hint
        super().__init__(self.message)


class ParamClient(object):

    def __init__(self, node, remote_node_name, param_change_callback=None):

        self._node = node
        self._remote_node_name = remote_node_name
        self._get_params_client = self._node.create_client(
            GetParameters, '{remote_node_name}/get_parameters'.format_map(locals())
        )
        self._set_params_client = self._node.create_client(
            SetParameters, '{remote_node_name}/set_parameters'.format_map(locals())
        )
        self._list_params_client = self._node.create_client(
            ListParameters, '{remote_node_name}/list_parameters'.format_map(locals())
        )
        self._describe_params_client = self._node.create_client(
            DescribeParameters, '{remote_node_name}/describe_parameters'.format_map(locals())
        )
        self._param_events_subscription = self._node.create_subscription(
            ParameterEvent, '/parameter_events', self._on_parameter_event,
            qos_profile_parameter_events
        )
        self._param_change_callback = param_change_callback

    def _on_parameter_event(self, event):
        if event.node != self._remote_node_name:
            return
        if self._param_change_callback is not None:
            self._param_change_callback(
                [Parameter.from_parameter_msg(p) for p in event.new_parameters],
                [Parameter.from_parameter_msg(p) for p in event.changed_parameters],
                [Parameter.from_parameter_msg(p) for p in event.deleted_parameters]
            )

    def list_parameters(self):
        list_params_request = ListParameters.Request()
        list_params_response = self._call_service(self._list_params_client, list_params_request)
        return list_params_response.result.names

    def get_parameters(self, names):
        get_params_request = GetParameters.Request()
        get_params_request.names = names
        get_params_response = self._call_service(self._get_params_client, get_params_request)
        return [
            Parameter.from_parameter_msg(ParameterMsg(name=name, value=value))
            for name, value in zip(names, get_params_response.values)
        ]

    def describe_parameters(self, names):
        describe_params_request = DescribeParameters.Request()
        describe_params_request.names = names
        describe_params_response = self._call_service(self._describe_params_client,
                                                      describe_params_request)
        return describe_params_response.descriptors

    def set_parameters(self, parameters):
        set_params_request = SetParameters.Request()
        set_params_request.parameters = [p.to_parameter_msg() for p in parameters]
        return self._call_service(self._set_params_client, set_params_request)

    def close(self):
        self._node.destroy_subscription(self._param_events_subscription)
        self._node.destroy_client(self._describe_params_client)
        self._node.destroy_client(self._list_params_client)
        self._node.destroy_client(self._set_params_client)
        self._node.destroy_client(self._get_params_client)

    def _call_service(self, client, request, timeout=1.0):
        if not client.service_is_ready():
            if not client.wait_for_service(timeout):
                raise AsyncServiceCallFailed(hint='timed out waiting for service')

        # It is possible that a node has the parameter services but is not
        # spinning. In that is the case, the client call will time out.
        event = Event()
        future = client.call_async(request)
        future.add_done_callback(lambda _: event.set())

        event.wait(timeout)

        result = future.result()
        if result is None:
            raise AsyncServiceCallFailed(hint='the target node may not be spinning')

        return future.result()


def create_param_client(node, remote_node_name, param_change_callback=None):
    return ParamClient(node, remote_node_name, param_change_callback)


def _has_parameters(node, node_name, node_namespace):
    # Get all of the services provided by a node (node_name)
    for service_name, service_types in node.get_service_names_and_types_by_node(
            node_name, node_namespace):

        # Make sure the node supports the ListParameters service
        if 'rcl_interfaces/srv/ListParameters' in service_types:
            return True
    return False


def find_nodes_with_params(node):
    names_and_namespaces = node.get_node_names_and_namespaces()
    node_list = []
    for node_name, node_namespace in names_and_namespaces:
        if _has_parameters(node, node_name, node_namespace):
            full_name = node_namespace.rstrip('/') + '/' + node_name
            node_list.append(full_name)
    return node_list



================================================
FILE: vizanti_server/scripts/server.py
================================================
#!/usr/bin/env python3

import os
import threading
import logging
import json
import rclpy

from flask import Flask, render_template, send_from_directory, make_response
from waitress.server import create_server

from std_msgs.msg import String
from ament_index_python.packages import get_package_share_directory

from pathlib import Path

node = None
param_base_url = ""
param_port = 5000
param_port_rosbridge = 5001
param_compression = "none"
param_default_widget_config = ""

def get_public_dir():
	p = Path(__file__).resolve()
	path = p.parents[1] / 'public'
	if path.exists():
		return path #for --symlink-install
	return get_package_share_directory('vizanti_server')+ '/public/'

app = Flask(__name__, static_folder=get_public_dir(), template_folder=get_public_dir())

def get_file(path):
	with open(param_default_widget_config, 'r') as f:
		file_content = f.read()
		js_module = f"const content = {json.dumps(file_content)};\nexport default content;"
		response = make_response(js_module)
		response.headers['Content-Type'] = 'application/javascript'
		return response

def get_files(path, valid_extensions):
	templates_dir = os.path.join(app.static_folder, path)
	file_list = []

	for root, dirs, files in os.walk(templates_dir):
		for file in files:
			if os.path.splitext(file)[1] in valid_extensions:
				file_path = os.path.join(root, file)
				with open(file_path, 'r') as f:
					file_content = f.read()
				file_list.append({'path': os.path.relpath(file_path, templates_dir), 'content': file_content})

	js_module = f"const files = {json.dumps(file_list)};\nexport default files;"

	#fetch workaround hackery for webkit support on HTTP
	response = make_response(js_module)
	response.headers['Content-Type'] = 'application/javascript'
	return response

def get_paths(path, valid_extensions):
	templates_dir = os.path.join(app.static_folder, path)
	file_list = []

	for root, dirs, files in os.walk(templates_dir):
		for file in files:
			if os.path.splitext(file)[1] in valid_extensions:
				file_list.append(os.path.relpath(os.path.join(root, file), templates_dir))

	js_module = f"const paths = {json.dumps(file_list)};\nexport default paths;"

	response = make_response(js_module)
	response.headers['Content-Type'] = 'application/javascript'
	return response

def index():
	return render_template('index.html', base_url=param_base_url)

def list_template_files():
	return get_files("templates", ['.html', '.js', '.css'])

def list_robot_model_files():
	templates_dir = os.path.join(app.static_folder, "assets/robot_model")
	categorized_files = {
		'ground': [],
		'air': [],
		'sea': [],
		'misc': []
	}
	
	for root, dirs, files in os.walk(templates_dir):
		for file in files:
			if os.path.splitext(file)[1] == '.png':
				rel_path = os.path.relpath(root, templates_dir)
				category = rel_path if rel_path in categorized_files else 'misc'
				if category == '.':  # files in root directory
					category = 'misc'
				categorized_files[category].append(file)
	
	js_module = f"const categorizedPaths = {json.dumps(categorized_files)};\nexport default categorizedPaths;"
	response = make_response(js_module)
	response.headers['Content-Type'] = 'application/javascript'
	return response


def get_default_widget_config():
	return get_file(param_default_widget_config)

def list_ros_launch_params():
	params = {
		"port": param_port,
		"port_rosbridge": param_port_rosbridge,
		"compression": param_compression
	}
	js_module = f"const params = {json.dumps(params)};\nexport default params;"
	response = make_response(js_module)
	response.headers['Content-Type'] = 'application/javascript'
	return response

def serve_static(path):
	return send_from_directory(app.static_folder, path)

class ServerThread(threading.Thread):
	def __init__(self, app, host='0.0.0.0', port=5000):
		threading.Thread.__init__(self)
		self.daemon = True

		self.log = logging.getLogger('waitress')
		self.log.setLevel(logging.INFO)
		handler = logging.StreamHandler()
		handler.setFormatter(logging.Formatter(
			'[%(levelname)s] [%(asctime)s] [waitress]: %(message)s '
		))
		self.log.addHandler(handler)

		self.app = app
		self.host = host
		self.port = port
		self.ctx = app.app_context()
		self.ctx.push()
		
		self._server = None
		self._stop_event = threading.Event()

	def run(self):
		self._server = create_server(self.app, host=self.host, port=self.port)
		try:
			self._server.run()
		except KeyboardInterrupt:
			self.shutdown()
		
	def shutdown(self):
		if self._server:
			self._server.close()  # This triggers waitress to stop accepting new connections
			self._stop_event.set()  # Signal that we're stopping
			rospy.loginfo("Waitress server shutting down...")

def main(args=None):
	global node, param_base_url, param_port, param_port_rosbridge, param_compression, param_default_widget_config

	rclpy.init(args=args)
	node = rclpy.create_node('vizanti_flask_node')

	node.declare_parameter('host', '0.0.0.0')
	node.declare_parameter('port', param_port)
	node.declare_parameter('port_rosbridge', param_port_rosbridge)
	node.declare_parameter('flask_debug', True)
	node.declare_parameter('base_url', param_base_url)
	node.declare_parameter('compression', param_compression)
	node.declare_parameter('default_widget_config',param_default_widget_config)

	param_host = node.get_parameter('host').value
	param_port = node.get_parameter('port').value
	param_port_rosbridge = node.get_parameter('port_rosbridge').value
	param_base_url = node.get_parameter('base_url').value
	param_compression = node.get_parameter('compression').value
	param_default_widget_config = node.get_parameter('default_widget_config').value

	if param_default_widget_config != "":
		param_default_widget_config = os.path.expanduser(param_default_widget_config)
	else:
		param_default_widget_config = os.path.join(app.static_folder, "assets/default_layout.json")

	node.get_logger().info(f"Default widget config set to {param_default_widget_config}")

	app.debug = node.get_parameter('flask_debug').value
	app.add_url_rule(param_base_url + '/', 'index', index)
	app.add_url_rule(param_base_url + '/templates/files', 'list_template_files', list_template_files)
	app.add_url_rule(param_base_url + '/assets/robot_model/paths', 'list_robot_model_files', list_robot_model_files)
	app.add_url_rule(param_base_url + '/ros_launch_params', 'ros_launch_params', list_ros_launch_params)
	app.add_url_rule(param_base_url + '/default_widget_config', 'get_default_widget_config', get_default_widget_config)
	app.add_url_rule(param_base_url + '/<path:path>', 'serve_static', serve_static)

	server = ServerThread(app, param_host, param_port)
	server.start()

	node.get_logger().info(f"Flask server running at http://{param_host}:{param_port}{param_base_url}")
	node.get_logger().info(f"Public directory set as {get_public_dir()}")

	rclpy.spin(node)

	server.shutdown()
	server.join()
	node.destroy_node()
	rclpy.shutdown()

if __name__ == '__main__':
	main()


================================================
FILE: vizanti_server/scripts/service_handler.py
================================================
#!/usr/bin/env python3

import subprocess
import os
import fcntl
import sys
import rclpy
import json
import time

from rclpy.node import Node

from rclpy.executors import  MultiThreadedExecutor
from rclpy.callback_groups import ReentrantCallbackGroup

from ros2lifecycle.api import get_node_names
from ros2pkg.api import get_package_names, get_prefix_path
from rqt_reconfigure_param_api import create_param_client
from rclpy.parameter import Parameter

from std_srvs.srv import Trigger
from vizanti_msgs.srv import GetNodeParameters, SetNodeParameter
from vizanti_msgs.srv import LoadMap, SaveMap
from vizanti_msgs.srv import RecordRosbag
from vizanti_msgs.srv import ManageNode, ListPackages, ListExecutables, ListLifecycles

from lifecycle_msgs.srv import GetState
from lifecycle_msgs.msg import State

class ServiceHandler(Node):
    def __init__(self, group):
        super().__init__("vizanti_service_handler")

        self.proc = None
        self.packages = sorted(list(get_package_names()))

        self.get_node_parameters_service = self.create_service(GetNodeParameters, 'vizanti/get_node_parameters', self.get_node_parameters, callback_group=group)
        self.set_node_parameter_service = self.create_service(SetNodeParameter, 'vizanti/set_node_parameter', self.set_node_parameter, callback_group=group)

        self.load_map_service = self.create_service(LoadMap, 'vizanti/load_map', self.load_map, callback_group=group)
        self.save_map_service = self.create_service(SaveMap, 'vizanti/save_map', self.save_map, callback_group=group)

        self.record_setup_service = self.create_service(RecordRosbag, 'vizanti/bag/setup', self.recording_setup, callback_group=group)

        self.kill_service = self.create_service(ManageNode, 'vizanti/node/kill', self.node_kill, callback_group=group)
        self.start_service = self.create_service(ManageNode, 'vizanti/node/start', self.node_start, callback_group=group)
        self.info_service = self.create_service(ManageNode, 'vizanti/node/info', self.node_info, callback_group=group)
        self.wtf_service = self.create_service(Trigger, 'vizanti/roswtf', self.roswtf, callback_group=group)
        self.record_status_service = self.create_service(Trigger, 'vizanti/bag/status', self.recording_status, callback_group=group)
        self.list_lifecycle_service = self.create_service(ListLifecycles, 'vizanti/list_lifecycle_nodes', self.list_lifecycle_nodes_status, callback_group=group)

        self.list_packages_service = self.create_service(ListPackages, 'vizanti/list_packages', self.list_packages_callback, callback_group=group)
        self.list_executables_service = self.create_service(ListExecutables, 'vizanti/list_executables', self.list_executables_callback, callback_group=group)

        self.get_logger().info("Service handler ready.")

    def list_lifecycle_nodes_status(self, req, res):
        node_names = get_node_names(node=self, include_hidden_nodes=True)
        fullnames = [n.full_name for n in node_names]
        state_ids = [0] * len(fullnames)

        for i in range(len(fullnames)):
            try:
                client = self.create_client(GetState,f'{fullnames[i]}/get_state')
                response = client.call(GetState.Request())
                state_ids[i] = response.current_state.id
            except:
                pass

        res.nodes = fullnames
        res.states = state_ids
        return res

    def list_packages_callback(self, req, res):
        res.packages = self.packages
        return res

    def get_filenames(self, file_paths):
        file_names = []
        for file_path in file_paths:
            base_name = os.path.basename(file_path)
            if base_name.endswith(tuple([".py",".launch",".yaml"])) or "." not in base_name:
                file_names.append(base_name)
        return file_names

    def list_executables_callback(self, req, res):

        if req.package not in self.packages:
            self.get_logger().error("Package not found: " + req.package)
            res.executables = []
            return res
        
        path = get_prefix_path(req.package)

        #TODO add path to apt installed packages, I'm not sure where exactly those executables are yet
        #self.get_logger().info(f"libpath: {libpath}")

        cmd_exec = ["find", path+"/share/"+req.package] # get list of executables
        cmd_exec = cmd_exec + ["-type", "f", "-o", "-type", "l"] # files or symlinks

        cmd_launch = ["find", path+"/lib/"+req.package]
        cmd_launch = cmd_launch + ["-type", "f", "-o", "-type", "l"]
        process_exec = subprocess.Popen(cmd_exec, stdout=subprocess.PIPE)
        process_launch = subprocess.Popen(cmd_launch, stdout=subprocess.PIPE)

        output_exec, _ = process_exec.communicate()
        output_launch, _ = process_launch.communicate()

        # Process output
        lines_exec = self.get_filenames(output_exec.decode('utf-8').split('\n'))
        lines_launch = self.get_filenames(output_launch.decode('utf-8').split('\n'))

        self.get_logger().info(f"lines_exec: {lines_exec}")
        self.get_logger().info(f"output_python_and_launch: {lines_launch}")

        executables = [line.split("/")[-1] for line in lines_exec if line]
        launch_files = [line.split("/")[-1] for line in lines_launch if line]

        res.executables = executables + launch_files
        return res

    def node_kill(self, req, res):
        try:
            #ros 2 doesn't let you kill nodes in a legit way, so we have to be extra janky lol
            #this seems to also have the weird side effect that it takes a year for ros2 node list to show the change
            self.get_logger().info("Attempting to kill node "+str(req.node))
            subprocess.call("ps aux | grep '"+req.node+"' | awk '{print $2}' | xargs kill -9", shell=True)
            res.success = True
            res.message = f'Killed node {req.node}'
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def node_start(self, req, res):
        try:
            args = req.node.split(" ")

            # Open /dev/null
            devnull = open(os.devnull, 'w')

            # Set up the process to ignore the SIGTERM signal
            def preexec():
                os.setpgrp()
                sys.stdin = open(os.devnull, 'r')
                sys.stdout = open(os.devnull, 'w')
                sys.stderr = open(os.devnull, 'w')

            subprocess.Popen(args, stdout=devnull, stderr=devnull, preexec_fn=preexec)

            self.get_logger().info("Starting node "+str(req.node))

            res.success = True
            res.message = f'Started node {req.node}'
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def node_info(self, req, res):
        try:
            rosinfo = subprocess.check_output(["ros2", "node", "info", req.node]).decode('utf-8')
            rosinfo = rosinfo.replace("--------------------------------------------------------------------------------", "")
            res.success = True
            res.message = rosinfo
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def roswtf(self, req, res):
        try:
            self.get_logger().info("Compiling doctor report...")
            rosinfo = subprocess.check_output(["ros2", "doctor", "--report"]).decode('utf-8')
            res.success = True
            res.message = rosinfo
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def load_map(self, req, res):
        file_path = os.path.expanduser(req.file_path)
        topic = req.topic
        try:
            process = subprocess.Popen(["ros2", "run", "nav2_map_server", "map_server", file_path, "map:=" + topic, "__name:=vizanti_map_server"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            flags = fcntl.fcntl(process.stdout, fcntl.F_GETFL)
            fcntl.fcntl(process.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)

            # Wait for it to either fail or not
            time.sleep(1)

            # Check if the process is still running
            if process.poll() is not None:
                # Process terminated, read the error output
                error_output = process.stdout.read().decode('utf-8')
                res.success = False
                res.message = "Map server failed to load the map: " + error_output
            else:
                res.success = True
                res.message = "Map loaded successfully"
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def save_map(self, req, res):
        file_path = os.path.expanduser(req.file_path)
        topic = req.topic
        try:
            process = subprocess.Popen(["ros2", "run", "nav2_map_server", "map_saver_cli", "-f", file_path, "--ros-args", "map:=" + topic], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            flags = fcntl.fcntl(process.stdout, fcntl.F_GETFL)
            fcntl.fcntl(process.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)

            while True:
                # Check if the process is still running
                if process.poll() is not None:
                    break

                while True:
                    try:
                        line = process.stdout.readline()
                        if not line:
                            break

                        if b"[ERROR]" in line:
                            process.terminate()
                            res.success = False
                            res.message = "Map saver failed to save the map: " + line.decode('utf-8')
                            return res
                    except IOError:
                        break

                # Sleep for a short period of time to avoid excessive CPU usage
                time.sleep(0.2)

            res.success = True
            res.message = "Map saved successfully"
        except Exception as e:
            res.success = False
            res.message = str(e)
        return res

    def get_node_parameters(self, req, res):
        try:
            param_client = create_param_client(self, req.node)
            param_names = param_client.list_parameters()
            descriptors = param_client.describe_parameters(param_names)
            #Parameter.Type Enum
            #  <Type.NOT_SET: 0>,
            #  <Type.BOOL: 1>,
            #  <Type.INTEGER: 2>,
            #  <Type.DOUBLE: 3>,
            #  <Type.STRING: 4>,
            #  <Type.BYTE_ARRAY: 5>,
            #  <Type.BOOL_ARRAY: 6>,
            #  <Type.INTEGER_ARRAY: 7>,
            #  <Type.DOUBLE_ARRAY: 8>,
            #  <Type.STRING_ARRAY: 9>

            parameters = param_client.get_parameters(param_names)
            param_list = []
            for param, descriptor in zip(parameters, descriptors):
                if descriptor.type > 0 and descriptor.type < 5: #TODO add support for the rest if anyone actually uses them
                    param_list.append([param.name, param.value, descriptor.type])
            res.parameters = json.dumps(param_list)            
        except Exception as e:
            res.parameters = "[]"
            print(f"Failed to fetch parameters from node: {e}")
        return res
    
    def set_node_parameter(self, req, res):
        try:
            param_client = create_param_client(self, req.node)
            descriptors = param_client.describe_parameters([req.param])
            param_type = Parameter.Type(descriptors[0].type)

            value = req.value
            if param_type == Parameter.Type.BOOL:
                value = value == "true"
            elif param_type == Parameter.Type.INTEGER:
                value = int(value)
            elif param_type == Parameter.Type.DOUBLE:
                value = float(value)
            """elif param_type == Parameter.Type.BYTE_ARRAY:
                value = int(value)
            elif param_type == Parameter.Type.BOOL_ARRAY:
                value = int(value)
            elif param_type == Parameter.Type.DOUBLE_ARRAY:
                value = int(value)
            elif param_type == Parameter.Type.STRING_ARRAY:
                value = int(value)"""
            
            self.get_logger().info(f"Setting {req.node}/{req.param} to {value}")

            parameter = Parameter(name=req.param, type_=param_type, value=value)
            param_client.set_parameters([parameter])
            res.status = "Ok."
        except Exception as e:
            res.status = "Error, could not set param."
        return res

    def recording_status(self, req, res):
        response = Trigger.Response()
        response.success = self.proc is not None

        if response.success:
            response.message = "Bag recording in progress..."
        else:
            response.message = "Bag recorder idle."

        return response

    def recording_setup(self, req, res):
        response = RecordRosbag.Response()

        if req.start:
            if self.proc is not None:
                response.success = False
                response.message = "Already recording, please stop the current recording first."
            else:
                command = ['ros2', 'bag', 'record', '-o']

                # Expand and add the path to the command
                expanded_path = os.path.expanduser(req.path)
                command.append(expanded_path)

                # Add the topics to the command
                for topic in req.topics:
                    command.append(topic)

                # Use subprocess to start rosbag record in a new process
                self.proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                response.success = True
                response.message = "Recording started."

                self.get_logger().info("Recording ros2 bag to "+str(expanded_path))
        else:
            if self.proc is not None:
                # Terminate the rosbag record process
                self.proc.terminate()
                self.proc.wait()
                self.proc = None
                response.success = True
                response.message = "Recording stopped."

                self.get_logger().info("Recording stopped.")
            else:
                response.success = False
                response.message = "No active recording found."
                self.get_logger().info("No active recording found.")

        return response

def main(args=None):
    rclpy.init(args=args)

    service_handler = ServiceHandler(group=ReentrantCallbackGroup())
    executor = MultiThreadedExecutor(num_threads=20)
    executor.add_node(service_handler)

    try:
        executor.spin()
    except rclpy.executors.ExternalShutdownException:
        pass

    service_handler.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()



================================================
FILE: .github/ISSUE_TEMPLATE/bug-issue.md
================================================
---
name: Bug/Issue
about: Something ain't working.
title: ''
labels: bug
assignees: MoffKalast

---

[Problem description]

**Server Platform(s):**
 - OS: [e.g. Ubuntu 22.04]
 - Architecture: [e.g. x86_64]
 - ROS Version: [e.g. Humble]
 - Branch/Tag: [e.g. ros2]

**Client Platform(s):**
 - OS: [e.g. Android 14]
 - Architecture: [e.g. aarch64]
 - Browser: [e.g. Chrome]



================================================
FILE: .github/ISSUE_TEMPLATE/discussion.md
================================================
---
name: Discussion
about: Anything else you want to ask or talk about.
title: ''
labels: question
assignees: ''

---

Best head over to https://github.com/MoffKalast/vizanti/discussions



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Let's add something new.
title: ''
labels: enhancement
assignees: MoffKalast

---




